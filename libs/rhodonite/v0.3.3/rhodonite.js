(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Rn"] = factory();
	else
		root["Rn"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "rhodonite-" + ({}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// The chunk loading function for additional chunks
/******/ 	// Since all referenced chunks are already included
/******/ 	// in this file, this function is empty here.
/******/ 	__webpack_require__.e = function requireEnsure() {
/******/ 		return Promise.resolve();
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonpRn"] = window["webpackJsonpRn"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./VERSION-FILE":
/*!**********************!*\
  !*** ./VERSION-FILE ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"version":"v0.3.3-0-g85bfe43a","branch":""});

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/shaderity/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/shaderity/dist/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Reflection = void 0;
class Reflection {
    constructor() {
        this.attributes = [];
        this.varyings = [];
        this.uniforms = [];
    }
    get attributesNames() {
        return this.attributes.map((attribute) => { return attribute.name; });
    }
    get attributesSemantics() {
        return this.attributes.map((attribute) => { return attribute.semantic; });
    }
    get attributesTypes() {
        return this.attributes.map((attribute) => { return attribute.type; });
    }
}
exports.Reflection = Reflection;
;
class Shaderity {
    constructor() {
        this.__attributeSemanticsMap = new Map();
        this.__uniformSemanticsMap = new Map();
        this.__attributeSemanticsMap.set('position', 'POSITION');
        this.__attributeSemanticsMap.set('color', 'COLOR_0');
        this.__attributeSemanticsMap.set('texcoord_0', 'TEXCOORD_0');
        this.__attributeSemanticsMap.set('texcoord_1', 'TEXCOORD_1');
        this.__attributeSemanticsMap.set('normal', 'NORMAL');
        this.__attributeSemanticsMap.set('tangent', 'TANGENT');
        this.__attributeSemanticsMap.set('joint', 'JOINTS_0');
        this.__attributeSemanticsMap.set('bone', 'JOINTS_0');
        this.__attributeSemanticsMap.set('weight', 'WEIGHTS_0');
        this.__uniformSemanticsMap.set('worldmatrix', 'WorldMatrix');
        this.__uniformSemanticsMap.set('normalmatrix', 'NormalMatrix');
        this.__uniformSemanticsMap.set('viewmatrix', 'ViewMatrix');
        this.__uniformSemanticsMap.set('projectionmatrix', 'ProjectionMatrix');
        this.__uniformSemanticsMap.set('modelviewmatrix', 'ModelViewMatrix');
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new Shaderity();
        }
        return this.__instance;
    }
    addAttributeSemanticsMap(map) {
        this.__attributeSemanticsMap = new Map([...this.__attributeSemanticsMap, ...map]);
    }
    addUniformSemanticsMap(map) {
        this.__uniformSemanticsMap = new Map([...this.__uniformSemanticsMap, ...map]);
    }
    isVertexShader(obj) {
        if (obj.shaderStage === 'vertex') {
            return true;
        }
        else {
            return false;
        }
    }
    isFragmentShader(obj) {
        if (obj.shaderStage === 'fragment' || obj.shaderStage === 'pixel') {
            return true;
        }
        else {
            return false;
        }
    }
    isPixelShader(obj) {
        return this.isFragmentShader(obj);
    }
    _replaceRow(inout_splitedSource, inReg, inAsES1) {
        for (let i = 0; i < inout_splitedSource.length; i++) {
            inout_splitedSource[i] = inout_splitedSource[i].replace(inReg, inAsES1);
        }
    }
    _convertIn(obj, inout_splitedSource) {
        const inReg = /^(?![\/])[\t ]*in[\t ]+(\w+[\t ]*\w+[\t ]*;)/;
        let inAsES1 = function (match, p1) {
            return 'attribute ' + p1;
        };
        if (this.isFragmentShader(obj)) {
            inAsES1 = function (match, p1) {
                return 'varying ' + p1;
            };
        }
        this._replaceRow(inout_splitedSource, inReg, inAsES1);
        return inout_splitedSource;
    }
    _convertOut(obj, inout_splitedSource) {
        const inReg = /^(?![\/])[\t ]*out[\t ]+(\w+[\t ]*\w+[\t ]*;)/;
        let inAsES1 = function (match, p1) {
            return 'varying ' + p1;
        };
        this._replaceRow(inout_splitedSource, inReg, inAsES1);
        return inout_splitedSource;
    }
    _createUniformSamplerMap(inout_splitedSource, row_i) {
        const uniformSamplerMap = new Map();
        for (let i = 0; i < row_i; i++) {
            const row = inout_splitedSource[i];
            const match = row.match(/^(?![\/])[\t ]*\w*[\t ]*(sampler\w+)[\t ]+(\w+)/);
            if (match) {
                const samplerType = match[1];
                const name = match[2];
                uniformSamplerMap.set(name, samplerType);
            }
        }
        return uniformSamplerMap;
    }
    _convertAttribute(obj, inout_splitedSource) {
        const inReg = /^(?![\/])[\t ]*attribute[\t ]+/g;
        let inAsES3 = 'in ';
        this._replaceRow(inout_splitedSource, inReg, inAsES3);
        return inout_splitedSource;
    }
    _convertVarying(obj, inout_splitedSource) {
        const inReg = /^(?![\/])[\t ]*varying[\t ]+/g;
        let inAsES3 = 'out ';
        if (this.isFragmentShader(obj)) {
            inAsES3 = 'in ';
        }
        this._replaceRow(inout_splitedSource, inReg, inAsES3);
        return inout_splitedSource;
    }
    _regSymbols() {
        return `[!"#$%&'()\*\+\-\.,\/:;<=>?@\[\\\]^` + '`{|}~\t\n ]';
    }
    _convertTexture2D(obj, inout_splitedSource) {
        const sbl = this._regSymbols();
        const reg = new RegExp(`(${sbl}+)(texture2D)(${sbl}+)`, 'g');
        let inAsES3 = 'texture';
        this._replaceRow(inout_splitedSource, reg, '$1' + inAsES3 + '$3');
        return inout_splitedSource;
    }
    _convertTextureCube(obj, inout_splitedSource) {
        const sbl = this._regSymbols();
        const reg = new RegExp(`(${sbl}+)(textureCube)(${sbl}+)`, 'g');
        let inAsES3 = 'texture';
        this._replaceRow(inout_splitedSource, reg, '$1' + inAsES3 + '$3');
        return inout_splitedSource;
    }
    _convertTexture2DProd(obj, inout_splitedSource) {
        const sbl = this._regSymbols();
        const reg = new RegExp(`(${sbl}+)(texture2DProj)(${sbl}+)`, 'g');
        let inAsES3 = 'textureProj';
        this._replaceRow(inout_splitedSource, reg, '$1' + inAsES3 + '$3');
        return inout_splitedSource;
    }
    copyShaderityObject(obj) {
        const copiedObj = {
            code: obj.code,
            shaderStage: obj.shaderStage
        };
        return copiedObj;
    }
    _convertTextureFunctionToES1(inout_splitedSource) {
        const sbl = this._regSymbols();
        for (let i = 0; i < inout_splitedSource.length; i++) {
            const row = inout_splitedSource[i];
            let reg = new RegExp(`(${sbl}+)(textureProj)(${sbl}+)`, 'g');
            let match = row.match(/textureProj[\t ]*\([\t ]*(\w+),/);
            if (match) {
                const name = match[1];
                const uniformSamplerMap = this._createUniformSamplerMap(inout_splitedSource, i);
                const samplerType = uniformSamplerMap.get(name);
                if (samplerType != null) {
                    let textureFunc = '';
                    switch (samplerType) {
                        case 'sampler2D':
                            textureFunc = 'texture2DProj';
                            break;
                        case 'sampler3D':
                            textureFunc = 'texture3DProj';
                            break;
                        default: console.log('not found');
                    }
                    inout_splitedSource[i] = inout_splitedSource[i].replace(reg, '$1' + textureFunc + '$3');
                }
                continue;
            }
            reg = new RegExp(`(${sbl}+)(texture)(${sbl}+)`, 'g');
            match = row.match(/texture[\t ]*\([\t ]*(\w+),/);
            if (match) {
                const name = match[1];
                const uniformSamplerMap = this._createUniformSamplerMap(inout_splitedSource, i);
                const samplerType = uniformSamplerMap.get(name);
                if (samplerType != null) {
                    let textureFunc = '';
                    switch (samplerType) {
                        case 'sampler2D':
                            textureFunc = 'texture2D';
                            break;
                        case 'sampler3D':
                            textureFunc = 'texture3D';
                            break;
                        case 'samplerCube':
                            textureFunc = 'textureCube';
                            break;
                        default: console.log('not found');
                    }
                    inout_splitedSource[i] = inout_splitedSource[i].replace(reg, '$1' + textureFunc + '$3');
                }
            }
        }
        return inout_splitedSource;
    }
    transformToGLSLES1(obj) {
        const copy = this.copyShaderityObject(obj);
        let splited = this._splitShaderCode(obj.code);
        this._convertIn(obj, splited);
        this._convertOut(obj, splited);
        splited = this._convertTextureFunctionToES1(splited);
        copy.code = this._joinSplitedRow(splited);
        return copy;
    }
    transformToGLSLES3(obj) {
        const copy = this.copyShaderityObject(obj);
        let splited = this._splitShaderCode(obj.code);
        this._convertAttribute(obj, splited);
        this._convertVarying(obj, splited);
        this._convertTexture2D(obj, splited);
        this._convertTextureCube(obj, splited);
        this._convertTexture2DProd(obj, splited);
        copy.code = this._joinSplitedRow(splited);
        return copy;
    }
    transformTo(version, obj) {
        if (version.match(/webgl2|es3/i)) {
            return this.transformToGLSLES3(obj);
        }
        else if (version.match(/webgl1|es1/i)) {
            return this.transformToGLSLES1(obj);
        }
        else {
            console.error('Invalid Version');
            return obj;
        }
    }
    _splitShaderCode(source) {
        return source.split(/\r\n|\n/);
    }
    _joinSplitedRow(splitedRow) {
        return splitedRow.join('\n');
    }
    /**
     * Fill arguments into template shader text in ShaderityObject.
     * @param obj a shaderity object
     * @returns a copied and processed shaderity object
     */
    fillTemplate(obj, arg) {
        const copy = this.copyShaderityObject(obj);
        const templateString = obj.code.replace(/\/\*[\t ]*shaderity:[\t ]*(@{[\t ]*)(\S+)([\t ]*})[\t ]*\*\//g, '${this.$2}');
        const fillTemplate = function (templateString, arg) {
            return new Function("return `" + templateString + "`;").call(arg);
        };
        copy.code = fillTemplate(templateString, arg);
        return copy;
    }
    insertDefinition(obj, definition) {
        const copy = this.copyShaderityObject(obj);
        let splited = this._splitShaderCode(obj.code);
        const defStr = definition.replace(/#define[\t ]+/, '');
        splited.unshift(`#define ${defStr}`);
        copy.code = this._joinSplitedRow(splited);
        return copy;
    }
    reflect(obj) {
        let splited = this._splitShaderCode(obj.code);
        const reflection = new Reflection();
        const varTypes = /[\t ]+(float|int|vec2|vec3|vec4|mat2|mat3|mat4|ivec2|ivec3|ivec4)[\t ]+(\w+);/;
        const varTypes2 = /[\t ]+(float|int|vec2|vec3|vec4|mat2|mat3|mat4|ivec2|ivec3|ivec4|sampler2D|samplerCube|sampler3D)[\t ]+(\w+);/;
        const semanticRegExp = /<.*semantic[\t ]*=[\t ]*(\w+).*>/;
        for (let row of splited) {
            if (obj.shaderStage === 'vertex') {
                const attributeMatch = row.match(/^(?![\/])[\t ]*(attribute|in)[\t ]+.+;/);
                if (attributeMatch) {
                    const reflectionAttribute = {
                        name: '',
                        type: 'float',
                        semantic: 'UNKNOWN'
                    };
                    const match = row.match(varTypes);
                    if (match) {
                        const type = match[1];
                        reflectionAttribute.type = type;
                        const name = match[2];
                        reflectionAttribute.name = name;
                        const match2 = row.match(semanticRegExp);
                        if (match2) {
                            reflectionAttribute.semantic = match2[1];
                        }
                        else {
                            for (let [key, value] of this.__attributeSemanticsMap) {
                                if (name.match(new RegExp(key, 'i'))) {
                                    reflectionAttribute.semantic = value;
                                }
                            }
                        }
                    }
                    reflection.attributes.push(reflectionAttribute);
                    continue;
                }
            }
            let varyingMatch;
            if (obj.shaderStage === 'vertex') {
                varyingMatch = row.match(/^(?![\/])[\t ]*(varying|out)[\t ]+.+;/);
            }
            else {
                varyingMatch = row.match(/^(?![\/])[\t ]*(varying|in)[\t ]+.+;/);
            }
            if (varyingMatch) {
                const reflectionVarying = {
                    name: '',
                    type: 'float',
                    inout: 'in'
                };
                const match = row.match(varTypes);
                if (match) {
                    const type = match[1];
                    reflectionVarying.type = type;
                    const name = match[2];
                    reflectionVarying.name = name;
                    reflectionVarying.inout = (obj.shaderStage === 'vertex') ? 'out' : 'in';
                }
                reflection.varyings.push(reflectionVarying);
                continue;
            }
            const uniformMatch = row.match(/^(?![\/])[\t ]*uniform[\t ]+/);
            if (uniformMatch) {
                const reflectionUniform = {
                    name: '',
                    type: 'float',
                    semantic: 'UNKNOWN'
                };
                const match = row.match(varTypes2);
                if (match) {
                    const type = match[1];
                    reflectionUniform.type = type;
                    const name = match[2];
                    reflectionUniform.name = name;
                    const match2 = row.match(semanticRegExp);
                    if (match2) {
                        reflectionUniform.semantic = match2[1];
                    }
                    else {
                        for (let [key, value] of this.__uniformSemanticsMap) {
                            if (name.match(new RegExp(key, 'i'))) {
                                reflectionUniform.semantic = value;
                            }
                        }
                    }
                }
                reflection.uniforms.push(reflectionUniform);
                continue;
            }
        }
        return reflection;
    }
    _defineGLSLES3() {
    }
}
exports.default = Shaderity;


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/effekseer/EffekseerComponent.ts":
/*!*********************************************!*\
  !*** ./src/effekseer/EffekseerComponent.ts ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EffekseerComponent; });
/* harmony import */ var _foundation_core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../foundation/core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../foundation/components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _foundation_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../foundation/definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _foundation_components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../foundation/components/TransformComponent */ "./src/foundation/components/TransformComponent.ts");
/* harmony import */ var _foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../foundation/components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../foundation/core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../foundation/components/WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../foundation/renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _foundation_core_Config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../foundation/core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _foundation_math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../foundation/math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");










class EffekseerComponent extends _foundation_core_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(entityUid, componentSid, entityRepository) {
        super(entityUid, componentSid, entityRepository);
        this.__speed = 1;
        this.playJustAfterLoaded = false;
        this.isLoop = false;
        _foundation_core_Config__WEBPACK_IMPORTED_MODULE_8__["default"].noWebGLTex2DStateCache = true;
    }
    static get componentTID() {
        return _foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_6__["WellKnownComponentTIDs"].EffekseerComponentTID;
    }
    cancelLoop() {
        clearInterval(this.__timer);
    }
    play() {
        const __play = () => {
            // Play the loaded effect
            this.__handle = effekseer.play(this.__effect);
        };
        if (this.isLoop) {
            this.__timer = setInterval(__play, 200);
        }
        else {
            __play();
        }
    }
    set playSpeed(val) {
        if (this.__handle) {
            this.__handle.setSpeed(val);
        }
        this.__speed = val;
    }
    get playSpeed() {
        return this.__speed;
    }
    set translate(vec) {
        if (this.__handle) {
            this.__handle.setLocation(vec.x, vec.y, vec.z);
        }
        this.__transformComponent.translate = vec;
    }
    get translate() {
        return this.__transformComponent.translate;
    }
    set rotate(vec) {
        if (this.__handle) {
            this.__handle.setRotation(vec.x, vec.y, vec.z);
        }
        this.__transformComponent.rotate = vec;
    }
    get rotate() {
        return this.__transformComponent.rotate;
    }
    set scale(vec) {
        if (this.__handle) {
            this.__handle.setScale(vec.x, vec.y, vec.z);
        }
        this.__transformComponent.scale = vec;
    }
    get scale() {
        return this.__transformComponent.scale;
    }
    $create() {
        this.__sceneGraphComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_1__["default"]);
        this.__transformComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _foundation_components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__["default"]);
        this.moveStageTo(_foundation_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_2__["ProcessStage"].Load);
    }
    static common_$load() {
        if (EffekseerComponent.__isInitialized) {
            return;
        }
        const webGLResourceRepository = _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_7__["default"].getWebGLResourceRepository();
        const glw = webGLResourceRepository.currentWebGLContextWrapper;
        if (glw) {
            effekseer.init(glw.getRawContext());
            EffekseerComponent.__isInitialized = true;
        }
    }
    $load() {
        if (this.__effect == null) {
            this.__effect = effekseer.loadEffect(this.uri, () => {
                if (this.playJustAfterLoaded) {
                    if (this.isLoop) {
                        this.__timer = setInterval(() => { this.play(); }, 500);
                    }
                    else {
                        this.play();
                    }
                }
            });
        }
        this.moveStageTo(_foundation_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_2__["ProcessStage"].Logic);
    }
    static common_$logic() {
        effekseer.update();
    }
    $logic() {
        if (this.__handle != null) {
            const worldMatrix = EffekseerComponent.__tmp_identityMatrix_0.copyComponents(this.__sceneGraphComponent.worldMatrixInner);
            this.__handle.setMatrix(worldMatrix.v);
            this.__handle.setSpeed(this.__speed);
        }
    }
    static common_$render() {
        const cameraComponent = _foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_5__["default"].getInstance().getComponent(_foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_4__["default"], _foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_4__["default"].main);
        const viewMatrix = EffekseerComponent.__tmp_identityMatrix_0;
        const projectionMatrix = EffekseerComponent.__tmp_identityMatrix_1;
        if (cameraComponent) {
            viewMatrix.copyComponents(cameraComponent.viewMatrix);
            projectionMatrix.copyComponents(cameraComponent.projectionMatrix);
        }
        else {
            viewMatrix.identity();
            projectionMatrix.identity();
        }
        effekseer.setProjectionMatrix(projectionMatrix.v);
        effekseer.setCameraMatrix(viewMatrix.v);
        effekseer.draw();
    }
}
EffekseerComponent.__isInitialized = false;
EffekseerComponent.__tmp_identityMatrix_0 = _foundation_math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_9__["default"].identity();
EffekseerComponent.__tmp_identityMatrix_1 = _foundation_math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_9__["default"].identity();
_foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_5__["default"].registerComponentClass(EffekseerComponent);


/***/ }),

/***/ "./src/effekseer/main.ts":
/*!*******************************!*\
  !*** ./src/effekseer/main.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _EffekseerComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EffekseerComponent */ "./src/effekseer/EffekseerComponent.ts");
/* harmony import */ var _foundation_core_EntityRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../foundation/core/EntityRepository */ "./src/foundation/core/EntityRepository.ts");
/* harmony import */ var _foundation_components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../foundation/components/TransformComponent */ "./src/foundation/components/TransformComponent.ts");
/* harmony import */ var _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../foundation/components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");




const createEffekseerEntity = function () {
    const entityRepository = _foundation_core_EntityRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance();
    const entity = entityRepository.createEntity([_foundation_components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__["default"], _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_3__["default"], _EffekseerComponent__WEBPACK_IMPORTED_MODULE_0__["default"]]);
    return entity;
};
const Effekseer = Object.freeze({
    EffekseerComponent: _EffekseerComponent__WEBPACK_IMPORTED_MODULE_0__["default"],
    createEffekseerEntity
});
/* harmony default export */ __webpack_exports__["default"] = (Effekseer);


/***/ }),

/***/ "./src/foundation/cameras/AbstractCameraController.ts":
/*!************************************************************!*\
  !*** ./src/foundation/cameras/AbstractCameraController.ts ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AbstractCameraController; });
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");

class AbstractCameraController {
    constructor() {
        this.zNearLimitFactor = 10; // must be more than 0
        this.zFarScalingFactor = 10000;
        this.autoCalculateZNearAndZFar = true;
    }
    _calcZNearInner(camera, eyePosition, eyeDirection) {
        if (this.autoCalculateZNearAndZFar && this.__targetEntity != null) {
            const targetAABB = this.__targetEntity.getSceneGraph().worldAABB;
            const lengthOfCenterToEye = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].lengthBtw(eyePosition, targetAABB.centerPoint);
            const sizeMin = Math.min(targetAABB.sizeX, targetAABB.sizeY, targetAABB.sizeZ);
            // avoid minLimit equals to 0
            const halfSizeMinNon0 = sizeMin > 0 ? sizeMin / 2 :
                Math.min(targetAABB.sizeX > 0 ? targetAABB.sizeX : Infinity, targetAABB.sizeY > 0 ? targetAABB.sizeY : Infinity, targetAABB.sizeZ > 0 ? targetAABB.sizeZ : Infinity) / 2;
            const minLimit = halfSizeMinNon0 / this.zNearLimitFactor;
            if (lengthOfCenterToEye - targetAABB.lengthCenterToCorner < minLimit) {
                camera.zNearInner = minLimit;
                return;
            }
            // calc cos between eyeToTarget and eye direction
            const eyeToTargetDirectionX = targetAABB.centerPoint.v[0] - eyePosition.v[0];
            const eyeToTargetDirectionY = targetAABB.centerPoint.v[1] - eyePosition.v[1];
            const eyeToTargetDirectionZ = targetAABB.centerPoint.v[2] - eyePosition.v[2];
            const cos = (eyeToTargetDirectionX * eyeDirection.v[0] + eyeToTargetDirectionY * eyeDirection.v[1] + eyeToTargetDirectionZ * eyeDirection.v[2])
                / (Math.hypot(eyeToTargetDirectionX, eyeToTargetDirectionY, eyeToTargetDirectionZ) * eyeDirection.length());
            camera.zNearInner = Math.max(lengthOfCenterToEye * cos - targetAABB.lengthCenterToCorner, minLimit);
        }
        else {
            camera.zNearInner = camera.zNear;
        }
    }
    _calcZFarInner(camera) {
        if (this.autoCalculateZNearAndZFar) {
            camera.zFarInner = camera.zNearInner * this.zFarScalingFactor;
        }
        else {
            camera.zNearInner = camera.zFar;
        }
    }
}


/***/ }),

/***/ "./src/foundation/cameras/OrbitCameraController.ts":
/*!*********************************************************!*\
  !*** ./src/foundation/cameras/OrbitCameraController.ts ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OrbitCameraController; });
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");
/* harmony import */ var _math_MathUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/MathUtil */ "./src/foundation/math/MathUtil.ts");
/* harmony import */ var _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/MutableMatrix33 */ "./src/foundation/math/MutableMatrix33.ts");
/* harmony import */ var _math_Matrix44__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _AbstractCameraController__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AbstractCameraController */ "./src/foundation/cameras/AbstractCameraController.ts");







class OrbitCameraController extends _AbstractCameraController__WEBPACK_IMPORTED_MODULE_6__["default"] {
    constructor() {
        super();
        this.__isKeyUp = true;
        this.__originalY = -1;
        this.__originalX = -1;
        this.__buttonNumber = 0;
        this.__mouse_translate_y = 0;
        this.__mouse_translate_x = 0;
        this.__efficiency = 1;
        this.__lengthOfCenterToEye = 1;
        this.__fovyBias = 1.0;
        this.__scaleOfTranslation = 2.8;
        this.__mouseTranslateVec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
        this.__newEyeVec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
        this.__newCenterVec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
        this.__newUpVec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
        this.__newTangentVec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
        // private __verticalAngleThreshold = 0;
        // private __verticalAngleOfVectors = 0;
        this.__isSymmetryMode = true;
        // private __doResetWhenCameraSettingChanged = false;
        this.__rot_bgn_x = 0;
        this.__rot_bgn_y = 0;
        this.__rot_x = 0;
        this.__rot_y = 0;
        this.__dolly = 0.5;
        this.dollyScale = 2.0;
        this.__eyeVec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
        this.__centerVec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
        this.__upVec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
        this.scaleOfLengthCenterToCamera = 1.0;
        this.__scaleOfZNearAndZFar = 5000;
        this.__doPreventDefault = true;
        this.moveSpeed = 1;
        this.__isPressingShift = false;
        this.__isPressingCtrl = false;
        this.__pinchInOutControl = false;
        this.__pinchInOutOriginalDistance = null;
        this.__resetDollyTouchTime = 0;
        // private __controllerTranslate = MutableVector3.zero();
        this.__mouseDownFunc = this.__mouseDown.bind(this);
        this.__mouseUpFunc = this.__mouseUp.bind(this);
        this.__mouseMoveFunc = this.__mouseMove.bind(this);
        this.__touchDownFunc = this.__touchDown.bind(this);
        this.__touchUpFunc = this.__touchUp.bind(this);
        this.__touchMoveFunc = this.__touchMove.bind(this);
        this.__pinchInOutFunc = this.__pinchInOut.bind(this);
        this.__pinchInOutEndFunc = this.__pinchInOutEnd.bind(this);
        this.__mouseWheelFunc = this.__mouseWheel.bind(this);
        this.__mouseDblClickFunc = this.__mouseDblClick.bind(this);
        this.__contextMenuFunc = this.__contextMenu.bind(this);
        this.__pressShiftFunc = this.__pressShift.bind(this);
        this.__releaseShiftFunc = this.__releaseShift.bind(this);
        this.__pressCtrlFunc = this.__pressCtrl.bind(this);
        this.__releaseCtrlFunc = this.__releaseCtrl.bind(this);
        this.__resetDollyAndPositionFunc = this.__resetDollyAndPosition.bind(this);
        this.registerEventListeners();
    }
    setTarget(targetEntity) {
        this.__targetEntity = targetEntity;
    }
    getTarget() {
        return this.__targetEntity;
    }
    set doPreventDefault(flag) {
        this.__doPreventDefault = flag;
    }
    get doPreventDefault() {
        return this.__doPreventDefault;
    }
    __mouseDown(e) {
        this.__tryToPreventDefault(e);
        if (!this.__isKeyUp)
            return;
        if (this.__isPressingCtrl)
            return;
        this.__originalX = e.clientX;
        this.__originalY = e.clientY;
        this.__rot_bgn_x = this.__rot_x;
        this.__rot_bgn_y = this.__rot_y;
        this.__isKeyUp = false;
        // if (typeof e.buttons !== "undefined") {
        //        this.updateCamera();
        // }
    }
    __mouseMove(e) {
        this.__tryToPreventDefault(e);
        if (this.__isKeyUp)
            return;
        if (this.__isPressingCtrl)
            return;
        if (this.__buttonNumber === 0) {
            this.__buttonNumber = e.buttons;
        }
        const currentMouseX = e.clientX;
        const currentMouseY = e.clientY;
        switch (this.__buttonNumber) {
            case 1: // left
                if (this.__isPressingShift) {
                    this.__parallelTranslateControl(this.__originalX, this.__originalY, currentMouseX, currentMouseY);
                }
                else {
                    this.__rotateControl(this.__originalX, this.__originalY, currentMouseX, currentMouseY);
                    this.__rot_bgn_x = this.__rot_x;
                    this.__rot_bgn_y = this.__rot_y;
                }
                break;
            case 2: // right
                this.__zoomControl(this.__originalX, currentMouseX);
                break;
            case 4: // center
                this.__parallelTranslateControl(this.__originalX, this.__originalY, currentMouseX, currentMouseY);
                break;
            default:
                return;
        }
        this.__originalX = currentMouseX;
        this.__originalY = currentMouseY;
    }
    ;
    __mouseUp(e) {
        this.__buttonNumber = 0;
        this.__originalX = -1;
        this.__originalY = -1;
        this.__isKeyUp = true;
    }
    __touchDown(e) {
        this.__tryToPreventDefault(e);
        if (e.touches.length === 1) {
            this.__originalX = e.touches[0].clientX;
            this.__originalY = e.touches[0].clientY;
            this.__rot_bgn_x = this.__rot_x;
            this.__rot_bgn_y = this.__rot_y;
        }
        else {
            this.__originalX = (e.touches[0].clientX + e.touches[1].clientX) * 0.5;
            this.__originalY = (e.touches[0].clientY + e.touches[1].clientY) * 0.5;
        }
        this.__isKeyUp = false;
    }
    __touchMove(e) {
        this.__tryToPreventDefault(e);
        if (this.__isKeyUp)
            return;
        let currentTouchX = e.touches[0].clientX;
        let currentTouchY = e.touches[0].clientY;
        if (e.touches.length === 1) {
            currentTouchX = e.touches[0].clientX;
            currentTouchY = e.touches[0].clientY;
            this.__rotateControl(this.__originalX, this.__originalY, currentTouchX, currentTouchY);
            this.__rot_bgn_x = this.__rot_x;
            this.__rot_bgn_y = this.__rot_y;
        }
        else {
            currentTouchX = (e.touches[0].clientX + e.touches[1].clientX) * 0.5;
            currentTouchY = (e.touches[0].clientY + e.touches[1].clientY) * 0.5;
            this.__parallelTranslateControl(this.__originalX, this.__originalY, currentTouchX, currentTouchY);
        }
        this.__originalX = currentTouchX;
        this.__originalY = currentTouchY;
    }
    __touchUp(e) {
        const touchNumber = e.touches.length;
        if (touchNumber === 0) {
            this.__originalX = -1;
            this.__originalY = -1;
            this.__isKeyUp = true;
        }
        else if (touchNumber === 1) {
            this.__originalX = e.touches[0].clientX;
            this.__originalY = e.touches[0].clientY;
            this.__rot_bgn_x = this.__rot_x;
            this.__rot_bgn_y = this.__rot_y;
        }
        else {
            this.__originalX = (e.touches[0].clientX + e.touches[1].clientX) * 0.5;
            this.__originalY = (e.touches[0].clientY + e.touches[1].clientY) * 0.5;
        }
    }
    set rotX(value) {
        this.__rot_x = value;
    }
    set rotY(value) {
        this.__rot_y = value;
    }
    get rotX() {
        return this.__rot_x;
    }
    get rotY() {
        return this.__rot_y;
    }
    set maximumY(maximum_y) {
        this.__maximum_y = maximum_y;
    }
    set minimumY(minimum_y) {
        this.__minimum_y = minimum_y;
    }
    __rotateControl(originalX, originalY, currentX, currentY) {
        // calc rotation angle
        let delta_x = (currentX - originalX) * this.__efficiency * 0.3;
        let delta_y = (currentY - originalY) * this.__efficiency * 0.3;
        this.__rot_x = this.__rot_bgn_x - delta_x;
        this.__rot_y = this.__rot_bgn_y - delta_y;
        // check if rotation angle is within range
        // if (
        //   this.__verticalAngleThreshold - this.__verticalAngleOfVectors < this.__rot_y
        // ) {
        //          this._rot_y -= this._rot_y - (this._verticalAngleThreshold - this._verticalAngleOfVectors);
        // }
        // if (
        //   this.__rot_y < -this.__verticalAngleThreshold + this.__verticalAngleOfVectors
        // ) {
        //         this._rot_y += this._rot_y - (this._verticalAngleThreshold - this._verticalAngleOfVectors);
        // }
        if (this.__maximum_y != null && this.__rot_y > this.__maximum_y) {
            this.__rot_y = this.__maximum_y;
        }
        if (this.__minimum_y != null && this.__rot_y < this.__minimum_y) {
            this.__rot_y = this.__minimum_y;
        }
    }
    __zoomControl(originalValue, currentValue) {
        this.dolly -= ((currentValue - originalValue) / 1000) * this.__efficiency;
    }
    __parallelTranslateControl(originalX, originalY, currentX, currentY) {
        this.__mouse_translate_y = ((currentY - originalY) / 1000) * this.__efficiency;
        this.__mouse_translate_x = ((currentX - originalX) / 1000) * this.__efficiency;
        const scale = this.__lengthOfCenterToEye * this.__fovyBias * this.__scaleOfTranslation;
        const upDirTranslateVec = OrbitCameraController.__tmpVec3_0;
        upDirTranslateVec.copyComponents(this.__newUpVec).normalize().multiply(this.__mouse_translate_y).multiply(scale);
        const tangentDirTranslateVec = OrbitCameraController.__tmpVec3_1;
        tangentDirTranslateVec.copyComponents(this.__newTangentVec).normalize().multiply(this.__mouse_translate_x).multiply(scale);
        this.__mouseTranslateVec.add(upDirTranslateVec).add(tangentDirTranslateVec);
    }
    __getTouchesDistance(e) {
        const touches = e.touches;
        const diffX = touches[1].clientX - touches[0].clientX;
        const diffY = touches[1].clientY - touches[0].clientY;
        return Math.hypot(diffX, diffY);
    }
    __pinchInOut(e) {
        if (e.touches.length < 2)
            return;
        if (this.__pinchInOutOriginalDistance == null) {
            this.__pinchInOutOriginalDistance = this.__getTouchesDistance(e);
            return;
        }
        const currentDistance = this.__getTouchesDistance(e);
        const originalDistance = this.__pinchInOutOriginalDistance;
        if (!this.__pinchInOutControl) {
            if (Math.abs(currentDistance - originalDistance) > 35.0) {
                this.__pinchInOutOriginalDistance = currentDistance;
                this.__pinchInOutControl = true;
            }
            return;
        }
        const ratio = originalDistance / currentDistance;
        this.dolly *= Math.pow(ratio * this.__efficiency, 2.2 / 15.0);
        this.__pinchInOutOriginalDistance = currentDistance;
    }
    __pinchInOutEnd(e) {
        if (e.touches.length < 2) {
            this.__pinchInOutControl = false;
            this.__pinchInOutOriginalDistance = null;
        }
    }
    __tryToPreventDefault(evt) {
        if (this.__doPreventDefault) {
            evt.preventDefault();
        }
    }
    __mouseWheel(evt) {
        this.__tryToPreventDefault(evt);
        this.dolly += Math.sign(evt.deltaY) / 200;
    }
    ;
    __contextMenu(evt) {
        this.__tryToPreventDefault(evt);
    }
    ;
    set dolly(value) {
        value = Math.min(value, 1);
        value = Math.max(value, 0.0001);
        let gamma = Math.pow(value, 5);
        gamma = Math.max(gamma, 0.0001);
        this.__dolly = gamma;
    }
    get dolly() {
        return Math.pow(this.__dolly, 1 / 5);
    }
    __mouseDblClick(evt) {
        if (evt.shiftKey) {
            this.__mouseTranslateVec.zero();
        }
        else if (evt.ctrlKey) {
            this.__rot_y = 0;
            this.__rot_x = 0;
            this.__rot_bgn_y = 0;
            this.__rot_bgn_x = 0;
        }
    }
    ;
    __resetDollyAndPosition(e) {
        if (e.touches.length > 1)
            return;
        const currentTime = new Date().getTime();
        if (currentTime - this.__resetDollyTouchTime < 300) {
            this.dolly = Math.pow(0.5, 1.0 / 2.2);
            this.__mouseTranslateVec.zero();
            this.__rot_x = 0;
            this.__rot_y = 0;
        }
        else {
            this.__resetDollyTouchTime = currentTime;
        }
    }
    __pressShift(e) {
        if (e.shiftKey === true) {
            this.__isPressingShift = true;
        }
    }
    __releaseShift(e) {
        if (e.shiftKey === false) {
            this.__isPressingShift = false;
        }
    }
    __pressCtrl(e) {
        if (e.ctrlKey === true) {
            this.__isPressingCtrl = true;
        }
    }
    __releaseCtrl(e) {
        if (e.ctrlKey === false) {
            this.__isPressingCtrl = false;
        }
    }
    registerEventListeners(eventTargetDom = document) {
        this._eventTargetDom = eventTargetDom;
        if (eventTargetDom) {
            if ("ontouchend" in document) {
                eventTargetDom.addEventListener("touchstart", this.__touchDownFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("touchmove", this.__touchMoveFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("touchend", this.__touchUpFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("touchmove", this.__pinchInOutFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("touchend", this.__pinchInOutEndFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("touchstart", this.__resetDollyAndPositionFunc, { passive: !this.__doPreventDefault });
            }
            else {
                eventTargetDom.addEventListener("mousedown", this.__mouseDownFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("mouseup", this.__mouseUpFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("mouseleave", this.__mouseUpFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("mousemove", this.__mouseMoveFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("keydown", this.__pressShiftFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("keyup", this.__releaseShiftFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("keydown", this.__pressCtrlFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("keyup", this.__releaseCtrlFunc, { passive: !this.__doPreventDefault });
                eventTargetDom.addEventListener("contextmenu", (e) => { e.preventDefault(); });
            }
            if (window.WheelEvent) {
                eventTargetDom.addEventListener("wheel", this.__mouseWheelFunc, { passive: !this.__doPreventDefault });
            }
            eventTargetDom.addEventListener("contextmenu", this.__contextMenuFunc, { passive: !this.__doPreventDefault });
            eventTargetDom.addEventListener("dblclick", this.__mouseDblClickFunc, { passive: !this.__doPreventDefault });
        }
    }
    unregisterEventListeners() {
        const eventTargetDom = this._eventTargetDom;
        if (eventTargetDom) {
            if ("ontouchend" in document) {
                eventTargetDom.removeEventListener("touchstart", this.__touchDownFunc);
                eventTargetDom.removeEventListener("touchmove", this.__touchMoveFunc);
                eventTargetDom.removeEventListener("touchend", this.__touchUpFunc);
                eventTargetDom.removeEventListener("touchmove", this.__pinchInOutFunc);
                eventTargetDom.removeEventListener("touchend", this.__pinchInOutEndFunc);
                eventTargetDom.removeEventListener("touchstart", this.__resetDollyAndPositionFunc);
            }
            else {
                eventTargetDom.removeEventListener("mousedown", this.__mouseDownFunc);
                eventTargetDom.removeEventListener("mouseup", this.__mouseUpFunc);
                eventTargetDom.removeEventListener("mouseleave", this.__mouseUpFunc);
                eventTargetDom.removeEventListener("mousemove", this.__mouseMoveFunc);
                eventTargetDom.removeEventListener("keydown", this.__pressShiftFunc);
                eventTargetDom.removeEventListener("keyup", this.__releaseShiftFunc);
                eventTargetDom.removeEventListener("contextmenu", (e) => { e.preventDefault(); });
            }
            if (window.WheelEvent) {
                eventTargetDom.removeEventListener("wheel", this.__mouseWheelFunc);
            }
            eventTargetDom.removeEventListener("contextmenu", this.__contextMenuFunc);
            eventTargetDom.removeEventListener("dblclick", this.__mouseDblClickFunc);
        }
    }
    __getFovyFromCamera(camera) {
        if (camera.fovy) {
            return camera.fovy;
        }
        else {
            return _math_MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].radianToDegree(2 * Math.atan(Math.abs(camera.top - camera.bottom) / (2 * camera.zNear)));
        }
    }
    logic(cameraComponent) {
        this.__updateTargeting(cameraComponent);
        this.__calculateInfluenceOfController();
        this.__updateCameraComponent(cameraComponent);
    }
    /**
     * @private update center, eye and up vectors of OrbitCameraController
     */
    __updateTargeting(camera) {
        const eyeVec = camera.eye;
        const centerVec = camera._direction;
        const upVec = camera._up;
        const newEyeVec = this.__eyeVec;
        const newCenterVec = this.__centerVec;
        const newUpVec = this.__upVec.copyComponents(upVec);
        if (this.__targetEntity == null) {
            newEyeVec.copyComponents(eyeVec);
            newCenterVec.copyComponents(centerVec);
        }
        else {
            const targetAABB = this.__targetEntity.getSceneGraph().worldAABB;
            // calc newCenterVec
            newCenterVec.copyComponents(targetAABB.centerPoint);
            // calc newEyeVec
            const centerToCameraVec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].subtractTo(eyeVec, centerVec, newEyeVec);
            const centerToCameraVecNormalized = centerToCameraVec.normalize();
            const lengthCenterToCamera = targetAABB.lengthCenterToCorner * (1.0 + 1.0 / Math.tan(_math_MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].degreeToRadian(camera.fovy / 2.0))) * this.scaleOfLengthCenterToCamera;
            centerToCameraVecNormalized.multiply(lengthCenterToCamera).add(newCenterVec);
            const sg = camera.entity.getSceneGraph();
            if (sg != null) {
                const invMat = _math_Matrix44__WEBPACK_IMPORTED_MODULE_4__["default"].invertTo(sg.worldMatrixInner, OrbitCameraController.__tmpMat44_0);
                invMat.multiplyVector3To(newCenterVec, newCenterVec);
                invMat.multiplyVector3To(newEyeVec, newEyeVec);
                invMat.multiplyVector3To(newUpVec, newUpVec);
            }
        }
    }
    /**
     * @private calculate up, eye, center and tangent vector with controller influence
     */
    __calculateInfluenceOfController() {
        const centerToEyeVec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].subtractTo(this.__eyeVec, this.__centerVec, OrbitCameraController.__tmpVec3_0);
        centerToEyeVec.multiply(this.__dolly * this.dollyScale);
        this.__lengthOfCenterToEye = centerToEyeVec.length();
        const newUpVec = this.__newUpVec;
        const newEyeVec = this.__newEyeVec;
        const newCenterVec = this.__newCenterVec;
        const newTangentVec = this.__newTangentVec;
        if (this.__isSymmetryMode) {
            const projectedCenterToEyeVec = OrbitCameraController.__tmpVec3_1;
            projectedCenterToEyeVec.setComponents(centerToEyeVec.x, 0, centerToEyeVec.z);
            let horizontalAngleOfVectors = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].angleOfVectors(projectedCenterToEyeVec, OrbitCameraController.__tmp_up);
            const horizontalSign = Math.sign(projectedCenterToEyeVec.cross(OrbitCameraController.__tmp_up).y);
            horizontalAngleOfVectors *= horizontalSign;
            const rotateM_X = OrbitCameraController.__tmp_rotateM_X;
            const rotateM_Y = OrbitCameraController.__tmp_rotateM_Y;
            const rotateM_Reset = OrbitCameraController.__tmp_rotateM_Reset;
            const rotateM_Revert = OrbitCameraController.__tmp_rotateM_Revert;
            rotateM_X.rotateX(_math_MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].degreeToRadian(this.__rot_y));
            rotateM_Y.rotateY(_math_MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].degreeToRadian(this.__rot_x));
            rotateM_Reset.rotateY(_math_MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].degreeToRadian(horizontalAngleOfVectors));
            rotateM_Revert.rotateY(_math_MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].degreeToRadian(-horizontalAngleOfVectors));
            const rotateM = OrbitCameraController.__tmp_rotateM;
            _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_3__["default"].multiplyTo(rotateM_X, rotateM_Reset, rotateM);
            rotateM.multiplyByLeft(rotateM_Y);
            rotateM.multiplyByLeft(rotateM_Revert);
            rotateM.multiplyVectorTo(this.__upVec, newUpVec);
            rotateM.multiplyVectorTo(centerToEyeVec, newEyeVec).add(this.__centerVec);
            newCenterVec.copyComponents(this.__centerVec);
            const newEyeToCenterVec = OrbitCameraController.__tmpVec3_2;
            _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].subtractTo(newCenterVec, newEyeVec, newEyeToCenterVec);
            _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].crossTo(newUpVec, newEyeToCenterVec, newTangentVec);
            newEyeVec.add(this.__mouseTranslateVec);
            newCenterVec.add(this.__mouseTranslateVec);
            // const horizonResetVec = OrbitCameraController.__tmpVec3_2;
            // rotateM_Reset.multiplyVectorTo(centerToEyeVec, horizonResetVec);
            // this.__verticalAngleOfVectors = Vector3.angleOfVectors(horizonResetVec, OrbitCameraController.__tmp_up);
            // const verticalSign = Math.sign(Vector3.crossTo(horizonResetVec, OrbitCameraController.__tmp_up, OrbitCameraController.__tmp_verticalSign).x);
            //this._verticalAngleOfVectors *= verticalSign;
        }
        else {
            const rotateM_X = OrbitCameraController.__tmp_rotateM_X;
            const rotateM_Y = OrbitCameraController.__tmp_rotateM_Y;
            rotateM_X.rotateX(_math_MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].degreeToRadian(this.__rot_y));
            rotateM_Y.rotateY(_math_MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].degreeToRadian(this.__rot_x));
            const rotateM = _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_3__["default"].multiplyTo(rotateM_Y, rotateM_X, OrbitCameraController.__tmp_rotateM);
            rotateM.multiplyVectorTo(this.__upVec, newUpVec);
            rotateM.multiplyVectorTo(centerToEyeVec, newEyeVec).add(this.__centerVec);
            newCenterVec.copyComponents(this.__centerVec);
            const newEyeToCenterVec = OrbitCameraController.__tmpVec3_1;
            _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].subtractTo(newCenterVec, newEyeVec, newEyeToCenterVec);
            _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].crossTo(newUpVec, newEyeToCenterVec, newTangentVec);
            newEyeVec.add(this.__mouseTranslateVec);
            newCenterVec.add(this.__mouseTranslateVec);
        }
    }
    __updateCameraComponent(camera) {
        const eyeDirection = OrbitCameraController.__tmpVec3_0.copyComponents(this.__newCenterVec);
        eyeDirection.subtract(this.__newEyeVec).normalize();
        this._calcZNearInner(camera, this.__newEyeVec, eyeDirection);
        this._calcZFarInner(camera);
        const ratio = camera.zFar / camera.zNear;
        const minRatio = this.__scaleOfZNearAndZFar;
        const scale = ratio / minRatio;
        const newLeft = camera.left + scale;
        const newRight = camera.right + scale;
        const newTop = camera.top + scale;
        const newBottom = camera.bottom + scale;
        const fovy = this.__getFovyFromCamera(camera);
        this.__fovyBias = Math.tan(_math_MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].degreeToRadian(fovy / 2.0));
        camera.eyeInner = this.__newEyeVec;
        camera.directionInner = this.__newCenterVec;
        camera.upInner = this.__newUpVec;
        camera.leftInner = newLeft;
        camera.rightInner = newRight;
        camera.topInner = newTop;
        camera.bottomInner = newBottom;
        camera.fovyInner = fovy;
    }
    set scaleOfZNearAndZFar(value) {
        this.__scaleOfZNearAndZFar = value;
    }
    get scaleOfZNearAndZFar() {
        return this.__scaleOfZNearAndZFar;
    }
}
OrbitCameraController.__tmp_up = new _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](0, 0, 1);
OrbitCameraController.__tmpVec3_0 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
OrbitCameraController.__tmpVec3_1 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
OrbitCameraController.__tmpVec3_2 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
OrbitCameraController.__tmp_rotateM_X = _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_3__["default"].identity();
OrbitCameraController.__tmp_rotateM_Y = _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_3__["default"].identity();
OrbitCameraController.__tmp_rotateM = _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_3__["default"].identity();
OrbitCameraController.__tmp_rotateM_Reset = _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_3__["default"].identity();
OrbitCameraController.__tmp_rotateM_Revert = _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_3__["default"].identity();
OrbitCameraController.__tmpMat44_0 = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_5__["default"].identity();


/***/ }),

/***/ "./src/foundation/cameras/WalkThroughCameraController.ts":
/*!***************************************************************!*\
  !*** ./src/foundation/cameras/WalkThroughCameraController.ts ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WalkThroughCameraController; });
/* harmony import */ var _math_Matrix44__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/MathClassUtil */ "./src/foundation/math/MathClassUtil.ts");
/* harmony import */ var _misc_MiscUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../misc/MiscUtil */ "./src/foundation/misc/MiscUtil.ts");
/* harmony import */ var _math_MutableVector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");
/* harmony import */ var _math_MathUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/MathUtil */ "./src/foundation/math/MathUtil.ts");
/* harmony import */ var _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/MutableMatrix33 */ "./src/foundation/math/MutableMatrix33.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _AbstractCameraController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AbstractCameraController */ "./src/foundation/cameras/AbstractCameraController.ts");








class WalkThroughCameraController extends _AbstractCameraController__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor(options = {
        eventTargetDom: document,
        verticalSpeed: 1,
        horizontalSpeed: 1,
        turnSpeed: 0.25,
        mouseWheelSpeedScale: 1,
        inverseVerticalRotating: false,
        inverseHorizontalRotating: false
    }) {
        super();
        this._isKeyDown = false;
        this._isMouseDrag = false;
        this._lastKeyCode = -1;
        this._currentDir = new _math_MutableVector3__WEBPACK_IMPORTED_MODULE_3__["default"](0, 0, -1);
        this._currentPos = new _math_MutableVector3__WEBPACK_IMPORTED_MODULE_3__["default"](0, 0, 0);
        this._currentCenter = new _math_MutableVector3__WEBPACK_IMPORTED_MODULE_3__["default"](0, 0, -1);
        this._currentHorizontalDir = new _math_MutableVector3__WEBPACK_IMPORTED_MODULE_3__["default"](0, 0, -1);
        this._newDir = new _math_MutableVector3__WEBPACK_IMPORTED_MODULE_3__["default"](0, 0, -1);
        this._isMouseDown = false;
        this._clickedMouseXOnCanvas = -1;
        this._clickedMouseYOnCanvas = -1;
        this._draggedMouseXOnCanvas = -1;
        this._draggedMouseYOnCanvas = -1;
        this._deltaMouseXOnCanvas = -1;
        this._deltaMouseYOnCanvas = -1;
        this._mouseXAdjustScale = 1;
        this._mouseYAdjustScale = 1;
        this._deltaY = -1;
        this._deltaX = -1;
        this._mouseUpBind = this._mouseUp.bind(this);
        this._mouseDownBind = this._mouseDown.bind(this);
        this._mouseMoveBind = this._mouseMove.bind(this);
        this._mouseWheelBind = this._mouseWheel.bind(this);
        this._needInitialize = true;
        this._zFarAdjustingFactorBasedOnAABB = 150.0;
        this._horizontalSpeed = options.horizontalSpeed;
        this._verticalSpeed = options.verticalSpeed;
        this._turnSpeed = options.turnSpeed;
        this._mouseXAdjustScale = this._turnSpeed;
        this._mouseYAdjustScale = this._turnSpeed;
        this._mouseWheelSpeedScale = options.mouseWheelSpeedScale;
        this._inverseVerticalRotating = options.inverseVerticalRotating;
        this._inverseHorizontalRotating = options.inverseHorizontalRotating;
        this.reset();
        this._onKeydown = e => {
            this._isKeyDown = true;
            this._lastKeyCode = e.keyCode;
        };
        this._onKeyup = e => {
            this._isKeyDown = false;
            this._lastKeyCode = -1;
        };
        const eventTargetDom = options.eventTargetDom;
        this.registerEventListeners(eventTargetDom);
    }
    registerEventListeners(eventTargetDom = document) {
        this._eventTargetDom = eventTargetDom;
        if (eventTargetDom) {
            eventTargetDom.addEventListener("keydown", this._onKeydown);
            eventTargetDom.addEventListener("keyup", this._onKeyup);
            if ("ontouchend" in document) {
                document.addEventListener("touchstart", this._mouseDownBind);
                document.addEventListener("touchend", this._mouseUpBind);
                document.addEventListener("touchmove", this._mouseMoveBind);
            }
            if ("onmouseup" in document) {
                eventTargetDom.addEventListener("mousedown", this._mouseDownBind);
                eventTargetDom.addEventListener("mouseup", this._mouseUpBind);
                eventTargetDom.addEventListener("mouseleave", this._mouseUpBind);
                eventTargetDom.addEventListener("mousemove", this._mouseMoveBind);
            }
            if ("onwheel" in document) {
                eventTargetDom.addEventListener("wheel", this._mouseWheelBind);
            }
        }
    }
    unregisterEventListeners() {
        const eventTargetDom = this._eventTargetDom;
        if (eventTargetDom) {
            eventTargetDom.removeEventListener("keydown", this._onKeydown);
            eventTargetDom.removeEventListener("keyup", this._onKeyup);
            if ("ontouchend" in document) {
                document.removeEventListener("touchstart", this._mouseDownBind);
                document.removeEventListener("touchend", this._mouseUpBind);
                document.removeEventListener("touchmove", this._mouseMoveBind);
            }
            if ("onmouseup" in document) {
                eventTargetDom.removeEventListener("mousedown", this._mouseDownBind);
                eventTargetDom.removeEventListener("mouseup", this._mouseUpBind);
                eventTargetDom.removeEventListener("mouseleave", this._mouseUpBind);
                eventTargetDom.removeEventListener("mousemove", this._mouseMoveBind);
            }
            if ("onwheel" in document) {
                eventTargetDom.removeEventListener("wheel", this._mouseWheelBind);
            }
        }
    }
    _mouseWheel(e) {
        if (this._currentDir === null) {
            return;
        }
        const delta = -1 * Math.sign(e.deltaY) * this._mouseWheelSpeedScale * this._horizontalSpeed;
        const horizontalDir = WalkThroughCameraController.__tmp_Vec3_0;
        horizontalDir.setComponents(this._currentDir.x, 0, this._currentDir.z).normalize();
        const deltaVec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_3__["default"].multiplyTo(horizontalDir, delta, WalkThroughCameraController.__tmp_Vec3_1);
        this._currentPos.add(deltaVec);
        this._currentCenter.add(deltaVec);
    }
    _mouseDown(evt) {
        _misc_MiscUtil__WEBPACK_IMPORTED_MODULE_2__["MiscUtil"].preventDefaultForDesktopOnly(evt);
        evt.stopPropagation();
        this._isMouseDown = true;
        let rect = evt.target.getBoundingClientRect();
        this._clickedMouseXOnCanvas = evt.clientX - rect.left;
        this._clickedMouseYOnCanvas = evt.clientY - rect.top;
        return false;
    }
    _mouseMove(evt) {
        _misc_MiscUtil__WEBPACK_IMPORTED_MODULE_2__["MiscUtil"].preventDefaultForDesktopOnly(evt);
        if (!this._isMouseDown) {
            return;
        }
        evt.stopPropagation();
        let rect = evt.target.getBoundingClientRect();
        this._draggedMouseXOnCanvas = evt.clientX - rect.left;
        this._draggedMouseYOnCanvas = evt.clientY - rect.top;
        this._deltaMouseXOnCanvas =
            this._draggedMouseXOnCanvas - this._clickedMouseXOnCanvas;
        this._deltaMouseYOnCanvas =
            this._draggedMouseYOnCanvas - this._clickedMouseYOnCanvas;
        this._isMouseDrag = true;
    }
    _mouseUp(evt) {
        this._isMouseDown = false;
        this._isMouseDrag = false;
        const target = evt.target;
        if ((target === null || target === void 0 ? void 0 : target.getBoundingClientRect) == null) {
            return;
        }
        const rect = target.getBoundingClientRect();
        this._clickedMouseXOnCanvas = evt.clientX - rect.left;
        this._clickedMouseYOnCanvas = evt.clientY - rect.top;
    }
    tryReset() { }
    reset() {
        this._isKeyDown = false;
        this._lastKeyCode = -1;
        this._currentPos.zero();
        this._currentCenter.setComponents(0, 0, -1);
        this._currentDir.setComponents(0, 0, -1);
        this._currentHorizontalDir.setComponents(0, 0, -1);
        this._isMouseDown = false;
        this._isMouseDrag = false;
        this._draggedMouseXOnCanvas = -1;
        this._draggedMouseYOnCanvas = -1;
        this._deltaMouseXOnCanvas = -1;
        this._deltaMouseYOnCanvas = -1;
        this._mouseXAdjustScale = this._turnSpeed;
        this._mouseYAdjustScale = this._turnSpeed;
        this._deltaY = 0;
        this._deltaX = 0;
        this._newDir.setComponents(0, 0, -1);
    }
    logic(cameraComponent) {
        this.__updateCameraComponent(cameraComponent);
    }
    __updateCameraComponent(camera) {
        var _a;
        const targetAABB = (_a = this.__targetEntity) === null || _a === void 0 ? void 0 : _a.getSceneGraph().worldAABB;
        if (this._needInitialize && targetAABB != null) {
            const lengthCenterToCamera = targetAABB.lengthCenterToCorner * (1.0 + 1.0 / Math.tan(_math_MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].degreeToRadian(camera.fovy / 2.0)));
            this._currentPos.copyComponents(targetAABB.centerPoint);
            this._currentPos.z += lengthCenterToCamera;
            this._currentCenter.copyComponents(targetAABB.centerPoint);
            this._currentDir.setComponents(0, 0, -1);
            if (camera.entity.getSceneGraph()) {
                const sg = camera.entity.getSceneGraph();
                const invMat = _math_Matrix44__WEBPACK_IMPORTED_MODULE_0__["default"].invertTo(sg.worldMatrixInner, WalkThroughCameraController.__tmpInvMat);
                invMat.multiplyVector3To(this._currentPos, this._currentPos);
                invMat.multiplyVector3To(this._currentCenter, this._currentCenter);
            }
            this._needInitialize = false;
        }
        const t = this._deltaY / 90;
        this._newDir.x = this._currentDir.x * (1 - t);
        this._newDir.y = t;
        this._newDir.z = this._currentDir.z * (1 - t);
        this._newDir.normalize();
        this._currentHorizontalDir.x = this._currentDir.x;
        this._currentHorizontalDir.y = 0;
        this._currentHorizontalDir.z = this._currentDir.z;
        this._currentHorizontalDir.normalize();
        const moveVector = WalkThroughCameraController.__tmp_Vec3_0.zero();
        switch (this._lastKeyCode) {
            case 87: // w key
            case 38: // arrow upper key
                moveVector.x = this._currentHorizontalDir.x * this._horizontalSpeed;
                moveVector.z = this._currentHorizontalDir.z * this._horizontalSpeed;
                break;
            case 65: // a key
            case 37: // arrow left key
                moveVector.x = this._currentHorizontalDir.z * this._horizontalSpeed;
                moveVector.z = -this._currentHorizontalDir.x * this._horizontalSpeed;
                break;
            case 83: // s key
            case 40: // arrow down key
                moveVector.x = -this._currentHorizontalDir.x * this._horizontalSpeed;
                moveVector.z = -this._currentHorizontalDir.z * this._horizontalSpeed;
                break;
            case 68: // d key
            case 39: // arrow right key
                moveVector.x = -this._currentHorizontalDir.z * this._horizontalSpeed;
                moveVector.z = this._currentHorizontalDir.x * this._horizontalSpeed;
                break;
            case 81: // q key
                moveVector.x = -this._newDir.x * this._horizontalSpeed;
                moveVector.y = -this._newDir.y * this._horizontalSpeed;
                moveVector.z = -this._newDir.z * this._horizontalSpeed;
                break;
            case 69: // e key
                moveVector.x = this._newDir.x * this._horizontalSpeed;
                moveVector.y = this._newDir.y * this._horizontalSpeed;
                moveVector.z = this._newDir.z * this._horizontalSpeed;
                break;
            case 82: // r key
                moveVector.y = this._verticalSpeed;
                break;
            case 70: // f key
                moveVector.y = -this._verticalSpeed;
                break;
        }
        this._currentPos.add(moveVector);
        this._currentCenter.add(moveVector);
        if (this._isMouseDrag) {
            if (this._inverseHorizontalRotating) {
                this._deltaX = this._deltaMouseXOnCanvas * this._mouseXAdjustScale;
            }
            else {
                this._deltaX = -this._deltaMouseXOnCanvas * this._mouseXAdjustScale;
            }
            if (this._inverseVerticalRotating) {
                this._deltaY += this._deltaMouseYOnCanvas * this._mouseYAdjustScale;
            }
            else {
                this._deltaY += -this._deltaMouseYOnCanvas * this._mouseYAdjustScale;
            }
            this._deltaY = Math.max(-120, Math.min(50, this._deltaY));
            const rotateMatrix = WalkThroughCameraController.__tmpRotateMat.rotateY(_math_MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].degreeToRadian(this._deltaX));
            rotateMatrix.multiplyVectorTo(this._currentDir, this._currentDir);
            const newEyeToCenter = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_3__["default"].subtractTo(this._currentCenter, this._currentPos, WalkThroughCameraController.__tmp_Vec3_1);
            rotateMatrix.multiplyVectorTo(newEyeToCenter, newEyeToCenter);
            newEyeToCenter.x = newEyeToCenter.x * (1 - t);
            newEyeToCenter.y = t;
            newEyeToCenter.z = newEyeToCenter.z * (1 - t);
            newEyeToCenter.normalize();
            this._currentCenter.copyComponents(this._currentPos);
            this._currentCenter.add(newEyeToCenter);
            this._clickedMouseXOnCanvas = this._draggedMouseXOnCanvas;
            this._clickedMouseYOnCanvas = this._draggedMouseYOnCanvas;
            this._deltaMouseXOnCanvas = 0;
            this._deltaMouseYOnCanvas = 0;
        }
        camera.eyeInner = this._currentPos;
        camera.directionInner = this._currentCenter;
        camera.upInner = camera._up;
        camera.leftInner = camera.left;
        camera.rightInner = camera.right;
        camera.topInner = camera.top;
        camera.bottomInner = camera.bottom;
        camera.fovyInner = camera.fovy;
        this._calcZNearInner(camera, this._currentPos, this._newDir);
        this._calcZFarInner(camera);
    }
    getDirection() {
        return this._currentCenter !== null ? this._newDir.clone() : null;
    }
    set horizontalSpeed(value) {
        this._horizontalSpeed = value;
    }
    get horizontalSpeed() {
        return this._horizontalSpeed;
    }
    set verticalSpeed(value) {
        this._verticalSpeed = value;
    }
    get verticalSpeed() {
        return this._verticalSpeed;
    }
    set mouseWheelSpeed(value) {
        this._mouseWheelSpeedScale = value;
    }
    get mouseWheelSpeed() {
        return this._mouseWheelSpeedScale;
    }
    setTarget(targetEntity) {
        const speed = targetEntity.getSceneGraph().worldAABB.lengthCenterToCorner / 10;
        this.verticalSpeed = speed;
        this.horizontalSpeed = speed;
        this.__targetEntity = targetEntity;
        this._needInitialize = true;
    }
    getTarget() {
        return this.__targetEntity;
    }
    set zFarAdjustingFactorBasedOnAABB(value) {
        this._zFarAdjustingFactorBasedOnAABB = value;
    }
    get zFarAdjustingFactorBasedOnAABB() {
        return this._zFarAdjustingFactorBasedOnAABB;
    }
    get allInfo() {
        const info = {};
        info.verticalSpeed = this.verticalSpeed;
        info.horizontalSpeed = this.horizontalSpeed;
        info._turnSpeed = this._turnSpeed;
        if (this._currentPos) {
            info._currentPos = this._currentPos.clone();
        }
        if (this._currentCenter) {
            info._currentCenter = this._currentCenter.clone();
        }
        if (this._currentDir) {
            info._currentDir = this._currentDir.clone();
        }
        info._deltaY = this._deltaY;
        info._newDir = this._newDir.clone();
        return info;
    }
    set allInfo(arg) {
        let json = arg;
        if (typeof arg === "string") {
            json = JSON.parse(arg);
        }
        for (let key in json) {
            if (json.hasOwnProperty(key) && key in this) {
                if (key === "quaternion") {
                    this[key] = _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_1__["default"].cloneOfMathObjects(_math_MathClassUtil__WEBPACK_IMPORTED_MODULE_1__["default"].arrayToQuaternion(json[key]));
                }
                else {
                    this[key] = _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_1__["default"].cloneOfMathObjects(_math_MathClassUtil__WEBPACK_IMPORTED_MODULE_1__["default"].arrayToVectorOrMatrix(json[key]));
                }
            }
        }
    }
}
WalkThroughCameraController.__tmpInvMat = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_6__["default"].identity();
WalkThroughCameraController.__tmpRotateMat = _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_5__["default"].identity();
WalkThroughCameraController.__tmp_Vec3_0 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_3__["default"].zero();
WalkThroughCameraController.__tmp_Vec3_1 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_3__["default"].zero();


/***/ }),

/***/ "./src/foundation/components/AnimationComponent.ts":
/*!*********************************************************!*\
  !*** ./src/foundation/components/AnimationComponent.ts ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationComponent; });
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _definitions_AnimationInterpolation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/AnimationInterpolation */ "./src/foundation/definitions/AnimationInterpolation.ts");
/* harmony import */ var _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../definitions/AnimationAttribute */ "./src/foundation/definitions/AnimationAttribute.ts");
/* harmony import */ var _TransformComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TransformComponent */ "./src/foundation/components/TransformComponent.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _math_MutableVector3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");
/* harmony import */ var _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/MutableQuaternion */ "./src/foundation/math/MutableQuaternion.ts");
/* harmony import */ var _MeshComponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./MeshComponent */ "./src/foundation/components/MeshComponent.ts");










class AnimationComponent extends _core_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(entityUid, componentSid, entityRepository) {
        super(entityUid, componentSid, entityRepository);
        this.__animationLine = new Map();
        this.__backupDefaultValues = new Map();
        this.__isAnimating = true;
        this.__currentProcessStage = _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_6__["ProcessStage"].Create;
    }
    static get componentTID() {
        return _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__["WellKnownComponentTIDs"].AnimationComponentTID;
    }
    setAnimation(attributeName, animationInputArray, animationOutputArray, interpolation) {
        const line = {
            input: animationInputArray,
            output: animationOutputArray,
            outputAttributeName: attributeName,
            interpolationMethod: interpolation
        };
        this.__animationLine.set(_definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].fromString(attributeName).index, line);
        this.__transformComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _TransformComponent__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.__meshComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _MeshComponent__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.backupDefaultValues(_definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].fromString(attributeName).index);
        AnimationComponent.__startInputValueDirty = true;
        AnimationComponent.__endInputValueDirty = true;
    }
    static lerp(start, end, ratio, animationAttributeIndex) {
        if (animationAttributeIndex === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Quaternion.index) {
            return _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_8__["default"].qlerpTo(start, end, ratio, AnimationComponent.__returnQuaternion);
        }
        else if (animationAttributeIndex === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Weights.index) {
            const returnArray = Array(start.length);
            for (let i = 0; i < start.length; i++) {
                returnArray[i] = start[i] * (1 - ratio) + end[i] * ratio;
            }
            return returnArray;
        }
        else {
            const l_vec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_7__["default"].multiplyTo(start, (1 - ratio), this.__tmpVector3_0);
            const r_vec = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_7__["default"].multiplyTo(end, ratio, this.__tmpVector3_1);
            return this.__returnVector3.copyComponents(l_vec).add(r_vec);
        }
    }
    /**
     * Compute cubic spline interpolation.
     * @param p_0 starting point
     * @param p_1 ending point
     * @param m_0 inTangent
     * @param m_1 outTangent
     * @param t ratio
     * @param animationAttributeIndex index of attribution
     */
    static cubicSpline(p_0, p_1, m_0, m_1, t, animationAttributeIndex) {
        const ratio2 = t * t;
        const ratio3 = ratio2 * t;
        // coefficients
        const c_0 = 2 * ratio3 - 3 * ratio2 + 1;
        const c_1 = ratio3 - 2 * ratio2 + t;
        const c_2 = -2 * ratio3 + 3 * ratio2;
        const c_3 = ratio3 - ratio2;
        if (animationAttributeIndex === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Quaternion.index) {
            const cp_0 = _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_8__["default"].multiplyNumberTo(p_0, c_0, this.__tmpQuaternion_0);
            const cm_0 = _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_8__["default"].multiplyNumberTo(m_0, c_1, this.__tmpQuaternion_1);
            const cp_1 = _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_8__["default"].multiplyNumberTo(p_1, c_2, this.__tmpQuaternion_2);
            const cm_1 = _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_8__["default"].multiplyNumberTo(m_1, c_3, this.__tmpQuaternion_3);
            return this.__returnQuaternion.copyComponents(cp_0).add(cm_0).add(cp_1).add(cm_1);
        }
        else if (animationAttributeIndex === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Weights.index) {
            return [c_0 * p_0 + c_1 * m_0 + c_2 * p_1 + c_3 * m_1];
        }
        else {
            const cp_0 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_7__["default"].multiplyTo(p_0, c_0, this.__tmpVector3_0);
            const cm_0 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_7__["default"].multiplyTo(m_0, c_1, this.__tmpVector3_1);
            const cp_1 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_7__["default"].multiplyTo(p_1, c_2, this.__tmpVector3_2);
            const cm_1 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_7__["default"].multiplyTo(m_1, c_3, this.__tmpVector3_3);
            return this.__returnVector3.copyComponents(cp_0).add(cm_0).add(cp_1).add(cm_1);
        }
    }
    static __isClamped(idx, inputArray) {
        if (idx < 0) {
            return true;
        }
        if (idx >= inputArray.length) {
            return true;
        }
        return false;
    }
    static binarySearch(inputArray, currentTime) {
        let low = 0;
        let high = inputArray.length - 1;
        let mid = 0;
        let retVal = 0;
        while (low <= high) {
            mid = low + ((high - low) >> 1);
            if (inputArray[mid] < currentTime) {
                low = mid + 1;
                retVal = mid;
            }
            else if (currentTime < inputArray[mid]) {
                high = mid - 1;
                retVal = high;
            }
            else { // if (inputArray[mid] === input) {
                return mid;
            }
        }
        return retVal;
    }
    static interpolationSearch(inputArray, currentTime) {
        let mid = 0;
        let lower = 0;
        let upper = inputArray.length - 1;
        let retVal = 0;
        while (lower <= upper && currentTime >= inputArray[lower] && currentTime <= inputArray[upper]) {
            mid = Math.floor(lower + (currentTime - inputArray[lower]) * ((upper - lower)) / (inputArray[upper] - inputArray[lower]));
            if (inputArray[mid] < currentTime) {
                lower = mid + 1;
                retVal = mid;
            }
            else if (currentTime < inputArray[mid]) {
                upper = mid - 1;
                retVal = upper;
            }
            else { // if (inputArray[mid] === input) {
                return mid;
            }
        }
        return retVal;
    }
    static bruteForceSearch(inputArray, currentTime) {
        for (let i = 0; i < inputArray.length; i++) {
            if (inputArray[i] <= currentTime && currentTime < inputArray[i + 1]) {
                return i;
            }
        }
        return inputArray.length - 1;
    }
    static interpolate(line, currentTime, animationAttributeIndex) {
        var _a;
        const inputArray = line.input;
        const outputArray = line.output;
        const method = (_a = line.interpolationMethod) !== null && _a !== void 0 ? _a : _definitions_AnimationInterpolation__WEBPACK_IMPORTED_MODULE_3__["AnimationInterpolation"].Linear;
        // out of range
        if (currentTime <= inputArray[0]) {
            return outputArray[0];
        }
        else if (inputArray[inputArray.length - 1] <= currentTime) {
            return outputArray[inputArray.length - 1];
        }
        if (method === _definitions_AnimationInterpolation__WEBPACK_IMPORTED_MODULE_3__["AnimationInterpolation"].CubicSpline) {
            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-c-spline-interpolation
            const k = this.interpolationSearch(inputArray, currentTime);
            const t_diff = (inputArray[k + 1] - inputArray[k]); // t_(k+1) - t_k
            const t = (currentTime - inputArray[k]) / t_diff;
            const [p_0, p_1, m_0, m_1] = this.__prepareVariablesForCubicSpline(outputArray, k, t_diff, animationAttributeIndex);
            return this.cubicSpline(p_0, p_1, m_0, m_1, t, animationAttributeIndex);
        }
        else if (method === _definitions_AnimationInterpolation__WEBPACK_IMPORTED_MODULE_3__["AnimationInterpolation"].Linear) {
            const i = this.interpolationSearch(inputArray, currentTime);
            const ratio = (currentTime - inputArray[i]) / (inputArray[i + 1] - inputArray[i]);
            return this.lerp(outputArray[i], outputArray[i + 1], ratio, animationAttributeIndex);
        }
        else if (method === _definitions_AnimationInterpolation__WEBPACK_IMPORTED_MODULE_3__["AnimationInterpolation"].Step) {
            for (let i = 0; i < inputArray.length - 1; i++) {
                if (inputArray[i] <= currentTime && currentTime < inputArray[i + 1]) {
                    return outputArray[i];
                }
            }
            return outputArray[inputArray.length - 1];
        }
        // non supported type
        return outputArray[0];
    }
    static __prepareVariablesForCubicSpline(outputArray, k, t_diff, animationAttributeIndex) {
        let p_0, p_1, m_0, m_1;
        if (animationAttributeIndex === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Quaternion.index) {
            p_0 = outputArray[3 * k + 1]; //v_k
            p_1 = outputArray[3 * k + 4]; //v_(k+1)
            // the num of__tmpQuaternion is specified by this.cubicSpline
            const b_k = this.__tmpQuaternion_2.copyComponents(outputArray[3 * k + 2]);
            m_0 = b_k.multiplyNumber(t_diff);
            const a_k_plus_one = this.__tmpQuaternion_3.copyComponents(outputArray[3 * k + 3]); // a_(k+1)
            m_1 = a_k_plus_one.multiplyNumber(t_diff);
        }
        else if (animationAttributeIndex === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Weights.index) {
            p_0 = outputArray[k][1]; //v_k
            p_1 = outputArray[k + 1][1]; //v_(k+1)
            const b_k = outputArray[k][2];
            m_0 = t_diff * b_k;
            const a_k_plus_one = outputArray[k + 1][0];
            m_1 = t_diff * a_k_plus_one;
        }
        else {
            p_0 = outputArray[3 * k + 1];
            p_1 = outputArray[3 * k + 4];
            const b_k = this.__tmpVector3_2.copyComponents(outputArray[3 * k + 2]);
            m_0 = b_k.multiply(t_diff);
            const a_k_plus_one = this.__tmpVector3_3.copyComponents(outputArray[3 * k + 3]);
            m_1 = a_k_plus_one.multiply(t_diff);
        }
        return [p_0, p_1, m_0, m_1];
    }
    getStartInputValueOfAnimation() {
        let latestInputValue = Number.MAX_VALUE;
        for (let line of this.__animationLine.values()) {
            let inputValueArray = line.input;
            let inputLatestValueAtThisAttribute = inputValueArray[0];
            if (inputLatestValueAtThisAttribute < latestInputValue) {
                latestInputValue = inputLatestValueAtThisAttribute;
                if (latestInputValue < AnimationComponent.__startInputValueOfAllComponent) {
                    AnimationComponent.__startInputValueOfAllComponent = latestInputValue;
                }
            }
        }
        return latestInputValue;
    }
    getEndInputValueOfAnimation() {
        let latestInputValue = -Number.MAX_VALUE;
        for (let line of this.__animationLine.values()) {
            let inputValueArray = line.input;
            let inputLatestValueAtThisAttribute = inputValueArray[inputValueArray.length - 1];
            if (inputLatestValueAtThisAttribute > latestInputValue) {
                latestInputValue = inputLatestValueAtThisAttribute;
                if (latestInputValue > AnimationComponent.__endInputValueOfAllComponent) {
                    AnimationComponent.__endInputValueOfAllComponent = latestInputValue;
                }
            }
        }
        return latestInputValue;
    }
    static get startInputValue() {
        if (this.__startInputValueDirty) {
            const components = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance().getComponentsWithType(AnimationComponent);
            components.forEach(component => {
                component.getStartInputValueOfAnimation();
            });
            this.__startInputValueDirty = false;
        }
        return AnimationComponent.__startInputValueOfAllComponent;
    }
    static get endInputValue() {
        if (this.__endInputValueDirty) {
            const components = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance().getComponentsWithType(AnimationComponent);
            components.forEach(component => {
                component.getEndInputValueOfAnimation();
            });
            this.__endInputValueDirty = false;
        }
        return AnimationComponent.__endInputValueOfAllComponent;
    }
    static get isAnimating() {
        return this.__isAnimating;
    }
    static set isAnimating(flg) {
        const animationComponents = this.__componentRepository._getComponents(AnimationComponent);
        for (let animationComponent of animationComponents) {
            animationComponent.isAnimating = flg;
        }
    }
    get isAnimating() {
        return this.__isAnimating;
    }
    set isAnimating(flg) {
        if (flg) {
            for (var [i, line] of this.__animationLine) {
                this.backupDefaultValues(i);
            }
        }
        else {
            for (var [i, line] of this.__animationLine) {
                this.restoreDefaultValues(i);
            }
        }
        this.__isAnimating = flg;
    }
    restoreDefaultValues(i) {
        if (this.__backupDefaultValues.get(i) == null) {
            if (i === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Quaternion.index) {
                this.__transformComponent.quaternion = this.__backupDefaultValues.get(i);
            }
            else if (i === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Translate.index) {
                this.__transformComponent.translate = this.__backupDefaultValues.get(i);
            }
            else if (i === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Scale.index) {
                this.__transformComponent.scale = this.__backupDefaultValues.get(i);
            }
            else if (i === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Weights.index) {
                this.__meshComponent.weights = this.__backupDefaultValues.get(i);
            }
        }
    }
    backupDefaultValues(i) {
        if (this.__backupDefaultValues.get(i) == null) {
            if (i === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Quaternion.index) {
                this.__backupDefaultValues.set(i, this.__transformComponent.quaternion);
            }
            else if (i === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Translate.index) {
                this.__backupDefaultValues.set(i, this.__transformComponent.translate);
            }
            else if (i === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Scale.index) {
                this.__backupDefaultValues.set(i, this.__transformComponent.scale);
            }
            else if (i === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Weights.index) {
                this.__backupDefaultValues.set(i, this.__meshComponent.weights);
            }
        }
    }
    $create() {
        this.__transformComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _TransformComponent__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.__meshComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _MeshComponent__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_6__["ProcessStage"].Logic);
    }
    $logic() {
        if (AnimationComponent.isAnimating) {
            for (var [i, line] of this.__animationLine) {
                let value = AnimationComponent.interpolate(line, AnimationComponent.globalTime, i);
                if (i === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Quaternion.index) {
                    this.__transformComponent.quaternion = value;
                }
                else if (i === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Translate.index) {
                    this.__transformComponent.translate = value;
                }
                else if (i === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Scale.index) {
                    this.__transformComponent.scale = value;
                }
                else if (i === _definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_4__["AnimationAttribute"].Weights.index) {
                    this.__meshComponent.weights = value;
                }
            }
        }
    }
}
AnimationComponent.globalTime = 0;
AnimationComponent.__isAnimating = true;
AnimationComponent.__startInputValueOfAllComponent = Number.MAX_VALUE;
AnimationComponent.__endInputValueOfAllComponent = -Number.MAX_VALUE;
AnimationComponent.__startInputValueDirty = false;
AnimationComponent.__endInputValueDirty = false;
AnimationComponent.__componentRepository = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance();
AnimationComponent.__returnVector3 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_7__["default"].zero();
AnimationComponent.__tmpVector3_0 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_7__["default"].zero();
AnimationComponent.__tmpVector3_1 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_7__["default"].zero();
AnimationComponent.__tmpVector3_2 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_7__["default"].zero();
AnimationComponent.__tmpVector3_3 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_7__["default"].zero();
AnimationComponent.__returnQuaternion = _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_8__["default"].identity();
AnimationComponent.__tmpQuaternion_0 = _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_8__["default"].identity();
AnimationComponent.__tmpQuaternion_1 = _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_8__["default"].identity();
AnimationComponent.__tmpQuaternion_2 = _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_8__["default"].identity();
AnimationComponent.__tmpQuaternion_3 = _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_8__["default"].identity();
_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__["default"].registerComponentClass(AnimationComponent);


/***/ }),

/***/ "./src/foundation/components/BlendShapeComponent.ts":
/*!**********************************************************!*\
  !*** ./src/foundation/components/BlendShapeComponent.ts ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BlendShapeComponent; });
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");




class BlendShapeComponent extends _core_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(entityUid, componentSid, entityComponent) {
        super(entityUid, componentSid, entityComponent);
        this.__weights = [];
        this.__targetNames = [];
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Logic);
    }
    static get componentTID() {
        return _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__["WellKnownComponentTIDs"].BlendShapeComponentTID;
    }
    set weights(weights) {
        this.__weights = weights;
    }
    get weights() {
        return this.__weights;
    }
    set targetNames(names) {
        this.__targetNames = names;
    }
    get targetNames() {
        return this.__targetNames;
    }
    $logic() {
    }
}
_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__["default"].registerComponentClass(BlendShapeComponent);


/***/ }),

/***/ "./src/foundation/components/CameraComponent.ts":
/*!******************************************************!*\
  !*** ./src/foundation/components/CameraComponent.ts ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CameraComponent; });
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _definitions_CameraType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../definitions/CameraType */ "./src/foundation/definitions/CameraType.ts");
/* harmony import */ var _SceneGraphComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _definitions_BufferUse__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../definitions/BufferUse */ "./src/foundation/definitions/BufferUse.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../math/MutableVector4 */ "./src/foundation/math/MutableVector4.ts");
/* harmony import */ var _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");
/* harmony import */ var _geometry_Frustum__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geometry/Frustum */ "./src/foundation/geometry/Frustum.ts");
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../core/GlobalDataRepository */ "./src/foundation/core/GlobalDataRepository.ts");
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _math_MathUtil__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../math/MathUtil */ "./src/foundation/math/MathUtil.ts");
/* harmony import */ var _CameraControllerComponent__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./CameraControllerComponent */ "./src/foundation/components/CameraControllerComponent.ts");
/* harmony import */ var _system_ModuleManager__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../system/ModuleManager */ "./src/foundation/system/ModuleManager.ts");



















class CameraComponent extends _core_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(entityUid, componentSid, entityRepository) {
        super(entityUid, componentSid, entityRepository);
        this._eyeInner = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].dummy();
        this._direction = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].dummy();
        this._directionInner = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].dummy();
        this._up = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].dummy();
        this._upInner = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].dummy();
        this._filmWidth = 36; // mili meter
        this._filmHeight = 24; // mili meter
        this._focalLength = 20;
        // x: left, y:right, z:top, w: bottom
        this._corner = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__["default"].dummy();
        this._cornerInner = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__["default"].dummy();
        // x: zNear, y: zFar,
        // if perspective, z: fovy, w: aspect
        // if ortho, z: xmag, w: ymag
        this._parameters = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__["default"].dummy();
        this._parametersInner = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__["default"].dummy();
        this.__type = _definitions_CameraType__WEBPACK_IMPORTED_MODULE_4__["CameraType"].Perspective;
        this._projectionMatrix = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].dummy();
        this.__isProjectionMatrixUpToDate = false;
        this._viewMatrix = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].dummy();
        this.__isViewMatrixUpToDate = false;
        this.__frustum = new _geometry_Frustum__WEBPACK_IMPORTED_MODULE_12__["default"]();
        this.maxNumberOfComponent = Math.max(10, Math.floor(_core_Config__WEBPACK_IMPORTED_MODULE_13__["default"].maxEntityNumber / 100));
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_6__["BufferUse"].CPUGeneric, 'eyeInner', _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_7__["ComponentType"].Float, [0, 0, 0]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_6__["BufferUse"].CPUGeneric, 'direction', _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_7__["ComponentType"].Float, [0, 0, -1]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_6__["BufferUse"].CPUGeneric, 'up', _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_7__["ComponentType"].Float, [0, 1, 0]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_6__["BufferUse"].CPUGeneric, 'directionInner', _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_7__["ComponentType"].Float, [0, 0, -1]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_6__["BufferUse"].CPUGeneric, 'upInner', _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_7__["ComponentType"].Float, [0, 1, 0]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_6__["BufferUse"].CPUGeneric, 'corner', _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_7__["ComponentType"].Float, [-1, 1, 1, -1]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_6__["BufferUse"].CPUGeneric, 'cornerInner', _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_7__["ComponentType"].Float, [-1, 1, 1, -1]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_6__["BufferUse"].CPUGeneric, 'parameters', _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_7__["ComponentType"].Float, [0.1, 10000, 90, 1]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_6__["BufferUse"].CPUGeneric, 'parametersInner', _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_7__["ComponentType"].Float, [0.1, 10000, 90, 1]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_6__["BufferUse"].CPUGeneric, 'projectionMatrix', _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_7__["ComponentType"].Float, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_6__["BufferUse"].CPUGeneric, 'viewMatrix', _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_7__["ComponentType"].Float, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        this.submitToAllocation(_core_Config__WEBPACK_IMPORTED_MODULE_13__["default"].maxCameraNumber);
        const globalDataRepository = _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_14__["default"].getInstance();
        globalDataRepository.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_15__["ShaderSemantics"].ViewMatrix);
        globalDataRepository.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_15__["ShaderSemantics"].ProjectionMatrix);
        globalDataRepository.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_15__["ShaderSemantics"].ViewPosition);
        this.setFovyAndChangeFocalLength(90);
        if (CameraComponent.main === -1) {
            CameraComponent.main = componentSid;
        }
    }
    static set main(componentSID) {
        this.__main = componentSID;
    }
    static get main() {
        return this.__main;
    }
    set type(type) {
        this.__type = type;
        if (type === _definitions_CameraType__WEBPACK_IMPORTED_MODULE_4__["CameraType"].Orthographic) {
            this._parameters.z = 1;
            this._parameters.w = 1;
            this._parametersInner.z = 1;
            this._parametersInner.w = 1;
        }
        else {
            this.setFovyAndChangeFocalLength(90);
            this._parameters.w = 1;
            this._parametersInner.z = 90;
            this._parametersInner.w = 1;
        }
    }
    get type() {
        return this.__type;
    }
    get eye() {
        // In Rhodonite, eye is always (0,0,0). Use TransformComponent for Camera positioning
        return CameraComponent._eye;
    }
    set eye(noUseVec) {
        throw Error('In Rhodonite, eye is always (0,0,0). Use TransformComponent for Camera positioning.');
    }
    get eyeInner() {
        return this._eyeInner;
    }
    /**
     * @private
     */
    set eyeInner(vec) {
        this._eyeInner.copyComponents(vec);
    }
    set upInner(vec) {
        this._upInner.copyComponents(vec);
    }
    set up(vec) {
        this._up.copyComponents(vec);
    }
    get up() {
        return this._up.clone();
    }
    get upInner() {
        return this._upInner;
    }
    set direction(vec) {
        const oldDirection = this._direction;
        const newDirection = vec;
        const oldUp = this._up;
        const orthogonalVectorNewDirectionAndOldUp = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].crossTo(newDirection, oldUp, CameraComponent.__tmpVector3_0);
        const isOrthogonalNewDirectionAndOldUp = orthogonalVectorNewDirectionAndOldUp.length() === 0.0;
        let newUpNonNormalize;
        if (isOrthogonalNewDirectionAndOldUp) {
            const relativeXaxis = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].crossTo(oldDirection, oldUp, CameraComponent.__tmpVector3_1);
            newUpNonNormalize = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].crossTo(relativeXaxis, newDirection, CameraComponent.__tmpVector3_2);
        }
        else {
            const newDirectionComponentInOldUp = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].multiplyTo(newDirection, newDirection.dot(oldUp), CameraComponent.__tmpVector3_1);
            newUpNonNormalize = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].subtractTo(oldUp, newDirectionComponentInOldUp, CameraComponent.__tmpVector3_2);
        }
        this._up.copyComponents(newUpNonNormalize).normalize();
        this._direction.copyComponents(newDirection);
    }
    set directionInner(vec) {
        this._directionInner.copyComponents(vec);
    }
    get direction() {
        return this._direction.clone();
    }
    get directionInner() {
        return this._directionInner;
    }
    set corner(vec) {
        this._corner.copyComponents(vec);
    }
    get corner() {
        return this._corner.clone();
    }
    set left(value) {
        this._corner.x = value;
    }
    set leftInner(value) {
        this._cornerInner.x = value;
    }
    get left() {
        return this._corner.x;
    }
    set right(value) {
        this._corner.y = value;
    }
    set rightInner(value) {
        this._cornerInner.y = value;
    }
    get right() {
        return this._corner.y;
    }
    set top(value) {
        this._corner.z = value;
    }
    set topInner(value) {
        this._cornerInner.z = value;
    }
    get top() {
        return this._corner.z;
    }
    set bottom(value) {
        this._corner.w = value;
    }
    set bottomInner(value) {
        this._cornerInner.w = value;
    }
    get bottom() {
        return this._corner.w;
    }
    set cornerInner(vec) {
        this._corner.copyComponents(vec);
    }
    get cornerInner() {
        return this._corner;
    }
    // set parameters(vec: Vector4) {
    //   this._parameters.copyComponents(vec);
    // }
    set parametersInner(vec) {
        this._parametersInner.copyComponents(vec);
    }
    get parametersInner() {
        return this._parametersInner;
    }
    get parameters() {
        return this._parameters.clone();
    }
    set zNear(val) {
        this._parameters.x = val;
    }
    set zNearInner(val) {
        this._parametersInner.x = val;
    }
    get zNearInner() {
        return this._parametersInner.x;
    }
    get zNear() {
        return this._parameters.x;
    }
    set focalLength(val) {
        this._focalLength = val;
        this._parameters.z = 2 * _math_MathUtil__WEBPACK_IMPORTED_MODULE_16__["MathUtil"].radianToDegree(Math.atan(this._filmHeight / (val * 2)));
    }
    get focalLength() {
        return this._focalLength;
    }
    set zFar(val) {
        this._parameters.y = val;
    }
    set zFarInner(val) {
        this._parametersInner.y = val;
    }
    get zFarInner() {
        return this._parametersInner.y;
    }
    get zFar() {
        return this._parameters.y;
    }
    setFovyAndChangeFilmSize(degree) {
        this._parameters.z = degree;
        this._filmHeight = 2 * this.focalLength * Math.tan(_math_MathUtil__WEBPACK_IMPORTED_MODULE_16__["MathUtil"].degreeToRadian(degree) / 2);
        this._filmWidth = this._filmHeight * this.aspect;
    }
    setFovyAndChangeFocalLength(degree) {
        this._parameters.z = degree;
        this._focalLength = this._filmHeight / 2 / Math.tan(_math_MathUtil__WEBPACK_IMPORTED_MODULE_16__["MathUtil"].degreeToRadian(degree) / 2);
    }
    get fovy() {
        return this._parameters.z;
    }
    set fovyInner(val) {
        this._parametersInner.z = val;
    }
    set aspect(val) {
        this._parameters.w = val;
        this._filmWidth = this._filmHeight * val;
    }
    get aspect() {
        return this._parameters.w;
    }
    set xMag(val) {
        this._parameters.z = val;
    }
    get xMag() {
        return this._parameters.z;
    }
    set yMag(val) {
        this._parameters.w = val;
    }
    get yMag() {
        return this._parameters.w;
    }
    static get componentTID() {
        return _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__["WellKnownComponentTIDs"].CameraComponentTID;
    }
    calcProjectionMatrix() {
        const zNear = this._parametersInner.x;
        const zFar = this._parametersInner.y;
        if (this.type === _definitions_CameraType__WEBPACK_IMPORTED_MODULE_4__["CameraType"].Perspective) {
            const fovy = this._parametersInner.z;
            const aspect = this._parametersInner.w;
            var yscale = 1.0 / Math.tan((0.5 * fovy * Math.PI) / 180);
            var xscale = yscale / aspect;
            this._projectionMatrix.setComponents(xscale, 0, 0, 0, 0, yscale, 0, 0, 0, 0, -(zFar + zNear) / (zFar - zNear), -(2.0 * zFar * zNear) / (zFar - zNear), 0, 0, -1, 0);
        }
        else if (this.type === _definitions_CameraType__WEBPACK_IMPORTED_MODULE_4__["CameraType"].Orthographic) {
            const xmag = this._parametersInner.z;
            const ymag = this._parametersInner.w;
            this._projectionMatrix.setComponents(1 / xmag, 0.0, 0.0, 0, 0.0, 1 / ymag, 0.0, 0, 0.0, 0.0, -2 / (zFar - zNear), -(zFar + zNear) / (zFar - zNear), 0.0, 0.0, 0.0, 1.0);
        }
        else {
            const left = this._cornerInner.x;
            const right = this._cornerInner.y;
            const top = this._cornerInner.z;
            const bottom = this._cornerInner.w;
            this._projectionMatrix.setComponents(2 * zNear / (right - left), 0.0, (right + left) / (right - left), 0.0, 0.0, 2 * zNear / (top - bottom), (top + bottom) / (top - bottom), 0.0, 0.0, 0.0, -(zFar + zNear) / (zFar - zNear), -1 * 2 * zFar * zNear / (zFar - zNear), 0.0, 0.0, -1.0, 0.0);
        }
        return this._projectionMatrix;
    }
    get projectionMatrix() {
        return this._projectionMatrix;
    }
    calcViewMatrix() {
        const eye = this.eyeInner;
        const f = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].subtractTo(this._directionInner, eye, CameraComponent.__tmpVector3_0).normalize();
        const s = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].crossTo(f, this._upInner, CameraComponent.__tmpVector3_1).normalize();
        const u = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].crossTo(s, f, CameraComponent.__tmpVector3_2);
        this._viewMatrix.setComponents(s.x, s.y, s.z, -_math_Vector3__WEBPACK_IMPORTED_MODULE_3__["default"].dot(s, eye), u.x, u.y, u.z, -_math_Vector3__WEBPACK_IMPORTED_MODULE_3__["default"].dot(u, eye), -f.x, -f.y, -f.z, _math_Vector3__WEBPACK_IMPORTED_MODULE_3__["default"].dot(f, eye), 0, 0, 0, 1);
        const invertWorldMatrix = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].invertTo(this.__sceneGraphComponent.worldMatrixInner, CameraComponent.__tmpMatrix44_0);
        this._viewMatrix.multiply(invertWorldMatrix);
        return this._viewMatrix;
    }
    get viewMatrix() {
        return this._viewMatrix;
    }
    set viewMatrix(viewMatrix) {
        this._viewMatrix.copyComponents(viewMatrix);
    }
    set projectionMatrix(projectionMatrix) {
        this._projectionMatrix.copyComponents(projectionMatrix);
    }
    get viewProjectionMatrix() {
        return _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].multiplyTo(this._projectionMatrix, this._viewMatrix, CameraComponent.__tmpMatrix44_0);
    }
    setValuesToGlobalDataRepository() {
        CameraComponent.__globalDataRepository.setValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_15__["ShaderSemantics"].ViewMatrix, this.componentSID, this.viewMatrix);
        CameraComponent.__globalDataRepository.setValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_15__["ShaderSemantics"].ProjectionMatrix, this.componentSID, this.projectionMatrix);
        CameraComponent.__globalDataRepository.setValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_15__["ShaderSemantics"].ViewPosition, this.componentSID, this.worldPosition);
    }
    get worldPosition() {
        this.__sceneGraphComponent.worldMatrixInner.multiplyVector3To(this.eyeInner, CameraComponent.returnVector3);
        return CameraComponent.returnVector3;
    }
    updateFrustum() {
        this.__frustum.update(this.viewMatrix, this.projectionMatrix);
    }
    get frustum() {
        return this.__frustum;
    }
    $create() {
        this.__sceneGraphComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _SceneGraphComponent__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_9__["ProcessStage"].Logic);
    }
    $logic({ renderPass }) {
        const cameraControllerComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _CameraControllerComponent__WEBPACK_IMPORTED_MODULE_17__["default"]);
        if (cameraControllerComponent == null) {
            this._eyeInner.copyComponents(CameraComponent._eye);
            this._directionInner.copyComponents(this._direction);
            this._upInner.copyComponents(this._up);
            this._cornerInner.copyComponents(this._corner);
            this._parametersInner.copyComponents(this._parameters);
        }
        else {
            this._parametersInner.w = this._parameters.w;
        }
        this.calcViewMatrix();
        this.calcProjectionMatrix();
        const rnXRModule = _system_ModuleManager__WEBPACK_IMPORTED_MODULE_18__["default"].getInstance().getModule('xr');
        if ((rnXRModule === null || rnXRModule === void 0 ? void 0 : rnXRModule.WebVRSystem.getInstance().isWebVRMode) && renderPass.isMainPass) {
            const webvrSystem = rnXRModule.WebVRSystem.getInstance();
            webvrSystem.setValuesToGlobalDataRepository();
        }
        else {
            this.setValuesToGlobalDataRepository();
        }
    }
}
CameraComponent._eye = _math_Vector3__WEBPACK_IMPORTED_MODULE_3__["default"].zero();
CameraComponent.__main = -1;
CameraComponent.returnVector3 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].zero();
CameraComponent.__globalDataRepository = _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_14__["default"].getInstance();
CameraComponent.__tmpVector3_0 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].zero();
CameraComponent.__tmpVector3_1 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].zero();
CameraComponent.__tmpVector3_2 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].zero();
CameraComponent.__tmpMatrix44_0 = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].zero();
_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__["default"].registerComponentClass(CameraComponent);


/***/ }),

/***/ "./src/foundation/components/CameraControllerComponent.ts":
/*!****************************************************************!*\
  !*** ./src/foundation/components/CameraControllerComponent.ts ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CameraControllerComponent; });
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _CameraComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _cameras_OrbitCameraController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cameras/OrbitCameraController */ "./src/foundation/cameras/OrbitCameraController.ts");
/* harmony import */ var _cameras_WalkThroughCameraController__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cameras/WalkThroughCameraController */ "./src/foundation/cameras/WalkThroughCameraController.ts");
/* harmony import */ var _definitions_CameraControllerType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../definitions/CameraControllerType */ "./src/foundation/definitions/CameraControllerType.ts");








class CameraControllerComponent extends _core_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(entityUid, componentSid, entityRepository) {
        super(entityUid, componentSid, entityRepository);
        this.__cameraController = new _cameras_OrbitCameraController__WEBPACK_IMPORTED_MODULE_5__["default"]();
    }
    set type(type) {
        this.__cameraController.unregisterEventListeners();
        if (type === _definitions_CameraControllerType__WEBPACK_IMPORTED_MODULE_7__["CameraControllerType"].Orbit) {
            this.__cameraController = new _cameras_OrbitCameraController__WEBPACK_IMPORTED_MODULE_5__["default"]();
        }
        else if (type === _definitions_CameraControllerType__WEBPACK_IMPORTED_MODULE_7__["CameraControllerType"].WalkThrough) {
            this.__cameraController = new _cameras_WalkThroughCameraController__WEBPACK_IMPORTED_MODULE_6__["default"]();
        }
        else {
            console.warn('Not support type!');
        }
    }
    get type() {
        if (this.__cameraController instanceof _cameras_OrbitCameraController__WEBPACK_IMPORTED_MODULE_5__["default"]) {
            return _definitions_CameraControllerType__WEBPACK_IMPORTED_MODULE_7__["CameraControllerType"].Orbit;
        }
        else {
            return _definitions_CameraControllerType__WEBPACK_IMPORTED_MODULE_7__["CameraControllerType"].WalkThrough;
        }
    }
    get controller() {
        return this.__cameraController;
    }
    static get componentTID() {
        return _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_4__["WellKnownComponentTIDs"].CameraControllerComponentTID;
    }
    $create() {
        this.__cameraComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _CameraComponent__WEBPACK_IMPORTED_MODULE_1__["default"]);
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_2__["ProcessStage"].Logic);
    }
    $logic() {
        if (this.__cameraController) {
            this.__cameraController.logic(this.__cameraComponent);
        }
    }
}
_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_3__["default"].registerComponentClass(CameraControllerComponent);


/***/ }),

/***/ "./src/foundation/components/LightComponent.ts":
/*!*****************************************************!*\
  !*** ./src/foundation/components/LightComponent.ts ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LightComponent; });
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _definitions_LightType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/LightType */ "./src/foundation/definitions/LightType.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _SceneGraphComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/GlobalDataRepository */ "./src/foundation/core/GlobalDataRepository.ts");
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../math/MutableVector4 */ "./src/foundation/math/MutableVector4.ts");
/* harmony import */ var _math_VectorN__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../math/VectorN */ "./src/foundation/math/VectorN.ts");












class LightComponent extends _core_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(entityUid, componentSid, entityRepository) {
        super(entityUid, componentSid, entityRepository);
        this.type = _definitions_LightType__WEBPACK_IMPORTED_MODULE_3__["LightType"].Point;
        this.__intensity = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](1, 1, 1);
        this.__initialdirection = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](0, 1, 0);
        this.__direction = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](0, 1, 0);
        this.spotExponent = 1.0;
        this.spotCutoff = 30; // in degree
        this.range = -1;
        this.maxNumberOfComponent = Math.max(10, Math.floor(_core_Config__WEBPACK_IMPORTED_MODULE_7__["default"].maxEntityNumber / 100));
    }
    static get componentTID() {
        return _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__["WellKnownComponentTIDs"].LightComponentTID;
    }
    get direction() {
        return this.__direction;
    }
    set intensity(value) {
        this.__intensity = value;
    }
    get intensity() {
        return this.__intensity;
    }
    $create() {
        this.__sceneGraphComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _SceneGraphComponent__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_6__["ProcessStage"].Load);
    }
    $load() {
        const lightComponents = LightComponent.__componentRepository.getComponentsWithType(LightComponent);
        const currentComponentSIDs = LightComponent.__globalDataRepository.getValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].CurrentComponentSIDs, 0);
        currentComponentSIDs.v[_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__["WellKnownComponentTIDs"].LightComponentTID] = lightComponents.length;
        LightComponent.__lightPositions = LightComponent.__globalDataRepository.getValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].LightPosition, 0);
        LightComponent.__lightDirections = LightComponent.__globalDataRepository.getValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].LightDirection, 0);
        LightComponent.__lightIntensities = LightComponent.__globalDataRepository.getValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].LightIntensity, 0);
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_6__["ProcessStage"].Logic);
    }
    $logic() {
        this.__direction = this.__sceneGraphComponent.normalMatrixInner.multiplyVector(this.__initialdirection);
        LightComponent.__lightDirections.v[4 * this.componentSID + 0] = this.__direction.x;
        LightComponent.__lightDirections.v[4 * this.componentSID + 1] = this.__direction.y;
        LightComponent.__lightDirections.v[4 * this.componentSID + 2] = this.__direction.z;
        LightComponent.__lightDirections.v[4 * this.componentSID + 3] = 0;
        const lightPosition = this.__sceneGraphComponent.worldPosition;
        LightComponent.__lightPositions.v[4 * this.componentSID + 0] = lightPosition.x;
        LightComponent.__lightPositions.v[4 * this.componentSID + 1] = lightPosition.y;
        LightComponent.__lightPositions.v[4 * this.componentSID + 2] = lightPosition.z;
        LightComponent.__lightPositions.v[4 * this.componentSID + 3] = this.type.index;
        LightComponent.__lightIntensities.v[4 * this.componentSID + 0] = this.__intensity.x;
        LightComponent.__lightIntensities.v[4 * this.componentSID + 1] = this.__intensity.y;
        LightComponent.__lightIntensities.v[4 * this.componentSID + 2] = this.__intensity.z;
        LightComponent.__lightIntensities.v[4 * this.componentSID + 3] = 0;
    }
}
LightComponent.__componentRepository = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
LightComponent.__globalDataRepository = _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_8__["default"].getInstance();
LightComponent.__tmp_vec4 = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
LightComponent.__lightPositions = new _math_VectorN__WEBPACK_IMPORTED_MODULE_11__["default"](new Float32Array(0));
LightComponent.__lightDirections = new _math_VectorN__WEBPACK_IMPORTED_MODULE_11__["default"](new Float32Array(0));
LightComponent.__lightIntensities = new _math_VectorN__WEBPACK_IMPORTED_MODULE_11__["default"](new Float32Array(0));
_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__["default"].registerComponentClass(LightComponent);


/***/ }),

/***/ "./src/foundation/components/MeshComponent.ts":
/*!****************************************************!*\
  !*** ./src/foundation/components/MeshComponent.ts ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MeshComponent; });
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_Vector4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _core_Entity__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/Entity */ "./src/foundation/core/Entity.ts");
/* harmony import */ var _BlendShapeComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BlendShapeComponent */ "./src/foundation/components/BlendShapeComponent.ts");
/* harmony import */ var _SceneGraphComponent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _math_Matrix44__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../math/MathClassUtil */ "./src/foundation/math/MathClassUtil.ts");
/* harmony import */ var _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");













class MeshComponent extends _core_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(entityUid, componentSid, entityRepository) {
        super(entityUid, componentSid, entityRepository);
        this.__viewDepth = -Number.MAX_VALUE;
        this.isPickable = true;
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Create);
    }
    static get componentTID() {
        return _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__["WellKnownComponentTIDs"].MeshComponentTID;
    }
    setMesh(mesh) {
        this.__mesh = mesh;
        mesh._attachedEntityUID = this.entityUID;
    }
    unsetMesh() {
        if (this.__mesh == null) {
            return false;
        }
        this.__mesh._attachedEntityUID = _core_Entity__WEBPACK_IMPORTED_MODULE_6__["default"].invalidEntityUID;
        this.__mesh = void 0;
        return true;
    }
    get mesh() {
        return this.__mesh;
    }
    set weights(value) {
        if (this.__mesh == null) {
            return;
        }
        //    this.__mesh!.makeVerticesSeparated();
        this.__mesh.weights = value;
    }
    calcViewDepth(cameraComponent) {
        let centerPosition_inLocal = this.__mesh.AABB.centerPoint;
        const skeletal = this.entity.getSkeletal();
        if (skeletal === null || skeletal === void 0 ? void 0 : skeletal._bindShapeMatrix) {
            skeletal._bindShapeMatrix.multiplyVector3To(this.__mesh.AABB.centerPoint, centerPosition_inLocal);
        }
        const worldMatrixInner = this.entity.getSceneGraph().worldMatrixInner;
        const centerPosition_inWorld = worldMatrixInner.multiplyVector3To(centerPosition_inLocal, MeshComponent.__tmpVector3_0);
        const viewMatrix = cameraComponent.viewMatrix;
        const centerPosition_inView = viewMatrix.multiplyVector3To(centerPosition_inWorld, MeshComponent.__tmpVector3_1);
        this.__viewDepth = centerPosition_inView.z;
        return this.__viewDepth;
    }
    get viewDepth() {
        return this.__viewDepth;
    }
    static alertNoMeshSet(meshComponent) {
        console.debug('No mesh is set on this MeshComponent:' + meshComponent.componentSID);
    }
    castRay(srcPointInWorld, directionInWorld, dotThreshold = 0) {
        if (this.__mesh) {
            let srcPointInLocal = srcPointInWorld;
            let directionInLocal = directionInWorld;
            if (this.__sceneGraphComponent) {
                const invWorldMatrix = _math_Matrix44__WEBPACK_IMPORTED_MODULE_9__["default"].invert(this.__sceneGraphComponent.worldMatrixInner);
                srcPointInLocal = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](invWorldMatrix.multiplyVector(new _math_Vector4__WEBPACK_IMPORTED_MODULE_5__["default"](srcPointInWorld)));
                const distVecInWorld = _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"].add(srcPointInWorld, directionInWorld);
                const distVecInLocal = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](invWorldMatrix.multiplyVector(new _math_Vector4__WEBPACK_IMPORTED_MODULE_5__["default"](distVecInWorld)));
                directionInLocal = _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"].normalize(_math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"].subtract(distVecInLocal, srcPointInLocal));
                const { t, intersectedPosition } = this.__mesh.castRay(srcPointInLocal, directionInLocal, dotThreshold);
                let intersectPositionInWorld = null;
                if (t >= 0) {
                    intersectPositionInWorld = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](this.__sceneGraphComponent.worldMatrixInner.multiplyVector(new _math_Vector4__WEBPACK_IMPORTED_MODULE_5__["default"](intersectedPosition)));
                }
                return { t, intersectedPositionInWorld: intersectPositionInWorld };
            }
        }
        return { t: -1, intersectedPositionInWorld: undefined };
    }
    castRayFromScreen(x, y, camera, viewport, dotThreshold = 0) {
        if (this.__mesh) {
            if (this.__sceneGraphComponent) {
                const invPVW = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_10__["default"].multiplyTo(camera.projectionMatrix, camera.viewMatrix, MeshComponent.__tmpMatrix44_0).multiply(this.__sceneGraphComponent.worldMatrixInner).invert();
                const srcPointInLocal = _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_11__["default"].unProjectTo(x, y, 0, invPVW, viewport, MeshComponent.__tmpVector3_0);
                const distVecInLocal = _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_11__["default"].unProjectTo(x, y, 1, invPVW, viewport, MeshComponent.__tmpVector3_1);
                const directionInLocal = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].subtractTo(distVecInLocal, srcPointInLocal, MeshComponent.__tmpVector3_2).normalize();
                const { t, intersectedPosition } = this.__mesh.castRay(srcPointInLocal, directionInLocal, dotThreshold);
                let intersectedPositionInWorld = null;
                if (intersectedPosition != null && t >= 0) {
                    intersectedPositionInWorld = this.__sceneGraphComponent.worldMatrixInner.multiplyVector3To(intersectedPosition, MeshComponent.__returnVector3);
                }
                return { t, intersectedPositionInWorld };
            }
        }
        return { t: -1, intersectedPositionInWorld: undefined };
    }
    $create() {
        this.__blendShapeComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _BlendShapeComponent__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.__sceneGraphComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _SceneGraphComponent__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Load);
    }
    $load() {
        if (this.__mesh == null) {
            return;
        }
        //    this.__mesh!.makeVerticesSeparated();
        this.__mesh.__calcTangents();
        this.__mesh._calcArenbergInverseMatrices();
        // this.__mesh.__initMorphPrimitives();
        this.__mesh.__calcFaceNormalsIfNonNormal();
        if (this.__blendShapeComponent && this.__blendShapeComponent.weights.length > 0) {
            this.__mesh.__calcBaryCentricCoord();
        }
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Logic);
    }
    $logic() {
        if (this.__mesh == null) {
            return;
        }
        // this.__mesh.__calcMorphPrimitives();
    }
}
MeshComponent.__tmpVector3_0 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].zero();
MeshComponent.__tmpVector3_1 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].zero();
MeshComponent.__tmpVector3_2 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].zero();
MeshComponent.__returnVector3 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].zero();
MeshComponent.__tmpMatrix44_0 = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__["default"].registerComponentClass(MeshComponent);


/***/ }),

/***/ "./src/foundation/components/MeshRendererComponent.ts":
/*!************************************************************!*\
  !*** ./src/foundation/components/MeshRendererComponent.ts ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MeshRendererComponent; });
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _MeshComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MeshComponent */ "./src/foundation/components/MeshComponent.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _SceneGraphComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _CameraComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _math_Matrix44__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _core_MemoryManager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _definitions_BufferUse__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../definitions/BufferUse */ "./src/foundation/definitions/BufferUse.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _system_ModuleManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../system/ModuleManager */ "./src/foundation/system/ModuleManager.ts");
/* harmony import */ var _definitions_visibility__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../definitions/visibility */ "./src/foundation/definitions/visibility.ts");
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _materials_core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../materials/core/AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");


















class MeshRendererComponent extends _core_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(entityUid, componentSid, entityRepository) {
        super(entityUid, componentSid, entityRepository);
        this.diffuseCubeMapContribution = 1.0;
        this.specularCubeMapContribution = 1.0;
        this.rotationOfCubeMap = 0;
        this._readyForRendering = false;
        this.__sceneGraphComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _SceneGraphComponent__WEBPACK_IMPORTED_MODULE_4__["default"]);
        const componentRepository = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
        const cameraComponents = componentRepository.getComponentsWithType(_CameraComponent__WEBPACK_IMPORTED_MODULE_6__["default"]);
        if (cameraComponents) {
            MeshRendererComponent.__cameraComponent = cameraComponents[0];
        }
    }
    static get componentTID() {
        return _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_5__["WellKnownComponentTIDs"].MeshRendererComponentTID;
    }
    static get firstTransparentIndex() {
        return MeshRendererComponent.__firstTransparentIndex;
    }
    static get lastTransparentIndex() {
        return MeshRendererComponent.__lastTransparentIndex;
    }
    static __isReady() {
        if (MeshRendererComponent.__instanceIDBufferUid !== _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__["default"].InvalidCGAPIResourceUid) {
            return true;
        }
        else {
            return false;
        }
    }
    static __setupInstanceIDBuffer() {
        if (MeshRendererComponent.__instanceIdAccessor == null) {
            const buffer = _core_MemoryManager__WEBPACK_IMPORTED_MODULE_9__["default"].getInstance().createOrGetBuffer(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_11__["BufferUse"].CPUGeneric);
            const count = _core_Config__WEBPACK_IMPORTED_MODULE_10__["default"].maxEntityNumber;
            const bufferView = buffer.takeBufferView({ byteLengthToNeed: 4 /*byte*/ * count, byteStride: 0, isAoS: false });
            MeshRendererComponent.__instanceIdAccessor = bufferView.takeAccessor({ compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_12__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_13__["ComponentType"].Float, count: count });
        }
        const meshComponents = MeshRendererComponent.__componentRepository.getComponentsWithType(_MeshComponent__WEBPACK_IMPORTED_MODULE_2__["default"]);
        if (meshComponents == null) {
            return _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__["default"].InvalidCGAPIResourceUid;
        }
        for (var i = 0; i < meshComponents.length; i++) {
            MeshRendererComponent.__instanceIdAccessor.setScalar(i, meshComponents[i].entityUID, {});
        }
        return MeshRendererComponent.__webglResourceRepository.createVertexBuffer(MeshRendererComponent.__instanceIdAccessor);
    }
    static set manualTransparentSids(sids) {
        MeshRendererComponent.__manualTransparentSids = sids;
    }
    static set manualTransparentEntityNames(names) {
        MeshRendererComponent.__manualTransparentSids = [];
        for (let name of names) {
            const entity = _core_RnObject__WEBPACK_IMPORTED_MODULE_16__["default"].getRnObjectByName(name);
            if (entity) {
                const meshComponent = entity.getMesh();
                if (meshComponent) {
                    const mesh = meshComponent.mesh;
                    if (mesh) {
                        if (!mesh.isOpaque()) {
                            MeshRendererComponent.__manualTransparentSids.push(meshComponent.componentSID);
                        }
                    }
                }
            }
        }
    }
    $create() {
        this.__meshComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _MeshComponent__WEBPACK_IMPORTED_MODULE_2__["default"]);
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Load);
    }
    static common_$load({ processApproach }) {
        const moduleManager = _system_ModuleManager__WEBPACK_IMPORTED_MODULE_14__["default"].getInstance();
        const moduleName = 'webgl';
        const webglModule = moduleManager.getModule(moduleName);
        // Strategy
        MeshRendererComponent.__webglRenderingStrategy = webglModule.getRenderingStrategy(processApproach);
        // ResourceRepository
        MeshRendererComponent.__webglResourceRepository = webglModule.WebGLResourceRepository.getInstance();
        _materials_core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_17__["default"].initDefaultTextures();
    }
    $load() {
        MeshRendererComponent.__webglRenderingStrategy.$load(this.__meshComponent);
        if (this.diffuseCubeMap && !this.diffuseCubeMap.startedToLoad) {
            this.diffuseCubeMap.loadTextureImagesAsync();
        }
        if (this.specularCubeMap && !this.specularCubeMap.startedToLoad) {
            this.specularCubeMap.loadTextureImagesAsync();
        }
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].PreRender);
    }
    static common_$prerender() {
        const gl = MeshRendererComponent.__webglResourceRepository.currentWebGLContextWrapper;
        if (gl == null) {
            throw new Error('No WebGLRenderingContext!');
        }
        MeshRendererComponent.__webglRenderingStrategy.common_$prerender();
        if (MeshRendererComponent.__isReady()) {
            return 0;
        }
        MeshRendererComponent.__instanceIDBufferUid = MeshRendererComponent.__setupInstanceIDBuffer();
        return MeshRendererComponent.__instanceIDBufferUid;
    }
    $prerender() {
        MeshRendererComponent.__webglRenderingStrategy.$prerender(this.__meshComponent, this, MeshRendererComponent.__instanceIDBufferUid);
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Render);
    }
    static sort_$render(renderPass) {
        if (MeshRendererComponent.__manualTransparentSids == null) {
            const sortedMeshComponentSids = MeshRendererComponent.sort_$render_inner(void 0, renderPass);
            // const sortedMeshComponentSids = MeshRendererComponent.sort_$render_inner();
            return sortedMeshComponentSids;
        }
        else {
            const sortedMeshComponentSids = MeshRendererComponent.sort_$render_inner(MeshRendererComponent.__manualTransparentSids, renderPass);
            // const sortedMeshComponentSids = MeshRendererComponent.sort_$render_inner(MeshRendererComponent.__manualTransparentSids);
            return sortedMeshComponentSids;
        }
    }
    static sort_$render_inner(transparentMeshComponentSids_ = [], renderPass) {
        const sceneGraphComponents = renderPass.sceneTopLevelGraphComponents;
        let meshComponents = [];
        const componentRepository = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
        let cameraComponent = renderPass.cameraComponent;
        if (cameraComponent == null) {
            cameraComponent = componentRepository.getComponent(_CameraComponent__WEBPACK_IMPORTED_MODULE_6__["default"], _CameraComponent__WEBPACK_IMPORTED_MODULE_6__["default"].main);
        }
        if (cameraComponent && MeshRendererComponent.isViewFrustumCullingEnabled) {
            cameraComponent.updateFrustum();
            const whetherContainsSkeletal = (sg) => {
                const skeletalComponent = sg.entity.getSkeletal();
                if (skeletalComponent != null) {
                    return true;
                }
                else {
                    const children = sg.children;
                    for (let child of children) {
                        return whetherContainsSkeletal(child);
                    }
                    return false;
                }
            };
            const frustum = cameraComponent.frustum;
            const doAsVisible = (sg, meshComponents) => {
                const sgs = _SceneGraphComponent__WEBPACK_IMPORTED_MODULE_4__["default"].flattenHierarchy(sg, false);
                for (let sg of sgs) {
                    const mesh = sg.entity.getMesh();
                    if (mesh) {
                        meshComponents.push(mesh);
                    }
                }
            };
            const frustumCullingRecursively = (sg, meshComponents) => {
                const result = frustum.culling(sg);
                if (result === _definitions_visibility__WEBPACK_IMPORTED_MODULE_15__["Visibility"].Visible) {
                    doAsVisible(sg, meshComponents);
                }
                else if (result === _definitions_visibility__WEBPACK_IMPORTED_MODULE_15__["Visibility"].Neutral ||
                    whetherContainsSkeletal(sg)) {
                    const children = sg.children;
                    const mesh = sg.entity.getMesh();
                    if (mesh) {
                        meshComponents.push(mesh);
                    }
                    for (let child of children) {
                        frustumCullingRecursively(child, meshComponents);
                    }
                }
            };
            for (let tlsg of sceneGraphComponents) {
                frustumCullingRecursively(tlsg, meshComponents);
            }
        }
        else {
            meshComponents = renderPass.meshComponents;
        }
        meshComponents = Array.from(new Set(meshComponents));
        const opaqueAndTransparentPartiallyMeshComponentSids = [];
        const transparentPartiallyMeshComponents = [];
        const transparentCompletelyMeshComponents = [];
        for (let i = 0; i < meshComponents.length; i++) {
            if (!meshComponents[i].entity.getSceneGraph().isVisible) {
                continue;
            }
            const meshRendererComponent = meshComponents[i].entity.getMeshRenderer();
            if (meshRendererComponent.currentProcessStage === _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Render) {
                const meshComponent = meshComponents[i];
                if (meshComponent.mesh) {
                    if (transparentMeshComponentSids_.length === 0 && meshComponent.mesh.isBlendPartially()) {
                        transparentPartiallyMeshComponents.push(meshComponent);
                        opaqueAndTransparentPartiallyMeshComponentSids.push(meshComponent.componentSID);
                    }
                    else if (transparentMeshComponentSids_.length === 0 && meshComponent.mesh.isAllBlend()) {
                        transparentCompletelyMeshComponents.push(meshComponent);
                    }
                    if (meshComponent.mesh.isOpaque()) {
                        opaqueAndTransparentPartiallyMeshComponentSids.push(meshComponent.componentSID);
                    }
                    else {
                        if (cameraComponent) {
                            meshComponent.calcViewDepth(cameraComponent);
                        }
                    }
                }
                else {
                    _MeshComponent__WEBPACK_IMPORTED_MODULE_2__["default"].alertNoMeshSet(meshComponent);
                }
            }
        }
        // Sort transparent meshes
        const transparentPartiallyOrAllMeshComponents = transparentPartiallyMeshComponents.concat(transparentCompletelyMeshComponents);
        transparentPartiallyOrAllMeshComponents.sort(function (a, b) {
            return a.viewDepth - b.viewDepth;
        });
        let transparentMeshComponentSids;
        if (transparentMeshComponentSids_.length === 0) {
            transparentMeshComponentSids = transparentPartiallyOrAllMeshComponents.map((meshComponent) => {
                return meshComponent.componentSID;
            });
        }
        else {
            transparentMeshComponentSids = transparentMeshComponentSids_;
        }
        MeshRendererComponent.__firstTransparentIndex = opaqueAndTransparentPartiallyMeshComponentSids.length;
        // Concat opaque and transparent meshes
        const sortedMeshComponentSids = opaqueAndTransparentPartiallyMeshComponentSids.concat(transparentMeshComponentSids);
        MeshRendererComponent.__lastTransparentIndex = sortedMeshComponentSids.length - 1;
        // Add terminator
        sortedMeshComponentSids.push(_core_Component__WEBPACK_IMPORTED_MODULE_1__["default"].invalidComponentSID);
        return sortedMeshComponentSids;
    }
    static common_$render({ renderPass, processStage, renderPassTickCount }) {
        MeshRendererComponent.__cameraComponent = renderPass.cameraComponent;
        if (MeshRendererComponent.__cameraComponent == null) {
            MeshRendererComponent.__cameraComponent = MeshRendererComponent.__componentRepository.getComponent(_CameraComponent__WEBPACK_IMPORTED_MODULE_6__["default"], _CameraComponent__WEBPACK_IMPORTED_MODULE_6__["default"].main);
        }
        let viewMatrix = MeshRendererComponent.__tmp_identityMatrix;
        let projectionMatrix = MeshRendererComponent.__tmp_identityMatrix;
        if (MeshRendererComponent.__cameraComponent) {
            viewMatrix = MeshRendererComponent.__cameraComponent.viewMatrix;
            projectionMatrix = MeshRendererComponent.__cameraComponent.projectionMatrix;
        }
        const meshComponentSids = _core_Component__WEBPACK_IMPORTED_MODULE_1__["default"].__componentsOfProcessStages.get(processStage);
        const meshComponents = MeshRendererComponent.__componentRepository._getComponents(_MeshComponent__WEBPACK_IMPORTED_MODULE_2__["default"]);
        MeshRendererComponent.__webglRenderingStrategy.common_$render(meshComponentSids, meshComponents, viewMatrix, projectionMatrix, renderPass, renderPassTickCount);
    }
    $render({ i, renderPass, renderPassTickCount }) {
        if (MeshRendererComponent.__webglRenderingStrategy.$render == null) {
            return;
        }
        const entity = this.__entityRepository.getEntity(this.__entityUid);
        MeshRendererComponent.__webglRenderingStrategy.$render(i, this.__meshComponent, this.__sceneGraphComponent.worldMatrixInner, this.__sceneGraphComponent.normalMatrixInner, entity, renderPass, renderPassTickCount, this.diffuseCubeMap, this.specularCubeMap);
        if (this.__meshComponent.mesh) {
            if (this.__meshComponent.mesh.weights.length > 0) {
                this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].PreRender);
            }
        }
        else {
            _MeshComponent__WEBPACK_IMPORTED_MODULE_2__["default"].alertNoMeshSet(this.__meshComponent);
        }
    }
}
MeshRendererComponent.__shaderProgramHandleOfPrimitiveObjectUids = new Map();
MeshRendererComponent.__componentRepository = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
MeshRendererComponent.__instanceIDBufferUid = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__["default"].InvalidCGAPIResourceUid;
MeshRendererComponent.__tmp_identityMatrix = _math_Matrix44__WEBPACK_IMPORTED_MODULE_7__["default"].identity();
MeshRendererComponent.__firstTransparentIndex = -1;
MeshRendererComponent.__lastTransparentIndex = -1;
MeshRendererComponent.isViewFrustumCullingEnabled = true;
MeshRendererComponent.isDepthMaskTrueForTransparencies = false;
_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__["default"].registerComponentClass(MeshRendererComponent);


/***/ }),

/***/ "./src/foundation/components/PhysicsComponent.ts":
/*!*******************************************************!*\
  !*** ./src/foundation/components/PhysicsComponent.ts ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PhysicsComponent; });
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _physics_VRMSpringBonePhysicsStrategy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../physics/VRMSpringBonePhysicsStrategy */ "./src/foundation/physics/VRMSpringBonePhysicsStrategy.ts");





class PhysicsComponent extends _core_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(entityUid, componentSid, entityComponent) {
        super(entityUid, componentSid, entityComponent);
        this.__strategy = new _physics_VRMSpringBonePhysicsStrategy__WEBPACK_IMPORTED_MODULE_4__["default"]();
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Logic);
    }
    static get componentTID() {
        return _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__["WellKnownComponentTIDs"].PhysicsComponentTID;
    }
    get strategy() {
        return this.__strategy;
    }
    static common_$logic() {
        _physics_VRMSpringBonePhysicsStrategy__WEBPACK_IMPORTED_MODULE_4__["default"].update();
    }
    $logic() {
    }
}
_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__["default"].registerComponentClass(PhysicsComponent);


/***/ }),

/***/ "./src/foundation/components/SceneGraphComponent.ts":
/*!**********************************************************!*\
  !*** ./src/foundation/components/SceneGraphComponent.ts ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SceneGraphComponent; });
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _math_Matrix44__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _definitions_BufferUse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../definitions/BufferUse */ "./src/foundation/definitions/BufferUse.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/MutableMatrix33 */ "./src/foundation/math/MutableMatrix33.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_AABB__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../math/AABB */ "./src/foundation/math/AABB.ts");
/* harmony import */ var _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");
/* harmony import */ var _AnimationComponent__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./AnimationComponent */ "./src/foundation/components/AnimationComponent.ts");
/* harmony import */ var _gizmos_AABBGizmo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../gizmos/AABBGizmo */ "./src/foundation/gizmos/AABBGizmo.ts");














class SceneGraphComponent extends _core_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(entityUid, componentSid, entityRepository) {
        super(entityUid, componentSid, entityRepository);
        this.__children = [];
        this._worldMatrix = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__["default"].dummy();
        this._normalMatrix = _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_8__["default"].dummy();
        this.__isWorldMatrixUpToDate = false;
        this.__isNormalMatrixUpToDate = false;
        this.__tmpMatrix = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__["default"].identity();
        this.__worldAABB = new _math_AABB__WEBPACK_IMPORTED_MODULE_10__["default"]();
        this.__isWorldAABBDirty = true;
        this.isVisible = true;
        this.__AABBGizmo = new _gizmos_AABBGizmo__WEBPACK_IMPORTED_MODULE_13__["default"](this);
        // Skeletal
        this.isRootJoint = false;
        this.jointIndex = -1;
        const thisClass = SceneGraphComponent;
        SceneGraphComponent.__sceneGraphs.push(this);
        this.isAbleToBeParent = false;
        this.beAbleToBeParent(true);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_5__["BufferUse"].GPUInstanceData, 'worldMatrix', _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_5__["BufferUse"].GPUInstanceData, 'normalMatrix', _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_8__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, [1, 0, 0, 0, 1, 0, 0, 0, 1]);
        this.submitToAllocation(this.maxNumberOfComponent);
    }
    set isGizmoVisible(flg) {
        if (flg) {
            this.__AABBGizmo.setup();
        }
        this.__AABBGizmo.isVisible = flg;
    }
    get isGizmoVisible() {
        return this.__AABBGizmo.isVisible;
    }
    static getTopLevelComponents() {
        return SceneGraphComponent.__sceneGraphs.filter((sg) => {
            return sg.isTopLevel;
        });
    }
    isJoint() {
        if (this.jointIndex >= 0) {
            return true;
        }
        else {
            return false;
        }
    }
    static get componentTID() {
        return _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_4__["WellKnownComponentTIDs"].SceneGraphComponentTID;
    }
    beAbleToBeParent(flag) {
        this.isAbleToBeParent = flag;
    }
    setWorldMatrixDirty() {
        var _a;
        this.setWorldMatrixDirtyRecursively();
        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.setWorldAABBDirtyParentRecursively();
    }
    setWorldMatrixDirtyRecursively() {
        this.__isWorldMatrixUpToDate = false;
        this.__isNormalMatrixUpToDate = false;
        this.__isWorldAABBDirty = true;
        this.children.forEach((child) => {
            child.setWorldMatrixDirtyRecursively();
        });
    }
    setWorldAABBDirtyParentRecursively() {
        var _a;
        this.__isWorldAABBDirty = true;
        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.setWorldAABBDirtyParentRecursively();
    }
    addChild(sg) {
        if (this.__children != null) {
            sg.__parent = this;
            this.__children.push(sg);
        }
        else {
            console.error('This is not allowed to have children.');
        }
    }
    get isTopLevel() {
        return this.__parent == null;
    }
    get children() {
        return this.__children;
    }
    get parent() {
        return this.__parent;
    }
    get worldMatrixInner() {
        if (!this.__isWorldMatrixUpToDate) {
            this._worldMatrix.copyComponents(this.calcWorldMatrixRecursively(false)); //this.isJoint()));
            this.__isWorldMatrixUpToDate = true;
        }
        return this._worldMatrix;
    }
    get worldMatrix() {
        return this.worldMatrixInner.clone();
    }
    get normalMatrixInner() {
        if (!this.__isNormalMatrixUpToDate) {
            _math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"].invertTo(this.worldMatrixInner, SceneGraphComponent.invertedMatrix44);
            this._normalMatrix.copyComponents(SceneGraphComponent.invertedMatrix44.transpose());
            this.__isNormalMatrixUpToDate = true;
        }
        return this._normalMatrix;
    }
    get normalMatrix() {
        return this.normalMatrixInner.clone();
    }
    isWorldMatrixUpToDateRecursively() {
        if (this.__isWorldMatrixUpToDate) {
            if (this.__parent) {
                let result = this.__parent.isWorldMatrixUpToDateRecursively();
                return result;
            }
            else {
                return true;
            }
        }
        return false;
    }
    calcWorldMatrixRecursively(isJointMode) {
        if (this.__isWorldMatrixUpToDate) {
            return this._worldMatrix;
        }
        const entity = this.__entityRepository.getEntity(this.__entityUid);
        const transform = entity.getTransform();
        if (this.__parent == null || (isJointMode && this.__parent != null && !this.__parent.isJoint())) {
            return transform.matrixInner;
        }
        const matrixFromAncestorToParent = this.__parent.calcWorldMatrixRecursively(isJointMode);
        return _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__["default"].multiplyTo(matrixFromAncestorToParent, transform.matrixInner, this.__tmpMatrix);
    }
    /**
     * Collects children and itself from specified sceneGraphComponent.
     * @param sceneGraphComponent collects children and itself from the sceneGraphComponent
     * @param isJointMode collects joints only
     */
    static flattenHierarchy(sceneGraphComponent, isJointMode) {
        const results = [];
        if (!isJointMode || sceneGraphComponent.isJoint()) {
            results.push(sceneGraphComponent);
        }
        if (sceneGraphComponent.isAbleToBeParent) {
            const children = sceneGraphComponent.children;
            for (let i = 0; i < children.length; i++) {
                const hitChildren = this.flattenHierarchy(children[i], isJointMode);
                Array.prototype.push.apply(results, hitChildren);
            }
        }
        return results;
    }
    get worldPosition() {
        const zeroVector = SceneGraphComponent.__originVector3;
        this.worldMatrixInner.multiplyVector3To(zeroVector, SceneGraphComponent.returnVector3);
        return SceneGraphComponent.returnVector3;
    }
    getWorldPositionOf(localPosition) {
        return this.worldMatrixInner.multiplyVector3(localPosition);
    }
    getLocalPositionOf(worldPosition) {
        return _math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"].invert(this.worldMatrixInner).multiplyVector3(worldPosition);
    }
    calcWorldAABB() {
        // this.__worldAABB.initialize();
        var aabb = (function mergeAABBRecursively(elem, flg) {
            const meshComponent = elem.entity.getMesh();
            elem.__worldAABB.initialize();
            if ((meshComponent === null || meshComponent === void 0 ? void 0 : meshComponent.mesh) != null) {
                // const skeletalComponent = elem.entity.getSkeletal();
                // if (false) {//skeletalComponent) {
                //   // AABB.multiplyMatrixTo(skeletalComponent.rootJointWorldMatrixInner as any as Matrix44, meshComponent.mesh.AABB, elem.__worldAABB);
                // } else {
                _math_AABB__WEBPACK_IMPORTED_MODULE_10__["default"].multiplyMatrixTo(elem.worldMatrixInner, meshComponent.mesh.AABB, elem.__worldAABB);
                // }
            }
            var children = elem.children;
            for (let i = 0; i < children.length; i++) {
                var aabb = mergeAABBRecursively(children[i], true);
                if (flg && elem.__animationComponent == null) {
                    elem.__worldAABB.mergeAABB(aabb);
                }
                else {
                    elem.__worldAABB.mergeAABB(aabb);
                }
            }
            return elem.__worldAABB;
        })(this, false);
        this.__worldAABB.mergeAABB(aabb);
        return this.__worldAABB;
    }
    get worldAABB() {
        if (!SceneGraphComponent.isJointAABBShouldBeCalculated && this.isJoint()) {
            return this.__worldAABB;
        }
        if (this.__isWorldAABBDirty) {
            this.calcWorldAABB();
            this.__isWorldAABBDirty = false;
        }
        else {
            // console.count('skipped')
        }
        return this.__worldAABB;
    }
    setVisibilityRecursively(flag) {
        this.isVisible = flag;
        for (let child of this.__children) {
            child.setVisibilityRecursively(flag);
        }
    }
    castRay(srcPointInWorld, directionInWorld, dotThreshold = 0, ignoreMeshComponents = []) {
        const collectedSgComponents = SceneGraphComponent.flattenHierarchy(this, false);
        const meshComponents = [];
        for (let sg of collectedSgComponents) {
            const mesh = sg.entity.getMesh();
            if (mesh) {
                meshComponents.push(mesh);
            }
        }
        let rayDistance = Number.MAX_VALUE;
        let intersectedPosition = null;
        let selectedMeshComponent = null;
        for (let meshComponent of meshComponents) {
            if (!meshComponent.entity.getSceneGraph().isVisible) {
                continue;
            }
            if (!meshComponent.isPickable) {
                continue;
            }
            if (ignoreMeshComponents.indexOf(meshComponent) !== -1) {
                continue;
            }
            let { t, intersectedPositionInWorld } = meshComponent.castRay(srcPointInWorld, directionInWorld, dotThreshold);
            if (t < rayDistance) {
                rayDistance = t;
                intersectedPositionInWorld = intersectedPositionInWorld;
                selectedMeshComponent = meshComponent;
            }
        }
        if (rayDistance === Number.MAX_VALUE) {
            rayDistance = -1;
        }
        return { intersectedPosition, rayDistance, selectedMeshComponent };
    }
    castRayFromScreen(x, y, camera, viewport, dotThreshold = 0, ignoreMeshComponents = []) {
        const collectedSgComponents = SceneGraphComponent.flattenHierarchy(this, false);
        const meshComponents = [];
        for (let sg of collectedSgComponents) {
            const mesh = sg.entity.getMesh();
            if (mesh) {
                meshComponents.push(mesh);
            }
        }
        let rayDistance = Number.MAX_VALUE;
        let intersectedPosition = null;
        let selectedMeshComponent = null;
        for (let meshComponent of meshComponents) {
            if (!meshComponent.entity.getSceneGraph().isVisible) {
                continue;
            }
            if (!meshComponent.isPickable) {
                continue;
            }
            if (ignoreMeshComponents.indexOf(meshComponent) !== -1) {
                continue;
            }
            let { t, intersectedPositionInWorld } = meshComponent.castRayFromScreen(x, y, camera, viewport, dotThreshold);
            if (t < rayDistance) {
                rayDistance = t;
                intersectedPosition = intersectedPositionInWorld;
                selectedMeshComponent = meshComponent;
            }
        }
        if (rayDistance === Number.MAX_VALUE) {
            rayDistance = -1;
        }
        return { intersectedPosition, rayDistance, selectedMeshComponent };
    }
    $create() {
        this.__animationComponent = this.entity.getComponent(_AnimationComponent__WEBPACK_IMPORTED_MODULE_12__["default"]);
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_6__["ProcessStage"].Logic);
    }
    $logic() {
        this._worldMatrix.copyComponents(this.calcWorldMatrixRecursively(false));
        if (this.__AABBGizmo.isSetup && this.__AABBGizmo.isVisible) {
            this.__AABBGizmo.update();
        }
        // if (this.parent == null) {
        // this.calcWorldAABB();
        // }
    }
}
SceneGraphComponent.__sceneGraphs = [];
SceneGraphComponent._isAllUpdate = false;
SceneGraphComponent.__originVector3 = _math_Vector3__WEBPACK_IMPORTED_MODULE_9__["default"].zero();
SceneGraphComponent.returnVector3 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].zero();
SceneGraphComponent.isJointAABBShouldBeCalculated = false;
SceneGraphComponent.invertedMatrix44 = new _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__["default"]([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__["default"].registerComponentClass(SceneGraphComponent);


/***/ }),

/***/ "./src/foundation/components/SkeletalComponent.ts":
/*!********************************************************!*\
  !*** ./src/foundation/components/SkeletalComponent.ts ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SkeletalComponent; });
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _math_MutableVector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");
/* harmony import */ var _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/MutableQuaternion */ "./src/foundation/math/MutableQuaternion.ts");
/* harmony import */ var _math_MathUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/MathUtil */ "./src/foundation/math/MathUtil.ts");
/* harmony import */ var _math_MutableVector4__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/MutableVector4 */ "./src/foundation/math/MutableVector4.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/GlobalDataRepository */ "./src/foundation/core/GlobalDataRepository.ts");
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../definitions/BoneDataType */ "./src/foundation/definitions/BoneDataType.ts");













class SkeletalComponent extends _core_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(entityUid, componentSid, entityRepository) {
        super(entityUid, componentSid, entityRepository);
        this._jointIndices = [];
        this.__joints = [];
        this._inverseBindMatrices = [];
        this.isSkinning = true;
        this.isOptimizingMode = true;
        this.__qArray = new Float32Array(0);
        this.__tArray = new Float32Array(0);
        this.__qtArray = new Float32Array(0);
        this.__qtInfo = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_7__["default"].dummy();
        this.__matArray = new Float32Array(0);
        if (SkeletalComponent.__tookGlobalDataNum < _core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxSkeletonNumber) {
            if (_core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__["BoneDataType"].Mat4x4) {
                SkeletalComponent.__globalDataRepository.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].BoneMatrix);
            }
            else if (_core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__["BoneDataType"].Vec4x2) {
                SkeletalComponent.__globalDataRepository.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].BoneQuaternion);
                SkeletalComponent.__globalDataRepository.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].BoneTranslateScale);
            }
            else if (_core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__["BoneDataType"].Vec4x1) {
                SkeletalComponent.__globalDataRepository.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].BoneMatrix);
                SkeletalComponent.__globalDataRepository.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].BoneCompressedChunk);
            }
            SkeletalComponent.__tookGlobalDataNum++;
        }
        else {
            console.warn('The actual number of Skeleton generated exceeds Config.maxSkeletonNumber.');
        }
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Logic);
    }
    static get componentTID() {
        return _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_2__["WellKnownComponentTIDs"].SkeletalComponentTID;
    }
    set joints(joints) {
        this.__joints = joints;
        let index = 0;
        if (this.componentSID < _core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxSkeletonNumber) {
            index = this.componentSID;
        }
        if (_core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__["BoneDataType"].Mat4x4) {
            this.__matArray = SkeletalComponent.__globalDataRepository.getValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].BoneMatrix, index).v;
        }
        else if (_core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__["BoneDataType"].Vec4x2) {
            this.__qArray = SkeletalComponent.__globalDataRepository.getValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].BoneQuaternion, index).v;
            this.__tArray = SkeletalComponent.__globalDataRepository.getValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].BoneTranslateScale, index).v;
        }
        else if (_core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__["BoneDataType"].Vec4x1) {
            this.__matArray = SkeletalComponent.__globalDataRepository.getValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].BoneMatrix, index).v;
            this.__qtArray = SkeletalComponent.__globalDataRepository.getValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].BoneCompressedChunk, index).v;
            this.__qtInfo = SkeletalComponent.__globalDataRepository.getValue(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_9__["ShaderSemantics"].BoneCompressedInfo, 0);
        }
    }
    get rootJointWorldMatrixInner() {
        var _a;
        return (_a = this.jointsHierarchy) === null || _a === void 0 ? void 0 : _a.worldMatrixInner;
    }
    get jointMatrices() {
        return this.__jointMatrices;
    }
    get jointQuaternionArray() {
        return this.__qArray;
    }
    get jointTranslateScaleArray() {
        return this.__tArray;
    }
    get jointMatricesArray() {
        return this.__matArray;
    }
    get jointCompressedChunk() {
        return this.__qtArray;
    }
    get jointCompressedInfo() {
        return this.__qtInfo;
    }
    $logic() {
        if (!this.isSkinning) {
            return;
        }
        const scales = [];
        const tXArray = [];
        const tYArray = [];
        const tZArray = [];
        for (let i = 0; i < this.__joints.length; i++) {
            const joint = this.__joints[i];
            let m;
            if (joint.isVisible) {
                const globalJointTransform = joint.worldMatrixInner;
                const inverseBindMatrix = this._inverseBindMatrices[i];
                _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].multiplyTo(globalJointTransform, inverseBindMatrix, SkeletalComponent.__tmp_mat4);
                if (this._bindShapeMatrix) {
                    SkeletalComponent.__tmp_mat4.multiply(this._bindShapeMatrix); // only for glTF1
                }
                m = SkeletalComponent.__tmp_mat4;
            }
            else {
                m = SkeletalComponent.__identityMat;
            }
            if (_core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__["BoneDataType"].Mat4x4 || _core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__["BoneDataType"].Vec4x1) {
                this.__matArray[i * 16 + 0] = m.v[0];
                this.__matArray[i * 16 + 1] = m.v[1];
                this.__matArray[i * 16 + 2] = m.v[2];
                this.__matArray[i * 16 + 3] = m.v[3];
                this.__matArray[i * 16 + 4] = m.v[4];
                this.__matArray[i * 16 + 5] = m.v[5];
                this.__matArray[i * 16 + 6] = m.v[6];
                this.__matArray[i * 16 + 7] = m.v[7];
                this.__matArray[i * 16 + 8] = m.v[8];
                this.__matArray[i * 16 + 9] = m.v[9];
                this.__matArray[i * 16 + 10] = m.v[10];
                this.__matArray[i * 16 + 11] = m.v[11];
                this.__matArray[i * 16 + 12] = m.v[12];
                this.__matArray[i * 16 + 13] = m.v[13];
                this.__matArray[i * 16 + 14] = m.v[14];
                this.__matArray[i * 16 + 15] = m.v[15];
            }
            if (_core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType !== _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__["BoneDataType"].Mat4x4) {
                const scaleVec = SkeletalComponent.__tmpVec3_0.setComponents(Math.hypot(m.m00, m.m01, m.m02), Math.hypot(m.m10, m.m11, m.m12), Math.hypot(m.m20, m.m21, m.m22));
                if (_core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__["BoneDataType"].Vec4x2) {
                    m.m00 /= scaleVec.x;
                    m.m01 /= scaleVec.x;
                    m.m02 /= scaleVec.x;
                    m.m10 /= scaleVec.y;
                    m.m11 /= scaleVec.y;
                    m.m12 /= scaleVec.y;
                    m.m20 /= scaleVec.z;
                    m.m21 /= scaleVec.z;
                    m.m22 /= scaleVec.z;
                    const q = SkeletalComponent.__tmp_q.fromMatrix(m);
                    this.__qArray[i * 4 + 0] = q.x;
                    this.__qArray[i * 4 + 1] = q.y;
                    this.__qArray[i * 4 + 2] = q.z;
                    this.__qArray[i * 4 + 3] = q.w;
                    this.__tArray[i * 4 + 0] = m.m03; // m.getTranslate().x
                    this.__tArray[i * 4 + 1] = m.m13; // m.getTranslate().y
                    this.__tArray[i * 4 + 2] = m.m23; // m.getTranslate().z
                    this.__tArray[i * 4 + 3] = Math.max(scaleVec.x, scaleVec.y, scaleVec.z);
                }
                else if (_core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__["BoneDataType"].Vec4x1) {
                    scales.push(Math.max(scaleVec.x, scaleVec.y, scaleVec.z));
                    const t = m.getTranslateTo(SkeletalComponent.__tmpVec3_1);
                    tXArray.push(Math.abs(t.x));
                    tYArray.push(Math.abs(t.y));
                    tZArray.push(Math.abs(t.z));
                }
            }
        }
        if (_core_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_12__["BoneDataType"].Vec4x1) {
            const maxScale = Math.max(...scales);
            const maxX = Math.max(...tXArray);
            const maxY = Math.max(...tYArray);
            const maxZ = Math.max(...tZArray);
            this.__qtInfo.x = maxX * 1.1;
            this.__qtInfo.y = maxY * 1.1;
            this.__qtInfo.z = maxZ * 1.1;
            this.__qtInfo.w = maxScale;
            for (let i = 0; i < this.__joints.length; i++) {
                const m = SkeletalComponent.__tmp_mat4;
                m.v[0] = this.__matArray[i * 16 + 0];
                m.v[1] = this.__matArray[i * 16 + 1];
                m.v[2] = this.__matArray[i * 16 + 2];
                m.v[3] = this.__matArray[i * 16 + 3];
                m.v[4] = this.__matArray[i * 16 + 4];
                m.v[5] = this.__matArray[i * 16 + 5];
                m.v[6] = this.__matArray[i * 16 + 6];
                m.v[7] = this.__matArray[i * 16 + 7];
                m.v[8] = this.__matArray[i * 16 + 8];
                m.v[9] = this.__matArray[i * 16 + 9];
                m.v[10] = this.__matArray[i * 16 + 10];
                m.v[11] = this.__matArray[i * 16 + 11];
                m.v[12] = this.__matArray[i * 16 + 12];
                m.v[13] = this.__matArray[i * 16 + 13];
                m.v[14] = this.__matArray[i * 16 + 14];
                m.v[15] = this.__matArray[i * 16 + 15];
                const q = SkeletalComponent.__tmp_q.fromMatrix(m);
                q.normalize();
                const vec2QPacked = _math_MathUtil__WEBPACK_IMPORTED_MODULE_6__["MathUtil"].packNormalizedVec4ToVec2(q.x, q.y, q.z, q.w, 4096);
                this.__qtArray[i * 4 + 0] = vec2QPacked[0];
                this.__qtArray[i * 4 + 1] = vec2QPacked[1];
                const t = m.getTranslateTo(SkeletalComponent.__tmpVec3_0);
                const normalizedX = this.__qtInfo.x === 0.0 ? 0.0 : t.x / this.__qtInfo.x;
                const normalizedY = this.__qtInfo.y === 0.0 ? 0.0 : t.y / this.__qtInfo.y;
                const normalizedZ = this.__qtInfo.z === 0.0 ? 0.0 : t.z / this.__qtInfo.z;
                const normalizedW = this.__qtInfo.w === 0.0 ? 0.0 : scales[i] / this.__qtInfo.w;
                const vec2TPacked = _math_MathUtil__WEBPACK_IMPORTED_MODULE_6__["MathUtil"].packNormalizedVec4ToVec2(normalizedX, normalizedY, normalizedZ, normalizedW, 4096);
                this.__qtArray[i * 4 + 2] = vec2TPacked[0];
                this.__qtArray[i * 4 + 3] = vec2TPacked[1];
            }
        }
    }
}
SkeletalComponent.__tmpVec3_0 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_4__["default"].zero();
SkeletalComponent.__tmpVec3_1 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_4__["default"].zero();
SkeletalComponent.__tmp_mat4 = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].identity();
SkeletalComponent.__tmp_q = new _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_5__["default"](0, 0, 0, 1);
SkeletalComponent.__identityMat = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].identity();
SkeletalComponent.__globalDataRepository = _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_10__["default"].getInstance();
SkeletalComponent.__tookGlobalDataNum = 0;
_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_0__["default"].registerComponentClass(SkeletalComponent);


/***/ }),

/***/ "./src/foundation/components/TransformComponent.ts":
/*!*********************************************************!*\
  !*** ./src/foundation/components/TransformComponent.ts ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TransformComponent; });
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_Quaternion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Quaternion */ "./src/foundation/math/Quaternion.ts");
/* harmony import */ var _math_Matrix44__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _definitions_BufferUse__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../definitions/BufferUse */ "./src/foundation/definitions/BufferUse.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/MutableQuaternion */ "./src/foundation/math/MutableQuaternion.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../math/MutableMatrix33 */ "./src/foundation/math/MutableMatrix33.ts");
/* harmony import */ var _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");













// import AnimationComponent from './AnimationComponent';
class TransformComponent extends _core_Component__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(entityUid, componentSid, entityComponent) {
        super(entityUid, componentSid, entityComponent);
        this._translate = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].dummy();
        this._rotate = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].dummy();
        this._scale = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].dummy();
        this._quaternion = _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_9__["default"].dummy();
        this._matrix = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].dummy();
        this._invMatrix = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].dummy();
        this._normalMatrix = _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_11__["default"].dummy();
        this.__toUpdateAllTransform = true;
        this._updateCount = 0;
        this.__updateCountAtLastLogic = 0;
        // dependencies
        this._dependentAnimationComponentId = 0;
        const thisClass = TransformComponent;
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_7__["BufferUse"].CPUGeneric, 'translate', _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, [0, 0, 0]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_7__["BufferUse"].CPUGeneric, 'rotate', _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, [0, 0, 0]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_7__["BufferUse"].CPUGeneric, 'scale', _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, [1, 1, 1]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_7__["BufferUse"].CPUGeneric, 'quaternion', _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_9__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, [0, 0, 0, 1]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_7__["BufferUse"].CPUGeneric, 'matrix', _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_7__["BufferUse"].CPUGeneric, 'invMatrix', _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        this.registerMember(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_7__["BufferUse"].CPUGeneric, 'normalMatrix', _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_11__["default"], _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, [1, 0, 0, 0, 1, 0, 0, 0, 1]);
        this.submitToAllocation(this.maxNumberOfComponent);
        this._is_translate_updated = true;
        this._is_euler_angles_updated = true;
        this._is_scale_updated = true;
        this._is_quaternion_updated = true;
        this._is_trs_matrix_updated = true;
        this._is_inverse_trs_matrix_updated = true;
        this._is_normal_trs_matrix_updated = true;
        this.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_10__["ProcessStage"].Logic);
    }
    static get renderedPropertyCount() {
        return null;
    }
    static get componentTID() {
        return _WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_6__["WellKnownComponentTIDs"].TransformComponentTID;
    }
    set toUpdateAllTransform(flag) {
        this.__toUpdateAllTransform = flag;
    }
    get toUpdateAllTransform() {
        return this.__toUpdateAllTransform;
    }
    _needUpdate() {
        this._updateCount++;
    }
    set translate(vec) {
        this._translate.copyComponents(vec);
        this._is_translate_updated = true;
        this._is_trs_matrix_updated = false;
        this._is_inverse_trs_matrix_updated = false;
        this._is_normal_trs_matrix_updated = false;
        this.__updateTransform();
    }
    get translate() {
        return this.translateInner.clone();
    }
    get translateInner() {
        if (this._is_translate_updated) {
            return this._translate;
        }
        else if (this._is_trs_matrix_updated) {
            this._matrix.getTranslateTo(this._translate);
            this._is_translate_updated = true;
        }
        return this._translate;
    }
    set rotate(vec) {
        this._rotate.copyComponents(vec);
        this._is_euler_angles_updated = true;
        this._is_quaternion_updated = false;
        this._is_trs_matrix_updated = false;
        this._is_inverse_trs_matrix_updated = false;
        this._is_normal_trs_matrix_updated = false;
        this.__updateTransform();
    }
    get rotate() {
        return this.rotateInner.clone();
    }
    get rotateInner() {
        if (this._is_euler_angles_updated) {
            return this._rotate;
        }
        else if (this._is_trs_matrix_updated) {
            this._matrix.toEulerAnglesTo(this._rotate);
        }
        else if (this._is_quaternion_updated) {
            this._quaternion.toEulerAnglesTo(this._rotate);
        }
        this._is_euler_angles_updated = true;
        return this._rotate;
    }
    set scale(vec) {
        this._scale.copyComponents(vec);
        this._is_scale_updated = true;
        this._is_trs_matrix_updated = false;
        this._is_inverse_trs_matrix_updated = false;
        this._is_normal_trs_matrix_updated = false;
        this.__updateTransform();
    }
    get scale() {
        return this.scaleInner.clone();
    }
    get scaleInner() {
        if (this._is_scale_updated) {
            return this._scale;
        }
        else if (this._is_trs_matrix_updated) {
            this._matrix.getScaleTo(this._scale);
            this._is_scale_updated = true;
        }
        return this._scale;
    }
    set quaternion(quat) {
        this._quaternion.copyComponents(quat);
        this._is_quaternion_updated = true;
        this._is_euler_angles_updated = false;
        this._is_trs_matrix_updated = false;
        this._is_inverse_trs_matrix_updated = false;
        this._is_normal_trs_matrix_updated = false;
        this.__updateTransform();
    }
    get quaternion() {
        return this.quaternionInner.clone();
    }
    get quaternionInner() {
        if (this._is_quaternion_updated) {
            return this._quaternion;
        }
        else if (!this._is_quaternion_updated) {
            if (this._is_trs_matrix_updated) {
                this._is_quaternion_updated = true;
                this._quaternion.fromMatrix(this._matrix);
                return this._quaternion;
            }
            else if (this._is_euler_angles_updated) {
                const rotationMat = TransformComponent.__tmpMatrix44_0.rotate(this._rotate);
                this._quaternion.fromMatrix(rotationMat);
                this._is_quaternion_updated = true;
                return this._quaternion;
            }
        }
        return this._quaternion;
    }
    set matrix(mat) {
        this._matrix.copyComponents(mat);
        this._is_trs_matrix_updated = true;
        this._is_translate_updated = false;
        this._is_euler_angles_updated = false;
        this._is_quaternion_updated = false;
        this._is_scale_updated = false;
        this._is_inverse_trs_matrix_updated = false;
        this._is_normal_trs_matrix_updated = false;
        this.__updateTransform();
    }
    get matrix() {
        return this.matrixInner.clone();
    }
    get matrixInner() {
        if (this._is_trs_matrix_updated) {
            return this._matrix;
        }
        // Clear and set Scale
        const scale = this.scaleInner;
        const n00 = scale.v[0];
        // const n01 = 0;
        // const n02 = 0;
        // const n03 = 0;
        // const n10 = 0;
        const n11 = scale.v[1];
        // const n12 = 0;
        // const n13 = 0;
        // const n20 = 0;
        // const n21 = 0;
        const n22 = scale.v[2];
        // const n23 = 0;
        // const n30 = 0;
        // const n31 = 0;
        // const n32 = 0;
        // const n33 = 1;
        const q = this.quaternionInner;
        const sx = q.v[0] * q.v[0];
        const sy = q.v[1] * q.v[1];
        const sz = q.v[2] * q.v[2];
        const cx = q.v[1] * q.v[2];
        const cy = q.v[0] * q.v[2];
        const cz = q.v[0] * q.v[1];
        const wx = q.v[3] * q.v[0];
        const wy = q.v[3] * q.v[1];
        const wz = q.v[3] * q.v[2];
        const m00 = 1.0 - 2.0 * (sy + sz);
        const m01 = 2.0 * (cz - wz);
        const m02 = 2.0 * (cy + wy);
        // const m03 = 0.0;
        const m10 = 2.0 * (cz + wz);
        const m11 = 1.0 - 2.0 * (sx + sz);
        const m12 = 2.0 * (cx - wx);
        // const m13 = 0.0;
        const m20 = 2.0 * (cy - wy);
        const m21 = 2.0 * (cx + wx);
        const m22 = 1.0 - 2.0 * (sx + sy);
        // const m23 = 0.0;
        // const m30 = 0.0;
        // const m31 = 0.0;
        // const m32 = 0.0;
        // const m33 = 1.0;
        const translate = this.translateInner;
        // TranslateMatrix * RotateMatrix * ScaleMatrix
        this._matrix.m00 = m00 * n00;
        this._matrix.m01 = m01 * n11;
        this._matrix.m02 = m02 * n22;
        this._matrix.m03 = translate.v[0];
        this._matrix.m10 = m10 * n00;
        this._matrix.m11 = m11 * n11;
        this._matrix.m12 = m12 * n22;
        this._matrix.m13 = translate.v[1];
        this._matrix.m20 = m20 * n00;
        this._matrix.m21 = m21 * n11;
        this._matrix.m22 = m22 * n22;
        this._matrix.m23 = translate.v[2];
        this._matrix.m30 = 0;
        this._matrix.m31 = 0;
        this._matrix.m32 = 0;
        this._matrix.m33 = 1;
        // const rotateMatrix = new Matrix44(this.quaternion);
        // const matrix = MutableMatrix44.multiply(rotateMatrix, Matrix44.scale(this.scale));
        // matrix.m03 = this.translate.x;
        // matrix.m13 = this.translate.y;
        // matrix.m23 = this.translate.z;
        //this._matrix.copyComponents(matrix);
        this._is_trs_matrix_updated = true;
        return this._matrix;
    }
    get inverseMatrix() {
        return this.inverseMatrixInner.clone();
    }
    get inverseMatrixInner() {
        if (!this._is_inverse_trs_matrix_updated) {
            _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].invertTo(this.matrixInner, this._invMatrix);
            this._is_inverse_trs_matrix_updated = true;
        }
        return this._invMatrix;
    }
    get normalMatrix() {
        return this.normalMatrixInner.clone();
    }
    get normalMatrixInner() {
        if (!this._is_normal_trs_matrix_updated) {
            const invertedMatrix44 = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].invertTo(this.matrixInner, TransformComponent.__tmpMatrix44_0);
            const newNormalMatrix = invertedMatrix44.transpose();
            this._normalMatrix.copyComponents(newNormalMatrix);
            this._is_normal_trs_matrix_updated = true;
        }
        return this._normalMatrix;
    }
    /**
     * Set multiple transform information at once. By using this method,
     * we reduce the cost of automatically updating other transform components inside this class.
     * This method may be useful for animation processing and so on.
     *
     * The transform components of these arguments must not be mutually discrepant.
     * for example. The transform components of matrix argument (translate, rotate/quaternion, scale)
     * must be equal to translate, rotate, scale, quaternion arguments.
     * And both rotate and quaternion arguments must be same rotation.
     * If there is an argument passed with null or undefined, it is interpreted as unchanged.
     *
     * @param {*} translate
     * @param {*} rotate
     * @param {*} scale
     * @param {*} quaternion
     * @param {*} matrix
     */
    setTransform(translate, rotate, scale, quaternion, matrix) {
        this._is_trs_matrix_updated = false;
        this._is_inverse_trs_matrix_updated = false;
        this._is_normal_trs_matrix_updated = false;
        // Matrix
        if (matrix != null) {
            this._matrix.copyComponents(matrix);
            this._is_trs_matrix_updated = true;
            this._is_translate_updated = false;
            this._is_euler_angles_updated = false;
            this._is_quaternion_updated = false;
            this._is_scale_updated = false;
        }
        // Translate
        if (translate != null) {
            this._translate.copyComponents(translate);
            this._is_translate_updated = true;
        }
        // Rotation
        if (rotate != null && quaternion != null) {
            this._rotate.copyComponents(rotate);
            this._quaternion = new _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_9__["default"](quaternion);
            this._is_euler_angles_updated = true;
            this._is_quaternion_updated = true;
        }
        else if (rotate != null) {
            this._rotate.copyComponents(rotate);
            this._is_euler_angles_updated = true;
            this._is_quaternion_updated = false;
        }
        else if (quaternion != null) {
            this._quaternion.copyComponents(quaternion);
            this._is_euler_angles_updated = false;
            this._is_quaternion_updated = true;
        }
        // Scale
        if (scale != null) {
            this._scale.copyComponents(scale);
            this._is_scale_updated = true;
        }
        this.__updateTransform();
    }
    __updateTransform() {
        if (this.__toUpdateAllTransform) {
            this.__updateRotation();
            this.__updateTranslate();
            this.__updateScale();
        }
        //this.__updateMatrix();
        this._needUpdate();
    }
    __updateRotation() {
        if (this._is_euler_angles_updated && !this._is_quaternion_updated) {
            const rotationMat = TransformComponent.__tmpMatrix44_0.rotate(this._rotate);
            this._quaternion.fromMatrix(rotationMat);
            this._is_quaternion_updated = true;
        }
        else if (!this._is_euler_angles_updated && this._is_quaternion_updated) {
            this._quaternion.toEulerAnglesTo(this._rotate);
            this._is_euler_angles_updated = true;
        }
        else if (!this._is_euler_angles_updated && !this._is_quaternion_updated && this._is_trs_matrix_updated) {
            this._quaternion.fromMatrix(this._matrix);
            this._is_quaternion_updated = true;
            this._matrix.toEulerAnglesTo(this._rotate);
            this._is_euler_angles_updated = true;
        }
    }
    __updateTranslate() {
        if (!this._is_translate_updated && this._is_trs_matrix_updated) {
            this._matrix.getTranslateTo(this._translate);
            this._is_translate_updated = true;
        }
    }
    __updateScale() {
        if (!this._is_scale_updated && this._is_trs_matrix_updated) {
            this._matrix.getScaleTo(this._scale);
            this._is_scale_updated = true;
        }
    }
    __updateMatrix() {
        if (!this._is_trs_matrix_updated && this._is_translate_updated && this._is_quaternion_updated && this._is_scale_updated) {
            const rotationMatrix = this._matrix.fromQuaternion(this._quaternion);
            const scaleMat = TransformComponent.__tmpMatrix44_0.scale(this._scale);
            const rsMatrix = rotationMatrix.multiply(scaleMat); // rsMatrix references to this._matrix
            rsMatrix.putTranslate(this._translate);
            this._is_trs_matrix_updated = true;
        }
    }
    setPropertiesFromJson(arg) {
        let json = arg;
        if (typeof arg === "string") {
            json = JSON.parse(arg);
        }
        for (let key in json) {
            if (json.hasOwnProperty(key) && key in this) {
                if (key === "quaternion") {
                    this[key] = new _math_Quaternion__WEBPACK_IMPORTED_MODULE_1__["default"](json[key]);
                }
                else if (key === 'matrix') {
                    this[key] = new _math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"](json[key]);
                }
                else {
                    this[key] = new _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](json[key]);
                }
            }
        }
    }
    setRotationFromNewUpAndFront(UpVec, FrontVec) {
        const yDir = UpVec;
        const xDir = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].crossTo(yDir, FrontVec, TransformComponent.__tmpVector3_0);
        const zDir = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].crossTo(xDir, yDir, TransformComponent.__tmpVector3_1);
        const rotateMatrix = TransformComponent.__tmpMatrix44_0.setComponents(xDir.x, yDir.x, zDir.x, 0, xDir.y, yDir.y, zDir.y, 0, xDir.z, yDir.z, zDir.z, 0, 0, 0, 0, 1);
        this.rotateMatrix44 = rotateMatrix;
    }
    headToDirection(fromVec, toVec) {
        const fromDir = TransformComponent.__tmpVector3_0.copyComponents(fromVec).normalize();
        const toDir = TransformComponent.__tmpVector3_1.copyComponents(toVec).normalize();
        const rotationDir = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].crossTo(fromDir, toDir, TransformComponent.__tmpVector3_2);
        const cosTheta = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].dot(fromDir, toDir);
        const theta = Math.acos(cosTheta);
        this.quaternion = TransformComponent.__tmpQuaternion_0.axisAngle(rotationDir, theta);
    }
    set rotateMatrix44(rotateMatrix) {
        this.quaternion = TransformComponent.__tmpQuaternion_0.fromMatrix(rotateMatrix);
    }
    get rotateMatrix44() {
        return new _math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"](this.quaternion);
    }
    $logic() {
        const sceneGraphComponent = this.entity.getSceneGraph();
        if (this.__updateCountAtLastLogic !== this._updateCount) {
            sceneGraphComponent.setWorldMatrixDirty();
            this.__updateCountAtLastLogic = this._updateCount;
        }
        else {
            const skeletalComponent = this.entity.getSkeletal();
            if (skeletalComponent != null) {
                sceneGraphComponent.setWorldMatrixDirty();
            }
        }
    }
}
TransformComponent.__tmpMatrix44_0 = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_8__["default"].zero();
TransformComponent.__tmpVector3_0 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].zero();
TransformComponent.__tmpVector3_1 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].zero();
TransformComponent.__tmpVector3_2 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_12__["default"].zero();
TransformComponent.__tmpQuaternion_0 = _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_9__["default"].identity();
_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_4__["default"].registerComponentClass(TransformComponent);


/***/ }),

/***/ "./src/foundation/components/WellKnownComponentTIDs.ts":
/*!*************************************************************!*\
  !*** ./src/foundation/components/WellKnownComponentTIDs.ts ***!
  \*************************************************************/
/*! exports provided: WellKnownComponentTIDs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WellKnownComponentTIDs", function() { return WellKnownComponentTIDs; });
// const MaterialSID = 0
const AnimationComponentTID = 1;
const TransformComponentTID = 2;
const SceneGraphComponentTID = 3;
const MeshComponentTID = 4;
const MeshRendererComponentTID = 5;
const CameraControllerComponentTID = 6;
const CameraComponentTID = 7;
const LightComponentTID = 8;
const SkeletalComponentTID = 9;
const BlendShapeComponentTID = 10;
const PhysicsComponentTID = 11;
const SparkGearComponentTID = 12;
const EffekseerComponentTID = 13;
const maxWellKnownTidNumber = 13;
const WellKnownComponentTIDs = Object.freeze({
    AnimationComponentTID,
    TransformComponentTID,
    SceneGraphComponentTID,
    MeshComponentTID,
    MeshRendererComponentTID,
    CameraControllerComponentTID,
    CameraComponentTID,
    LightComponentTID,
    SkeletalComponentTID,
    BlendShapeComponentTID,
    PhysicsComponentTID,
    SparkGearComponentTID,
    EffekseerComponentTID,
    maxWellKnownTidNumber
});


/***/ }),

/***/ "./src/foundation/core/Component.ts":
/*!******************************************!*\
  !*** ./src/foundation/core/Component.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Component; });
/* harmony import */ var _core_MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _EntityRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EntityRepository */ "./src/foundation/core/EntityRepository.ts");
/* harmony import */ var _math_Matrix44__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _ComponentRepository__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _RnObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./RnObject */ "./src/foundation/core/RnObject.ts");








/**
 * Component is a functional unit that can be added to an Entity instance.
 */
class Component extends _RnObject__WEBPACK_IMPORTED_MODULE_7__["default"] {
    /**
     * The constructor of the Component class.
     * When creating an Component, use the createComponent method of the ComponentRepository class
     * instead of directly calling this constructor.
     * @param entityUid Unique ID of the corresponding entity
     * @param componentSid Scoped ID of the Component
     * @param entityRepository The instance of the EntityRepository class (Dependency Injection)
     */
    constructor(entityUid, componentSid, entityRepository) {
        super();
        this.__currentProcessStage = _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Create;
        this.__byteOffsetOfThisComponent = -1;
        this.__maxComponentNumber = _Config__WEBPACK_IMPORTED_MODULE_5__["default"].maxEntityNumber;
        this.__entityUid = entityUid;
        this._component_sid = componentSid;
        this.__isAlive = true;
        const stages = Component._processStages;
        stages.forEach(stage => {
            if (this.isExistProcessStageMethod(stage)) {
                if (Component.__componentsOfProcessStages.get(stage) == null) {
                    Component.__componentsOfProcessStages.set(stage, new Int32Array(_Config__WEBPACK_IMPORTED_MODULE_5__["default"].maxEntityNumber));
                    // Component.__dirtyOfArrayOfProcessStages.set(stage, false);
                    Component.__lengthOfArrayOfProcessStages.set(stage, 0);
                }
            }
        });
        this.__memoryManager = _core_MemoryManager__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
        this.__entityRepository = entityRepository;
    }
    set maxNumberOfComponent(value) {
        this.__maxComponentNumber = value;
    }
    get maxNumberOfComponent() {
        return this.__maxComponentNumber;
    }
    /**
     * Move to the other stages of process
     * @param processStage stage of component's process
     */
    moveStageTo(processStage) {
        // Component.__dirtyOfArrayOfProcessStages.set(this.__currentProcessStage, false);
        // Component.__dirtyOfArrayOfProcessStages.set(processStage, true);
        this.__currentProcessStage = processStage;
    }
    /**
     * Get the Type ID of the Component
     */
    static get componentTID() {
        return 0;
    }
    /**
     * Get the Scoped ID of the Component
     */
    get componentSID() {
        return this._component_sid;
    }
    /**
     * Get the unique ID of the entity corresponding to the component.
     */
    get entityUID() {
        return this.__entityUid;
    }
    /**
     * Get the current process stage of the component.
     */
    get currentProcessStage() {
        return this.__currentProcessStage;
    }
    /**
     * Get true or false whether the specified ProcessStage exists in Component.
     */
    static isExistProcessStageMethod(componentType, processStage, componentRepository) {
        if (componentType.prototype[processStage.methodName] == null) {
            return false;
        }
        return true;
    }
    /**
     * Get true or false whether the specified ProcessStage exists in Component.
     */
    isExistProcessStageMethod(processStage) {
        if (this[processStage.methodName] == null) {
            return false;
        }
        return true;
    }
    /**
     * Process the components
     * @param param0 params
     */
    static process({ componentType, processStage, processApproach, componentRepository, strategy, renderPass, renderPassTickCount }) {
        if (!Component.isExistProcessStageMethod(componentType, processStage, componentRepository)) {
            return;
        }
        const methodName = processStage.methodName;
        const array = this.__componentsOfProcessStages.get(processStage);
        const components = componentRepository._getComponents(componentType);
        for (let i = 0; i < array.length; ++i) {
            const componentSid = array[i];
            if (componentSid === Component.invalidComponentSID) {
                return;
            }
            const component = components[componentSid];
            component[methodName]({
                i,
                processStage,
                processApproach,
                strategy,
                renderPass,
                renderPassTickCount
            });
        }
    }
    /**
     * Update all components at each process stage.
     */
    static updateComponentsOfEachProcessStage(componentClass, processStage, componentRepository, renderPass) {
        if (!Component.isExistProcessStageMethod(componentClass, processStage, componentRepository)) {
            return;
        }
        const array = Component.__componentsOfProcessStages.get(processStage);
        if (array) {
            const method = componentClass['sort_' + processStage.methodName];
            if (method != null) {
                let sids = [];
                sids = method(renderPass);
                for (let i = 0; i < sids.length; i++) {
                    array[i] = sids[i];
                }
            }
            else {
                let count = 0;
                const components = componentRepository.getComponentsWithType(componentClass);
                for (let i = 0; i < components.length; ++i) {
                    const component = components[i];
                    if (processStage === component.__currentProcessStage) {
                        array[count++] = i;
                    }
                }
                array[count] = Component.invalidComponentSID;
            }
        }
    }
    /**
     * get byte length of sum of member fields in the component class
     */
    static getByteLengthSumOfMembers(bufferUse, componentClass) {
        const byteLengthSumOfMembers = this.__byteLengthSumOfMembers.get(componentClass);
        return byteLengthSumOfMembers.get(bufferUse);
    }
    static setupBufferView() {
    }
    /**
     * register a dependency for the other components.
     */
    registerDependency(component, isMust) {
    }
    /**
     * take a buffer view from the buffer.
     */
    static takeBufferView(bufferUse, componentClass, byteLengthSumOfMembers, count) {
        const buffer = _core_MemoryManager__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance().createOrGetBuffer(bufferUse);
        if (!this.__bufferViews.has(componentClass)) {
            this.__bufferViews.set(componentClass, new Map());
        }
        const bufferViews = this.__bufferViews.get(componentClass);
        if (!bufferViews.has(bufferUse)) {
            const bufferView = buffer.takeBufferView({ byteLengthToNeed: byteLengthSumOfMembers * count, byteStride: 0, isAoS: false, byteAlign: 16 });
            bufferViews.set(bufferUse, bufferView);
            return bufferView;
        }
        return void 0;
    }
    /**
     * take one memory area for the specified member for all same type of the component instances.
     */
    takeOne(memberName, dataClassType, initValues) {
        if (!this['_' + memberName].isDummy()) {
            return;
        }
        let taken = Component.__accessors.get(this.constructor).get(memberName).takeOne();
        if (dataClassType === _math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"] || dataClassType === _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_6__["default"]) {
            this['_' + memberName] = new dataClassType(taken, false, true);
        }
        else {
            this['_' + memberName] = new dataClassType(taken, false, true);
        }
        for (let i = 0; i < this['_' + memberName].v.length; ++i) {
            this['_' + memberName].v[i] = initValues[i];
        }
        return null;
    }
    /**
     * get the taken accessor for the member field.
     */
    static getAccessor(memberName, componentClass) {
        return this.__accessors.get(componentClass).get(memberName);
    }
    /**
     * take one accessor for the member field.
     */
    static takeAccessor(bufferUse, memberName, componentClass, compositionType, componentType, count) {
        if (!this.__accessors.has(componentClass)) {
            this.__accessors.set(componentClass, new Map());
        }
        const accessors = this.__accessors.get(componentClass);
        if (!accessors.has(memberName)) {
            const bufferViews = this.__bufferViews.get(componentClass);
            const bytes = compositionType.getNumberOfComponents() * componentType.getSizeInBytes();
            let alignedBytes = bytes;
            if (bytes % 16 !== 0) {
                alignedBytes += (bytes % 16 === 0) ? 0 : 16 - bytes % 16;
            }
            const accessor = bufferViews.get(bufferUse).takeFlexibleAccessor({ compositionType: compositionType, componentType, count: count, byteStride: alignedBytes, byteAlign: 16 });
            accessors.set(memberName, accessor);
            return accessor;
        }
        else {
            return void 0;
        }
    }
    static getByteOffsetOfThisComponentTypeInBuffer(bufferUse, componentClass) {
        return this.__bufferViews.get(componentClass).get(bufferUse).byteOffsetInBuffer;
    }
    static getByteOffsetOfFirstOfThisMemberInBuffer(memberName, componentClass) {
        return this.__accessors.get(componentClass).get(memberName).byteOffsetInBuffer;
    }
    static getByteOffsetOfFirstOfThisMemberInBufferView(memberName, componentClass) {
        return this.__accessors.get(componentClass).get(memberName).byteOffsetInBufferView;
    }
    static getCompositionTypeOfMember(memberName, componentClass) {
        const memberInfoArray = this.__memberInfo.get(componentClass);
        const info = memberInfoArray.find(info => {
            return info.memberName === memberName;
        });
        if (info != null) {
            return info.compositionType;
        }
        else {
            return null;
        }
    }
    static getComponentTypeOfMember(memberName, componentClass) {
        const memberInfoArray = this.__memberInfo.get(componentClass);
        const info = memberInfoArray.find(info => {
            return info.memberName === memberName;
        });
        if (info != null) {
            return info.componentType;
        }
        else {
            return null;
        }
    }
    /**
     * Register a member field of component class for memory allocation.
     * @param bufferUse purpose type of buffer use
     * @param memberName the name of member field
     * @param dataClassType a class of data
     * @param componentType a type of number
     * @param initValues a initial value
     */
    registerMember(bufferUse, memberName, dataClassType, componentType, initValues) {
        if (!Component.__memberInfo.has(this.constructor)) {
            Component.__memberInfo.set(this.constructor, []);
        }
        const memberInfoArray = Component.__memberInfo.get(this.constructor);
        memberInfoArray.push({
            bufferUse: bufferUse, memberName: memberName, dataClassType: dataClassType,
            compositionType: dataClassType.compositionType,
            componentType: componentType, initValues: initValues
        });
    }
    /**
     * Allocate memory of self member fields
     * @param count a number of entities to need allocate
     */
    submitToAllocation(count) {
        const componentClass = this.constructor;
        const memberInfoArray = Component.__memberInfo.get(componentClass);
        if (this._component_sid === 0) {
            if (!Component.__members.has(componentClass)) {
                Component.__members.set(componentClass, new Map());
            }
            const member = Component.__members.get(componentClass);
            memberInfoArray.forEach(info => {
                member.set(info.bufferUse, []);
            });
            memberInfoArray.forEach(info => {
                member.get(info.bufferUse).push(info);
            });
            // take a BufferView for all entities for each member fields.
            for (let bufferUse of member.keys()) {
                const infoArray = member.get(bufferUse);
                if (!Component.__byteLengthSumOfMembers.has(componentClass)) {
                    Component.__byteLengthSumOfMembers.set(componentClass, new Map());
                }
                let byteLengthSumOfMembers = Component.__byteLengthSumOfMembers.get(componentClass);
                if (!byteLengthSumOfMembers.has(bufferUse)) {
                    byteLengthSumOfMembers.set(bufferUse, 0);
                }
                infoArray.forEach(info => {
                    byteLengthSumOfMembers.set(bufferUse, byteLengthSumOfMembers.get(bufferUse) +
                        info.compositionType.getNumberOfComponents() * info.componentType.getSizeInBytes());
                });
                if (infoArray.length > 0) {
                    const bufferView = Component.takeBufferView(bufferUse, componentClass, byteLengthSumOfMembers.get(bufferUse), count);
                    this.__byteOffsetOfThisComponent = bufferView.byteOffsetInBuffer;
                }
            }
            // take a Accessor for all entities for each member fields (same as BufferView)
            for (let bufferUse of member.keys()) {
                const infoArray = member.get(bufferUse);
                infoArray.forEach(info => {
                    const accessor = Component.takeAccessor(info.bufferUse, info.memberName, componentClass, info.compositionType, info.componentType, count);
                    this['_byteOffsetOfAccessorInBuffer_' + info.memberName] = accessor.byteOffsetInBuffer;
                    this['_byteOffsetOfAccessorInComponent_' + info.memberName] = accessor.byteOffsetInBufferView;
                });
            }
        }
        const member = Component.__members.get(componentClass);
        // take a field value allocation for each entity for each member field
        for (let bufferUse of member.keys()) {
            const infoArray = member.get(bufferUse);
            infoArray.forEach(info => {
                this.takeOne(info.memberName, info.dataClassType, info.initValues);
            });
        }
    }
    /**
     * get the entity which has this component.
     * @returns the entity which has this component
     */
    get entity() {
        return this.__entityRepository.getEntity(this.__entityUid);
    }
    /**
     * get the bytes Information of the member
     * @param component a instance of the component
     * @param memberName the member of component in string
     * @returns bytes information
     */
    static getDataByteInfoInner(component, memberName) {
        const data = component['_' + memberName];
        const typedArray = data.v;
        const byteOffsetInBuffer = typedArray.byteOffset;
        const byteLength = typedArray.byteLength;
        const componentNumber = typedArray.length;
        const locationOffsetInBuffer = byteOffsetInBuffer / 4 / 4; // 4byte is the size of Float32Array, and texel fetch is 4 components unit.
        const byteOffsetInThisComponent = this['_byteOffsetOfAccessorInComponent_' + memberName] + component.componentSID * componentNumber * 4;
        const locationOffsetInThisComponent = this['_byteOffsetOfAccessorInComponent_' + memberName] + component.componentSID * componentNumber;
        const thisComponentByteOffsetInBuffer = component.__byteOffsetOfThisComponent;
        const thisComponentLocationOffsetInBuffer = component.__byteOffsetOfThisComponent / 4 / 4;
        return {
            byteLength,
            byteOffsetInBuffer,
            byteOffsetInThisComponent,
            locationOffsetInBuffer,
            locationOffsetInThisComponent,
            thisComponentByteOffsetInBuffer,
            thisComponentLocationOffsetInBuffer,
            componentNumber
        };
    }
    /**
     * get the bytes Information of the member
     * @param memberName the member of component in string
     * @returns bytes information
     */
    getDataByteInfo(memberName) {
        return Component.getDataByteInfoInner(this, memberName);
    }
    /**
     * get the bytes Information of the member (static version) by ComponentSID
     * @param componentType the Component type
     * @param componentSID the ComponentSID of the component
     * @param memberName the member of component in string
     * @returns bytes information
     */
    static getDataByteInfoByComponentSID(componentType, componentSID, memberName) {
        const component = _ComponentRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getInstance().getComponent(componentType, componentSID);
        if (component) {
            return Component.getDataByteInfoInner(component, memberName);
        }
        return void 0;
    }
    /**
     * get the bytes Information of the member (static version) by EntityUID
     * @param componentType the component type
     * @param entityUID the EntityUID
     * @param memberName the member of component in string
     * @returns bytes information
     */
    static getDataByteInfoByEntityUID(componentType, entityUID, memberName) {
        const component = _EntityRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance().getComponentOfEntity(entityUID, componentType);
        if (component) {
            return Component.getDataByteInfoInner(component, memberName);
        }
        return void 0;
    }
    /**
     * get the Pixel Location Offset in the Buffer of the Member
     * @param componentType the component type (e.g. TransformComponent )
     * @param memberName the member name in string
     * @returns the pixel offsets
     */
    static getLocationOffsetOfMemberOfComponent(componentType, memberName) {
        const component = _ComponentRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getInstance().getComponent(componentType, 0);
        return component['_byteOffsetOfAccessorInBuffer_' + memberName] / 4 / 4;
    }
}
Component.invalidComponentSID = -1;
Component.__componentsOfProcessStages = new Map();
Component.__lengthOfArrayOfProcessStages = new Map();
// protected static __dirtyOfArrayOfProcessStages: Map<ProcessStageEnum, boolean> = new Map();
Component.__bufferViews = new Map();
Component.__accessors = new Map();
Component.__byteLengthSumOfMembers = new Map();
Component.__memberInfo = new Map();
Component.__members = new Map();
Component._processStages = [
    _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Create,
    _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Load,
    // ProcessStage.Mount,
    _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Logic,
    _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].PreRender,
    _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_3__["ProcessStage"].Render,
];


/***/ }),

/***/ "./src/foundation/core/ComponentRepository.ts":
/*!****************************************************!*\
  !*** ./src/foundation/core/ComponentRepository.ts ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ComponentRepository; });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _misc_IsUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc/IsUtil */ "./src/foundation/misc/IsUtil.ts");
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Config */ "./src/foundation/core/Config.ts");



/**
 * The class that generates and manages all kinds of components.
 */
class ComponentRepository {
    constructor() {
        this.__component_sid_count_map = new Map();
        this.__components = new Map();
    }
    static registerComponentClass(componentClass) {
        const thisClass = ComponentRepository;
        thisClass.__componentClasses.set(componentClass.componentTID, componentClass);
    }
    static unregisterComponentClass(componentTID) {
        const thisClass = ComponentRepository;
        thisClass.__componentClasses.delete(componentTID);
    }
    /**
     * Gets the singleton instance of the ComponentRepository.
     */
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new ComponentRepository();
        }
        return this.__instance;
    }
    /**
     * Gets the class object of the component corresponding to specified ComponentTID.
     * @param componentTid The componentTID to get the class object.
     */
    static getComponentClass(componentTid) {
        return this.__componentClasses.get(componentTid);
    }
    /**
     * Creates an instance of the component for the entity.
     * @param componentTid The componentTID to create the instance.
     * @param entityUid The entityUID of the entity.
     * @param entityRepository the reference of the entityRepository.
     */
    createComponent(componentTid, entityUid, entityRepository) {
        const thisClass = ComponentRepository;
        const componentClass = thisClass.__componentClasses.get(componentTid);
        if (componentClass != null) {
            let component_sid_count = this.__component_sid_count_map.get(componentTid);
            if (!_misc_IsUtil__WEBPACK_IMPORTED_MODULE_1__["default"].exist(component_sid_count)) {
                this.__component_sid_count_map.set(componentTid, 0);
                component_sid_count = _Component__WEBPACK_IMPORTED_MODULE_0__["default"].invalidComponentSID;
            }
            this.__component_sid_count_map.set(componentTid, ++component_sid_count);
            const component = new componentClass(entityUid, component_sid_count, entityRepository);
            if (!this.__components.has(componentTid)) {
                this.__components.set(componentTid, []);
            }
            const array = this.__components.get(componentTid);
            if (array != null) {
                array[component.componentSID] = component;
                return component;
            }
        }
        return null;
    }
    /**
     * Get the instance of the component corresponding to the component class and componentSID.
     * @param componentClass The class object to get the component.
     * @param componentSid The componentSID to get the component.
     */
    getComponent(componentClass, componentSid) {
        return this.getComponentFromComponentTID(componentClass.componentTID, componentSid);
    }
    /**
     * Get the instance of the component corresponding to the componentTID and componentSID.
     * @param componentTid The componentTID to get the component.
     * @param componentSid The componentSID to get the component.
     */
    getComponentFromComponentTID(componentTid, componentSid) {
        const map = this.__components.get(componentTid);
        if (map != null) {
            const component = map[componentSid];
            if (component != null) {
                return map[componentSid];
            }
            else {
                return null;
            }
        }
        return null;
    }
    /**
     * @private
     * Gets an array of components corresponding to the class object of the component.
     * @param componentClass The class object of the component.
     */
    _getComponents(componentClass) {
        return this.__components.get(componentClass.componentTID);
    }
    static getMemoryBeginIndex(componentTid) {
        let memoryBeginIndex = 0;
        for (let i = 0; i < componentTid; i++) {
            const componentClass = ComponentRepository.__componentClasses.get(i);
            if (componentClass != null) {
                const sizeOfComponent = componentClass.sizeOfThisComponent;
                const maxEntityNumber = _Config__WEBPACK_IMPORTED_MODULE_2__["default"].maxEntityNumber;
                memoryBeginIndex += sizeOfComponent * maxEntityNumber;
            }
        }
        return memoryBeginIndex;
    }
    /**
     * Gets an array of components corresponding to the class object of the component.
     * @param componentType The class object of the component.
     */
    getComponentsWithType(componentType) {
        const components = this.__components.get(componentType.componentTID);
        if (components == null) {
            return [];
        }
        return components;
    }
    /**
     * Gets all componentTIDs.
     */
    getComponentTIDs() {
        const indices = [];
        for (let type of this.__components.keys()) {
            indices.push(type);
        }
        indices.sort(function (a, b) {
            if (a < b)
                return -1;
            if (a > b)
                return 1;
            return 0;
        });
        return indices;
    }
}
ComponentRepository.__componentClasses = new Map();


/***/ }),

/***/ "./src/foundation/core/Config.ts":
/*!***************************************!*\
  !*** ./src/foundation/core/Config.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../definitions/BoneDataType */ "./src/foundation/definitions/BoneDataType.ts");

let maxEntityNumber = 5000;
let maxLightNumberInShader = 4;
let maxVertexMorphNumberInShader = 41;
let maxMaterialInstanceForEachType = 500;
let maxSkeletonNumber = 33;
let maxCameraNumber = 15;
let maxSizeLimitOfNonCompressedTexture = 512;
let maxSkeletalBoneNumber = 250;
let dataTextureWidth = Math.pow(2, 12);
let dataTextureHeight = Math.pow(2, 12);
let boneDataType = _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_0__["BoneDataType"].Vec4x2;
let noWebGLTex2DStateCache = false;
/* harmony default export */ __webpack_exports__["default"] = ({
    maxEntityNumber, maxLightNumberInShader, maxVertexMorphNumberInShader, maxMaterialInstanceForEachType, boneDataType,
    maxSkeletonNumber, maxCameraNumber, maxSizeLimitOfNonCompressedTexture, maxSkeletalBoneNumber, dataTextureWidth, dataTextureHeight,
    noWebGLTex2DStateCache
});


/***/ }),

/***/ "./src/foundation/core/Entity.ts":
/*!***************************************!*\
  !*** ./src/foundation/core/Entity.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Entity; });
/* harmony import */ var _components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _RnObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RnObject */ "./src/foundation/core/RnObject.ts");


/**
 * The Rhodonite Entity Class which are an entities that exists in space.
 * Entities can acquire various functions by having components on themselves.
 */
class Entity extends _RnObject__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * The constructor of the Entity class.
     * When creating an Entity, use the createEntity method of the EntityRepository class
     * instead of directly calling this constructor.
     * @param entityUID The unique ID of the entity
     * @param isAlive Whether this entity alive or not
     * @param entityComponent The instance of EntityComponent (Dependency Injection)
     */
    constructor(entityUID, isAlive) {
        super();
        this.__components = []; // index is ComponentTID
        this.__entity_uid = entityUID;
        this.__isAlive = isAlive;
    }
    /**
     * Get Unique ID of the entity.
     */
    get entityUID() {
        return this.__entity_uid;
    }
    /**
     * @private
     * Sets a component to this entity.
     * @param component The component to set.
     */
    _setComponent(component) {
        this.__components[component.constructor.componentTID] = component;
    }
    /**
     * Get the component of the specified type that the entity has
     * @param componentType
     */
    getComponent(componentType) {
        return this.__components[componentType.componentTID];
    }
    /**
     * Gets the component corresponding to the ComponentTID.
     * @param componentTID The ComponentTID to get the component.
     */
    getComponentByComponentTID(componentTID) {
        return this.__components[componentTID];
    }
    /**
     * Get the TransformComponent of the entity.
     * It's a shortcut method of getComponent(TransformComponent).
     */
    getTransform() {
        if (this.__transformComponent == null) {
            this.__transformComponent = this.getComponentByComponentTID(_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_0__["WellKnownComponentTIDs"].TransformComponentTID);
        }
        return this.__transformComponent;
    }
    /**
     * Get the SceneGraphComponent of the entity.
     * It's a shortcut method of getComponent(SceneGraphComponent).
     */
    getSceneGraph() {
        if (this.__sceneGraphComponent == null) {
            this.__sceneGraphComponent = this.getComponentByComponentTID(_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_0__["WellKnownComponentTIDs"].SceneGraphComponentTID);
        }
        return this.__sceneGraphComponent;
    }
    getSkeletal() {
        if (this.__skeletalComponent == null) {
            this.__skeletalComponent = this.getComponentByComponentTID(_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_0__["WellKnownComponentTIDs"].SkeletalComponentTID);
        }
        return this.__skeletalComponent;
    }
    getMesh() {
        if (this.__meshComponent == null) {
            this.__meshComponent = this.getComponentByComponentTID(_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_0__["WellKnownComponentTIDs"].MeshComponentTID);
        }
        return this.__meshComponent;
    }
    getMeshRenderer() {
        if (this.__meshRendererComponent == null) {
            this.__meshRendererComponent = this.getComponentByComponentTID(_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_0__["WellKnownComponentTIDs"].MeshRendererComponentTID);
        }
        return this.__meshRendererComponent;
    }
    getCamera() {
        if (this.__cameraComponent == null) {
            this.__cameraComponent = this.getComponentByComponentTID(_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_0__["WellKnownComponentTIDs"].CameraComponentTID);
        }
        return this.__cameraComponent;
    }
    getCameraController() {
        if (this.__cameraControllerComponent == null) {
            this.__cameraControllerComponent = this.getComponentByComponentTID(_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_0__["WellKnownComponentTIDs"].CameraControllerComponentTID);
        }
        return this.__cameraControllerComponent;
    }
    getBlendShape() {
        if (this.__blendShapeComponent == null) {
            this.__blendShapeComponent = this.getComponentByComponentTID(_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_0__["WellKnownComponentTIDs"].BlendShapeComponentTID);
        }
        return this.__blendShapeComponent;
    }
    getPhysics() {
        if (this.__physicsComponent == null) {
            this.__physicsComponent = this.getComponentByComponentTID(_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_0__["WellKnownComponentTIDs"].PhysicsComponentTID);
        }
        return this.__physicsComponent;
    }
}
Entity.invalidEntityUID = -1;


/***/ }),

/***/ "./src/foundation/core/EntityRepository.ts":
/*!*************************************************!*\
  !*** ./src/foundation/core/EntityRepository.ts ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EntityRepository; });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./src/foundation/core/Entity.ts");
/* harmony import */ var _ComponentRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");


/**
 * The class that generates and manages entities.
 */
class EntityRepository {
    constructor() {
        this.__entity_uid_count = _Entity__WEBPACK_IMPORTED_MODULE_0__["default"].invalidEntityUID;
        this.__entities = [];
        this._components = [];
        this.__componentRepository = _ComponentRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance();
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new EntityRepository();
        }
        return this.__instance;
    }
    /**
     * Creates an entity which has the given types of the components
     * @param componentClasses The class objects of the components.
     */
    createEntity(componentClasses) {
        const entity = new _Entity__WEBPACK_IMPORTED_MODULE_0__["default"](++this.__entity_uid_count, true);
        this.__entities[this.__entity_uid_count] = entity;
        return this.addComponentsToEntity(componentClasses, entity.entityUID);
    }
    /**
     * Add components to the entity.
     * @param componentClasses The class objects to set to the entity.
     * @param entityUid The entityUID of the entity.
     */
    addComponentsToEntity(componentClasses, entityUid) {
        const entity = this.getEntity(entityUid);
        for (let componentClass of componentClasses) {
            const component = this.__componentRepository.createComponent(componentClass.componentTID, entityUid, this);
            let map = this._components[entity.entityUID];
            if (map == null) {
                map = new Map();
                this._components[entity.entityUID] = map;
            }
            if (component != null) {
                map.set(componentClass.componentTID, component);
                entity._setComponent(component);
            }
        }
        return entity;
    }
    /**
     * Remove components from the entity.
     * @param componentClasses The class object of the components to remove.
     * @param entityUid The entityUID of the entity.
     */
    removeComponentsFromEntity(componentClasses, entityUid) {
        const entity = this.getEntity(entityUid);
        for (let componentClass of componentClasses) {
            let map = this._components[entity.entityUID];
            if (map == null) {
                map = new Map();
                this._components[entity.entityUID] = map;
            }
            map.delete(componentClass.componentTID);
        }
        return entity;
    }
    /**
     * Gets the entity corresponding to the entityUID.
     * @param entityUid The entityUID of the entity.
     */
    getEntity(entityUid) {
        return this.__entities[entityUid];
    }
    /**
     * Gets the specified component from the entity.
     * @param entityUid The entity to get the component from.
     * @param componentType The class object of the component to get.
     */
    getComponentOfEntity(entityUid, componentType) {
        const entity = this._components[entityUid];
        let component = null;
        if (entity != null) {
            component = entity.get(componentType.componentTID);
            if (component != null) {
                return component;
            }
            else {
                return null;
            }
        }
        return component;
    }
    /**
     * Search entities by the given tags.
     * @param tags The tags to search
     */
    searchByTags(tags) {
        const matchEntities = [];
        for (let entity of this.__entities) {
            if (entity.matchTags(tags)) {
                matchEntities.push(entity);
            }
        }
        return matchEntities;
    }
    /**
     * Gets entity by the unique name.
     * @param uniqueName The unique name of the entity.
     */
    getEntityByUniqueName(uniqueName) {
        for (let entity of this.__entities) {
            if (entity.uniqueName === uniqueName) {
                return entity;
            }
        }
        return void 0;
    }
    /**
     * @private
     * Gets all entities.
     */
    _getEntities() {
        return this.__entities.concat();
    }
    /**
     * Gets the number of all entities.
     */
    getEntitiesNumber() {
        return this.__entities.length;
    }
}


/***/ }),

/***/ "./src/foundation/core/GlobalDataRepository.ts":
/*!*****************************************************!*\
  !*** ./src/foundation/core/GlobalDataRepository.ts ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GlobalDataRepository; });
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _definitions_BufferUse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/BufferUse */ "./src/foundation/definitions/BufferUse.ts");
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _materials_core_Material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../materials/core/Material */ "./src/foundation/materials/core/Material.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/MathClassUtil */ "./src/foundation/math/MathClassUtil.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _math_VectorN__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/VectorN */ "./src/foundation/math/VectorN.ts");
/* harmony import */ var _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _math_Scalar__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../math/Scalar */ "./src/foundation/math/Scalar.ts");
/* harmony import */ var _math_Vector4__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../components/WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../definitions/BoneDataType */ "./src/foundation/definitions/BoneDataType.ts");


















/**
 * The class which manages global data.
 */
class GlobalDataRepository {
    constructor() {
        this.__fields = new Map();
    }
    initialize() {
        // CurrentComponentSIDs
        const currentComponentSIDsInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].CurrentComponentSIDs, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].ScalarArray, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, maxIndex: _components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_16__["WellKnownComponentTIDs"].maxWellKnownTidNumber,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexAndPixelShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, needUniformInFastest: true, initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_9__["default"](new Float32Array(_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_16__["WellKnownComponentTIDs"].maxWellKnownTidNumber))
        };
        this.registerProperty(currentComponentSIDsInfo, 1);
        this.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].CurrentComponentSIDs);
        // Camera
        const viewMatrixInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].ViewMatrix, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Mat4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, initialValue: _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_15__["default"].identity()
        };
        const projectionMatrixInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].ProjectionMatrix, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Mat4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, initialValue: _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_15__["default"].identity()
        };
        const viewPositionInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].ViewPosition, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec3, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexAndPixelShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_14__["default"](0, 0, 1)
        };
        this.registerProperty(viewMatrixInfo, _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxCameraNumber);
        this.registerProperty(projectionMatrixInfo, _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxCameraNumber);
        this.registerProperty(viewPositionInfo, _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxCameraNumber);
        // Skinning
        const boneMatrixInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].BoneMatrix, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Mat4Array, maxIndex: _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxSkeletalBoneNumber, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: true, initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_9__["default"](new Float32Array(0))
        };
        const boneQuaternionInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].BoneQuaternion, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec4Array, maxIndex: _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxSkeletalBoneNumber, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: true, initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_9__["default"](new Float32Array(0))
        };
        const boneTranslateScaleInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].BoneTranslateScale, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec4Array, maxIndex: _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxSkeletalBoneNumber, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, soloDatum: true,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_9__["default"](new Float32Array(0))
        };
        const boneCompressedChunkInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].BoneCompressedChunk, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec4Array, maxIndex: _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxSkeletalBoneNumber, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, soloDatum: true,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_9__["default"](new Float32Array(0))
        };
        const boneCompressedInfoInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].BoneCompressedInfo, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, soloDatum: true,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: _math_Vector4__WEBPACK_IMPORTED_MODULE_13__["default"].zero()
        };
        const skeletalComponentSIDInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].SkinningMode, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Int,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexAndPixelShader, min: 0, max: 1, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].EveryTime, initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_12__["default"](-1)
        };
        if (_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_17__["BoneDataType"].Mat4x4) {
            this.registerProperty(boneMatrixInfo, _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxSkeletonNumber);
        }
        else if (_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_17__["BoneDataType"].Vec4x2) {
            this.registerProperty(boneQuaternionInfo, _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxSkeletonNumber);
            this.registerProperty(boneTranslateScaleInfo, _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxSkeletonNumber);
        }
        else if (_Config__WEBPACK_IMPORTED_MODULE_11__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_17__["BoneDataType"].Vec4x1) {
            this.registerProperty(boneMatrixInfo, _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxSkeletonNumber);
            this.registerProperty(boneCompressedChunkInfo, _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxSkeletonNumber);
            this.registerProperty(boneCompressedInfoInfo, 1);
            this.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].BoneCompressedInfo);
        }
        this.registerProperty(skeletalComponentSIDInfo, 1);
        this.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].SkinningMode);
        // Lighting
        const lightPositionInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].LightPosition, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec4Array, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, maxIndex: _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxLightNumberInShader,
            min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].EveryTime, initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_9__["default"](new Float32Array(_Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxLightNumberInShader))
        };
        const lightDirectionInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].LightDirection, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec4Array, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, maxIndex: _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxLightNumberInShader,
            min: -1, max: 1, isSystem: true, initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_9__["default"](new Float32Array(_Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxLightNumberInShader)), updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].EveryTime
        };
        const lightIntensityInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].LightIntensity, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec4Array, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float, stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, maxIndex: _Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxLightNumberInShader,
            min: 0, max: 10, isSystem: true, initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_9__["default"](new Float32Array(_Config__WEBPACK_IMPORTED_MODULE_11__["default"].maxLightNumberInShader)), updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].EveryTime
        };
        this.registerProperty(lightPositionInfo, 1);
        this.registerProperty(lightDirectionInfo, 1);
        this.registerProperty(lightIntensityInfo, 1);
        this.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].LightDirection);
        this.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].LightIntensity);
        this.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].LightPosition);
        const lightNumberInfo = {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].LightNumber,
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Scalar,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Int,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexAndPixelShader,
            min: 0,
            max: Number.MAX_SAFE_INTEGER,
            isSystem: true,
            updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].FirstTimeOnly,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_12__["default"](0),
        };
        this.registerProperty(lightNumberInfo, 1);
        this.takeOne(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].LightNumber);
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new GlobalDataRepository();
        }
        return this.__instance;
    }
    registerProperty(semanticInfo, maxCount) {
        const propertyIndex = _materials_core_Material__WEBPACK_IMPORTED_MODULE_4__["default"]._getPropertyIndex(semanticInfo);
        const buffer = _MemoryManager__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance().createOrGetBuffer(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_1__["BufferUse"].GPUInstanceData);
        const alignedByteLength = _materials_core_Material__WEBPACK_IMPORTED_MODULE_4__["default"]._calcAlignedByteLength(semanticInfo);
        const bufferView = buffer.takeBufferView({
            byteLengthToNeed: alignedByteLength * maxCount,
            byteStride: 0,
            byteAlign: 16,
            isAoS: false
        });
        let maxArrayLength = semanticInfo.maxIndex;
        if (_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].isArray(semanticInfo.compositionType) && maxArrayLength == null) {
            maxArrayLength = 100;
        }
        const accessor = bufferView.takeFlexibleAccessor({
            compositionType: semanticInfo.compositionType,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float,
            count: maxCount,
            byteStride: alignedByteLength,
            arrayLength: maxArrayLength,
            byteAlign: 16
        });
        const globalPropertyStruct = {
            shaderSemanticsInfo: semanticInfo,
            values: [],
            maxCount: maxCount,
            accessor: accessor
        };
        this.__fields.set(propertyIndex, globalPropertyStruct);
    }
    takeOne(shaderSemantic, arrayIndex) {
        const propertyIndex = _materials_core_Material__WEBPACK_IMPORTED_MODULE_4__["default"]._getPropertyIndex2(shaderSemantic, arrayIndex);
        const globalPropertyStruct = this.__fields.get(propertyIndex);
        if (globalPropertyStruct) {
            const semanticInfo = globalPropertyStruct.shaderSemanticsInfo;
            const typedArray = globalPropertyStruct.accessor.takeOne();
            const countIndex = globalPropertyStruct.values.length;
            const valueObj = _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_6__["default"].initWithFloat32Array(semanticInfo.initialValue, semanticInfo.initialValue, typedArray, semanticInfo.compositionType);
            globalPropertyStruct.values[countIndex] = valueObj;
            return valueObj;
        }
        return void 0;
    }
    setValue(shaderSemantic, countIndex, value, arrayIndex) {
        const propertyIndex = _materials_core_Material__WEBPACK_IMPORTED_MODULE_4__["default"]._getPropertyIndex2(shaderSemantic, arrayIndex);
        const globalPropertyStruct = this.__fields.get(propertyIndex);
        if (globalPropertyStruct) {
            const valueObj = globalPropertyStruct.values[countIndex];
            _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_6__["default"]._setForce(valueObj, value);
        }
    }
    getValue(shaderSemantic, countIndex, arrayIndex) {
        const propertyIndex = _materials_core_Material__WEBPACK_IMPORTED_MODULE_4__["default"]._getPropertyIndex2(shaderSemantic, arrayIndex);
        const globalPropertyStruct = this.__fields.get(propertyIndex);
        if (globalPropertyStruct) {
            const valueObj = globalPropertyStruct.values[countIndex];
            return valueObj;
        }
        return void 0;
    }
    getGlobalPropertyStruct(propertyIndex) {
        return this.__fields.get(propertyIndex);
    }
    setUniformLocations(shaderProgramUid) {
        const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_7__["default"].getWebGLResourceRepository();
        const semanticsInfoArray = [];
        this.__fields.forEach((globalPropertyStruct, key) => {
            const semanticInfo = globalPropertyStruct.shaderSemanticsInfo;
            semanticsInfoArray.push(semanticInfo);
        });
        webglResourceRepository.setupUniformLocations(shaderProgramUid, semanticsInfoArray);
    }
    setUniformValues(shaderProgram) {
        const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_7__["default"].getWebGLResourceRepository();
        this.__fields.forEach((globalPropertyStruct, key) => {
            const info = globalPropertyStruct.shaderSemanticsInfo;
            const values = globalPropertyStruct.values;
            for (let i = 0; i < values.length; i++) {
                webglResourceRepository.setUniformValue(shaderProgram, info.semantic.str, true, values[i], info.index);
            }
        });
    }
    // getLocationOffsetOfProperty(propertyIndex: Index, countIndex: Index) {
    //   const globalPropertyStruct = this.__fields.get(propertyIndex);
    //   if (globalPropertyStruct) {
    //     const value = globalPropertyStruct.values[countIndex];
    //     return (value.v as Float32Array).byteOffset / 4 / 4;
    //   }
    //   return void 0;
    // }
    getLocationOffsetOfProperty(propertyIndex) {
        const globalPropertyStruct = this.__fields.get(propertyIndex);
        if (globalPropertyStruct) {
            return globalPropertyStruct.accessor.byteOffsetInBuffer / 4 / 4;
        }
        return void 0;
    }
    getCurrentDataNumberOfTheProperty(propertyIndex) {
        const globalPropertyStruct = this.__fields.get(propertyIndex);
        if (globalPropertyStruct) {
            return globalPropertyStruct.values.length;
        }
        return 0;
    }
    addPropertiesStr(vertexPropertiesStr, pixelPropertiesStr, propertySetter, isWebGL2) {
        this.__fields.forEach((globalPropertyStruct, propertyIndex) => {
            const info = globalPropertyStruct.shaderSemanticsInfo;
            if (info.stage === _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader || info.stage === _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexAndPixelShader) {
                vertexPropertiesStr += propertySetter('', info, propertyIndex, true, isWebGL2);
            }
            if (info.stage === _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader || info.stage === _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexAndPixelShader) {
                pixelPropertiesStr += propertySetter('', info, propertyIndex, true, isWebGL2);
            }
        });
        return [vertexPropertiesStr, pixelPropertiesStr];
    }
}


/***/ }),

/***/ "./src/foundation/core/MemoryManager.ts":
/*!**********************************************!*\
  !*** ./src/foundation/core/MemoryManager.ts ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MemoryManager; });
/* harmony import */ var _memory_Buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../memory/Buffer */ "./src/foundation/memory/Buffer.ts");
/* harmony import */ var _definitions_BufferUse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/BufferUse */ "./src/foundation/definitions/BufferUse.ts");
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Config */ "./src/foundation/core/Config.ts");



/**
 * Usage
 * const mm = MemoryManager.getInstance();
 * this.translate = new Vector3(
 *   mm.assignMem(componentUID, propertyId, entityUID, isRendered)
 * );
 */
class MemoryManager {
    constructor(cpuGeneric, gpuInstanceData, gpuVertexData) {
        //__entityMaxCount: number;
        this.__buffers = {};
        this.__buffersOnDemand = new Map();
        this.__memorySizeRatios = {};
        this.__memorySizeRatios[_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_1__["BufferUse"].CPUGeneric.str] = cpuGeneric;
        this.__memorySizeRatios[_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_1__["BufferUse"].GPUInstanceData.str] = gpuInstanceData;
        this.__memorySizeRatios[_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_1__["BufferUse"].GPUVertexData.str] = gpuVertexData;
    }
    static createInstanceIfNotCreated(cpuGeneric, gpuInstanceData, gpuVertexData) {
        if (!this.__instance) {
            this.__instance = new MemoryManager(cpuGeneric, gpuInstanceData, gpuVertexData);
            return this.__instance;
        }
        return this.__instance;
    }
    __makeMultipleOf4byteSize(memorySize) {
        return memorySize + ((memorySize % 4 === 0) ? 0 : 4 - memorySize % 4);
    }
    static getInstance() {
        return this.__instance;
    }
    __createBuffer(bufferUse) {
        let memorySize = MemoryManager.bufferWidthLength * MemoryManager.bufferHeightLength /*width*height*/ * 4 /*rgba*/ * 4 /*byte*/ * this.__memorySizeRatios[bufferUse.str];
        const arrayBuffer = new ArrayBuffer(this.__makeMultipleOf4byteSize(memorySize));
        const buffer = new _memory_Buffer__WEBPACK_IMPORTED_MODULE_0__["default"]({
            byteLength: arrayBuffer.byteLength,
            buffer: arrayBuffer,
            name: bufferUse.str
        });
        this.__buffers[buffer.name] = buffer;
        return buffer;
    }
    getBuffer(bufferUse) {
        let buffer = this.__buffers[bufferUse.toString()];
        return buffer;
    }
    createOrGetBuffer(bufferUse) {
        let buffer = this.__buffers[bufferUse.toString()];
        if (buffer == null) {
            buffer = this.__createBuffer(bufferUse);
        }
        return buffer;
    }
    createBufferOnDemand(size, object) {
        const arrayBuffer = new ArrayBuffer(size);
        const buffer = new _memory_Buffer__WEBPACK_IMPORTED_MODULE_0__["default"]({
            byteLength: arrayBuffer.byteLength,
            buffer: arrayBuffer,
            name: _definitions_BufferUse__WEBPACK_IMPORTED_MODULE_1__["BufferUse"].UBOGeneric.toString()
        });
        this.__buffersOnDemand.set(object.objectUID, buffer);
        return buffer;
    }
    getBufferOnDemand(object) {
        return this.__buffersOnDemand.get(object.objectUID);
    }
    static get bufferWidthLength() {
        return _Config__WEBPACK_IMPORTED_MODULE_2__["default"].dataTextureWidth;
    }
    static get bufferHeightLength() {
        return _Config__WEBPACK_IMPORTED_MODULE_2__["default"].dataTextureHeight;
    }
    printMemoryUsage() {
        const cpuGeneric = this.__buffers[_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_1__["BufferUse"].CPUGeneric.toString()];
        const gpuInstanceData = this.__buffers[_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_1__["BufferUse"].GPUInstanceData.toString()];
        const gpuVertexData = this.__buffers[_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_1__["BufferUse"].GPUVertexData.toString()];
        // const uboGeneric = this.__buffers[BufferUse.UBOGeneric.toString()];
        console.log(`Memory Usage in Memory Manager:`);
        console.log(`CPUGeneric: ${cpuGeneric.takenSizeInByte} byte of ${cpuGeneric.byteLength} bytes. (${cpuGeneric.takenSizeInByte / cpuGeneric.byteLength * 100} %) `);
        console.log(`GPUInstanceData: ${gpuInstanceData.takenSizeInByte} byte of ${gpuInstanceData.byteLength} bytes. (${gpuInstanceData.takenSizeInByte / gpuInstanceData.byteLength * 100} %) `);
        if (gpuVertexData != null) {
            console.log(`GPUVertexData: ${gpuVertexData.takenSizeInByte} byte of ${gpuVertexData.byteLength} bytes. (${gpuVertexData.takenSizeInByte / gpuVertexData.byteLength * 100} %) `);
        }
        // console.log(`UBOGeneric: ${uboGeneric.takenSizeInByte} byte of ${uboGeneric.byteLength} bytes. (${uboGeneric.takenSizeInByte / uboGeneric.byteLength * 100} %) `);
    }
}


/***/ }),

/***/ "./src/foundation/core/RnObject.ts":
/*!*****************************************!*\
  !*** ./src/foundation/core/RnObject.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RnObject; });
/**
 * The root class of the objects in Rhodonite
 */
class RnObject {
    constructor() {
        this.__objectUid = RnObject.InvalidObjectUID;
        this.__tags = {}; // Tag string allows alphabet, digit and underscore (_) only
        this.__combinedTagString = ''; // Tag string allows alphabet, digit and underscore (_) only
        this.__objectUid = RnObject.currentMaxObjectCount++;
        RnObject.__objects[this.__objectUid] = this;
        this.__uniqueName = 'entity_of_uid_' + this.__objectUid;
        RnObject.__uniqueNames[this.__objectUid] = this.__uniqueName;
        RnObject.__objectsByNameMap.set(this.__uniqueName, this);
    }
    searchByTag(tag, value) {
        for (let obj of RnObject.__objects) {
            if (obj.getTagValue(tag) === value) {
                return obj;
            }
        }
        return void 0;
    }
    /**
     * Gets the objectUID of the object.
     */
    get objectUID() {
        return this.__objectUid;
    }
    /**
     * Gets the object by corresponding to the objectUID.
     * @param objectUid The objectUID of the object.
     */
    static getRnObject(objectUid) {
        return RnObject.__objects[objectUid];
    }
    /**
     * Gets the object by the unique name.
     * @param uniqueName The unique name of the object.
     */
    static getRnObjectByName(uniqueName) {
        return RnObject.__objectsByNameMap.get(uniqueName);
    }
    /**
     * Try to set a unique name of the entity.
     * @param name
     * @param toAddNameIfConflict If true, force to add name string to the current unique name string. If false, give up to change name.
     */
    tryToSetUniqueName(name, toAddNameIfConflict) {
        if (RnObject.__uniqueNames.indexOf(name) !== -1) {
            // Conflict
            if (toAddNameIfConflict) {
                const newName = name + '_(' + this.__uniqueName + ')';
                if (RnObject.__uniqueNames.indexOf(newName) === -1) {
                    this.__uniqueName = newName;
                    RnObject.__uniqueNames[this.__objectUid] = this.__uniqueName;
                    RnObject.__objectsByNameMap.set(this.__uniqueName, this);
                    return true;
                }
            }
            return false;
        }
        else {
            this.__uniqueName = name;
            RnObject.__uniqueNames[this.__objectUid] = this.__uniqueName;
            RnObject.__objectsByNameMap.set(this.__uniqueName, this);
            return true;
        }
    }
    /**
     * Validate the string of tags.
     * @param val The string to be validated
     */
    validateTagString(val) {
        var reg = new RegExp(/[!"#$%&'()\*\+\-\s\.,\/:;<=>?@\[\\\]^`{|}~]/g);
        if (reg.test(val)) {
            return false;
        }
        return true;
    }
    /**
     * Tries to set tag (name and value).
     * @param tagName The tag name.
     * @param tagValue Tha value of the tag.
     */
    tryToSetTag(tag) {
        if (this.validateTagString(tag.tag)) {
            if (this.hasTag(tag.tag)) {
                this.removeTag(tag.tag);
            }
            this.__tags[tag.tag] = tag.value;
            this.__combinedTagString += `${tag.tag}:${tag.value}` + ' ';
            return true;
        }
        return false;
    }
    /**
     * Gets the value of the tag.
     * @param tagName The tag name.
     */
    getTagValue(tagName) {
        return this.__tags[tagName];
    }
    /**
     * Gets the tag object.
     * @param tagName The tag name.
     */
    getTag(tagName) {
        const tag = {
            tag: tagName,
            value: this.__tags[tagName]
        };
        return tag;
    }
    /**
     * Gets the boolean value whether this object has the tag or not.
     * @param tagName The tag name.
     */
    hasTag(tagName) {
        if (this.__tags[tagName] != null) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Remove the tag.
     * @param tagName The tag name.
     */
    removeTag(tagName) {
        const strToDelete = `${tagName}:${this.__tags[tagName]}` + ' ';
        this.__combinedTagString.replace(this.__combinedTagString, "");
        delete this.__tags[tagName];
    }
    /**
     * Confirms the matching of the tag name and tag value.
     * @param tagName The tag name.
     * @param tagValue The tag value.
     */
    matchTag(tagName, tagValue) {
        if (this.__tags[tagName] === tagValue) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Confirm that this object's tags includes given an array of string.
     * @param stringArray an array of string.
     */
    matchTagsAsFreeStrings(stringArray) {
        let regExpStr = '^';
        for (let i = 0; i < stringArray.length; i++) {
            regExpStr += `(?=.*${stringArray[i]})`;
        }
        var reg = new RegExp(regExpStr);
        if (reg.test(this.__combinedTagString)) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Confirm that this object's tags includes given set of tags.
     * @param tags The set of tags.
     */
    matchTags(tags) {
        let regExpStr = '^';
        for (let tagName in tags) {
            regExpStr += `(?=.*${[tagName]}:${tags[tagName]})`;
        }
        var reg = new RegExp(regExpStr);
        if (reg.test(this.__combinedTagString)) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Get the unique name of the entity.
     */
    get uniqueName() {
        return this.__uniqueName;
    }
    /**
     * @private
     */
    static _reset() {
        this.currentMaxObjectCount = 0;
        this.__uniqueNames = [];
        this.__objectsByNameMap = new Map();
        this.__objects = [];
    }
}
RnObject.InvalidObjectUID = -1;
RnObject.currentMaxObjectCount = 0;
RnObject.__uniqueNames = [];
RnObject.__objectsByNameMap = new Map();
RnObject.__objects = [];


/***/ }),

/***/ "./src/foundation/definitions/AlphaMode.ts":
/*!*************************************************!*\
  !*** ./src/foundation/definitions/AlphaMode.ts ***!
  \*************************************************/
/*! exports provided: AlphaMode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaMode", function() { return AlphaMode; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class AlphaModeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const Opaque = new AlphaModeClass({ index: 0, str: 'OPAQUE' });
const Mask = new AlphaModeClass({ index: 1, str: 'MASK' });
const Translucent = new AlphaModeClass({ index: 2, str: 'TRANSLUCENT' });
const Additive = new AlphaModeClass({ index: 3, str: 'ADDITIVE' });
const typeList = [Opaque, Mask, Translucent, Additive];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
function fromGlTFString(str) {
    if (str === 'BLEND') {
        return Translucent;
    }
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const AlphaMode = Object.freeze({ Opaque, Mask, Translucent, Additive, from, fromString, fromGlTFString });


/***/ }),

/***/ "./src/foundation/definitions/AnimationAttribute.ts":
/*!**********************************************************!*\
  !*** ./src/foundation/definitions/AnimationAttribute.ts ***!
  \**********************************************************/
/*! exports provided: AnimationAttribute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationAttribute", function() { return AnimationAttribute; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class AnimationAttributeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const Quaternion = new AnimationAttributeClass({ index: 0, str: 'Quaternion' });
const Translate = new AnimationAttributeClass({ index: 1, str: 'Translate' });
const Scale = new AnimationAttributeClass({ index: 2, str: 'Scale' });
const Weights = new AnimationAttributeClass({ index: 3, str: 'Weights' });
const typeList = [Quaternion, Translate, Scale, Weights];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const AnimationAttribute = Object.freeze({ Quaternion, Translate, Scale, Weights, from, fromString });


/***/ }),

/***/ "./src/foundation/definitions/AnimationInterpolation.ts":
/*!**************************************************************!*\
  !*** ./src/foundation/definitions/AnimationInterpolation.ts ***!
  \**************************************************************/
/*! exports provided: AnimationInterpolation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationInterpolation", function() { return AnimationInterpolation; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class AnimationInterpolationClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const Linear = new AnimationInterpolationClass({ index: 0, str: 'Linear' });
const Step = new AnimationInterpolationClass({ index: 1, str: 'Step' });
const CubicSpline = new AnimationInterpolationClass({ index: 2, str: 'CubicSpline' });
const typeList = [Linear, Step, CubicSpline];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const AnimationInterpolation = Object.freeze({ Linear, Step, CubicSpline, from, fromString });


/***/ }),

/***/ "./src/foundation/definitions/BasisCompressionType.ts":
/*!************************************************************!*\
  !*** ./src/foundation/definitions/BasisCompressionType.ts ***!
  \************************************************************/
/*! exports provided: BasisCompressionType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasisCompressionType", function() { return BasisCompressionType; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class BasisCompressionTypeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const ETC1 = new BasisCompressionTypeClass({ index: 0, str: 'ETC1' });
const ETC2 = new BasisCompressionTypeClass({ index: 1, str: 'ETC2' });
const BC1 = new BasisCompressionTypeClass({ index: 2, str: 'BC1' });
const BC3 = new BasisCompressionTypeClass({ index: 3, str: 'BC3' });
const BC4 = new BasisCompressionTypeClass({ index: 4, str: 'BC4' });
const BC5 = new BasisCompressionTypeClass({ index: 5, str: 'BC5' });
const BC7_M6_OPAQUE = new BasisCompressionTypeClass({ index: 6, str: 'BC7_M6_OPAQUE' });
const BC7_M5 = new BasisCompressionTypeClass({ index: 7, str: 'BC7_M5' });
const PVRTC1_RGB = new BasisCompressionTypeClass({ index: 8, str: 'PVRTC1_RGB' });
const PVRTC1_RGBA = new BasisCompressionTypeClass({ index: 9, str: 'PVRTC1_RGBA' });
const ASTC = new BasisCompressionTypeClass({ index: 10, str: 'ASTC' });
const ATC_RGB = new BasisCompressionTypeClass({ index: 11, str: 'ATC_RGB' });
const ATC_RGBA = new BasisCompressionTypeClass({ index: 12, str: 'ATC_RGBA' });
const RGBA32 = new BasisCompressionTypeClass({ index: 13, str: 'RGBA32' });
const RGB565 = new BasisCompressionTypeClass({ index: 14, str: 'RGB565' });
const BGR565 = new BasisCompressionTypeClass({ index: 15, str: 'BGR565' });
const RGBA4444 = new BasisCompressionTypeClass({ index: 16, str: 'RGBA4444' });
const typeList = [ETC1, ETC2, BC1, BC3, BC4, BC5, BC7_M5, BC7_M6_OPAQUE, PVRTC1_RGB, PVRTC1_RGBA, ASTC, ATC_RGB, ATC_RGBA, RGBA32, RGB565, BGR565, RGBA4444];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const BasisCompressionType = Object.freeze({ ETC1, ETC2, BC1, BC3, BC4, BC5, BC7_M5, BC7_M6_OPAQUE, PVRTC1_RGB, PVRTC1_RGBA, ASTC, ATC_RGB, ATC_RGBA, RGBA32, RGB565, BGR565, RGBA4444, from, fromString });


/***/ }),

/***/ "./src/foundation/definitions/BoneDataType.ts":
/*!****************************************************!*\
  !*** ./src/foundation/definitions/BoneDataType.ts ***!
  \****************************************************/
/*! exports provided: BoneDataType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoneDataType", function() { return BoneDataType; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class BoneDataTypeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const Mat4x4 = new BoneDataTypeClass({ index: 0, str: 'Mat4x4' });
const Vec4x2 = new BoneDataTypeClass({ index: 1, str: 'Vec4x2' });
const Vec4x1 = new BoneDataTypeClass({ index: 2, str: 'Vec4x1' });
const typeList = [Mat4x4, Vec4x2, Vec4x1];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const BoneDataType = Object.freeze({ Mat4x4, Vec4x2, Vec4x1, from, fromString });


/***/ }),

/***/ "./src/foundation/definitions/BufferUse.ts":
/*!*************************************************!*\
  !*** ./src/foundation/definitions/BufferUse.ts ***!
  \*************************************************/
/*! exports provided: BufferUse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferUse", function() { return BufferUse; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class BufferUseClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const GPUInstanceData = new BufferUseClass({ index: 0, str: 'GPUInstanceData' });
const GPUVertexData = new BufferUseClass({ index: 1, str: 'GPUVertexData' });
const UBOGeneric = new BufferUseClass({ index: 2, str: 'UBOGeneric' });
const CPUGeneric = new BufferUseClass({ index: 3, str: 'CPUGeneric' });
const typeList = [GPUInstanceData, GPUVertexData, UBOGeneric, CPUGeneric];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const BufferUse = Object.freeze({ GPUInstanceData, GPUVertexData, UBOGeneric, CPUGeneric, from, fromString });


/***/ }),

/***/ "./src/foundation/definitions/CameraControllerType.ts":
/*!************************************************************!*\
  !*** ./src/foundation/definitions/CameraControllerType.ts ***!
  \************************************************************/
/*! exports provided: CameraControllerType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraControllerType", function() { return CameraControllerType; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class CameraControllerTypeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const Orbit = new CameraControllerTypeClass({ index: 0, str: 'Orbit' });
const WalkThrough = new CameraControllerTypeClass({ index: 1, str: 'WalkThrough' });
const typeList = [Orbit, WalkThrough];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const CameraControllerType = Object.freeze({ Orbit, WalkThrough, from, fromString });


/***/ }),

/***/ "./src/foundation/definitions/CameraType.ts":
/*!**************************************************!*\
  !*** ./src/foundation/definitions/CameraType.ts ***!
  \**************************************************/
/*! exports provided: CameraType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraType", function() { return CameraType; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class CameraTypeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const Perspective = new CameraTypeClass({ index: 0, str: 'Perspective' });
const Orthographic = new CameraTypeClass({ index: 1, str: 'Orthographic' });
const Frustom = new CameraTypeClass({ index: 2, str: 'Frustom' });
const typeList = [Perspective, Orthographic, Frustom];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const CameraType = Object.freeze({ Perspective, Orthographic, Frustom, from, fromString });


/***/ }),

/***/ "./src/foundation/definitions/ComponentType.ts":
/*!*****************************************************!*\
  !*** ./src/foundation/definitions/ComponentType.ts ***!
  \*****************************************************/
/*! exports provided: ComponentType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComponentType", function() { return ComponentType; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class ComponentTypeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str, sizeInBytes }) {
        super({ index, str });
        this.__sizeInBytes = sizeInBytes;
    }
    getSizeInBytes() {
        return this.__sizeInBytes;
    }
    isFloatingPoint() {
        if (this.index === 5126 // Float
            || this.index === 5127 // Double
            || this.index === 0x8D61 // HalfFloat
        ) {
            return true;
        }
        return false;
    }
    isInteger() {
        if (this.index === 5120 // Byte
            || this.index === 5121 // UnsignedByte
            || this.index === 5122 // Short
            || this.index === 5123 // UnsignedShort
            || this.index === 5124 // Int
            || this.index === 5125 // UnsignedInt
        ) {
            return true;
        }
        return false;
    }
}
const Unknown = new ComponentTypeClass({ index: 5119, str: 'UNKNOWN', sizeInBytes: 0 });
const Byte = new ComponentTypeClass({ index: 5120, str: 'BYTE', sizeInBytes: 1 });
const UnsignedByte = new ComponentTypeClass({ index: 5121, str: 'UNSIGNED_BYTE', sizeInBytes: 1 });
const Short = new ComponentTypeClass({ index: 5122, str: 'SHORT', sizeInBytes: 2 });
const UnsignedShort = new ComponentTypeClass({ index: 5123, str: 'UNSIGNED_SHORT', sizeInBytes: 2 });
const Int = new ComponentTypeClass({ index: 5124, str: 'INT', sizeInBytes: 4 });
const UnsignedInt = new ComponentTypeClass({ index: 5125, str: 'UNSIGNED_INT', sizeInBytes: 4 });
const Float = new ComponentTypeClass({ index: 5126, str: 'FLOAT', sizeInBytes: 4 });
const Double = new ComponentTypeClass({ index: 5127, str: 'DOUBLE', sizeInBytes: 8 });
const Bool = new ComponentTypeClass({ index: 35670, str: 'BOOL', sizeInBytes: 1 });
const HalfFloat = new ComponentTypeClass({ index: 0x8D61, str: 'HALF_FLOAT_OES', sizeInBytes: 2 });
const typeList = [Unknown, Byte, UnsignedByte, Short, UnsignedShort, Int, UnsignedInt, Float, Double, HalfFloat];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
function fromTypedArray(typedArray) {
    if (typedArray instanceof Int8Array) {
        return Byte;
    }
    else if (typedArray instanceof Uint8Array || typedArray instanceof Uint8ClampedArray) {
        return UnsignedByte;
    }
    else if (typedArray instanceof Int16Array) {
        return Short;
    }
    else if (typedArray instanceof Uint16Array) {
        return UnsignedShort;
    }
    else if (typedArray instanceof Int32Array) {
        return Int;
    }
    else if (typedArray instanceof Uint32Array) {
        return UnsignedInt;
    }
    else if (typedArray instanceof Float32Array) {
        return Float;
    }
    else if (typedArray instanceof Float64Array) {
        return Double;
    }
    return Unknown;
}
function fromGlslString(str_) {
    let str = str_;
    switch (str_) {
        case 'int':
            str = 'INT';
            break;
        case 'float':
            str = 'FLOAT';
            break;
        case 'vec2':
            str = 'FLOAT';
            break;
        case 'vec3':
            str = 'FLOAT';
            break;
        case 'vec4':
            str = 'FLOAT';
            break;
        case 'mat2':
            str = 'FLOAT';
            break;
        case 'mat3':
            str = 'FLOAT';
            break;
        case 'mat4':
            str = 'FLOAT';
            break;
        case 'ivec2':
            str = 'INT';
            break;
        case 'ivec3':
            str = 'INT';
            break;
        case 'ivec4':
            str = 'INT';
            break;
        case 'sampler2D':
            str = 'INT';
            break;
        case 'sampler3D':
            str = 'INT';
            break;
        case 'samplerCube':
            str = 'INT';
            break;
    }
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const ComponentType = Object.freeze({ Unknown, Byte, UnsignedByte, Short, UnsignedShort, Int, UnsignedInt: UnsignedInt, Float, Double, Bool, HalfFloat, from, fromTypedArray, fromString, fromGlslString });


/***/ }),

/***/ "./src/foundation/definitions/CompositionType.ts":
/*!*******************************************************!*\
  !*** ./src/foundation/definitions/CompositionType.ts ***!
  \*******************************************************/
/*! exports provided: CompositionType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompositionType", function() { return CompositionType; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");
/* harmony import */ var _ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComponentType */ "./src/foundation/definitions/ComponentType.ts");


class CompositionTypeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str, glslStr, hlslStr, numberOfComponents }) {
        super({ index, str });
        this.__numberOfComponents = 0;
        this.__numberOfComponents = numberOfComponents;
        this.__glslStr = glslStr;
        this.__hlslStr = hlslStr;
    }
    getNumberOfComponents() {
        return this.__numberOfComponents;
    }
    getGlslStr(componentType) {
        if (componentType === _ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float || componentType === _ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Double || this === CompositionType.Texture2D || this === CompositionType.TextureCube) {
            return this.__glslStr;
        }
        else if (componentType === _ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Byte || componentType === _ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Short || componentType === _ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Int) {
            if (this === CompositionType.Scalar) {
                return 'int';
            }
            else {
                return 'i' + this.__glslStr;
            }
        }
        else if (componentType === _ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Bool) {
            return 'bool';
        }
        return 'unknown';
    }
    getGlslInitialValue(componentType) {
        if (componentType === _ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float || componentType === _ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Double) {
            if (this === CompositionType.Scalar) {
                return '0.0';
            }
            else {
                if (this.__numberOfComponents === 2) {
                    return this.__glslStr + '(0.0, 0.0)';
                }
                else if (this.__numberOfComponents === 3) {
                    return this.__glslStr + '(0.0, 0.0, 0.0)';
                }
                else if (this.__numberOfComponents === 4) {
                    return this.__glslStr + '(0.0, 0.0, 0.0, 0.0)';
                }
                else if (this.__numberOfComponents === 9) {
                    return this.__glslStr + '(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)';
                }
                else if (this.__numberOfComponents === 16) {
                    return this.__glslStr + '(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)';
                }
            }
        }
        else if (componentType === _ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Byte || componentType === _ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Short || componentType === _ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Int) {
            if (this === CompositionType.Scalar) {
                return '0';
            }
            else {
                if (this.__numberOfComponents === 2) {
                    return this.__glslStr + '(0, 0)';
                }
                else if (this.__numberOfComponents === 3) {
                    return this.__glslStr + '(0, 0, 0)';
                }
                else if (this.__numberOfComponents === 4) {
                    return this.__glslStr + '(0, 0, 0, 0)';
                }
                else if (this.__numberOfComponents === 9) {
                    return this.__glslStr + '(0, 0, 0, 0, 0, 0, 0, 0, 0)';
                }
                else if (this.__numberOfComponents === 16) {
                    return this.__glslStr + '(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)';
                }
            }
        }
        else if (componentType === _ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Bool) {
            if (this === CompositionType.Scalar) {
                return 'false';
            }
            else {
                if (this.__numberOfComponents === 2) {
                    return this.__glslStr + '(false, false)';
                }
                else if (this.__numberOfComponents === 3) {
                    return this.__glslStr + '(false, false, false)';
                }
                else if (this.__numberOfComponents === 4) {
                    return this.__glslStr + '(false, false, false, false)';
                }
            }
        }
        return 'unknown';
    }
}
const Unknown = new CompositionTypeClass({ index: -1, str: 'UNKNOWN', glslStr: 'unknown', hlslStr: 'unknown', numberOfComponents: 0 });
const Scalar = new CompositionTypeClass({ index: 0, str: 'SCALAR', glslStr: 'float', hlslStr: 'float', numberOfComponents: 1 });
const Vec2 = new CompositionTypeClass({ index: 1, str: 'VEC2', glslStr: 'vec2', hlslStr: 'float2', numberOfComponents: 2 });
const Vec3 = new CompositionTypeClass({ index: 2, str: 'VEC3', glslStr: 'vec3', hlslStr: 'float3', numberOfComponents: 3 });
const Vec4 = new CompositionTypeClass({ index: 3, str: 'VEC4', glslStr: 'vec4', hlslStr: 'float4', numberOfComponents: 4 });
const Mat2 = new CompositionTypeClass({ index: 4, str: 'MAT2', glslStr: 'mat2', hlslStr: 'float2x2', numberOfComponents: 4 });
const Mat3 = new CompositionTypeClass({ index: 5, str: 'MAT3', glslStr: 'mat3', hlslStr: 'float3x3', numberOfComponents: 9 });
const Mat4 = new CompositionTypeClass({ index: 6, str: 'MAT4', glslStr: 'mat4', hlslStr: 'float4x4', numberOfComponents: 16 });
const Texture2D = new CompositionTypeClass({ index: 7, str: 'TEXTURE_2D', glslStr: 'sampler2D', hlslStr: 'Texture2D', numberOfComponents: 1 });
const TextureCube = new CompositionTypeClass({ index: 8, str: 'TEXTURE_CUBE_MAP', glslStr: 'samplerCube', hlslStr: 'TextureCube', numberOfComponents: 1 });
const ScalarArray = new CompositionTypeClass({ index: 9, str: 'SCALAR_ARRAY', glslStr: 'float', hlslStr: 'float', numberOfComponents: 1 });
const Vec2Array = new CompositionTypeClass({ index: 10, str: 'VEC2_ARRAY', glslStr: 'vec2', hlslStr: 'float2', numberOfComponents: 2 });
const Vec3Array = new CompositionTypeClass({ index: 11, str: 'VEC3_ARRAY', glslStr: 'vec3', hlslStr: 'float3', numberOfComponents: 3 });
const Vec4Array = new CompositionTypeClass({ index: 12, str: 'VEC4_ARRAY', glslStr: 'vec4', hlslStr: 'float4', numberOfComponents: 4 });
const Mat4Array = new CompositionTypeClass({ index: 13, str: 'MAT4_ARRAY', glslStr: 'mat4', hlslStr: 'float4x4', numberOfComponents: 16 });
const typeList = [Unknown, Scalar, Vec2, Vec3, Vec4, Mat2, Mat3, Mat4, Texture2D, TextureCube, ScalarArray, Vec2Array, Vec3Array, Vec4Array];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
function fromGlslString(str_) {
    let str = str_;
    switch (str_) {
        case 'int':
            str = 'scalar';
            break;
        case 'float':
            str = 'scalar';
            break;
        case 'ivec2':
            str = 'vec2';
            break;
        case 'ivec3':
            str = 'vec3';
            break;
        case 'ivec4':
            str = 'vec4';
            break;
        case 'sampler2D':
            str = 'TEXTURE_2D';
            break;
        case 'samplerCube':
            str = 'TEXTURE_CUBE_MAP';
            break;
    }
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
function isArray(compositionType) {
    if (compositionType === ScalarArray || compositionType === Vec2Array || compositionType === Vec3Array || compositionType === Vec4Array || compositionType === Mat4Array) {
        return true;
    }
    else {
        return false;
    }
}
const CompositionType = Object.freeze({ Unknown, Scalar, Vec2, Vec3, Vec4, Mat2, Mat3, Mat4, Texture2D, TextureCube, ScalarArray, Vec2Array, Vec3Array, Vec4Array, Mat4Array, from, fromString, fromGlslString, isArray });


/***/ }),

/***/ "./src/foundation/definitions/HdriFormat.ts":
/*!**************************************************!*\
  !*** ./src/foundation/definitions/HdriFormat.ts ***!
  \**************************************************/
/*! exports provided: HdriFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HdriFormat", function() { return HdriFormat; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class HdriFormatClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const LDR_SRGB = new HdriFormatClass({ index: 0, str: '.ldr_srgb' });
const LDR_LINEAR = new HdriFormatClass({ index: 1, str: '.ldr_linear' });
const HDR_LINEAR = new HdriFormatClass({ index: 2, str: '.hdr' });
const RGBE_PNG = new HdriFormatClass({ index: 3, str: '.rgbe.png' });
const RGB9_E5_PNG = new HdriFormatClass({ index: 4, str: '.rgb9_e5.png' });
const OpenEXR = new HdriFormatClass({ index: 5, str: '.exr' });
const typeList = [LDR_SRGB, LDR_LINEAR, HDR_LINEAR, RGBE_PNG, RGB9_E5_PNG, OpenEXR];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
const HdriFormat = Object.freeze({ LDR_SRGB, LDR_LINEAR, HDR_LINEAR, RGBE_PNG, RGB9_E5_PNG, OpenEXR });


/***/ }),

/***/ "./src/foundation/definitions/LightType.ts":
/*!*************************************************!*\
  !*** ./src/foundation/definitions/LightType.ts ***!
  \*************************************************/
/*! exports provided: LightType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightType", function() { return LightType; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class LightTypeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const Directional = new LightTypeClass({ index: 0, str: 'Directional' });
const Point = new LightTypeClass({ index: 1, str: 'Point' });
const Spot = new LightTypeClass({ index: 2, str: 'Spot' });
const Ambient = new LightTypeClass({ index: 3, str: 'Ambient' });
const typeList = [Point, Directional, Spot, Ambient];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const LightType = Object.freeze({ Point, Directional, Spot, Ambient, from, fromString });


/***/ }),

/***/ "./src/foundation/definitions/PixelFormat.ts":
/*!***************************************************!*\
  !*** ./src/foundation/definitions/PixelFormat.ts ***!
  \***************************************************/
/*! exports provided: PixelFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PixelFormat", function() { return PixelFormat; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class PixelFormatClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const DepthComponent = new PixelFormatClass({ index: 0x1902, str: 'DEPTH_COMPONENT' });
const Alpha = new PixelFormatClass({ index: 0x1906, str: 'ALPHA' });
const RGB = new PixelFormatClass({ index: 0x1907, str: 'RGB' });
const RGBA = new PixelFormatClass({ index: 0x1908, str: 'RGBA' });
const Luminance = new PixelFormatClass({ index: 0x1909, str: 'LUMINANCE' });
const LuminanceAlpha = new PixelFormatClass({ index: 0x190A, str: 'LUMINANCE_ALPHA' });
const typeList = [DepthComponent, Alpha, RGB, RGBA, Luminance, LuminanceAlpha];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
const PixelFormat = Object.freeze({ DepthComponent, Alpha, RGB, RGBA, Luminance, LuminanceAlpha });


/***/ }),

/***/ "./src/foundation/definitions/PrimitiveMode.ts":
/*!*****************************************************!*\
  !*** ./src/foundation/definitions/PrimitiveMode.ts ***!
  \*****************************************************/
/*! exports provided: PrimitiveMode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PrimitiveMode", function() { return PrimitiveMode; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class PrimitiveModeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const Unknown = new PrimitiveModeClass({ index: -1, str: 'UNKNOWN' });
const Points = new PrimitiveModeClass({ index: 0, str: 'POINTS' });
const Lines = new PrimitiveModeClass({ index: 1, str: 'LINES' });
const LineLoop = new PrimitiveModeClass({ index: 2, str: 'LINE_LOOP' });
const LineStrip = new PrimitiveModeClass({ index: 3, str: 'LINE_STRIP' });
const Triangles = new PrimitiveModeClass({ index: 4, str: 'TRIANGLES' });
const TriangleStrip = new PrimitiveModeClass({ index: 5, str: 'TRIANGLE_STRIP' });
const TriangleFan = new PrimitiveModeClass({ index: 6, str: 'TRIANGLE_FAN' });
const typeList = [Unknown, Points, Lines, LineLoop, LineStrip, Triangles, TriangleStrip, TriangleFan];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
const PrimitiveMode = Object.freeze({ Unknown, Points, Lines, LineLoop, LineStrip, Triangles, TriangleStrip, TriangleFan, from });


/***/ }),

/***/ "./src/foundation/definitions/ProcessApproach.ts":
/*!*******************************************************!*\
  !*** ./src/foundation/definitions/ProcessApproach.ts ***!
  \*******************************************************/
/*! exports provided: ProcessApproach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProcessApproach", function() { return ProcessApproach; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class ProcessApproachClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const None = new ProcessApproachClass({ index: 0, str: 'NONE' });
const UniformWebGL1 = new ProcessApproachClass({ index: 1, str: 'UNIFORM_WEBGL1' });
const UniformWebGL2 = new ProcessApproachClass({ index: 2, str: 'UNIFORM_WEBGL2' });
const DataTextureWebGL1 = new ProcessApproachClass({ index: 3, str: 'DATA_TEXTURE_WEBGL1' });
const DataTextureWebGL2 = new ProcessApproachClass({ index: 4, str: 'DATA_TEXTURE_WEBGL2' });
const UBOWebGL2 = new ProcessApproachClass({ index: 5, str: 'UBO_WEBGL2' });
const TransformFeedbackWebGL2 = new ProcessApproachClass({ index: 6, str: 'TRANSFORM_FEEDBACK_WEBGL2' });
const FastestWebGL1 = new ProcessApproachClass({ index: 7, str: 'FASTEST_WEBGL1' });
const typeList = [None, UniformWebGL1, UniformWebGL2, DataTextureWebGL1, DataTextureWebGL2, UBOWebGL2, TransformFeedbackWebGL2, FastestWebGL1];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
const ProcessApproach = Object.freeze({ None, UniformWebGL1, UniformWebGL2, DataTextureWebGL1, DataTextureWebGL2, UBOWebGL2, TransformFeedbackWebGL2, FastestWebGL1 });


/***/ }),

/***/ "./src/foundation/definitions/ProcessStage.ts":
/*!****************************************************!*\
  !*** ./src/foundation/definitions/ProcessStage.ts ***!
  \****************************************************/
/*! exports provided: ProcessStage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProcessStage", function() { return ProcessStage; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class ProcessStageClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str, methodName }) {
        super({ index, str });
        this.methodName = methodName;
    }
}
const Unknown = new ProcessStageClass({ index: -1, str: 'UNKNOWN', methodName: '$unknown' });
const Create = new ProcessStageClass({ index: 0, str: 'CREATE', methodName: '$create' });
const Load = new ProcessStageClass({ index: 1, str: 'LOAD', methodName: '$load' });
const Mount = new ProcessStageClass({ index: 2, str: 'MOUNT', methodName: '$mount' });
const Logic = new ProcessStageClass({ index: 3, str: 'LOGIC', methodName: '$logic' });
const PreRender = new ProcessStageClass({ index: 4, str: 'PRE_RENDER', methodName: '$prerender' });
const Render = new ProcessStageClass({ index: 5, str: 'RENDER', methodName: '$render' });
const Unmount = new ProcessStageClass({ index: 6, str: 'UNMOUNT', methodName: '$unmount' });
const Discard = new ProcessStageClass({ index: 7, str: 'DISCARD', methodName: '$discard' });
const typeList = [Unknown, Create, Load, Mount, Logic, PreRender, Render, Unmount, Discard];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
const ProcessStage = Object.freeze({ Unknown, Create, Load, Mount, Logic, PreRender, Render, Unmount, Discard, from });


/***/ }),

/***/ "./src/foundation/definitions/RenderBufferTarget.ts":
/*!**********************************************************!*\
  !*** ./src/foundation/definitions/RenderBufferTarget.ts ***!
  \**********************************************************/
/*! exports provided: RenderBufferTarget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderBufferTarget", function() { return RenderBufferTarget; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class RenderBufferTargetClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const None = new RenderBufferTargetClass({ index: -2, str: 'NONE' });
const Back = new RenderBufferTargetClass({ index: -1, str: 'BACK' });
const ColorAttachment0 = new RenderBufferTargetClass({ index: 0, str: 'COLOR_ATTACHMENT0' });
const ColorAttachment1 = new RenderBufferTargetClass({ index: 1, str: 'COLOR_ATTACHMENT1' });
const ColorAttachment2 = new RenderBufferTargetClass({ index: 2, str: 'COLOR_ATTACHMENT2' });
const ColorAttachment3 = new RenderBufferTargetClass({ index: 3, str: 'COLOR_ATTACHMENT3' });
const ColorAttachment4 = new RenderBufferTargetClass({ index: 4, str: 'COLOR_ATTACHMENT4' });
const ColorAttachment5 = new RenderBufferTargetClass({ index: 5, str: 'COLOR_ATTACHMENT5' });
const ColorAttachment6 = new RenderBufferTargetClass({ index: 6, str: 'COLOR_ATTACHMENT6' });
const ColorAttachment7 = new RenderBufferTargetClass({ index: 7, str: 'COLOR_ATTACHMENT7' });
const ColorAttachment8 = new RenderBufferTargetClass({ index: 8, str: 'COLOR_ATTACHMENT8' });
const ColorAttachment9 = new RenderBufferTargetClass({ index: 9, str: 'COLOR_ATTACHMENT9' });
const ColorAttachment10 = new RenderBufferTargetClass({ index: 10, str: 'COLOR_ATTACHMENT10' });
const ColorAttachment11 = new RenderBufferTargetClass({ index: 11, str: 'COLOR_ATTACHMENT11' });
const ColorAttachment12 = new RenderBufferTargetClass({ index: 12, str: 'COLOR_ATTACHMENT12' });
const ColorAttachment13 = new RenderBufferTargetClass({ index: 13, str: 'COLOR_ATTACHMENT13' });
const ColorAttachment14 = new RenderBufferTargetClass({ index: 14, str: 'COLOR_ATTACHMENT14' });
const ColorAttachment15 = new RenderBufferTargetClass({ index: 15, str: 'COLOR_ATTACHMENT15' });
const typeList = [None, Back, ColorAttachment0, ColorAttachment1, ColorAttachment2, ColorAttachment3, ColorAttachment4,
    ColorAttachment5, ColorAttachment6, ColorAttachment7, ColorAttachment8, ColorAttachment9, ColorAttachment10,
    ColorAttachment11, ColorAttachment12, ColorAttachment13, ColorAttachment14, ColorAttachment15];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
const RenderBufferTarget = Object.freeze({ None, Back, ColorAttachment0, ColorAttachment1, ColorAttachment2, ColorAttachment3, ColorAttachment4,
    ColorAttachment5, ColorAttachment6, ColorAttachment7, ColorAttachment8, ColorAttachment9, ColorAttachment10,
    ColorAttachment11, ColorAttachment12, ColorAttachment13, ColorAttachment14, ColorAttachment15, from });


/***/ }),

/***/ "./src/foundation/definitions/ShaderNode.ts":
/*!**************************************************!*\
  !*** ./src/foundation/definitions/ShaderNode.ts ***!
  \**************************************************/
/*! exports provided: ShaderNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderNode", function() { return ShaderNode; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class ShaderNodeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const ClassicShading = new ShaderNodeClass({ index: 0, str: 'ClassicShading' });
const PBRShading = new ShaderNodeClass({ index: 1, str: 'PBRShading' });
const Lerp = new ShaderNodeClass({ index: 2, str: 'Lerp' });
const Add = new ShaderNodeClass({ index: 3, str: 'Add' });
const typeList = [ClassicShading, PBRShading];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const ShaderNode = Object.freeze({ ClassicShading, PBRShading, from, fromString });


/***/ }),

/***/ "./src/foundation/definitions/ShaderSemantics.ts":
/*!*******************************************************!*\
  !*** ./src/foundation/definitions/ShaderSemantics.ts ***!
  \*******************************************************/
/*! exports provided: ShaderSemanticsClass, ShaderSemantics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderSemanticsClass", function() { return ShaderSemanticsClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderSemantics", function() { return ShaderSemantics; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");
/* harmony import */ var _CompositionType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CompositionType */ "./src/foundation/definitions/CompositionType.ts");


class ShaderSemanticsClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ str }) {
        super({ index: ++ShaderSemanticsClass.__indexCount * ShaderSemanticsClass._scale, str, noCheckStrUnique: true });
        ShaderSemanticsClass.__classes[this.index] = this;
    }
    static getShaderSemanticByIndex(index) {
        return this.__classes[Math.abs(index) - Math.abs(index) % this._scale];
    }
    static isNonArrayShaderSemanticIndex(index) {
        if (index >= this._scale) {
            return true;
        }
        else {
            return false;
        }
    }
    static isArrayAndZeroIndexShaderSemanticIndex(index) {
        if (index < 0 && Math.abs(index) % ShaderSemanticsClass._scale === 0) {
            return true;
        }
        else {
            return false;
        }
    }
    static isArrayAndNonZeroIndexShaderSemanticIndex(index) {
        if (index < 0 && Math.abs(index) % ShaderSemanticsClass._scale !== 0) {
            return true;
        }
        else {
            return false;
        }
    }
}
ShaderSemanticsClass.__indexCount = -1;
ShaderSemanticsClass._scale = 10000;
ShaderSemanticsClass.__classes = [];
const WorldMatrix = new ShaderSemanticsClass({ str: 'worldMatrix' });
const ViewMatrix = new ShaderSemanticsClass({ str: 'viewMatrix' });
const ProjectionMatrix = new ShaderSemanticsClass({ str: 'projectionMatrix' });
const NormalMatrix = new ShaderSemanticsClass({ str: 'normalMatrix' });
const BoneMatrix = new ShaderSemanticsClass({ str: 'boneMatrix' });
const BaseColorFactor = new ShaderSemanticsClass({ str: 'baseColorFactor' });
const BaseColorTexture = new ShaderSemanticsClass({ str: 'baseColorTexture' });
const NormalTexture = new ShaderSemanticsClass({ str: 'normalTexture' });
const MetallicRoughnessTexture = new ShaderSemanticsClass({ str: 'metallicRoughnessTexture' });
const OcclusionTexture = new ShaderSemanticsClass({ str: 'occlusionTexture' });
const EmissiveTexture = new ShaderSemanticsClass({ str: 'emissiveTexture' });
const LightNumber = new ShaderSemanticsClass({ str: 'lightNumber' });
const LightPosition = new ShaderSemanticsClass({ str: 'lightPosition' });
const LightDirection = new ShaderSemanticsClass({ str: 'lightDirection' });
const LightIntensity = new ShaderSemanticsClass({ str: 'lightIntensity' });
const MetallicRoughnessFactor = new ShaderSemanticsClass({ str: 'metallicRoughnessFactor' });
const BrdfLutTexture = new ShaderSemanticsClass({ str: 'brdfLutTexture' });
const DiffuseEnvTexture = new ShaderSemanticsClass({ str: 'diffuseEnvTexture' });
const SpecularEnvTexture = new ShaderSemanticsClass({ str: 'specularEnvTexture' });
const IBLParameter = new ShaderSemanticsClass({ str: 'iblParameter' });
const ViewPosition = new ShaderSemanticsClass({ str: 'viewPosition' });
const Wireframe = new ShaderSemanticsClass({ str: 'wireframe' });
const DiffuseColorFactor = new ShaderSemanticsClass({ str: 'diffuseColorFactor' });
const DiffuseColorTexture = new ShaderSemanticsClass({ str: 'diffuseColorTexture' });
const SpecularColorFactor = new ShaderSemanticsClass({ str: 'specularColorFactor' });
const SpecularColorTexture = new ShaderSemanticsClass({ str: 'specularColorTexture' });
const Shininess = new ShaderSemanticsClass({ str: 'shininess' });
const ShadingModel = new ShaderSemanticsClass({ str: 'shadingModel' });
const SkinningMode = new ShaderSemanticsClass({ str: 'skinningMode' });
const GeneralTexture = new ShaderSemanticsClass({ str: 'generalTexture' });
const VertexAttributesExistenceArray = new ShaderSemanticsClass({ str: 'vertexAttributesExistenceArray' });
const BoneQuaternion = new ShaderSemanticsClass({ str: 'boneQuaternion' });
const BoneTranslateScale = new ShaderSemanticsClass({ str: 'boneTranslateScale' });
const BoneCompressedChunk = new ShaderSemanticsClass({ str: 'boneCompressedChunk' });
const BoneCompressedInfo = new ShaderSemanticsClass({ str: 'boneCompressedInfo' });
const PointSize = new ShaderSemanticsClass({ str: 'pointSize' });
const ColorEnvTexture = new ShaderSemanticsClass({ str: 'colorEnvTexture' });
const PointDistanceAttenuation = new ShaderSemanticsClass({ str: 'pointDistanceAttenuation' });
const HDRIFormat = new ShaderSemanticsClass({ str: 'hdriFormat' });
const ScreenInfo = new ShaderSemanticsClass({ str: 'screenInfo' });
const DepthTexture = new ShaderSemanticsClass({ str: 'depthTexture' });
const LightViewProjectionMatrix = new ShaderSemanticsClass({ str: 'lightViewProjectionMatrix' });
const Anisotropy = new ShaderSemanticsClass({ str: 'anisotropy' });
const ClearCoatParameter = new ShaderSemanticsClass({ str: 'clearcoatParameter' });
const SheenParameter = new ShaderSemanticsClass({ str: 'sheenParameter' });
const SpecularGlossinessFactor = new ShaderSemanticsClass({ str: 'specularGlossinessFactor' });
const SpecularGlossinessTexture = new ShaderSemanticsClass({ str: 'specularGlossinessTexture' });
const EntityUID = new ShaderSemanticsClass({ str: 'entityUID' });
const MorphTargetNumber = new ShaderSemanticsClass({ str: 'morphTargetNumber' });
const DataTextureMorphOffsetPosition = new ShaderSemanticsClass({ str: 'dataTextureMorphOffsetPosition' });
const MorphWeights = new ShaderSemanticsClass({ str: 'morphWeights' });
const CurrentComponentSIDs = new ShaderSemanticsClass({ str: 'currentComponentSIDs' });
const AlphaCutoff = new ShaderSemanticsClass({ str: 'alphaCutoff' });
const AlphaTexture = new ShaderSemanticsClass({ str: 'alphaTexture' });
const typeList = [WorldMatrix, ViewMatrix, ProjectionMatrix, NormalMatrix, BoneMatrix, BaseColorFactor, BaseColorTexture,
    NormalTexture, MetallicRoughnessTexture, OcclusionTexture, EmissiveTexture, LightNumber, LightPosition, LightDirection, LightIntensity,
    MetallicRoughnessFactor, BrdfLutTexture, DiffuseEnvTexture, SpecularEnvTexture, IBLParameter, ViewPosition, Wireframe,
    DiffuseColorFactor, DiffuseColorTexture, SpecularColorFactor, SpecularColorTexture, Shininess, ShadingModel, SkinningMode, GeneralTexture,
    VertexAttributesExistenceArray, BoneQuaternion, BoneTranslateScale, BoneCompressedChunk, BoneCompressedInfo, PointSize, ColorEnvTexture, PointDistanceAttenuation, HDRIFormat,
    ScreenInfo, DepthTexture, LightViewProjectionMatrix, Anisotropy, ClearCoatParameter, SheenParameter, SpecularGlossinessFactor, SpecularGlossinessTexture,
    EntityUID, MorphTargetNumber, DataTextureMorphOffsetPosition, MorphWeights, CurrentComponentSIDs, AlphaCutoff, AlphaTexture];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
function fromStringCaseSensitively(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromStringCaseSensitively"])({ typeList, str });
}
function fullSemanticStr(info) {
    let prefix = '';
    if (info.prefix != null) {
        prefix = info.prefix;
    }
    return prefix + info.semantic.str;
}
const getShaderProperty = (materialTypeName, info, propertyIndex, isGlobalData, isWebGL2) => {
    if (info.isComponentData) {
        return '';
    }
    const returnType = info.compositionType.getGlslStr(info.componentType);
    let variableName = ShaderSemantics.fullSemanticStr(info);
    // definition of uniform variable
    const varType = info.compositionType.getGlslStr(info.componentType);
    let varIndexStr = '';
    if (info.maxIndex) {
        varIndexStr = `[${info.maxIndex}]`;
    }
    let varDef = `  uniform ${varType} u_${variableName}${varIndexStr};\n`;
    // inner contents of 'get_' shader function
    let str = '';
    if (propertyIndex < 0 || _CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].isArray(info.compositionType)) {
        if (Math.abs(propertyIndex) % ShaderSemanticsClass._scale !== 0 && !_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].isArray(info.compositionType)) {
            return '';
        }
        if (variableName.match(/\[.+?\]/)) {
            variableName = variableName.replace(/\[.+?\]/g, `[i]`);
        }
        else {
            variableName += '[i]';
        }
        if (isWebGL2) {
            str += `
        ${returnType} val;
          int i = index;
          return u_${variableName};
        `;
        }
        else {
            str += `
        ${returnType} val;
        for (int i=0; i<${info.maxIndex}; i++) {
          if (i == index) {
            val = u_${variableName};
            break;
          }
        }
        return val;
        `;
        }
    }
    else {
        str += `return u_${variableName};`;
    }
    let funcDef = '';
    const isTexture = info.compositionType === _CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Texture2D || info.compositionType === _CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].TextureCube;
    if (!isTexture) {
        funcDef = `
  ${returnType} get_${info.semantic.str}(float instanceId, int index) {
    ${str}
  }
`;
    }
    return `${varDef}${funcDef}`;
};
const ShaderSemantics = Object.freeze({
    from, fromString, fromStringCaseSensitively,
    WorldMatrix, ViewMatrix, ProjectionMatrix, NormalMatrix, BoneMatrix, BaseColorFactor, BaseColorTexture,
    NormalTexture, MetallicRoughnessTexture, OcclusionTexture, EmissiveTexture, LightNumber, LightPosition, LightDirection, LightIntensity,
    MetallicRoughnessFactor, BrdfLutTexture, DiffuseEnvTexture, SpecularEnvTexture, IBLParameter, ViewPosition, Wireframe,
    DiffuseColorFactor, DiffuseColorTexture, SpecularColorFactor, SpecularColorTexture, Shininess, ShadingModel, SkinningMode, GeneralTexture,
    VertexAttributesExistenceArray, BoneQuaternion, BoneTranslateScale, BoneCompressedChunk, BoneCompressedInfo, PointSize, ColorEnvTexture, PointDistanceAttenuation,
    HDRIFormat, ScreenInfo, DepthTexture, LightViewProjectionMatrix, Anisotropy, ClearCoatParameter, SheenParameter, SpecularGlossinessFactor, SpecularGlossinessTexture,
    fullSemanticStr, getShaderProperty,
    EntityUID, MorphTargetNumber, DataTextureMorphOffsetPosition, MorphWeights, CurrentComponentSIDs, AlphaCutoff, AlphaTexture
});


/***/ }),

/***/ "./src/foundation/definitions/ShaderType.ts":
/*!**************************************************!*\
  !*** ./src/foundation/definitions/ShaderType.ts ***!
  \**************************************************/
/*! exports provided: ShaderType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderType", function() { return ShaderType; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class ShaderTypeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const VertexShader = new ShaderTypeClass({ index: 1, str: 'VertexShader' });
const PixelShader = new ShaderTypeClass({ index: 2, str: 'PixelShader' });
const VertexAndPixelShader = new ShaderTypeClass({ index: 3, str: 'VertexAndPixelShader' });
const ComputeShader = new ShaderTypeClass({ index: 4, str: 'ComputeShader' });
const typeList = [VertexShader, PixelShader, VertexAndPixelShader, ComputeShader];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const ShaderType = Object.freeze({ VertexShader, PixelShader, VertexAndPixelShader, ComputeShader, from, fromString });


/***/ }),

/***/ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts":
/*!********************************************************************!*\
  !*** ./src/foundation/definitions/ShaderVariableUpdateInterval.ts ***!
  \********************************************************************/
/*! exports provided: ShaderVariableUpdateInterval */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderVariableUpdateInterval", function() { return ShaderVariableUpdateInterval; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class ShaderVariableUpdateIntervalClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const FirstTimeOnly = new ShaderVariableUpdateIntervalClass({ index: 0, str: 'FirstTimeOnly' });
const EveryTime = new ShaderVariableUpdateIntervalClass({ index: 1, str: 'EveryTime' });
const RenderPass = new ShaderVariableUpdateIntervalClass({ index: 2, str: 'RenderPass' });
const typeList = [FirstTimeOnly, EveryTime, RenderPass];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const ShaderVariableUpdateInterval = Object.freeze({ FirstTimeOnly, EveryTime, RenderPass, from, fromString });


/***/ }),

/***/ "./src/foundation/definitions/ShadingModel.ts":
/*!****************************************************!*\
  !*** ./src/foundation/definitions/ShadingModel.ts ***!
  \****************************************************/
/*! exports provided: ShadingModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadingModel", function() { return ShadingModel; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class ShadingModelClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const Unknown = new ShadingModelClass({ index: -1, str: 'UNKNOWN' });
const Constant = new ShadingModelClass({ index: 0, str: 'CONSTANT' });
const Lambert = new ShadingModelClass({ index: 1, str: 'LAMBERT' });
const BlinnPhong = new ShadingModelClass({ index: 2, str: 'BLINN' });
const Phong = new ShadingModelClass({ index: 3, str: 'PHONG' });
const typeList = [Unknown, Constant, Lambert, BlinnPhong, Phong];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
const ShadingModel = Object.freeze({ Unknown, Constant, Lambert, BlinnPhong, Phong, from });


/***/ }),

/***/ "./src/foundation/definitions/TextureParameter.ts":
/*!********************************************************!*\
  !*** ./src/foundation/definitions/TextureParameter.ts ***!
  \********************************************************/
/*! exports provided: TextureParameter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureParameter", function() { return TextureParameter; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class TextureParameterClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const Nearest = new TextureParameterClass({ index: 0x2600, str: 'NEAREST' });
const Linear = new TextureParameterClass({ index: 0x2601, str: 'LINEAR' });
const NearestMipmapNearest = new TextureParameterClass({ index: 0x2700, str: 'NEAREST_MIPMAP_NEAREST' });
const LinearMipmapNearest = new TextureParameterClass({ index: 0x2701, str: 'LINEAR_MIPMAP_NEAREST' });
const NearestMipmapLinear = new TextureParameterClass({ index: 0x2702, str: 'NEAREST_MIPMAP_LINEAR' });
const LinearMipmapLinear = new TextureParameterClass({ index: 0x2703, str: 'LINEAR_MIPMAP_LINEAR' });
const TextureMagFilter = new TextureParameterClass({ index: 0x2800, str: 'TEXTURE_MAG_FILTER' });
const TextureMinFilter = new TextureParameterClass({ index: 0x2801, str: 'TEXTURE_MIN_FILTER' });
const TextureWrapS = new TextureParameterClass({ index: 0x2802, str: 'TEXTURE_WRAP_S' });
const TextureWrapT = new TextureParameterClass({ index: 0x2803, str: 'TEXTURE_WRAP_T' });
const Texture2D = new TextureParameterClass({ index: 0x0DE1, str: 'TEXTURE_2D' });
const Texture = new TextureParameterClass({ index: 0x1702, str: 'TEXTURE' });
const Texture0 = new TextureParameterClass({ index: 0x84C0, str: 'TEXTURE0' });
const Texture1 = new TextureParameterClass({ index: 0x84C1, str: 'TEXTURE1' });
const ActiveTexture = new TextureParameterClass({ index: 0x84E0, str: 'ACTIVE_TEXTURE' });
const Repeat = new TextureParameterClass({ index: 0x2901, str: 'REPEAT' });
const ClampToEdge = new TextureParameterClass({ index: 0x812F, str: 'CLAMP_TO_EDGE' });
const MirroredRepeat = new TextureParameterClass({ index: 0x8370, str: 'MIRRORED_REPEAT' });
const RGB8 = new TextureParameterClass({ index: 0x8051, str: 'RGB8' });
const RGBA8 = new TextureParameterClass({ index: 0x8058, str: 'RGBA8' });
const RGB10_A2 = new TextureParameterClass({ index: 0x8059, str: 'RGB10_A2' });
const RGB16F = new TextureParameterClass({ index: 0x881B, str: 'RGB16F' });
const RGB32F = new TextureParameterClass({ index: 0x8815, str: 'RGB32F' });
const RGBA16F = new TextureParameterClass({ index: 0x881A, str: 'RGBA16F' });
const RGBA32F = new TextureParameterClass({ index: 0x8814, str: 'RGBA32F' });
const Depth16 = new TextureParameterClass({ index: 0x81A5, str: 'DEPTH_COMPONENT16' });
const Depth24 = new TextureParameterClass({ index: 0x81A6, str: 'DEPTH_COMPONENT24' });
const Depth32F = new TextureParameterClass({ index: 0x8CAC, str: 'DEPTH_COMPONENT32F' });
const Depth24Stencil8 = new TextureParameterClass({ index: 0x88F0, str: 'DEPTH24_STENCIL8' });
const Depth32FStencil8 = new TextureParameterClass({ index: 0x8CAD, str: 'DEPTH32F_STENCIL8' });
const typeList = [
    Nearest, Linear, NearestMipmapNearest, LinearMipmapNearest, NearestMipmapLinear, LinearMipmapLinear,
    TextureMagFilter, TextureMinFilter, TextureWrapS, TextureWrapT, Texture2D, Texture, Texture0, Texture1, ActiveTexture, Repeat, ClampToEdge, MirroredRepeat,
    RGB8, RGBA8, RGB10_A2, RGB16F, RGB32F, RGBA16F, RGBA32F, Depth16, Depth24, Depth32F, Depth24Stencil8, Depth32FStencil8
];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
const TextureParameter = Object.freeze({
    Nearest, Linear, NearestMipmapNearest, LinearMipmapNearest, NearestMipmapLinear, LinearMipmapLinear,
    TextureMagFilter, TextureMinFilter, TextureWrapS, TextureWrapT, Texture2D, Texture, Texture0, Texture1, ActiveTexture, Repeat, ClampToEdge, MirroredRepeat,
    RGB8, RGBA8, RGB10_A2, RGB16F, RGB32F, RGBA16F, RGBA32F, Depth16, Depth24, Depth32F, Depth24Stencil8, Depth32FStencil8,
    from
});


/***/ }),

/***/ "./src/foundation/definitions/VertexAttribute.ts":
/*!*******************************************************!*\
  !*** ./src/foundation/definitions/VertexAttribute.ts ***!
  \*******************************************************/
/*! exports provided: VertexAttributeClass, VertexAttribute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexAttributeClass", function() { return VertexAttributeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexAttribute", function() { return VertexAttribute; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class VertexAttributeClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str, shaderStr, attributeSlot }) {
        super({ index, str });
        this.__attributeSlot = attributeSlot;
        this.__shaderStr = shaderStr;
    }
    getAttributeSlot() {
        return this.__attributeSlot;
    }
    get shaderStr() {
        return this.__shaderStr;
    }
}
const Unknown = new VertexAttributeClass({ index: -1, str: 'UNKNOWN', shaderStr: 'a_unknown', attributeSlot: -1 });
const Position = new VertexAttributeClass({ index: 0, str: 'POSITION', shaderStr: 'a_position', attributeSlot: 0 });
const Normal = new VertexAttributeClass({ index: 1, str: 'NORMAL', shaderStr: 'a_normal', attributeSlot: 1 });
const Tangent = new VertexAttributeClass({ index: 2, str: 'TANGENT', shaderStr: 'a_tangent', attributeSlot: 2 });
const Texcoord0 = new VertexAttributeClass({ index: 3, str: 'TEXCOORD_0', shaderStr: 'a_texcoord_0', attributeSlot: 3 });
const Texcoord1 = new VertexAttributeClass({ index: 4, str: 'TEXCOORD_1', shaderStr: 'a_texcoord_1', attributeSlot: 4 });
const Color0 = new VertexAttributeClass({ index: 5, str: 'COLOR_0', shaderStr: 'a_color_0', attributeSlot: 5 });
const Joints0 = new VertexAttributeClass({ index: 6, str: 'JOINTS_0', shaderStr: 'a_joints_0', attributeSlot: 6 });
const Weights0 = new VertexAttributeClass({ index: 7, str: 'WEIGHTS_0', shaderStr: 'a_weights_0', attributeSlot: 7 });
const Instance = new VertexAttributeClass({ index: 8, str: 'INSTANCE', shaderStr: 'a_instance', attributeSlot: 8 });
const FaceNormal = new VertexAttributeClass({ index: 9, str: 'FACE_NORMAL', shaderStr: 'a_faceNormal', attributeSlot: 9 });
const BaryCentricCoord = new VertexAttributeClass({ index: 10, str: 'BARY_CENTRIC_COORD', shaderStr: 'a_baryCentricCoord', attributeSlot: 10 });
const typeList = [Unknown, Position, Normal, Tangent, Texcoord0, Texcoord1, Color0, Joints0, Weights0, Instance, FaceNormal, BaryCentricCoord];
const AttributeTypeNumber = 11;
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    let newStr = str;
    if (str === 'COLOR') {
        newStr = 'COLOR_0';
    }
    else if (str === 'TEXCOORD') {
        newStr = 'TEXCOORD_0';
    }
    else if (str === 'JOINTS') {
        newStr = 'JOINTS_0';
    }
    else if (str === 'WEIGHTS') {
        newStr = 'WEIGHTS_0';
    }
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str: newStr });
}
const VertexAttribute = Object.freeze({
    Unknown, Position, Normal, Tangent, Texcoord0, Texcoord1, Color0, Joints0, Weights0, Instance, FaceNormal, BaryCentricCoord, AttributeTypeNumber, from, fromString
});


/***/ }),

/***/ "./src/foundation/definitions/visibility.ts":
/*!**************************************************!*\
  !*** ./src/foundation/definitions/visibility.ts ***!
  \**************************************************/
/*! exports provided: Visibility */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Visibility", function() { return Visibility; });
/* harmony import */ var _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class VisibilityClass extends _misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const Neutral = new VisibilityClass({ index: 0, str: 'Neutral' });
const Visible = new VisibilityClass({ index: 1, str: 'Visible' });
const Invisible = new VisibilityClass({ index: -1, str: 'Invisible' });
const typeList = [Visible, Invisible, Neutral];
function from(index) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
function fromString(str) {
    return Object(_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_fromString"])({ typeList, str });
}
const Visibility = Object.freeze({ Visible, Invisible, Neutral, from, fromString });


/***/ }),

/***/ "./src/foundation/exporter/Gltf2Exporter.ts":
/*!**************************************************!*\
  !*** ./src/foundation/exporter/Gltf2Exporter.ts ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Gltf2Exporter; });
/* harmony import */ var _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EntityRepository */ "./src/foundation/core/EntityRepository.ts");
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");


const _VERSION = __webpack_require__(/*! ./../../../VERSION-FILE */ "./VERSION-FILE").default;
/**
 * The glTF2 format Exporter class.
 */
class Gltf2Exporter {
    constructor() {
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new Gltf2Exporter();
        }
        return this.__instance;
    }
    /**
     * Exports All scene data in the rhodonite system as glTF2 format.
     * @param filename
     */
    export(filename) {
        const entities = Gltf2Exporter.__entityRepository._getEntities();
        const json = {
            "asset": {
                "version": "2.0",
                "generator": `Rhodonite (${_VERSION.version})`
            }
        };
        const fileName = filename ? filename : 'Rhodonite_' + (new Date()).getTime();
        json.buffers = [{
                'uri': fileName + '.bin'
            }];
        json.bufferViews = [];
        json.accessors = [];
        json.materials = [{
                "pbrMetallicRoughness": {
                    "baseColorFactor": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ]
                }
            }];
        this.countMeshes(json, entities);
        this.createNodes(json, entities);
        this.createMeshBinaryMetaData(json, entities);
        this.createMeshes(json, entities);
        this.createMaterials(json, entities);
        const arraybuffer = this.createWriteBinary(json, entities);
        this.download(json, fileName, arraybuffer);
    }
    createWriteBinary(json, entities) {
        const buffer = new ArrayBuffer(json.buffers[0].byteLength);
        const dataView = new DataView(buffer);
        for (let i = 0; i < json.accessors.length; i++) {
            const accessor = json.accessors[i];
            const rnAccessor = accessor.accessor;
            const compositionType = rnAccessor.compositionType;
            const componentType = rnAccessor.componentType;
            const dataViewSetter = rnAccessor.getDataViewSetter(componentType);
            const attributeCount = accessor.count;
            const bufferview = json.bufferViews[accessor.bufferView];
            const bufferViewByteOffset = bufferview.byteOffset;
            for (let k = 0; k < attributeCount; k++) {
                if (compositionType.getNumberOfComponents() === 1) {
                    const byteIndex = componentType.getSizeInBytes() * k;
                    const value = rnAccessor.getScalar(k, {});
                    dataView[dataViewSetter](bufferViewByteOffset + byteIndex, value, true);
                }
                else if (compositionType.getNumberOfComponents() === 2) {
                    const array = rnAccessor.getVec2AsArray(k, {});
                    for (let l = 0; l < 2; l++) {
                        dataView[dataViewSetter](bufferViewByteOffset + componentType.getSizeInBytes() * (k * 2 + l), array[l], true);
                    }
                }
                else if (compositionType.getNumberOfComponents() === 3) {
                    const array = rnAccessor.getVec3AsArray(k, {});
                    for (let l = 0; l < 3; l++) {
                        dataView[dataViewSetter](bufferViewByteOffset + componentType.getSizeInBytes() * (k * 3 + l), array[l], true);
                    }
                }
                else if (compositionType.getNumberOfComponents() === 4) {
                    const array = rnAccessor.getVec4AsArray(k, {});
                    for (let l = 0; l < 4; l++) {
                        dataView[dataViewSetter](bufferViewByteOffset + componentType.getSizeInBytes() * (k * 4 + l), array[l], true);
                    }
                }
            }
            accessor.accessor = void 0;
        }
        return buffer;
    }
    countMeshes(json, entities) {
        let count = 0;
        json.meshes = [];
        for (let i = 0; i < entities.length; i++) {
            const entity = entities[i];
            const meshComponent = entity.getMesh();
            if (meshComponent) {
                entity.gltfMeshIndex = count++;
            }
        }
    }
    createMeshes(json, entities) {
        let count = 0;
        json.meshes = [];
        for (let i = 0; i < entities.length; i++) {
            const entity = entities[i];
            const meshComponent = entity.getMesh();
            if (meshComponent && meshComponent.mesh) {
                json.meshes[count] = {};
                const mesh = json.meshes[count];
                mesh.primitives = [];
                const primitiveCount = meshComponent.mesh.getPrimitiveNumber();
                for (let j = 0; j < primitiveCount; j++) {
                    mesh.primitives[j] = {};
                    const primitive = mesh.primitives[j];
                    const rnPrimitive = meshComponent.mesh.getPrimitiveAt(j);
                    const indicesAccessor = rnPrimitive.indicesAccessor;
                    if (indicesAccessor) {
                        primitive.indices = indicesAccessor.gltfAccessorIndex;
                        primitive.mode = rnPrimitive.primitiveMode.index;
                    }
                    const attributeAccessors = rnPrimitive.attributeAccessors;
                    primitive.attributes = {};
                    const attributes = primitive.attributes;
                    for (let k = 0; k < attributeAccessors.length; k++) {
                        const attributeAccessor = attributeAccessors[k];
                        attributes[rnPrimitive.attributeSemantics[k].str] = attributeAccessor.gltfAccessorIndex;
                    }
                    primitive.material = 0;
                }
                entity.gltfMeshIndex = count++;
            }
        }
    }
    createMaterials(json, entities) {
        let countMesh = 0;
        let countMaterial = 0;
        let countTexture = 0;
        let countImage = 0;
        json.materials = [];
        json.textures = [];
        json.samplers = [];
        json.images = [];
        json.samplers[0] = {
            "magFilter": 9729,
            "minFilter": 9987,
            "wrapS": 10497,
            "wrapT": 10497
        };
        for (let i = 0; i < entities.length; i++) {
            const entity = entities[i];
            const meshComponent = entity.getMesh();
            if (meshComponent && meshComponent.mesh) {
                const mesh = json.meshes[countMesh++];
                const primitiveCount = meshComponent.mesh.getPrimitiveNumber();
                for (let j = 0; j < primitiveCount; j++) {
                    const rnPrimitive = meshComponent.mesh.getPrimitiveAt(j);
                    const primitive = mesh.primitives[j];
                    const rnMaterial = rnPrimitive.material;
                    const material = {
                        "pbrMetallicRoughness": {}
                    };
                    let colorParam;
                    let metallic = 1.0;
                    let roughness = 1.0;
                    if (rnMaterial != null) {
                        colorParam = rnMaterial.getParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__["ShaderSemantics"].BaseColorFactor);
                        if (colorParam == null) {
                            colorParam = rnMaterial.getParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__["ShaderSemantics"].DiffuseColorFactor);
                        }
                        else {
                            metallic = rnMaterial.getParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__["ShaderSemantics"].MetallicRoughnessFactor).x;
                            roughness = rnMaterial.getParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__["ShaderSemantics"].MetallicRoughnessFactor).y;
                        }
                    }
                    if (colorParam) {
                        material.pbrMetallicRoughness.baseColorFactor = Array.prototype.slice.call(colorParam.v);
                    }
                    material.pbrMetallicRoughness.metallicFactor = metallic;
                    material.pbrMetallicRoughness.roughnessFactor = roughness;
                    if (rnMaterial) {
                        material.alphaMode = rnMaterial.alphaMode.str;
                        const processTexture = (rnTexture) => {
                            if (rnTexture && rnTexture.width > 1 && rnTexture.height > 1) {
                                let imageIndex = countImage;
                                let match = false;
                                for (let k = 0; k < json.images.length; k++) {
                                    const image = json.images[k];
                                    if (image.uri === rnTexture.name) {
                                        imageIndex = k;
                                        match = true;
                                    }
                                }
                                if (!match) {
                                    json.images[countImage++] = {
                                        uri: (rnTexture.name) ? rnTexture.name : rnTexture.uniqueName
                                    };
                                    const htmlCanvasElement = rnTexture.htmlCanvasElement;
                                    if (htmlCanvasElement) {
                                        const blob = htmlCanvasElement.toBlob((blob) => {
                                            setTimeout(function () {
                                                var a = document.createElement('a');
                                                const e = document.createEvent('MouseEvent');
                                                e.initEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
                                                a.href = URL.createObjectURL(blob);
                                                a.download = rnTexture.name;
                                                a.dispatchEvent(e);
                                            }, Math.random() * 10000);
                                        });
                                    }
                                }
                                json.textures[countTexture] = {
                                    sampler: 0,
                                    source: imageIndex
                                };
                                return countTexture++;
                            }
                            return void 0;
                        };
                        let textureParam = rnMaterial.getParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__["ShaderSemantics"].BaseColorTexture);
                        let rnTexture;
                        let textureIndex;
                        if (textureParam != null) {
                            rnTexture = (textureParam[1]);
                            textureIndex = processTexture(rnTexture);
                            if (textureIndex != null) {
                                material.pbrMetallicRoughness.baseColorTexture = { index: textureIndex };
                            }
                        }
                        else {
                            textureParam = rnMaterial.getParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__["ShaderSemantics"].DiffuseColorTexture);
                            if (textureParam != null) {
                                let rnTexture = (textureParam[1]);
                                let textureIndex = processTexture(rnTexture);
                                if (textureIndex != null) {
                                    material.pbrMetallicRoughness.diffuseColorTexture = { index: textureIndex };
                                }
                            }
                        }
                        textureParam = rnMaterial.getParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__["ShaderSemantics"].MetallicRoughnessTexture);
                        if (textureParam) {
                            rnTexture = (textureParam[1]);
                            textureIndex = processTexture(rnTexture);
                            if (textureIndex != null) {
                                material.pbrMetallicRoughness.metallicRoughnessTexture = { index: textureIndex };
                            }
                        }
                        textureParam = rnMaterial.getParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__["ShaderSemantics"].NormalTexture);
                        if (textureParam) {
                            rnTexture = (textureParam[1]);
                            textureIndex = processTexture(rnTexture);
                            if (textureIndex != null) {
                                material.normalTexture = { index: textureIndex };
                            }
                        }
                        textureParam = rnMaterial.getParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__["ShaderSemantics"].OcclusionTexture);
                        if (textureParam) {
                            rnTexture = (textureParam[1]);
                            textureIndex = processTexture(rnTexture);
                            if (textureIndex != null) {
                                material.occlusionTexture = { index: textureIndex };
                            }
                        }
                        textureParam = rnMaterial.getParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__["ShaderSemantics"].EmissiveTexture);
                        if (textureParam) {
                            rnTexture = (textureParam[1]);
                            textureIndex = processTexture(rnTexture);
                            if (textureIndex != null) {
                                material.emissiveTexture = { index: textureIndex };
                            }
                        }
                    }
                    json.materials.push(material);
                    primitive.material = countMaterial++;
                }
            }
        }
    }
    createNodes(json, entities) {
        json.nodes = [];
        json.scenes = [{ 'nodes': [] }];
        const scene = json.scenes[0];
        const nodes = json.nodes;
        for (let i = 0; i < entities.length; i++) {
            const entity = entities[i];
            entity.gltfNodeIndex = i;
        }
        for (let i = 0; i < entities.length; i++) {
            const entity = entities[i];
            nodes[i] = {};
            const node = nodes[i];
            // node.name
            node.name = entity.uniqueName;
            // node.children
            node.children = [];
            const sceneGraphComponent = entity.getSceneGraph();
            const children = sceneGraphComponent.children;
            for (let j = 0; j < children.length; j++) {
                const child = children[j];
                node.children.push(child.entity.gltfNodeIndex);
            }
            // matrix
            node.matrix = Array.prototype.slice.call(entity.getTransform().matrix.v);
            // mesh
            node.mesh = entity.gltfMeshIndex;
            if (sceneGraphComponent.parent == null) {
                scene.nodes.push(i);
            }
        }
    }
    createMeshBinaryMetaData(json, entities) {
        let count = 0;
        let bufferByteLength = 0;
        for (let i = 0; i < entities.length; i++) {
            const entity = entities[i];
            const meshComponent = entity.getMesh();
            if (meshComponent && meshComponent.mesh) {
                const primitiveCount = meshComponent.mesh.getPrimitiveNumber();
                for (let j = 0; j < primitiveCount; j++) {
                    const primitive = meshComponent.mesh.getPrimitiveAt(j);
                    const indicesAccessor = primitive.indicesAccessor;
                    if (indicesAccessor) {
                        // BufferView
                        let match = false;
                        for (let k = 0; k < json.bufferViews.length; k++) {
                            const bufferview = json.bufferViews[k];
                            if (bufferview.rnAccessor === indicesAccessor) {
                                match = true;
                                indicesAccessor.gltfAccessorIndex = k;
                            }
                        }
                        if (!match) {
                            json.bufferViews[count] = {};
                            const bufferview = json.bufferViews[count];
                            bufferview.rnAccessor = indicesAccessor;
                            bufferview.buffer = 0;
                            bufferview.byteLength = indicesAccessor.byteLength;
                            bufferview.byteOffset = bufferByteLength;
                            bufferview.target = 34963;
                            // Accessor
                            json.accessors[count] = {};
                            const accessor = json.accessors[count];
                            accessor.bufferView = count;
                            accessor.byteOffset = 0; //indicesAccessor.byteOffsetInBufferView;
                            accessor.componentType = 5123;
                            accessor.count = indicesAccessor.elementCount;
                            indicesAccessor.calcMinMax();
                            accessor.max = [indicesAccessor.max];
                            accessor.min = [indicesAccessor.min];
                            accessor.type = 'SCALAR';
                            bufferByteLength += indicesAccessor.byteLength;
                            indicesAccessor.gltfAccessorIndex = count;
                            count++;
                            accessor.accessor = indicesAccessor;
                        }
                    }
                    const attributeAccessors = primitive.attributeAccessors;
                    for (let j = 0; j < attributeAccessors.length; j++) {
                        const attributeAccessor = attributeAccessors[j];
                        let match = false;
                        for (let k = 0; k < json.bufferViews.length; k++) {
                            const bufferview = json.bufferViews[k];
                            if (bufferview.rnAccessor === attributeAccessor) {
                                match = true;
                                attributeAccessor.gltfAccessorIndex = k;
                            }
                        }
                        if (!match) {
                            // BufferView
                            json.bufferViews[count] = {};
                            const bufferview = json.bufferViews[count];
                            bufferview.rnAccessor = attributeAccessor;
                            bufferview.buffer = 0;
                            bufferview.byteLength = attributeAccessors[j].byteLength;
                            bufferview.byteOffset = bufferByteLength;
                            bufferview.target = 34962;
                            // Accessor
                            json.accessors[count] = {};
                            const accessor = json.accessors[count];
                            accessor.bufferView = count;
                            accessor.byteOffset = 0; //attributeAccessor.byteOffsetInBufferView;
                            accessor.componentType = 5126;
                            accessor.count = attributeAccessor.elementCount;
                            attributeAccessor.calcMinMax();
                            accessor.max = Array.prototype.slice.call(attributeAccessor.max);
                            accessor.min = Array.prototype.slice.call(attributeAccessor.min);
                            accessor.type = 'VEC' + accessor.max.length;
                            bufferByteLength += attributeAccessor.byteLength;
                            attributeAccessor.gltfAccessorIndex = count;
                            count++;
                            accessor.accessor = attributeAccessor;
                        }
                    }
                }
            }
        }
        json.bufferViews.forEach((bufferView) => {
            bufferView.rnAccessor = void 0;
        });
        const buffer = json.buffers[0];
        buffer.byteLength = bufferByteLength;
    }
    download(json, filename, arraybuffer) {
        let a = document.createElement('a');
        let e = document.createEvent('MouseEvent');
        a.download = filename + '.gltf';
        a.href = "data:application/octet-stream," + encodeURIComponent(JSON.stringify(json));
        e.initEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
        a.dispatchEvent(e);
        a = document.createElement('a');
        e = document.createEvent('MouseEvent');
        e.initEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
        var blob = new Blob([arraybuffer], { type: "octet/stream" }), url = window.URL.createObjectURL(blob);
        a.download = filename + '.bin';
        a.href = url;
        a.dispatchEvent(e);
    }
}
Gltf2Exporter.__entityRepository = _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();


/***/ }),

/***/ "./src/foundation/geometry/Frustum.ts":
/*!********************************************!*\
  !*** ./src/foundation/geometry/Frustum.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Frustum; });
/* harmony import */ var _math_Matrix44__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _math_MutableVector4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/MutableVector4 */ "./src/foundation/math/MutableVector4.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../definitions/visibility */ "./src/foundation/definitions/visibility.ts");





/**
 * The view frustum class.
 */
class Frustum {
    constructor() {
        this.top = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_2__["default"].zero();
        this.bottom = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_2__["default"].zero();
        this.right = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_2__["default"].zero();
        this.left = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_2__["default"].zero();
        this.zNear = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_2__["default"].zero();
        this.zFar = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_2__["default"].zero();
        this.__updated = false;
        this.__vp = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
    }
    /**
     * Updates this view frustum data from the view and projection matrices.
     * @param viewMatrix The view matrix.
     * @param projectionMatrix The projection matrix.
     */
    update(viewMatrix, projectionMatrix) {
        _math_Matrix44__WEBPACK_IMPORTED_MODULE_0__["default"].multiplyTo(projectionMatrix, viewMatrix, this.__vp);
        this.zNear.x = this.__vp.m20 + this.__vp.m30;
        this.zNear.y = this.__vp.m21 + this.__vp.m31;
        this.zNear.z = this.__vp.m22 + this.__vp.m32;
        this.zNear.w = this.__vp.m23 + this.__vp.m33;
        this.zNear.normalize3();
        this.zFar.x = -this.__vp.m20 + this.__vp.m30;
        this.zFar.y = -this.__vp.m21 + this.__vp.m31;
        this.zFar.z = -this.__vp.m22 + this.__vp.m32;
        this.zFar.w = -this.__vp.m23 + this.__vp.m33;
        this.zFar.normalize3();
        this.bottom.x = this.__vp.m10 + this.__vp.m30;
        this.bottom.y = this.__vp.m11 + this.__vp.m31;
        this.bottom.z = this.__vp.m12 + this.__vp.m32;
        this.bottom.w = this.__vp.m13 + this.__vp.m33;
        this.bottom.normalize3();
        this.top.x = -this.__vp.m10 + this.__vp.m30;
        this.top.y = -this.__vp.m11 + this.__vp.m31;
        this.top.z = -this.__vp.m12 + this.__vp.m32;
        this.top.w = -this.__vp.m13 + this.__vp.m33;
        this.top.normalize3();
        this.left.x = this.__vp.m00 + this.__vp.m30;
        this.left.y = this.__vp.m01 + this.__vp.m31;
        this.left.z = this.__vp.m02 + this.__vp.m32;
        this.left.w = this.__vp.m03 + this.__vp.m33;
        this.left.normalize3();
        this.right.x = -this.__vp.m00 + this.__vp.m30;
        this.right.y = -this.__vp.m01 + this.__vp.m31;
        this.right.z = -this.__vp.m02 + this.__vp.m32;
        this.right.w = -this.__vp.m03 + this.__vp.m33;
        this.right.normalize3();
    }
    /**
     * Do clipping test (Inside / outside / neutral) of the plane of the view frustum.
     * @param plane The plane of the view frustum.
     * @param point The point to test.
     * @param bias The bias value.
     */
    clipping(plane, point, bias) {
        const dot = _math_Vector3__WEBPACK_IMPORTED_MODULE_3__["default"].dot(plane, point);
        const d = dot + plane.w;
        if (d + bias < 0) {
            return _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Invisible; // outside completely
        }
        else if (d - bias > 0) {
            return _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Visible; // inside completely
        }
        else {
            return _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Neutral; // neutral
        }
    }
    /**
     * Do culling test (Inside / outside / neutral) of the entity against to the view frustum.
     * @param sg The SceneGraphComponent object of the entity.
     */
    culling(sg) {
        const aabb = sg.worldAABB;
        const center = aabb.centerPoint;
        const centerToCorner = aabb.lengthCenterToCorner;
        const right = this.clipping(this.right, center, centerToCorner);
        const left = this.clipping(this.left, center, centerToCorner);
        if (right === _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Invisible && left === _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Visible || right === _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Visible && left === _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Invisible) {
            return _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Invisible;
        }
        const zNear = this.clipping(this.zNear, center, centerToCorner);
        const zFar = this.clipping(this.zFar, center, centerToCorner);
        if (zNear === _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Invisible && zFar === _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Visible || zNear === _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Visible && zFar === _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Invisible) {
            return _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Invisible;
        }
        const top = this.clipping(this.top, center, centerToCorner);
        const bottom = this.clipping(this.bottom, center, centerToCorner);
        if (top === _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Invisible && bottom === _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Visible || top === _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Visible && bottom === _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Invisible) {
            return _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Invisible;
        }
        const sum = top.index + bottom.index + right.index + left.index + zNear.index + zFar.index;
        if (sum === 6) {
            return _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Visible;
        }
        return _definitions_visibility__WEBPACK_IMPORTED_MODULE_4__["Visibility"].Neutral;
    }
}


/***/ }),

/***/ "./src/foundation/geometry/Mesh.ts":
/*!*****************************************!*\
  !*** ./src/foundation/geometry/Mesh.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mesh; });
/* harmony import */ var _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/PrimitiveMode */ "./src/foundation/definitions/PrimitiveMode.ts");
/* harmony import */ var _core_MemoryManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _definitions_BufferUse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/BufferUse */ "./src/foundation/definitions/BufferUse.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_AABB__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/AABB */ "./src/foundation/math/AABB.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _core_Entity__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/Entity */ "./src/foundation/core/Entity.ts");
/* harmony import */ var _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");











/**
 * The Mesh class.
 * This mesh object has primitives (geometries) or a reference of 'original mesh'.
 * If the latter, this mesh object is an 'instanced mesh', which has no primitives.
 * Instanced meshes refer original mesh's primitives when drawing.
 */
class Mesh {
    constructor() {
        this.__instanceIdx = 0;
        this.__primitives = [];
        this.__opaquePrimitives = [];
        this.__transparentPrimitives = [];
        this.__morphPrimitives = [];
        this.weights = [];
        this.__localAABB = new _math_AABB__WEBPACK_IMPORTED_MODULE_7__["default"]();
        this.__vaoUids = [];
        this.__variationVBOUid = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__["default"].InvalidCGAPIResourceUid;
        this.__instances = [];
        this._attachedEntityUID = _core_Entity__WEBPACK_IMPORTED_MODULE_9__["default"].invalidEntityUID;
        this.__instancesDirty = true;
        this.tangentCalculationMode = 1; // 0: Off, 1: auto, 2: force calculation
        this.isPreComputeForRayCastPickingEnable = false;
        this.__hasFaceNormal = false;
        this.__meshUID = ++Mesh.__mesh_uid_count;
    }
    /**
     * Gets original (Non instanced) meshes.
     */
    static get originalMeshes() {
        return this.__originalMeshes;
    }
    get variationVBOUid() {
        if (this.isInstanceMesh()) {
            return this.__instanceOf.variationVBOUid;
        }
        else {
            return this.__variationVBOUid;
        }
    }
    getVaoUids(index) {
        if (this.isInstanceMesh()) {
            return this.__instanceOf.getVaoUids(index);
        }
        else {
            return this.__vaoUids[index];
        }
    }
    /**
     * @private
     * Adds the other mesh to this mesh as instanced meshes.
     * @param mesh The other mesh.
     */
    _addMeshToInstanceArray(mesh) {
        this.__instances.push(mesh);
        this.__instancesDirty = true;
    }
    /**
     * Adds primitive.
     * @param primitive The primitive object.
     */
    addPrimitive(primitive) {
        if (this.isInstanceMesh()) {
            // De-instancing
            this.__instanceOf.__instances = this.__instanceOf.__instances.filter(mesh => mesh !== this);
            this.__instanceOf = void 0;
            this.__instanceIdx = 0;
            // this.__primitives will initialize in this.__setPrimitives
            this.__opaquePrimitives = this.__opaquePrimitives.slice();
            this.__transparentPrimitives = this.__transparentPrimitives.slice();
            this.__morphPrimitives = this.__morphPrimitives.slice();
        }
        if (primitive.material == null || !primitive.material.isBlend()) {
            this.__opaquePrimitives.push(primitive);
        }
        else {
            this.__transparentPrimitives.push(primitive);
        }
        this.__setPrimitives(this.__opaquePrimitives.concat(this.__transparentPrimitives));
        Mesh.__originalMeshes.push(this);
    }
    __setPrimitives(primitives) {
        this.__primitives = primitives;
        for (const instanceMesh of this.__instances) {
            instanceMesh.__primitives = this.__primitives;
            instanceMesh.__opaquePrimitives = this.__opaquePrimitives;
            instanceMesh.__transparentPrimitives = this.__transparentPrimitives;
            instanceMesh.__morphPrimitives = this.__morphPrimitives;
        }
    }
    /**
     * Sets mesh.
     * @param mesh The mesh.
     */
    setOriginalMesh(mesh) {
        if (mesh.isInstanceMesh()) {
            console.error(`Don't set InstanceMesh.`);
            return false;
        }
        this.__primitives = mesh.__primitives;
        this.__opaquePrimitives = mesh.__opaquePrimitives;
        this.__transparentPrimitives = mesh.__transparentPrimitives;
        this.__morphPrimitives = mesh.__morphPrimitives;
        this.__instanceOf = mesh;
        mesh._addMeshToInstanceArray(this);
        this.__instanceIdx = mesh.instanceIndex + 1;
        // Remove this from original mesh list
        Mesh.__originalMeshes = Mesh.__originalMeshes.filter(mesh => mesh !== this);
        return true;
    }
    /**
     * Gets true if these primitives are all 'Blend' type
     */
    isAllBlend() {
        if (this.__transparentPrimitives.length > 0 && this.__opaquePrimitives.length === 0) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Gets true if some primitives are 'Blend' type
     */
    isBlendPartially() {
        if (this.__transparentPrimitives.length > 0 && this.__opaquePrimitives.length > 0) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Gets true if these primitives are all 'Opaque' type
     */
    isOpaque() {
        if (this.__transparentPrimitives.length === 0 && this.__opaquePrimitives.length > 0) {
            return true;
        }
        else {
            return false;
        }
    }
    isFirstOpaquePrimitiveAt(index) {
        if (this.isFirstOpaquePrimitiveAt(index)) {
            return this.__instanceOf.isFirstOpaquePrimitiveAt(index);
        }
        else {
            if (this.__opaquePrimitives.length > 0) {
                if (index === 0) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
    }
    isFirstTransparentPrimitiveAt(index) {
        if (this.isFirstOpaquePrimitiveAt(index)) {
            return this.__instanceOf.isFirstTransparentPrimitiveAt(index);
        }
        else {
            if (this.__transparentPrimitives.length > 0) {
                if (this.__opaquePrimitives.length === index) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
    }
    __calcTangents() {
        if (this.tangentCalculationMode === 0 || this.isInstanceMesh()) {
            return;
        }
        for (let primitive of this.__primitives) {
            const tangentIdx = primitive.attributeSemantics.indexOf(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Tangent);
            if (tangentIdx !== -1 && this.tangentCalculationMode === 1) {
                continue;
            }
            const texcoordIdx = primitive.attributeSemantics.indexOf(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Texcoord0);
            const normalIdx = primitive.attributeSemantics.indexOf(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Normal);
            if (texcoordIdx !== -1 && normalIdx !== -1) {
                const positionIdx = primitive.attributeSemantics.indexOf(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Position);
                const positionAccessor = primitive.attributeAccessors[positionIdx];
                const texcoordAccessor = primitive.attributeAccessors[texcoordIdx];
                const normalAccessor = primitive.attributeAccessors[normalIdx];
                const indicesAccessor = primitive.indicesAccessor;
                let incrementNum = 3; // PrimitiveMode.Triangles
                if (primitive.primitiveMode === _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_1__["PrimitiveMode"].TriangleStrip ||
                    primitive.primitiveMode === _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_1__["PrimitiveMode"].TriangleFan) {
                    incrementNum = 1;
                }
                const vertexNum = primitive.getVertexCountAsIndicesBased();
                const buffer = _core_MemoryManager__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance().createOrGetBuffer(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_3__["BufferUse"].CPUGeneric);
                const tangentAttributeByteSize = positionAccessor.byteLength * 4 / 3;
                const tangentBufferView = buffer.takeBufferView({ byteLengthToNeed: tangentAttributeByteSize, byteStride: 0, isAoS: false });
                const tangentAccessor = tangentBufferView.takeAccessor({ compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_5__["CompositionType"].Vec4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float, count: positionAccessor.elementCount });
                for (let i = 0; i < vertexNum - 2; i += incrementNum) {
                    const pos0 = positionAccessor.getVec3(i, { indicesAccessor });
                    const pos1 = positionAccessor.getVec3(i + 1, { indicesAccessor });
                    const pos2 = positionAccessor.getVec3(i + 2, { indicesAccessor });
                    const uv0 = texcoordAccessor.getVec2(i, { indicesAccessor });
                    const uv1 = texcoordAccessor.getVec2(i + 1, { indicesAccessor });
                    const uv2 = texcoordAccessor.getVec2(i + 2, { indicesAccessor });
                    const norm0 = normalAccessor.getVec3(i, { indicesAccessor });
                    this.__calcTangentFor3Vertices(i, pos0, pos1, pos2, uv0, uv1, uv2, norm0, tangentAccessor, indicesAccessor);
                }
                primitive.setVertexAttribute(tangentAccessor, _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Tangent);
            }
        }
    }
    __calcTangentFor3Vertices(i, pos0, pos1, pos2, uv0, uv1, uv2, norm0, tangentAccessor, indicesAccessor) {
        const tan0Vec3 = this.__calcTangentPerVertex(pos0, pos1, pos2, uv0, uv1, uv2, norm0, Mesh.__tmpReturnVec3_0);
        const tan1Vec3 = this.__calcTangentPerVertex(pos1, pos2, pos0, uv1, uv2, uv0, norm0, Mesh.__tmpReturnVec3_1);
        const tan2Vec3 = this.__calcTangentPerVertex(pos2, pos0, pos1, uv2, uv0, uv1, norm0, Mesh.__tmpReturnVec3_2);
        tangentAccessor.setVec4(i, tan0Vec3.x, tan0Vec3.y, tan0Vec3.z, 1, { indicesAccessor });
        tangentAccessor.setVec4(i + 1, tan1Vec3.x, tan1Vec3.y, tan1Vec3.z, 1, { indicesAccessor });
        tangentAccessor.setVec4(i + 2, tan2Vec3.x, tan2Vec3.y, tan2Vec3.z, 1, { indicesAccessor });
    }
    __calcTangentPerVertex(pos0Vec3, pos1Vec3, pos2Vec3, uv0Vec2, uv1Vec2, uv2Vec2, norm0Vec3, returnVec3) {
        let cp0 = [
            Mesh.__tmpVec3_0.setComponents(pos0Vec3.x, uv0Vec2.x, uv0Vec2.y),
            Mesh.__tmpVec3_1.setComponents(pos0Vec3.y, uv0Vec2.x, uv0Vec2.y),
            Mesh.__tmpVec3_2.setComponents(pos0Vec3.z, uv0Vec2.x, uv0Vec2.y)
        ];
        let cp1 = [
            Mesh.__tmpVec3_3.setComponents(pos1Vec3.x, uv1Vec2.x, uv1Vec2.y),
            Mesh.__tmpVec3_4.setComponents(pos1Vec3.y, uv1Vec2.x, uv1Vec2.y),
            Mesh.__tmpVec3_5.setComponents(pos1Vec3.z, uv1Vec2.x, uv1Vec2.y)
        ];
        let cp2 = [
            Mesh.__tmpVec3_6.setComponents(pos2Vec3.x, uv2Vec2.x, uv2Vec2.y),
            Mesh.__tmpVec3_7.setComponents(pos2Vec3.y, uv2Vec2.x, uv2Vec2.y),
            Mesh.__tmpVec3_8.setComponents(pos2Vec3.z, uv2Vec2.x, uv2Vec2.y)
        ];
        let u = [];
        let v = [];
        for (let i = 0; i < 3; i++) {
            const v1 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].subtractTo(cp1[i], cp0[i], Mesh.__tmpVec3_9);
            const v2 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].subtractTo(cp2[i], cp1[i], Mesh.__tmpVec3_10);
            const abc = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].crossTo(v1, v2, Mesh.__tmpVec3_11);
            const validate = Math.abs(abc.x) < Number.EPSILON;
            if (validate) {
                console.assert(validate, "Polygons or polygons on UV are degenerate!");
                return new _math_Vector3__WEBPACK_IMPORTED_MODULE_6__["default"](0, 0, 0);
            }
            u[i] = -abc.y / abc.x;
            v[i] = -abc.z / abc.x;
        }
        if (u[0] * u[0] + u[1] * u[1] + u[2] * u[2] < Number.EPSILON) {
            _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].crossTo(norm0Vec3, pos1Vec3, returnVec3);
            return returnVec3.normalize();
        }
        return returnVec3.setComponents(u[0], u[1], u[2]).normalize();
    }
    getPrimitiveAt(i) {
        // if (this.weights.length > 0) {
        // return this.__morphPrimitives[i];
        // } else {
        return this.__primitives[i];
        // }
    }
    getPrimitiveNumber() {
        return this.__primitives.length;
    }
    __calcFaceNormalsIfNonNormal() {
        if (this.isInstanceMesh()) {
            return;
        }
        for (let primitive of this.__primitives) {
            const normalIdx = primitive.attributeSemantics.indexOf(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Normal);
            if (normalIdx !== -1) {
                return;
            }
            this.__hasFaceNormal = true;
            const positionIdx = primitive.attributeSemantics.indexOf(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Position);
            const positionAccessor = primitive.attributeAccessors[positionIdx];
            const indicesAccessor = primitive.indicesAccessor;
            let incrementNum = 3; // PrimitiveMode.Triangles
            if (primitive.primitiveMode === _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_1__["PrimitiveMode"].TriangleStrip ||
                primitive.primitiveMode === _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_1__["PrimitiveMode"].TriangleFan) {
                incrementNum = 1;
            }
            const vertexNum = primitive.getVertexCountAsIndicesBased();
            const buffer = _core_MemoryManager__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance().createOrGetBuffer(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_3__["BufferUse"].CPUGeneric);
            const normalAttributeByteSize = positionAccessor.byteLength;
            const normalBufferView = buffer.takeBufferView({ byteLengthToNeed: normalAttributeByteSize, byteStride: 0, isAoS: false });
            const normalAccessor = normalBufferView.takeAccessor({ compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_5__["CompositionType"].Vec3, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float, count: positionAccessor.elementCount });
            for (let i = 0; i < vertexNum - 2; i += incrementNum) {
                const pos0 = positionAccessor.getVec3(i, { indicesAccessor });
                const pos1 = positionAccessor.getVec3(i + 1, { indicesAccessor });
                const pos2 = positionAccessor.getVec3(i + 2, { indicesAccessor });
                this.__calcFaceNormalFor3Vertices(i, pos0, pos1, pos2, normalAccessor, indicesAccessor);
            }
            primitive.setVertexAttribute(normalAccessor, _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Normal);
        }
    }
    __calcFaceNormalFor3Vertices(i, pos0, pos1, pos2, normalAccessor, indicesAccessor) {
        // Calc normal
        const ax = pos1.x - pos0.x;
        const ay = pos1.y - pos0.y;
        const az = pos1.z - pos0.z;
        const bx = pos2.x - pos0.x;
        const by = pos2.y - pos0.y;
        const bz = pos2.z - pos0.z;
        let nx = ay * bz - az * by; // cross product
        let ny = az * bx - ax * bz;
        let nz = ax * by - ay * bx;
        let da = Math.hypot(nx, ny, nz); // normalize
        if (da <= 1e-6) {
            da = 0.0001;
        }
        da = 1.0 / da;
        nx *= da;
        ny *= da;
        nz *= da;
        normalAccessor.setVec3(i, nx, ny, nz, { indicesAccessor });
        normalAccessor.setVec3(i + 1, nx, ny, nz, { indicesAccessor });
        normalAccessor.setVec3(i + 2, nx, ny, nz, { indicesAccessor });
    }
    // makeVerticesSeparated() {
    //   for (let primitive of this.__primitives) {
    //     if (primitive.hasIndices()) {
    //       const buffer = MemoryManager.getInstance().createOrGetBuffer(BufferUse.CPUGeneric);
    //       const vertexCount = primitive.getVertexCountAsIndicesBased();
    //       const indexAccessor = primitive.indicesAccessor;
    //       for (let i in primitive.attributeAccessors) {
    //         const attributeAccessor = primitive.attributeAccessors[i];
    //         const elementSizeInBytes = attributeAccessor.elementSizeInBytes;
    //         const bufferView = buffer.takeBufferView({ byteLengthToNeed: elementSizeInBytes * vertexCount, byteStride: 0, isAoS: false });
    //         const newAccessor = bufferView.takeAccessor({ compositionType: attributeAccessor.compositionType, componentType: attributeAccessor.componentType, count: vertexCount });
    //         for (let j = 0; j < vertexCount; j++) {
    //           const idx = indexAccessor!.getScalar(j, {});
    //           newAccessor.setElementFromSameCompositionAccessor(j, attributeAccessor, idx);
    //         }
    //         primitive.setVertexAttribute(newAccessor, primitive.attributeSemantics[i]);
    //       }
    //       const indicesAccessor = primitive.indicesAccessor!;
    //       const elementSizeInBytes = indicesAccessor.elementSizeInBytes;
    //       const bufferView = buffer.takeBufferView({ byteLengthToNeed: elementSizeInBytes * vertexCount, byteStride: 0, isAoS: false });
    //       const newAccessor = bufferView.takeAccessor({ compositionType: indicesAccessor.compositionType, componentType: indicesAccessor.componentType, count: vertexCount });
    //       for (let j = 0; j < vertexCount; j++) {
    //         //const idx = indexAccessor!.getScalar(j, {});
    //         newAccessor.setScalar(j, j, {});
    //       }
    //       primitive.setIndices(newAccessor);
    //     }
    //   }
    // }
    __calcBaryCentricCoord() {
        if (this.isInstanceMesh()) {
            return;
        }
        for (let primitive of this.__primitives) {
            const BaryCentricCoordId = primitive.attributeSemantics.indexOf(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].BaryCentricCoord);
            if (BaryCentricCoordId !== -1) {
                return;
            }
            const buffer = _core_MemoryManager__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance().createOrGetBuffer(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_3__["BufferUse"].CPUGeneric);
            const positionIdx = primitive.attributeSemantics.indexOf(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Position);
            const positionAccessor = primitive.attributeAccessors[positionIdx];
            const vertexNum = positionAccessor.elementCount;
            const num = vertexNum;
            const baryCentricCoordAttributeByteSize = num * 4 /* vec4 */ * 4 /* bytes */;
            const baryCentricCoordBufferView = buffer.takeBufferView({ byteLengthToNeed: baryCentricCoordAttributeByteSize, byteStride: 0, isAoS: false });
            const baryCentricCoordAccessor = baryCentricCoordBufferView.takeAccessor({ compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_5__["CompositionType"].Vec4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float, count: num });
            for (let ver_i = 0; ver_i < num; ver_i++) {
                baryCentricCoordAccessor.setVec4(ver_i, ver_i % 3 === 0 ? 1 : 0, // 1 0 0  1 0 0  1 0 0,
                ver_i % 3 === 1 ? 1 : 0, // 0 1 0  0 1 0  0 1 0,
                ver_i % 3 === 2 ? 1 : 0, // 0 0 1  0 0 1  0 0 1,
                ver_i, {});
            }
            primitive.setVertexAttribute(baryCentricCoordAccessor, _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].BaryCentricCoord);
        }
    }
    // __initMorphPrimitives() {
    //   if (this.weights.length === 0) {
    //     return;
    //   }
    //   const buffer = MemoryManager.getInstance().createOrGetBuffer(BufferUse.CPUGeneric);
    //   for (let i = 0; i < this.__primitives.length; i++) {
    //     const primitive = this.__primitives[i];
    //     if (this.__morphPrimitives[i] == null) {
    //       const target = primitive.targets[0];
    //       const map = new Map();
    //       target.forEach((accessor, semantic) => {
    //         const bufferView = buffer.takeBufferView({ byteLengthToNeed: accessor.byteLength, byteStride: 0, isAoS: false });
    //         const morphAccessor = bufferView.takeAccessor({ compositionType: accessor.compositionType, componentType: accessor.componentType, count: accessor.elementCount });
    //         map.set(semantic, morphAccessor);
    //       });
    //       const morphPrimitive = new Primitive();
    //       morphPrimitive.setData(map, primitive.primitiveMode, primitive.material, primitive.indicesAccessor);
    //       morphPrimitive.setTargets(primitive.targets);
    //       this.__morphPrimitives[i] = morphPrimitive;
    //     }
    //   }
    // }
    __calcMorphPrimitives() {
        if (this.weights.length === 0 || this.isInstanceMesh()) {
            return;
        }
        for (let i = 0; i < this.__primitives.length; i++) {
            const morphPrimitive = this.__morphPrimitives[i];
            const primitive = this.__primitives[i];
            const target0Attributes = primitive.targets[0];
            target0Attributes.forEach((accessor, semantic) => {
                const morphAccessor = morphPrimitive.getAttribute(semantic);
                const elementCount = morphAccessor.elementCount;
                for (let j = 0; j < elementCount; j++) {
                    morphAccessor.setElementFromSameCompositionAccessor(j, primitive.getAttribute(semantic));
                }
            });
            // primitive.targets.forEach((targetAttributes, k)=>{
            //   targetAttributes.forEach((accessor, semantic) => {
            //     const morphAccessor = morphPrimitive.getAttribute(semantic)!;
            //     const elementCount = morphAccessor.elementCount;
            //     for (let j = 0; j < elementCount; j++) {
            //       morphAccessor.addElementFromSameCompositionAccessor(j, accessor, this.weights[k]);
            //     }
            //   });
            // });
        }
    }
    /**
     * Gets AABB in local space.
     */
    get AABB() {
        if (this.isInstanceMesh()) {
            return this.__instanceOf.AABB;
        }
        if (this.__localAABB.isVanilla()) {
            for (let primitive of this.__primitives) {
                this.__localAABB.mergeAABB(primitive.AABB);
            }
        }
        return this.__localAABB;
    }
    get instanceIndex() {
        return this.__instanceIdx;
    }
    isInstanceMesh() {
        if (this.__instanceOf != null) {
            return true;
        }
        else {
            return false;
        }
    }
    isOriginalMesh() {
        return !this.isInstanceMesh();
    }
    get meshUID() {
        return this.__meshUID;
    }
    updateVariationVBO() {
        if (this.isInstanceMesh()) {
            return this.__instanceOf.updateVariationVBO();
        }
        else {
            if (!this.__instancesDirty) {
                return false;
            }
            const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__["default"].getWebGLResourceRepository();
            this.__primitives.forEach((prim, i) => {
                this.__vaoUids[i] = webglResourceRepository.createVertexArray();
            });
            if (this.__variationVBOUid != _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__["default"].InvalidCGAPIResourceUid) {
                webglResourceRepository.deleteVertexBuffer(this.__variationVBOUid);
            }
            const instanceNum = this.__instances.length;
            const entityUIDs = new Float32Array(instanceNum + 1); // instances and original
            entityUIDs[0] = this._attachedEntityUID;
            for (var i = 0; i < instanceNum; i++) {
                entityUIDs[i + 1] = this.__instances[i]._attachedEntityUID;
            }
            this.__variationVBOUid = webglResourceRepository.createVertexBufferFromTypedArray(entityUIDs);
            this.__instancesDirty = false;
            return true;
        }
    }
    deleteVariationVBO() {
        if (this.isInstanceMesh()) {
            return this.__instanceOf.deleteVariationVBO();
        }
        else {
            const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__["default"].getWebGLResourceRepository();
            if (this.__variationVBOUid !== _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__["default"].InvalidCGAPIResourceUid) {
                webglResourceRepository.deleteVertexBuffer(this.__variationVBOUid);
                this.__vaoUids.forEach((vaoUid) => {
                    webglResourceRepository.deleteVertexArray(vaoUid);
                });
                return true;
            }
        }
        return false;
    }
    get instanceCountIncludeOriginal() {
        return this.__instances.length + 1;
    }
    castRay(srcPointInLocal, directionInLocal, dotThreshold = 0) {
        let finalShortestIntersectedPosVec3;
        let finalShortestT = Number.MAX_VALUE;
        for (let primitive of this.__primitives) {
            const { currentShortestIntersectedPosVec3, currentShortestT } = primitive.castRay(srcPointInLocal, directionInLocal, true, true, dotThreshold, this.__hasFaceNormal);
            if (currentShortestT != null && currentShortestT < finalShortestT) {
                finalShortestT = currentShortestT;
                finalShortestIntersectedPosVec3 = currentShortestIntersectedPosVec3;
            }
        }
        if (finalShortestT === Number.MAX_VALUE) {
            finalShortestT === -1;
        }
        return { t: finalShortestT, intersectedPosition: finalShortestIntersectedPosVec3 };
    }
    _calcArenbergInverseMatrices() {
        if (this.isInstanceMesh()) {
            return;
        }
        if (this.isPreComputeForRayCastPickingEnable) {
            for (let primitive of this.__primitives) {
                primitive._calcArenbergInverseMatrices();
            }
        }
    }
}
Mesh.invalidateMeshUID = -1;
Mesh.__mesh_uid_count = Mesh.invalidateMeshUID;
Mesh.__originalMeshes = [];
Mesh.__tmpVec3_0 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpVec3_1 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpVec3_2 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpVec3_3 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpVec3_4 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpVec3_5 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpVec3_6 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpVec3_7 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpVec3_8 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpVec3_9 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpVec3_10 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpVec3_11 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpReturnVec3_0 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpReturnVec3_1 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
Mesh.__tmpReturnVec3_2 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].zero();


/***/ }),

/***/ "./src/foundation/geometry/Plane.ts":
/*!******************************************!*\
  !*** ./src/foundation/geometry/Plane.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Plane; });
/* harmony import */ var _Primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Primitive */ "./src/foundation/geometry/Primitive.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/PrimitiveMode */ "./src/foundation/definitions/PrimitiveMode.ts");
/* harmony import */ var _core_MemoryManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");






class Plane extends _Primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    /**
     * Generates a plane object
     * @param width the length of U(X)-axis direction
     * @param height the length of V(Y)-axis direction
     * @param uSpan number of spans in U(X)-axis direction
     * @param vSpan number of spans in V(Y)-axis direction
     * @param isUVRepeat draw uSpan times vSpan number of textures
     * @param flipTextureCoordinateY draw textures by flipping on the V(Y)-axis
     * @param material attach a rhodonite material to this plane(the default material is the classicUberMaterial)
     */
    generate({ width, height, uSpan, vSpan, isUVRepeat = false, flipTextureCoordinateY = false, material }) {
        var positions = [];
        for (let i = 0; i <= vSpan; i++) {
            for (let j = 0; j <= uSpan; j++) {
                positions.push((j / uSpan - 1 / 2) * width);
                positions.push(0);
                positions.push((i / vSpan - 1 / 2) * height);
            }
        }
        var indices = [];
        for (let i = 0; i < vSpan; i++) {
            let degenerate_left_index = 0;
            let degenerate_right_index = 0;
            for (let j = 0; j <= uSpan; j++) {
                indices.push(i * (uSpan + 1) + j);
                indices.push((i + 1) * (uSpan + 1) + j);
                if (j === 0) {
                    degenerate_left_index = (i + 1) * (uSpan + 1) + j;
                }
                else if (j === uSpan) {
                    degenerate_right_index = (i + 1) * (uSpan + 1) + j;
                }
            }
            indices.push(degenerate_right_index);
            indices.push(degenerate_left_index);
        }
        var normals = [];
        for (let i = 0; i <= vSpan; i++) {
            for (let j = 0; j <= uSpan; j++) {
                normals.push(0);
                normals.push(1);
                normals.push(0);
            }
        }
        var texcoords = [];
        for (let i = 0; i <= vSpan; i++) {
            const i_ = flipTextureCoordinateY ? i : vSpan - i;
            for (let j = 0; j <= uSpan; j++) {
                if (isUVRepeat) {
                    texcoords.push(j);
                    texcoords.push(i_);
                }
                else {
                    texcoords.push(j / uSpan);
                    texcoords.push(i_ / vSpan);
                }
            }
        }
        // Check Size
        const attributeCompositionTypes = [_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Vec3, _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Vec3, _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Vec2];
        const attributeSemantics = [_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_2__["VertexAttribute"].Position, _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_2__["VertexAttribute"].Normal, _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_2__["VertexAttribute"].Texcoord0];
        const primitiveMode = _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_3__["PrimitiveMode"].TriangleStrip;
        const attributes = [new Float32Array(positions), new Float32Array(normals), new Float32Array(texcoords)];
        let sumOfAttributesByteSize = 0;
        attributes.forEach(attribute => {
            sumOfAttributesByteSize += attribute.byteLength;
        });
        const indexSizeInByte = indices.length * 2;
        // Create Buffer
        const buffer = _core_MemoryManager__WEBPACK_IMPORTED_MODULE_4__["default"].getInstance().createBufferOnDemand(indexSizeInByte + sumOfAttributesByteSize, this);
        // Index Buffer
        const indicesBufferView = buffer.takeBufferView({ byteLengthToNeed: indexSizeInByte /*byte*/, byteStride: 0, isAoS: false });
        const indicesAccessor = indicesBufferView.takeAccessor({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Scalar,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].UnsignedShort,
            count: indices.length
        });
        for (let i = 0; i < indices.length; i++) {
            indicesAccessor.setScalar(i, indices[i], {});
        }
        // VertexBuffer
        const attributesBufferView = buffer.takeBufferView({ byteLengthToNeed: sumOfAttributesByteSize, byteStride: 0, isAoS: false });
        const attributeAccessors = [];
        const attributeComponentTypes = [];
        attributes.forEach((attribute, i) => {
            attributeComponentTypes[i] = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].fromTypedArray(attributes[i]);
            const accessor = attributesBufferView.takeAccessor({
                compositionType: attributeCompositionTypes[i],
                componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].fromTypedArray(attributes[i]),
                count: attribute.byteLength / attributeCompositionTypes[i].getNumberOfComponents() / attributeComponentTypes[i].getSizeInBytes()
            });
            accessor.copyFromTypedArray(attribute);
            attributeAccessors.push(accessor);
        });
        const attributeMap = new Map();
        for (let i = 0; i < attributeSemantics.length; i++) {
            attributeMap.set(attributeSemantics[i], attributeAccessors[i]);
        }
        this.setData(attributeMap, primitiveMode, material, indicesAccessor);
    }
}


/***/ }),

/***/ "./src/foundation/geometry/Primitive.ts":
/*!**********************************************!*\
  !*** ./src/foundation/geometry/Primitive.ts ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Primitive; });
/* harmony import */ var _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../definitions/PrimitiveMode */ "./src/foundation/definitions/PrimitiveMode.ts");
/* harmony import */ var _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _core_MemoryManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _math_AABB__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/AABB */ "./src/foundation/math/AABB.ts");
/* harmony import */ var _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/MaterialHelper */ "./src/foundation/helpers/MaterialHelper.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../math/MutableMatrix33 */ "./src/foundation/math/MutableMatrix33.ts");
/* harmony import */ var _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");












class Primitive extends _core_RnObject__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super();
        this.__mode = _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_0__["PrimitiveMode"].Unknown;
        this.__material = _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_7__["default"].createEmptyMaterial();
        this._prevMaterial = _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_7__["default"].createEmptyMaterial();
        this.__attributes = new Map();
        this.__primitiveUid = -1; // start ID from zero
        this.__aabb = new _math_AABB__WEBPACK_IMPORTED_MODULE_6__["default"]();
        this.__targets = [];
        this.__inverseArenbergMatrix = [];
        this.__arenberg3rdPosition = [];
    }
    set material(mat) {
        this.__material = mat;
    }
    get material() {
        return this.__material;
    }
    _backupMaterial() {
        this._prevMaterial = this.__material;
    }
    _restoreMaterial() {
        this.__material = this._prevMaterial;
    }
    setData(attributes, mode, material, indicesAccessor) {
        this.__indices = indicesAccessor;
        this.__attributes = attributes;
        if (material != null) {
            this.material = material;
        }
        else {
            this.material = _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_7__["default"].createClassicUberMaterial({ isSkinning: true, isLighting: true });
        }
        this.__mode = mode;
        this.__primitiveUid = Primitive.__primitiveCount++;
        // if (Primitive.__headerAccessor == null) {
        //   // primitive 0
        //   // prim0.indices.byteOffset, prim0.indices.componentSizeInByte, prim0.indices.indicesLength, null
        //   //   prim0.attrb0.byteOffset, prim0.attrib0.byteStride, prim0.attrib0.compositionN, prim0.attrib0.componentSizeInByte
        //   //   prim0.attrb1.byteOffset, prim0.attrib1.byteStride, prim0.attrib1.compositionN, prim0.attrib1.componentSizeInByte
        //   //   ...
        //   //   prim0.attrb7.byteOffset, prim0.attrib7.byteStride, prim0.attrib7.compositionN, prim0.attrib7.componentSizeInByte
        //   // primitive 1
        //   // prim1.indices.byteOffset, prim1.indices.componentSizeInByte, prim0.indices.indicesLength, null
        //   //   prim1.attrb0.byteOffset, prim1.attrib0.byteStride, prim1.attrib0.compositionN, prim1.attrib0.componentSizeInByte
        //   //   prim1.attrb1.byteOffset, prim1.attrib1.byteStride, prim1.attrib1.compositionN, prim1.attrib1.componentSizeInByte
        //   //   ...
        //   //   prim1.attrb7.byteOffset, prim1.attrib7.byteStride, prim1.attrib7.compositionN, prim1.attrib7.componentSizeInByte
        //   const buffer = MemoryManager.getInstance().createOrGetBuffer(BufferUse.UBOGeneric);
        //   const bufferView = buffer.takeBufferView({byteLengthToNeed: ((1*4) + (8*4)) * 4/*byte*/ * Primitive.maxPrimitiveCount, byteStride: 64, isAoS:false });
        //   Primitive.__headerAccessor = bufferView.takeAccessor(
        //     {compositionType: CompositionType.Vec4, componentType: ComponentType.Float, count: 9 * Primitive.maxPrimitiveCount})
        // }
        // const attributeNumOfPrimitive = 1/*indices*/ + 8/*vertexAttributes*/;
        // if (this.indicesAccessor != null) {
        //   Primitive.__headerAccessor.setVec4(attributeNumOfPrimitive * this.__primitiveUid + 0 /* 0 means indices */,
        //     this.indicesAccessor.byteOffsetInBuffer, this.indicesAccessor.componentSizeInBytes, this.indicesAccessor.byteLength / this.indicesAccessor.componentSizeInBytes, -1 );
        // } else {
        //   Primitive.__headerAccessor.setVec4(attributeNumOfPrimitive * this.__primitiveUid + 0 /* 0 means indices */, -1, -1, -1, -1 );
        // }
        // this.attributeAccessors.forEach((attributeAccessor, i)=>{
        //   Primitive.__headerAccessor!.setVec4(attributeNumOfPrimitive * this.__primitiveUid + i,
        //     attributeAccessor.byteOffsetInBuffer, attributeAccessor.byteStride, attributeAccessor.numberOfComponents, attributeAccessor.componentSizeInBytes);
        // });
    }
    static get maxPrimitiveCount() {
        return 500;
    }
    static get headerAccessor() {
        return this.__headerAccessor;
    }
    static createPrimitive({ indices, attributeCompositionTypes, attributeSemantics, attributes, material, primitiveMode }) {
        let sumOfAttributesByteSize = 0;
        attributes.forEach(attribute => {
            sumOfAttributesByteSize += attribute.byteLength;
        });
        let bufferSize = sumOfAttributesByteSize;
        if (indices != null) {
            bufferSize += indices.byteLength;
        }
        const primitive = new Primitive();
        const buffer = _core_MemoryManager__WEBPACK_IMPORTED_MODULE_4__["default"].getInstance().createBufferOnDemand(bufferSize, primitive);
        let indicesComponentType;
        let indicesBufferView;
        let indicesAccessor;
        if (indices != null) {
            indicesComponentType = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].fromTypedArray(indices);
            indicesBufferView = buffer.takeBufferView({ byteLengthToNeed: indices.byteLength, byteStride: 0, isAoS: false });
            indicesAccessor = indicesBufferView.takeAccessor({
                compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_5__["CompositionType"].Scalar,
                componentType: indicesComponentType,
                count: indices.byteLength / indicesComponentType.getSizeInBytes()
            });
            // copy indices
            for (let i = 0; i < indices.byteLength / indicesAccessor.componentSizeInBytes; i++) {
                indicesAccessor.setScalar(i, indices[i], {});
            }
        }
        const attributesBufferView = buffer.takeBufferView({ byteLengthToNeed: sumOfAttributesByteSize, byteStride: 0, isAoS: false });
        const attributeAccessors = [];
        const attributeComponentTypes = [];
        attributes.forEach((attribute, i) => {
            attributeComponentTypes[i] = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].fromTypedArray(attributes[i]);
            const accessor = attributesBufferView.takeAccessor({
                compositionType: attributeCompositionTypes[i],
                componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].fromTypedArray(attributes[i]),
                count: attribute.byteLength / attributeCompositionTypes[i].getNumberOfComponents() / attributeComponentTypes[i].getSizeInBytes()
            });
            accessor.copyFromTypedArray(attribute);
            attributeAccessors.push(accessor);
        });
        const attributeMap = new Map();
        for (let i = 0; i < attributeSemantics.length; i++) {
            attributeMap.set(attributeSemantics[i], attributeAccessors[i]);
        }
        primitive.setData(attributeMap, primitiveMode, material, indicesAccessor);
        return primitive;
    }
    get indicesAccessor() {
        return this.__indices;
    }
    getVertexCountAsIndicesBased() {
        if (this.indicesAccessor) {
            return this.indicesAccessor.elementCount;
        }
        else {
            return this.getVertexCountAsVerticesBased();
        }
    }
    getVertexCountAsVerticesBased() {
        const positionAccessor = this.__attributes.get(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].Position);
        return positionAccessor.elementCount;
    }
    getTriangleCountAsIndicesBased() {
        if (this.indicesAccessor) {
            switch (this.__mode) {
                case _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_0__["PrimitiveMode"].Triangles:
                    return this.indicesAccessor.elementCount / 3;
                case _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_0__["PrimitiveMode"].TriangleStrip:
                    return this.indicesAccessor.elementCount - 2;
                case _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_0__["PrimitiveMode"].TriangleFan:
                    return this.indicesAccessor.elementCount - 2;
                default:
                    return 0;
            }
        }
        else {
            return this.getTriangleCountAsVerticesBased();
        }
    }
    getTriangleCountAsVerticesBased() {
        const positionAccessor = this.__attributes.get(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].Position);
        switch (this.__mode) {
            case _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_0__["PrimitiveMode"].Triangles:
                return positionAccessor.elementCount / 3;
            case _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_0__["PrimitiveMode"].TriangleStrip:
                return positionAccessor.elementCount - 2;
            case _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_0__["PrimitiveMode"].TriangleFan:
                return positionAccessor.elementCount - 2;
            default:
                return 0;
        }
    }
    hasIndices() {
        return this.__indices != null;
    }
    get attributeAccessors() {
        const accessors = [];
        this.__attributes.forEach((accessor, semantic) => {
            accessors.push(accessor);
        });
        return accessors;
    }
    getAttribute(semantic) {
        return this.__attributes.get(semantic);
    }
    get attributeSemantics() {
        const semantics = [];
        this.__attributes.forEach((accessor, semantic) => {
            semantics.push(semantic);
        });
        return semantics;
    }
    get attributeEntries() {
        return this.__attributes.entries();
    }
    get attributeCompositionTypes() {
        const types = [];
        this.__attributes.forEach((accessor, semantic) => {
            types.push(accessor.compositionType);
        });
        return types;
    }
    get attributeComponentTypes() {
        const types = [];
        this.__attributes.forEach((accessor, semantic) => {
            types.push(accessor.componentType);
        });
        return types;
    }
    get primitiveMode() {
        return this.__mode;
    }
    get primitiveUid() {
        return this.__primitiveUid;
    }
    get AABB() {
        if (this.__aabb.isVanilla()) {
            const positionAccessor = this.__attributes.get(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].Position);
            if (positionAccessor.min == null || positionAccessor.max == null) {
                positionAccessor.calcMinMax();
            }
            const min = positionAccessor.min;
            this.__aabb.minPoint = Primitive.__tmpVec3_0.setComponents(min[0], min[1], min[2]);
            const max = positionAccessor.max;
            this.__aabb.maxPoint = Primitive.__tmpVec3_0.setComponents(max[0], max[1], max[2]);
        }
        return this.__aabb;
    }
    setVertexAttribute(accessor, vertexSemantics) {
        this.__attributes.set(vertexSemantics, accessor);
    }
    removeIndices() {
        this.__indices = undefined;
    }
    setIndices(accessor) {
        this.__indices = accessor;
    }
    setTargets(targets) {
        this.__targets = targets;
    }
    get targets() {
        return this.__targets;
    }
    isBlend() {
        if (this.material == null || !this.material.isBlend()) {
            return false;
        }
        else {
            return true;
        }
    }
    isOpaque() {
        return !this.isBlend();
    }
    create3DAPIVertexData() {
        if (this.__vertexHandles != null) {
            return false;
        }
        const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__["default"].getWebGLResourceRepository();
        this.__vertexHandles = webglResourceRepository.createVertexBufferAndIndexBuffer(this);
        return true;
    }
    delete3DAPIVertexData() {
        if (this.__vertexHandles == null) {
            return false;
        }
        const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_8__["default"].getWebGLResourceRepository();
        webglResourceRepository.deleteVertexDataResources(this.__vertexHandles);
        return true;
    }
    get vertexHandles() {
        return this.__vertexHandles;
    }
    castRay(origVec3, dirVec3, isFrontFacePickable, isBackFacePickable, dotThreshold, hasFaceNormal) {
        let currentShortestT = Number.MAX_VALUE;
        let currentShortestIntersectedPosVec3 = null;
        const positionAccessor = this.__attributes.get(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].Position);
        // const positionElementNumPerVertex = this._vertices.components.position;
        let incrementNum = 3; // gl.TRIANGLES
        if (this.__mode === _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_0__["PrimitiveMode"].TriangleStrip) {
            // gl.TRIANGLE_STRIP
            incrementNum = 1;
        }
        else if (this.__mode === _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_0__["PrimitiveMode"].Points) {
            return { currentShortestIntersectedPosVec3, currentShortestT };
        }
        if (this.hasIndices()) {
            for (let i = 0; i < this.__indices.elementCount - 2; i++) {
                const j = i * incrementNum;
                if (j + 2 > this.__indices.elementCount - 1) {
                    // gl.TRIANGLES
                    break;
                }
                let pos0IndexBase = this.__indices.getScalar(j, {});
                let pos1IndexBase = this.__indices.getScalar(j + 1, {});
                let pos2IndexBase = this.__indices.getScalar(j + 2, {});
                const result = this.__castRayInner(origVec3, dirVec3, i, pos0IndexBase, pos1IndexBase, pos2IndexBase, isFrontFacePickable, isBackFacePickable, dotThreshold, hasFaceNormal);
                if (result === null) {
                    continue;
                }
                const t = result[0];
                if (result[0] < currentShortestT) {
                    currentShortestT = t;
                    currentShortestIntersectedPosVec3 = result[1];
                }
            }
        }
        else {
            for (let i = 0; i < positionAccessor.elementCount; i += incrementNum) {
                const pos0IndexBase = i;
                const pos1IndexBase = i + 1;
                const pos2IndexBase = i + 2;
                const result = this.__castRayInner(origVec3, dirVec3, i, pos0IndexBase, pos1IndexBase, pos2IndexBase, isFrontFacePickable, isBackFacePickable, dotThreshold, hasFaceNormal);
                if (result === null) {
                    continue;
                }
                const t = result[0];
                if (result[0] < currentShortestT) {
                    currentShortestT = t;
                    currentShortestIntersectedPosVec3 = result[1];
                }
            }
        }
        return { currentShortestIntersectedPosVec3, currentShortestT };
    }
    __castRayInner(origVec3, dirVec3, i, pos0IndexBase, pos1IndexBase, pos2IndexBase, isFrontFacePickable, isBackFacePickable, dotThreshold, hasFaceNormal) {
        if (!this.__arenberg3rdPosition[i]) {
            return null;
        }
        if (hasFaceNormal) {
            const normalAccessor = this.__attributes.get(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].Normal);
            if (normalAccessor) {
                const normal = normalAccessor.getVec3(i, {});
                if (normal.dot(dirVec3) < dotThreshold && !isFrontFacePickable) {
                    return null;
                }
                if (normal.dot(dirVec3) > -dotThreshold && !isBackFacePickable) {
                    return null;
                }
            }
        }
        const vec3 = _math_Vector3__WEBPACK_IMPORTED_MODULE_9__["default"].subtract(origVec3, this.__arenberg3rdPosition[i]);
        const convertedOrigVec3 = this.__inverseArenbergMatrix[i].multiplyVector(vec3);
        const convertedDirVec3 = this.__inverseArenbergMatrix[i].multiplyVector(dirVec3);
        if (convertedDirVec3.z >= -1e-6 && convertedDirVec3.z <= 1e-6) {
            return null;
        }
        const t = -convertedOrigVec3.z / convertedDirVec3.z;
        if (t <= 1e-5) {
            return null;
        }
        const u = convertedOrigVec3.x + t * convertedDirVec3.x;
        const v = convertedOrigVec3.y + t * convertedDirVec3.y;
        if (u < 0.0 || v < 0.0 || u + v > 1.0) {
            return null;
        }
        const fDat = 1.0 - u - v;
        const positionAccessor = this.__attributes.get(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].Position);
        const pos0Vec3 = positionAccessor.getVec3(pos0IndexBase, {});
        const pos1Vec3 = positionAccessor.getVec3(pos1IndexBase, {});
        const pos2Vec3 = positionAccessor.getVec3(pos2IndexBase, {});
        const pos0 = _math_Vector3__WEBPACK_IMPORTED_MODULE_9__["default"].multiply(pos0Vec3, u);
        const pos1 = _math_Vector3__WEBPACK_IMPORTED_MODULE_9__["default"].multiply(pos1Vec3, v);
        const pos2 = _math_Vector3__WEBPACK_IMPORTED_MODULE_9__["default"].multiply(pos2Vec3, fDat);
        const intersectedPosVec3 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].zero().add(pos0).add(pos1).add(pos2);
        return [t, intersectedPosVec3];
    }
    _calcArenbergInverseMatrices() {
        if (this.__inverseArenbergMatrix.length != 0) {
            return;
        }
        const positionAccessor = this.__attributes.get(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].Position);
        let incrementNum = 3; // gl.TRIANGLES
        if (this.__mode === _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_0__["PrimitiveMode"].TriangleStrip) {
            // gl.TRIANGLE_STRIP
            incrementNum = 1;
        }
        else if (this.__mode === _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_0__["PrimitiveMode"].Points) {
            return;
        }
        if (this.hasIndices()) {
            for (let i = 0; i < this.__indices.elementCount - 2; i++) {
                const j = i * incrementNum;
                if (j + 2 > this.__indices.elementCount - 1) {
                    // gl.TRIANGLES
                    break;
                }
                let pos0IndexBase = this.__indices.getScalar(j, {});
                let pos1IndexBase = this.__indices.getScalar(j + 1, {});
                let pos2IndexBase = this.__indices.getScalar(j + 2, {});
                this._calcArenbergMatrixFor3Vertices(i, pos0IndexBase, pos1IndexBase, pos2IndexBase);
            }
        }
        else {
            for (let i = 0; i < positionAccessor.elementCount - 2; i += incrementNum) {
                const pos0IndexBase = i;
                const pos1IndexBase = i + 1;
                const pos2IndexBase = i + 2;
                this._calcArenbergMatrixFor3Vertices(i, pos0IndexBase, pos1IndexBase, pos2IndexBase);
            }
        }
    }
    _calcArenbergMatrixFor3Vertices(i, pos0IndexBase, pos1IndexBase, pos2IndexBase) {
        const positionAccessor = this.__attributes.get(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].Position);
        const pos0Vec3 = positionAccessor.getVec3(pos0IndexBase, {});
        const pos1Vec3 = positionAccessor.getVec3(pos1IndexBase, {});
        const pos2Vec3 = positionAccessor.getVec3(pos2IndexBase, {});
        const ax = pos0Vec3.x - pos2Vec3.x;
        const ay = pos0Vec3.y - pos2Vec3.y;
        const az = pos0Vec3.z - pos2Vec3.z;
        const bx = pos1Vec3.x - pos2Vec3.x;
        const by = pos1Vec3.y - pos2Vec3.y;
        const bz = pos1Vec3.z - pos2Vec3.z;
        let nx = ay * bz - az * by;
        let ny = az * bx - ax * bz;
        let nz = ax * by - ay * bx;
        let da = Math.sqrt(nx * nx + ny * ny + nz * nz);
        if (da <= 1e-6) {
            da = 0.0001;
        }
        da = 1.0 / da;
        nx *= da;
        ny *= da;
        nz *= da;
        const arenbergMatrix = new _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_10__["default"](pos0Vec3.x - pos2Vec3.x, pos1Vec3.x - pos2Vec3.x, nx - pos2Vec3.x, pos0Vec3.y - pos2Vec3.y, pos1Vec3.y - pos2Vec3.y, ny - pos2Vec3.y, pos0Vec3.z - pos2Vec3.z, pos1Vec3.z - pos2Vec3.z, nz - pos2Vec3.z);
        const inverseArenbergMatrix = arenbergMatrix.invert();
        this.__inverseArenbergMatrix[i] = inverseArenbergMatrix;
        this.__arenberg3rdPosition[i] = pos2Vec3;
    }
}
Primitive.__primitiveCount = 0;
Primitive.__tmpVec3_0 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_11__["default"].zero();


/***/ }),

/***/ "./src/foundation/geometry/Sphere.ts":
/*!*******************************************!*\
  !*** ./src/foundation/geometry/Sphere.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Sphere; });
/* harmony import */ var _Primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Primitive */ "./src/foundation/geometry/Primitive.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/PrimitiveMode */ "./src/foundation/definitions/PrimitiveMode.ts");
/* harmony import */ var _core_MemoryManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");







class Sphere extends _Primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    generate({ radius, widthSegments, heightSegments, material }) {
        var positions = [];
        var texcoords = [];
        var normals = [];
        let shiftValue = 0.00001; // for avoid Singular point
        for (var latNumber = 0; latNumber <= heightSegments; latNumber++) {
            var theta = latNumber * Math.PI / heightSegments + shiftValue;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            for (var longNumber = 0; longNumber <= widthSegments; longNumber++) {
                var phi = longNumber * 2 * Math.PI / widthSegments;
                var sinPhi = Math.sin(phi);
                var cosPhi = Math.cos(phi);
                var x = radius * cosPhi * sinTheta;
                var y = radius * cosTheta;
                var z = radius * sinPhi * sinTheta;
                var position = new _math_Vector3__WEBPACK_IMPORTED_MODULE_6__["default"](x, y, z);
                positions.push(x);
                positions.push(y);
                positions.push(z);
                var u = 1 - (longNumber / widthSegments);
                var v = latNumber / heightSegments;
                texcoords.push(u);
                texcoords.push(v);
                const normal = _math_Vector3__WEBPACK_IMPORTED_MODULE_6__["default"].normalize(position);
                normals.push(normal.x);
                normals.push(normal.y);
                normals.push(normal.z);
            }
        }
        // first    first+1
        //    +-------+
        //    |     / |
        //    |   /   |
        //    | /     |
        //    +-------+
        // second   second+1
        //
        var indices = [];
        for (var latNumber = 0; latNumber < heightSegments; latNumber++) {
            for (var longNumber = 0; longNumber < widthSegments; longNumber++) {
                var first = (latNumber * (widthSegments + 1)) + longNumber;
                var second = first + widthSegments + 1;
                indices.push(first + 1);
                indices.push(second);
                indices.push(first);
                indices.push(first + 1);
                indices.push(second + 1);
                indices.push(second);
            }
        }
        const attributeCompositionTypes = [_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Vec3, _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Vec3, _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Vec2];
        const attributeSemantics = [_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_2__["VertexAttribute"].Position, _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_2__["VertexAttribute"].Normal, _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_2__["VertexAttribute"].Texcoord0];
        const primitiveMode = _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_3__["PrimitiveMode"].Triangles;
        const attributes = [new Float32Array(positions), new Float32Array(normals), new Float32Array(texcoords)];
        let sumOfAttributesByteSize = 0;
        attributes.forEach(attribute => {
            sumOfAttributesByteSize += attribute.byteLength;
        });
        const indexSizeInByte = indices.length * 2;
        const buffer = _core_MemoryManager__WEBPACK_IMPORTED_MODULE_4__["default"].getInstance().createBufferOnDemand(indexSizeInByte + sumOfAttributesByteSize, this);
        const indicesBufferView = buffer.takeBufferView({ byteLengthToNeed: indexSizeInByte /*byte*/, byteStride: 0, isAoS: false });
        const indicesAccessor = indicesBufferView.takeAccessor({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Scalar,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].UnsignedShort,
            count: indices.length
        });
        for (let i = 0; i < indices.length; i++) {
            indicesAccessor.setScalar(i, indices[i], {});
        }
        const attributesBufferView = buffer.takeBufferView({ byteLengthToNeed: sumOfAttributesByteSize, byteStride: 0, isAoS: false });
        const attributeAccessors = [];
        const attributeComponentTypes = [];
        attributes.forEach((attribute, i) => {
            attributeComponentTypes[i] = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].fromTypedArray(attributes[i]);
            const accessor = attributesBufferView.takeAccessor({
                compositionType: attributeCompositionTypes[i],
                componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].fromTypedArray(attributes[i]),
                count: attribute.byteLength / attributeCompositionTypes[i].getNumberOfComponents() / attributeComponentTypes[i].getSizeInBytes()
            });
            accessor.copyFromTypedArray(attribute);
            attributeAccessors.push(accessor);
        });
        const attributeMap = new Map();
        for (let i = 0; i < attributeSemantics.length; i++) {
            attributeMap.set(attributeSemantics[i], attributeAccessors[i]);
        }
        this.setData(attributeMap, primitiveMode, material, indicesAccessor);
    }
}


/***/ }),

/***/ "./src/foundation/gizmos/AABBGizmo.ts":
/*!********************************************!*\
  !*** ./src/foundation/gizmos/AABBGizmo.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AABBGizmo; });
/* harmony import */ var _Gizmo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Gizmo */ "./src/foundation/gizmos/Gizmo.ts");
/* harmony import */ var _components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/TransformComponent */ "./src/foundation/components/TransformComponent.ts");
/* harmony import */ var _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _components_MeshComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/MeshComponent */ "./src/foundation/components/MeshComponent.ts");
/* harmony import */ var _components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/MeshRendererComponent */ "./src/foundation/components/MeshRendererComponent.ts");
/* harmony import */ var _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../definitions/PrimitiveMode */ "./src/foundation/definitions/PrimitiveMode.ts");
/* harmony import */ var _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _geometry_Primitive__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geometry/Primitive */ "./src/foundation/geometry/Primitive.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _geometry_Mesh__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geometry/Mesh */ "./src/foundation/geometry/Mesh.ts");











class AABBGizmo extends _Gizmo__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(substance) {
        super(substance);
    }
    get isSetup() {
        if (this.__topEntity != null) {
            return true;
        }
        else {
            return false;
        }
    }
    setup() {
        if (this.isSetup) {
            return;
        }
        this.__topEntity = this.__entityRepository.createEntity([_components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__["default"], _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_2__["default"], _components_MeshComponent__WEBPACK_IMPORTED_MODULE_3__["default"], _components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_4__["default"]]);
        const meshComponent = this.__topEntity.getMesh();
        // if (AABBGizmo.__aabbMesh == null) {
        AABBGizmo.__aabbMesh = new _geometry_Mesh__WEBPACK_IMPORTED_MODULE_10__["default"]();
        AABBGizmo.__aabbMesh.addPrimitive(AABBGizmo.generatePrimitive());
        meshComponent.setMesh(AABBGizmo.__aabbMesh);
        // } else {
        //   const mesh = new Mesh();
        //   mesh.setOriginalMesh(AABBGizmo.__aabbMesh);
        //   meshComponent.setMesh(mesh);
        // }
        this.setGizmoTag();
    }
    static generatePrimitive() {
        const indices = new Uint32Array([
            0, 1, 2, 3,
            4, 5, 6, 7,
            3, 0, 4, 7,
            2, 1, 5, 6,
            3, 2, 6, 7,
            0, 1, 5, 4
        ]);
        const length = 1;
        const positions = new Float32Array([
            -length, -length, -length,
            length, -length, -length,
            length, length, -length,
            -length, length, -length,
            -length, -length, length,
            length, -length, length,
            length, length, length,
            -length, length, length
        ]);
        const primitive = _geometry_Primitive__WEBPACK_IMPORTED_MODULE_8__["default"].createPrimitive({
            indices: indices,
            attributeCompositionTypes: [_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Vec3],
            attributeSemantics: [_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_6__["VertexAttribute"].Position],
            attributes: [positions],
            primitiveMode: _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_5__["PrimitiveMode"].LineLoop
        });
        return primitive;
    }
    update() {
        if (this.__topEntity == null) {
            return;
        }
        const sg = this.__substance;
        const aabb = sg.worldAABB;
        this.__topEntity.getTransform().translate = aabb.centerPoint;
        this.__topEntity.getTransform().scale = new _math_Vector3__WEBPACK_IMPORTED_MODULE_9__["default"](aabb.sizeX / 2, aabb.sizeY / 2, aabb.sizeZ / 2);
    }
}


/***/ }),

/***/ "./src/foundation/gizmos/Gizmo.ts":
/*!****************************************!*\
  !*** ./src/foundation/gizmos/Gizmo.ts ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Gizmo; });
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _core_EntityRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/EntityRepository */ "./src/foundation/core/EntityRepository.ts");



class Gizmo extends _core_RnObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(substance) {
        super();
        this.__entityRepository = _core_EntityRepository__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance();
        this.__isVisible = false;
        this.__substance = substance;
        this.setGizmoTag();
    }
    setGizmoTag() {
        if (this.__topEntity) {
            const sceneGraphs = _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_1__["default"].flattenHierarchy(this.__topEntity.getSceneGraph(), false);
            for (let sg of sceneGraphs) {
                sg.entity.tryToSetTag({ tag: 'Being', value: 'gizmo' });
            }
        }
    }
    set isVisible(flg) {
        this.__isVisible = flg;
        if (this.__topEntity) {
            this.__topEntity.getSceneGraph().setVisibilityRecursively(flg);
        }
    }
    get isVisible() {
        return this.__isVisible;
    }
}


/***/ }),

/***/ "./src/foundation/helpers/EntityHelper.ts":
/*!************************************************!*\
  !*** ./src/foundation/helpers/EntityHelper.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EntityRepository */ "./src/foundation/core/EntityRepository.ts");
/* harmony import */ var _components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/TransformComponent */ "./src/foundation/components/TransformComponent.ts");
/* harmony import */ var _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _components_MeshComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/MeshComponent */ "./src/foundation/components/MeshComponent.ts");
/* harmony import */ var _components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/MeshRendererComponent */ "./src/foundation/components/MeshRendererComponent.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _components_CameraControllerComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/CameraControllerComponent */ "./src/foundation/components/CameraControllerComponent.ts");







function createGroupEntity() {
    return _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance().createEntity([_components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__["default"], _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_2__["default"]]);
}
function createMeshEntity() {
    return _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance().createEntity([_components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__["default"], _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_2__["default"], _components_MeshComponent__WEBPACK_IMPORTED_MODULE_3__["default"], _components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_4__["default"]]);
}
function createCameraEntity() {
    return _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance().createEntity([_components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__["default"], _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_2__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_5__["default"]]);
}
function createCameraWithControllerEntity() {
    return _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance().createEntity([_components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__["default"], _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_2__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_5__["default"], _components_CameraControllerComponent__WEBPACK_IMPORTED_MODULE_6__["default"]]);
}
/* harmony default export */ __webpack_exports__["default"] = (Object.freeze({ createGroupEntity, createMeshEntity, createCameraEntity, createCameraWithControllerEntity }));


/***/ }),

/***/ "./src/foundation/helpers/MaterialHelper.ts":
/*!**************************************************!*\
  !*** ./src/foundation/helpers/MaterialHelper.ts ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _materials_core_Material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../materials/core/Material */ "./src/foundation/materials/core/Material.ts");
/* harmony import */ var _materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../materials/singles/PbrShadingSingleMaterialNode */ "./src/foundation/materials/singles/PbrShadingSingleMaterialNode.ts");
/* harmony import */ var _materials_singles_ClassicShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../materials/singles/ClassicShadingSingleMaterialNode */ "./src/foundation/materials/singles/ClassicShadingSingleMaterialNode.ts");
/* harmony import */ var _materials_singles_EnvConstantSingleMaterialNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../materials/singles/EnvConstantSingleMaterialNode */ "./src/foundation/materials/singles/EnvConstantSingleMaterialNode.ts");
/* harmony import */ var _materials_singles_FXAA3QualitySingleMaterialNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../materials/singles/FXAA3QualitySingleMaterialNode */ "./src/foundation/materials/singles/FXAA3QualitySingleMaterialNode.ts");
/* harmony import */ var _materials_singles_DepthEncodeSingleMaterialNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../materials/singles/DepthEncodeSingleMaterialNode */ "./src/foundation/materials/singles/DepthEncodeSingleMaterialNode.ts");
/* harmony import */ var _materials_singles_ShadowMapDecodeClassicSingleMaterialNode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../materials/singles/ShadowMapDecodeClassicSingleMaterialNode */ "./src/foundation/materials/singles/ShadowMapDecodeClassicSingleMaterialNode.ts");
/* harmony import */ var _materials_singles_GammaCorrectionSingleMaterialNode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../materials/singles/GammaCorrectionSingleMaterialNode */ "./src/foundation/materials/singles/GammaCorrectionSingleMaterialNode.ts");
/* harmony import */ var _materials_singles_EntityUIDOutputSingleMaterialNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../materials/singles/EntityUIDOutputSingleMaterialNode */ "./src/foundation/materials/singles/EntityUIDOutputSingleMaterialNode.ts");
/* harmony import */ var _materials_singles_MToonSingleMaterialNode__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../materials/singles/MToonSingleMaterialNode */ "./src/foundation/materials/singles/MToonSingleMaterialNode.ts");
/* harmony import */ var _webgl_shaderity_shaders_classicSingleShader_classicSingleShader_vert__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../webgl/shaderity_shaders/classicSingleShader/classicSingleShader.vert */ "./src/webgl/shaderity_shaders/classicSingleShader/classicSingleShader.vert");
/* harmony import */ var _webgl_shaderity_shaders_classicSingleShader_classicSingleShader_frag__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../webgl/shaderity_shaders/classicSingleShader/classicSingleShader.frag */ "./src/webgl/shaderity_shaders/classicSingleShader/classicSingleShader.frag");
/* harmony import */ var _materials_singles_CustomSingleMaterialNode__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../materials/singles/CustomSingleMaterialNode */ "./src/foundation/materials/singles/CustomSingleMaterialNode.ts");
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../definitions/AlphaMode */ "./src/foundation/definitions/AlphaMode.ts");
















function createMaterial(materialName, materialNodes, maxInstancesNumber) {
    const isRegistMaterialType = _materials_core_Material__WEBPACK_IMPORTED_MODULE_1__["default"].isRegisteredMaterialType(materialName);
    if (!isRegistMaterialType) {
        _materials_core_Material__WEBPACK_IMPORTED_MODULE_1__["default"].registerMaterial(materialName, materialNodes, maxInstancesNumber);
    }
    const material = _materials_core_Material__WEBPACK_IMPORTED_MODULE_1__["default"].createMaterial(materialName, materialNodes);
    return material;
}
function recreateMaterial(materialName, materialNodes, maxInstancesNumber) {
    _materials_core_Material__WEBPACK_IMPORTED_MODULE_1__["default"].forceRegisterMaterial(materialName, materialNodes, maxInstancesNumber);
    const material = _materials_core_Material__WEBPACK_IMPORTED_MODULE_1__["default"].createMaterial(materialName, materialNodes);
    return material;
}
function createEmptyMaterial() {
    const materialName = 'Empty';
    const material = createMaterial(materialName, [], _core_Config__WEBPACK_IMPORTED_MODULE_0__["default"].maxMaterialInstanceForEachType);
    material.tryToSetUniqueName('EmptyMaterial', true);
    return material;
}
function createPbrUberMaterial({ additionalName = '', isMorphing = false, isSkinning = false, isLighting = false, alphaMode = _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_15__["AlphaMode"].Opaque, maxInstancesNumber = _core_Config__WEBPACK_IMPORTED_MODULE_0__["default"].maxMaterialInstanceForEachType } = {}) {
    const materialName = 'PbrUber'
        + `_${additionalName}_`
        + (isMorphing ? '+morphing' : '')
        + (isSkinning ? '+skinning' : '')
        + (isLighting ? '' : '-lighting')
        + ' alpha_' + alphaMode.str.toLowerCase();
    const materialNode = new _materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_2__["default"]({ isMorphing, isSkinning, isLighting, alphaMode });
    materialNode.isSingleOperation = true;
    const material = createMaterial(materialName, [materialNode], maxInstancesNumber);
    return material;
}
function createClassicUberMaterialOld({ additionalName = '', isSkinning = false, isLighting = false, alphaMode = _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_15__["AlphaMode"].Opaque, maxInstancesNumber = _core_Config__WEBPACK_IMPORTED_MODULE_0__["default"].maxMaterialInstanceForEachType } = {}) {
    const materialName = 'ClassicUberOld'
        + `_${additionalName}_`
        + (isSkinning ? '+skinning' : '')
        + (isLighting ? '' : '-lighting');
    const materialNode = new _materials_singles_ClassicShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_3__["default"]({ isSkinning, isLighting, alphaMode });
    materialNode.isSingleOperation = true;
    const material = createMaterial(materialName, [materialNode], maxInstancesNumber);
    return material;
}
function createClassicUberMaterial({ additionalName = '', isSkinning = true, isLighting = false, isMorphing = false, alphaMode = _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_15__["AlphaMode"].Opaque, maxInstancesNumber = _core_Config__WEBPACK_IMPORTED_MODULE_0__["default"].maxMaterialInstanceForEachType } = {}) {
    const materialName = 'ClassicUber'
        + `_${additionalName}_`
        + (isSkinning ? '+skinning' : '')
        + (isLighting ? '' : '-lighting')
        + ' alpha_' + alphaMode.str.toLowerCase();
    const materialNode = new _materials_singles_CustomSingleMaterialNode__WEBPACK_IMPORTED_MODULE_13__["default"]({
        name: 'ClassicUber', isSkinning, isLighting, isMorphing, alphaMode,
        vertexShader: _webgl_shaderity_shaders_classicSingleShader_classicSingleShader_vert__WEBPACK_IMPORTED_MODULE_11__["default"],
        pixelShader: _webgl_shaderity_shaders_classicSingleShader_classicSingleShader_frag__WEBPACK_IMPORTED_MODULE_12__["default"]
    });
    materialNode.isSingleOperation = true;
    const material = createMaterial(materialName, [materialNode], maxInstancesNumber);
    return material;
}
function createEnvConstantMaterial({ additionalName = '', maxInstancesNumber = 10 } = {}) {
    const materialName = 'EnvConstant' + `_${additionalName}`;
    const materialNode = new _materials_singles_EnvConstantSingleMaterialNode__WEBPACK_IMPORTED_MODULE_4__["default"]();
    materialNode.isSingleOperation = true;
    const material = createMaterial(materialName, [materialNode], maxInstancesNumber);
    return material;
}
function createFXAA3QualityMaterial({ additionalName = '', maxInstancesNumber = 1 } = {}) {
    const materialName = 'FXAA3Quality' + `_${additionalName}`;
    const materialNode = new _materials_singles_FXAA3QualitySingleMaterialNode__WEBPACK_IMPORTED_MODULE_5__["default"]();
    materialNode.isSingleOperation = true;
    const material = createMaterial(materialName, [materialNode], maxInstancesNumber);
    return material;
}
function createDepthEncodeMaterial({ additionalName = '', isSkinning = false, maxInstancesNumber = 10 } = {}) {
    const materialName = 'DepthEncode'
        + `_${additionalName}_`
        + (isSkinning ? '+skinning' : '');
    const materialNode = new _materials_singles_DepthEncodeSingleMaterialNode__WEBPACK_IMPORTED_MODULE_6__["default"]({ isSkinning });
    materialNode.isSingleOperation = true;
    const material = createMaterial(materialName, [materialNode], maxInstancesNumber);
    return material;
}
function createShadowMapDecodeClassicSingleMaterial({ additionalName = '', isMorphing = false, isSkinning = false, isLighting = true, isDebugging = false, colorAttachmentsNumber = 0, maxInstancesNumber = 20 } = {}, depthEncodeRenderPass) {
    const materialName = 'ShadowMapDecodeClassic'
        + `_${additionalName}_`
        + (isSkinning ? '+skinning' : '')
        + (isLighting ? '' : '-lighting');
    const materialNode = new _materials_singles_ShadowMapDecodeClassicSingleMaterialNode__WEBPACK_IMPORTED_MODULE_7__["default"]({
        isMorphing, isSkinning, isLighting, isDebugging, colorAttachmentsNumber
    }, depthEncodeRenderPass);
    materialNode.isSingleOperation = true;
    const material = createMaterial(materialName, [materialNode], maxInstancesNumber);
    return material;
}
function createGammaCorrectionMaterial({ additionalName = '', maxInstancesNumber = 1 } = {}) {
    const materialName = 'GammaCorrection' + `_${additionalName}`;
    const materialNode = new _materials_singles_GammaCorrectionSingleMaterialNode__WEBPACK_IMPORTED_MODULE_8__["default"]();
    materialNode.isSingleOperation = true;
    const material = createMaterial(materialName, [materialNode], maxInstancesNumber);
    return material;
}
function createEntityUIDOutputMaterial({ additionalName = '', maxInstancesNumber = 10 } = {}) {
    const materialName = 'EntityUIDOutput' + `_${additionalName}`;
    const materialNode = new _materials_singles_EntityUIDOutputSingleMaterialNode__WEBPACK_IMPORTED_MODULE_9__["default"]();
    materialNode.isSingleOperation = true;
    const material = createMaterial(materialName, [materialNode], maxInstancesNumber);
    return material;
}
function createMToonMaterial({ additionalName = '', isMorphing = false, isSkinning = false, isLighting = true, isOutline = false, materialProperties = undefined, textures = undefined, debugMode = undefined, maxInstancesNumber = _core_Config__WEBPACK_IMPORTED_MODULE_0__["default"].maxMaterialInstanceForEachType } = {}) {
    const materialName = 'MToon'
        + `_${additionalName}_`
        + (isMorphing ? '+morphing' : '')
        + (isSkinning ? '+skinning' : '')
        + (isLighting ? '-lighting' : '')
        + (isOutline ? '-outline' : '');
    const materialNode = new _materials_singles_MToonSingleMaterialNode__WEBPACK_IMPORTED_MODULE_10__["default"](isOutline, materialProperties, textures, isMorphing, isSkinning, isLighting, debugMode);
    materialNode.isSingleOperation = true;
    const material = createMaterial(materialName, [materialNode], maxInstancesNumber);
    materialNode.setMaterialParameters(material, isOutline);
    return material;
}
function recreateCustomMaterial(vertexShaderStr, pixelShaderStr, { additionalName = '', isSkinning = true, isLighting = false, isMorphing = false, alphaMode = _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_15__["AlphaMode"].Opaque, maxInstancesNumber = _core_Config__WEBPACK_IMPORTED_MODULE_0__["default"].maxMaterialInstanceForEachType } = {}) {
    const materialName = 'Custom'
        + `_${additionalName}_`
        + (isMorphing ? '+morphing' : '')
        + (isSkinning ? '+skinning' : '')
        + (isLighting ? '' : '-lighting')
        + ' alpha_' + alphaMode.str.toLowerCase();
    const materialNode = new _materials_singles_CustomSingleMaterialNode__WEBPACK_IMPORTED_MODULE_13__["default"]({
        name: materialName, isSkinning, isLighting, isMorphing, alphaMode,
        vertexShader: { code: vertexShaderStr, shaderStage: 'vertex' },
        pixelShader: { code: pixelShaderStr, shaderStage: 'fragment' }
    });
    materialNode.isSingleOperation = true;
    const material = recreateMaterial(materialName, [materialNode], maxInstancesNumber);
    return material;
}
function changeMaterial(entity, primitive, material) {
    const meshRendererComponent = entity.getMeshRenderer();
    primitive.material = material;
    meshRendererComponent.moveStageTo(_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_14__["ProcessStage"].Load);
}
/* harmony default export */ __webpack_exports__["default"] = (Object.freeze({
    createMaterial, recreateMaterial, recreateCustomMaterial,
    createEmptyMaterial, createClassicUberMaterial, createPbrUberMaterial, createEnvConstantMaterial, createFXAA3QualityMaterial, createDepthEncodeMaterial,
    createShadowMapDecodeClassicSingleMaterial, createGammaCorrectionMaterial, createEntityUIDOutputMaterial, createMToonMaterial, changeMaterial
}));


/***/ }),

/***/ "./src/foundation/helpers/RenderableHelper.ts":
/*!****************************************************!*\
  !*** ./src/foundation/helpers/RenderableHelper.ts ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderer_FrameBuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer/FrameBuffer */ "./src/foundation/renderer/FrameBuffer.ts");
/* harmony import */ var _textures_RenderTargetTexture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../textures/RenderTargetTexture */ "./src/foundation/textures/RenderTargetTexture.ts");
/* harmony import */ var _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../definitions/TextureParameter */ "./src/foundation/definitions/TextureParameter.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../definitions/PixelFormat */ "./src/foundation/definitions/PixelFormat.ts");
/* harmony import */ var _textures_RenderBuffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../textures/RenderBuffer */ "./src/foundation/textures/RenderBuffer.ts");






function createTexturesForRenderTarget(width, height, textureNum, { level = 0, internalFormat = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_4__["PixelFormat"].RGBA, format = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_4__["PixelFormat"].RGBA, type = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].UnsignedByte, magFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Linear, minFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Linear, wrapS = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].ClampToEdge, wrapT = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].ClampToEdge }) {
    const frameBuffer = new _renderer_FrameBuffer__WEBPACK_IMPORTED_MODULE_0__["default"]();
    frameBuffer.create(width, height);
    for (let i = 0; i < textureNum; i++) {
        const renderTargetTexture = new _textures_RenderTargetTexture__WEBPACK_IMPORTED_MODULE_1__["default"]();
        renderTargetTexture.create({ width, height, level, internalFormat, format, type, magFilter, minFilter, wrapS, wrapT });
        frameBuffer.setColorAttachmentAt(i, renderTargetTexture);
    }
    const renderBuffer = new _textures_RenderBuffer__WEBPACK_IMPORTED_MODULE_5__["default"]();
    renderBuffer.create(width, height, _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Depth16);
    frameBuffer.setDepthAttachment(renderBuffer);
    return frameBuffer;
}
/*
function createTexturesForRenderTarget(width: number, height:number, textureNum:number,
  {
    level = 0,
    internalFormat = PixelFormat.RGBA,
    format = PixelFormat.RGBA,
    type = ComponentType.UnsignedByte,
    magFilter = TextureParameter.Linear,
    minFilter = TextureParameter.Linear,
    wrapS = TextureParameter.ClampToEdge,
    wrapT = TextureParameter.ClampToEdge
  }) {
  const frameBuffer = new FrameBuffer();
  frameBuffer.create(width, height);

  for (let i=0; i<textureNum; i++) {
    const renderTargetTexture = new RenderTargetTexture();
    renderTargetTexture.create({width, height, level, internalFormat, format, type, magFilter, minFilter, wrapS, wrapT});
    frameBuffer.setColorAttachmentAt(i, renderTargetTexture);
  }



  let format = gl.DEPTH_COMPONENT;
  let internalFormat = gl.DEPTH_COMPONENT;
  let type = gl.UNSIGNED_INT;
  if (GLBoost.isThisGLVersion_2(gl)) {
    type = gl.UNSIGNED_INT;
    format = gl.DEPTH_COMPONENT;
    internalFormat = gl.DEPTH_COMPONENT24;
  } else if (glem.extDepthTex) {
    type = glem.extDepthTex.UNSIGNED_INT_24_8_WEBGL;
    format = gl.DEPTH_STENCIL;
    internalFormat = gl.DEPTH_STENCIL;
  }

  const depthTexture = new RenderTargetTexture();
  depthTexture.create({width: width, height: height, level: 0, internalFormat: TextureParameter.Depth16, format: TextureParameter.Depth16,
     type: ComponentType.Float, magFilter: TextureParameter.Linear, minFilter: TextureParameter.Linear, wrapS: TextureParameter.ClampToEdge, wrapT: TextureParameter.ClampToEdge});

  frameBuffer.setDepthAttachment(depthTexture);

  return frameBuffer;
}
*/
/* harmony default export */ __webpack_exports__["default"] = (Object.freeze({ createTexturesForRenderTarget }));


/***/ }),

/***/ "./src/foundation/importer/AnimationAssigner.ts":
/*!******************************************************!*\
  !*** ./src/foundation/importer/AnimationAssigner.ts ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationAssigner; });
/* harmony import */ var _ModelConverter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelConverter */ "./src/foundation/importer/ModelConverter.ts");
/* harmony import */ var _core_EntityRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/EntityRepository */ "./src/foundation/core/EntityRepository.ts");
/* harmony import */ var _components_AnimationComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/AnimationComponent */ "./src/foundation/components/AnimationComponent.ts");
/* harmony import */ var _definitions_AnimationInterpolation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/AnimationInterpolation */ "./src/foundation/definitions/AnimationInterpolation.ts");




class AnimationAssigner {
    constructor() {
    }
    assignAnimation(rootEntity, gltfModel, vrmModel, isSameSkeleton = false) {
        this.__setupAnimationForSameSkeleton(rootEntity, gltfModel, vrmModel, isSameSkeleton);
        return rootEntity;
    }
    /**
     * The static method to get singleton instance of this class.
     * @return The singleton instance of ModelConverter class
     */
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new AnimationAssigner();
        }
        return this.__instance;
    }
    __getCorrespondingEntity(rootEntity, gltfModel, vrmModel, nodeIndex, nodeName, isSameSkeleton) {
        if (isSameSkeleton) {
            const rnEntities = rootEntity.getTagValue('rnEntitiesByNames');
            const node = gltfModel.nodes[nodeIndex];
            let rnEntity = rnEntities.get(node.name);
            return rnEntity;
        }
        else {
            const humanBones = vrmModel.extensions.VRM.humanoid.humanBones;
            let humanoidBoneName;
            const srcMapNodeIdName = new Map();
            const srcMapNodeNameName = new Map();
            for (let bone of humanBones) {
                srcMapNodeIdName.set(bone.node, bone.bone);
                srcMapNodeNameName.set(bone.name, bone.bone);
            }
            if (nodeName != null) {
                humanoidBoneName = srcMapNodeNameName.get(nodeName);
                if (humanoidBoneName == null) {
                    humanoidBoneName = srcMapNodeIdName.get(nodeIndex);
                }
            }
            const dstMapNameNodeId = rootEntity.getTagValue('humanoid_map_name_nodeId');
            const dstBoneNodeId = dstMapNameNodeId.get(humanoidBoneName);
            if (dstBoneNodeId != null) {
                const rnEntities = rootEntity.getTagValue('rnEntities');
                return rnEntities[dstBoneNodeId];
            }
            else {
                return void 0;
            }
        }
    }
    __isHips(rootEntity, vrmModel, nodeIndex) {
        const humanBones = vrmModel.extensions.VRM.humanoid.humanBones;
        const srcMapNodeIdName = new Map();
        for (let bone of humanBones) {
            srcMapNodeIdName.set(bone.node, bone.bone);
        }
        const dstMapNameNodeId = rootEntity.getTagValue('humanoid_map_name_nodeId');
        const humanoidBoneName = srcMapNodeIdName.get(nodeIndex);
        if (humanoidBoneName === 'hips') {
            return true;
        }
        else {
            return false;
        }
    }
    __setupAnimationForSameSkeleton(rootEntity, gltfModel, vrmModel, isSameSkeleton) {
        if (gltfModel.animations) {
            const modelConverter = _ModelConverter__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
            for (let animation of gltfModel.animations) {
                for (let sampler of animation.samplers) {
                    modelConverter._accessBinaryWithAccessor(sampler.input);
                    modelConverter._accessBinaryWithAccessor(sampler.output);
                }
            }
        }
        const entityRepository = _core_EntityRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance();
        if (gltfModel.animations) {
            for (let animation of gltfModel.animations) {
                for (let channel of animation.channels) {
                    const animInputArray = channel.sampler.input.extras.typedDataArray;
                    const animOutputArray = channel.sampler.output.extras.typedDataArray;
                    const interpolation = (channel.sampler.interpolation != null) ? channel.sampler.interpolation : 'LINEAR';
                    let animationAttributeName = '';
                    if (channel.target.path === 'translation') {
                        animationAttributeName = 'translate';
                    }
                    else if (channel.target.path === 'rotation') {
                        animationAttributeName = 'quaternion';
                    }
                    else {
                        animationAttributeName = channel.target.path;
                    }
                    const node = gltfModel.nodes[channel.target.nodeIndex];
                    const rnEntity = this.__getCorrespondingEntity(rootEntity, gltfModel, vrmModel, channel.target.nodeIndex, node.name, isSameSkeleton);
                    if (rnEntity) {
                        entityRepository.addComponentsToEntity([_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_2__["default"]], rnEntity.entityUID);
                        const animationComponent = rnEntity.getComponent(_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_2__["default"]);
                        if (animationComponent) {
                            if (animationAttributeName === 'quaternion') {
                                animationComponent.setAnimation(animationAttributeName, animInputArray, animOutputArray, _definitions_AnimationInterpolation__WEBPACK_IMPORTED_MODULE_3__["AnimationInterpolation"].fromString(interpolation));
                            }
                            else if (animationAttributeName === 'translate' && this.__isHips(rootEntity, vrmModel, channel.target.nodeIndex)) {
                                animationComponent.setAnimation(animationAttributeName, animInputArray, animOutputArray, _definitions_AnimationInterpolation__WEBPACK_IMPORTED_MODULE_3__["AnimationInterpolation"].fromString(interpolation));
                            }
                        }
                    }
                }
            }
        }
    }
}


/***/ }),

/***/ "./src/foundation/importer/DrcPointCloudImporter.ts":
/*!**********************************************************!*\
  !*** ./src/foundation/importer/DrcPointCloudImporter.ts ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DrcPointCloudImporter; });
/* harmony import */ var _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/DataUtil */ "./src/foundation/misc/DataUtil.ts");
/* harmony import */ var _geometry_Primitive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/Primitive */ "./src/foundation/geometry/Primitive.ts");
/* harmony import */ var _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/MaterialHelper */ "./src/foundation/helpers/MaterialHelper.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../definitions/PrimitiveMode */ "./src/foundation/definitions/PrimitiveMode.ts");
/* harmony import */ var _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _misc_RnPromise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../misc/RnPromise */ "./src/foundation/misc/RnPromise.ts");







/**
 * The draco Importer class.
 */
class DrcPointCloudImporter {
    constructor() {
    }
    /**
     * Import draco file of point cloud type
     * WEIGHTS_0 and JOINTS_0 attribute and all the mesh type and is not support yet.
     * @param uri - uri of drc file
     * @param options - options for loading process
     * @returns a glTF2 based JSON pre-processed
     */
    async importPointCloud(uri, options) {
        const basePath = uri.substring(0, uri.lastIndexOf('/')) + '/'; // location of model file as basePath
        const defaultOptions = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createDefaultGltfOptions();
        if (options && options.files) {
            for (let fileName in options.files) {
                const fileExtension = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].getExtension(fileName);
                if (fileExtension === 'drc') {
                    return await this.__decodeDraco(options.files[fileName], defaultOptions, basePath, options).catch((err) => {
                        console.log('this.__decodeDraco error', err);
                    });
                }
            }
        }
        const arrayBuffer = await _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].fetchArrayBuffer(uri);
        return await this.__decodeDraco(arrayBuffer, defaultOptions, basePath, options).catch((err) => {
            console.log('this.__decodeDraco error', err);
        });
    }
    /**
     * Import the specified array buffer of draco file where the type must be point cloud.
     * WEIGHTS_0 and JOINTS_0 attribute and all the mesh type and is not support yet.
     * @param uri - uri of drc file
     * @param arrayBuffer - fetched array buffer of drc file
     * @param options - options for loading process
     * @returns a glTF2 based JSON pre-processed
     */
    importArrayBuffer(uri, arrayBuffer, options) {
        const basePath = uri.substring(0, uri.lastIndexOf('/')) + '/'; // location of model file as basePath
        const defaultOptions = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createDefaultGltfOptions();
        return this.__decodeDraco(arrayBuffer, defaultOptions, basePath, options).catch((err) => {
            console.log('__loadFromArrayBuffer error', err);
        });
    }
    async __loadFromArrayBuffer(arrayBuffer, defaultOptions, basePath, options) {
        const dataView = new DataView(arrayBuffer, 0, 20);
        const isLittleEndian = true;
        // Magic field
        const magic = dataView.getUint32(0, isLittleEndian);
        let result;
        // 0x46546C67 is 'glTF' in ASCII codes.
        if (magic !== 0x46546C67) {
            //const json = await response.json();
            const gotText = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].arrayBufferToString(arrayBuffer);
            const json = JSON.parse(gotText);
            result = await this._loadAsTextJson(json, options, defaultOptions, basePath).catch((err) => {
                console.log('this.__loadAsTextJson error', err);
            });
        }
        else {
            result = await this._loadAsBinaryJson(dataView, isLittleEndian, arrayBuffer, options, defaultOptions, basePath).catch((err) => {
                console.log('this.__loadAsBinaryJson error', err);
            });
        }
        return result;
    }
    _getOptions(defaultOptions, json, options) {
        if (json.asset && json.asset.extras && json.asset.extras.rnLoaderOptions) {
            for (let optionName in json.asset.extras.rnLoaderOptions) {
                defaultOptions[optionName] = json.asset.extras.rnLoaderOptions[optionName];
            }
        }
        for (let optionName in options) {
            defaultOptions[optionName] = options[optionName];
        }
        if (options && options.loaderExtension && typeof options.loaderExtension === "string") {
            if (Rn[options.loaderExtension] != null) {
                defaultOptions.loaderExtension = Rn[options.loaderExtension].getInstance();
            }
            else {
                console.error(`${options.loaderExtension} not found!`);
                defaultOptions.loaderExtension = void 0;
            }
        }
        return defaultOptions;
    }
    async _loadAsBinaryJson(dataView, isLittleEndian, arrayBuffer, options, defaultOptions, basePath) {
        let lengthOfJSonChunkData = dataView.getUint32(12, isLittleEndian);
        let chunkType = dataView.getUint32(16, isLittleEndian);
        // 0x4E4F534A means JSON format (0x4E4F534A is 'JSON' in ASCII codes)
        if (chunkType !== 0x4E4F534A) {
            throw new Error('invalid chunkType of chunk0 in this binary glTF file.');
        }
        let uint8ArrayJSonContent = new Uint8Array(arrayBuffer, 20, lengthOfJSonChunkData);
        let gotText = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].uint8ArrayToString(uint8ArrayJSonContent);
        let gltfJson = JSON.parse(gotText);
        options = this._getOptions(defaultOptions, gltfJson, options);
        let uint8array = new Uint8Array(arrayBuffer, 20 + lengthOfJSonChunkData + 8);
        if (gltfJson.asset.extras === undefined) {
            gltfJson.asset.extras = { fileType: "glTF", version: "2" };
        }
        this._mergeExtendedJson(gltfJson, options.extendedJson);
        gltfJson.asset.extras.basePath = basePath;
        gltfJson.asset.extras.rnLoaderOptions = options;
        try {
            await this._loadInner(uint8array, basePath, gltfJson, options);
        }
        catch (err) {
            console.log("this._loadInner error in _loadAsBinaryJson", err);
        }
        return gltfJson;
    }
    async _loadAsTextJson(gltfJson, options, defaultOptions, basePath) {
        if (gltfJson.asset.extras === undefined) {
            gltfJson.asset.extras = { fileType: "glTF", version: "2" };
        }
        options = this._getOptions(defaultOptions, gltfJson, options);
        this._mergeExtendedJson(gltfJson, options.extendedJson);
        gltfJson.asset.extras.basePath = basePath;
        gltfJson.asset.extras.rnLoaderOptions = options;
        try {
            await this._loadInner(undefined, basePath, gltfJson, options);
        }
        catch (err) {
            console.log('this._loadInner error in _loadAsTextJson', err);
        }
        return gltfJson;
    }
    _loadInner(uint8array, basePath, gltfJson, options) {
        let promises = [];
        let resources = {
            shaders: [],
            buffers: [],
            images: []
        };
        promises.push(this._loadResources(uint8array, basePath, gltfJson, options, resources));
        promises.push(new Promise((resolve, reject) => {
            this._loadJsonContent(gltfJson, options);
            resolve();
        }));
        return Promise.all(promises);
    }
    _loadJsonContent(gltfJson, options) {
        // Scene
        this._loadDependenciesOfScenes(gltfJson);
        // Node
        this._loadDependenciesOfNodes(gltfJson);
        // Mesh
        this._loadDependenciesOfMeshes(gltfJson);
        // Material
        this._loadDependenciesOfMaterials(gltfJson);
        // Texture
        this._loadDependenciesOfTextures(gltfJson);
        // Joint
        this._loadDependenciesOfJoints(gltfJson);
        // Animation
        this._loadDependenciesOfAnimations(gltfJson);
        // Accessor
        this._loadDependenciesOfAccessors(gltfJson);
        // BufferView
        this._loadDependenciesOfBufferViews(gltfJson);
        if (gltfJson.asset === void 0) {
            gltfJson.asset = {};
        }
        if (gltfJson.asset.extras === void 0) {
            gltfJson.asset.extras = {};
        }
    }
    _loadDependenciesOfScenes(gltfJson) {
        for (let scene of gltfJson.scenes) {
            scene.nodesIndices = scene.nodes.concat();
            for (let i in scene.nodesIndices) {
                scene.nodes[i] = gltfJson.nodes[scene.nodes[i]];
            }
        }
    }
    _loadDependenciesOfNodes(gltfJson) {
        for (let node of gltfJson.nodes) {
            // Hierarchy
            if (node.children) {
                node.childrenIndices = node.children.concat();
                node.children = [];
                for (let i in node.childrenIndices) {
                    node.children[i] = gltfJson.nodes[node.childrenIndices[i]];
                }
            }
            // Mesh
            if (node.mesh !== void 0 && gltfJson.meshes !== void 0) {
                node.meshIndex = node.mesh;
                node.mesh = gltfJson.meshes[node.meshIndex];
            }
            // Skin
            if (node.skin !== void 0 && gltfJson.skins !== void 0) {
                node.skinIndex = node.skin;
                node.skin = gltfJson.skins[node.skinIndex];
                if (node.mesh.extras === void 0) {
                    node.mesh.extras = {};
                }
                node.mesh.extras._skin = node.skin;
            }
            // Camera
            if (node.camera !== void 0 && gltfJson.cameras !== void 0) {
                node.cameraIndex = node.camera;
                node.camera = gltfJson.cameras[node.cameraIndex];
            }
            // Lights
            if (node.extensions !== void 0 && gltfJson.extensions !== void 0 && gltfJson.extensions.KHR_lights_punctual !== void 0) {
                node.extensions.KHR_lights_punctual.lightIndex = node.extensions.KHR_lights_punctual.light;
                node.extensions.KHR_lights_punctual.light = gltfJson.extensions.KHR_lights_punctual.lights[node.extensions.KHR_lights_punctual.lightIndex];
            }
        }
    }
    _loadDependenciesOfMeshes(gltfJson) {
        // Mesh
        for (let mesh of gltfJson.meshes) {
            for (let primitive of mesh.primitives) {
                if (primitive.material !== void 0) {
                    primitive.materialIndex = primitive.material;
                    primitive.material = gltfJson.materials[primitive.materialIndex];
                }
                primitive.attributesIndex = Object.assign({}, primitive.attributes);
                for (let attributeName in primitive.attributesIndex) {
                    if (primitive.attributesIndex[attributeName] >= 0) {
                        let accessor = gltfJson.accessors[primitive.attributesIndex[attributeName]];
                        accessor.extras = {
                            toGetAsTypedArray: true,
                            attributeName: attributeName
                        };
                        primitive.attributes[attributeName] = accessor;
                    }
                    else {
                        primitive.attributes[attributeName] = void 0;
                    }
                }
                if (primitive.indices != null) {
                    primitive.indicesIndex = primitive.indices;
                    primitive.indices = gltfJson.accessors[primitive.indicesIndex];
                }
                if (primitive.targets != null) {
                    primitive.targetIndices = primitive.targets;
                    primitive.targets = [];
                    for (let target of primitive.targetIndices) {
                        const attributes = {};
                        for (let attributeName in target) {
                            if (target[attributeName] >= 0) {
                                let accessor = gltfJson.accessors[target[attributeName]];
                                accessor.extras = {
                                    toGetAsTypedArray: true,
                                    attributeName: attributeName
                                };
                                attributes[attributeName] = accessor;
                            }
                            else {
                                attributes[attributeName] = void 0;
                            }
                        }
                        primitive.targets.push(attributes);
                    }
                }
            }
        }
    }
    _checkRnGltfLoaderOptionsExist(gltfModel) {
        if (gltfModel.asset.extras && gltfModel.asset.extras.rnLoaderOptions) {
            return true;
        }
        else {
            return false;
        }
    }
    _loadDependenciesOfMaterials(gltfJson) {
        if (!gltfJson.textures)
            gltfJson.textures = [];
        // Material
        if (gltfJson.materials) {
            for (let material of gltfJson.materials) {
                if (material.pbrMetallicRoughness) {
                    let baseColorTexture = material.pbrMetallicRoughness.baseColorTexture;
                    if (baseColorTexture !== void 0) {
                        baseColorTexture.texture = gltfJson.textures[baseColorTexture.index];
                    }
                    let metallicRoughnessTexture = material.pbrMetallicRoughness.metallicRoughnessTexture;
                    if (metallicRoughnessTexture !== void 0) {
                        metallicRoughnessTexture.texture = gltfJson.textures[metallicRoughnessTexture.index];
                    }
                }
                let normalTexture = material.normalTexture;
                if (normalTexture !== void 0) {
                    normalTexture.texture = gltfJson.textures[normalTexture.index];
                }
                const occlusionTexture = material.occlusionTexture;
                if (occlusionTexture !== void 0) {
                    occlusionTexture.texture = gltfJson.textures[occlusionTexture.index];
                }
                const emissiveTexture = material.emissiveTexture;
                if (emissiveTexture !== void 0) {
                    emissiveTexture.texture = gltfJson.textures[emissiveTexture.index];
                }
                if (this._checkRnGltfLoaderOptionsExist(gltfJson) &&
                    gltfJson.asset.extras.rnLoaderOptions.loaderExtension &&
                    gltfJson.asset.extras.rnLoaderOptions.loaderExtension.setTextures) {
                    gltfJson.asset.extras.rnLoaderOptions.loaderExtension.setTextures(gltfJson, material);
                }
            }
        }
    }
    _loadDependenciesOfTextures(gltfJson) {
        // Texture
        if (gltfJson.textures) {
            for (let texture of gltfJson.textures) {
                if (texture.sampler !== void 0) {
                    texture.samplerIndex = texture.sampler;
                    texture.sampler = gltfJson.samplers[texture.samplerIndex];
                }
                if (texture.source !== void 0) {
                    texture.sourceIndex = texture.source;
                    texture.image = gltfJson.images[texture.sourceIndex];
                }
            }
        }
    }
    _loadDependenciesOfJoints(gltfJson) {
        if (gltfJson.skins) {
            for (let skin of gltfJson.skins) {
                skin.skeletonIndex = skin.skeleton;
                skin.skeleton = gltfJson.nodes[skin.skeletonIndex];
                skin.inverseBindMatricesIndex = skin.inverseBindMatrices;
                skin.inverseBindMatrices = gltfJson.accessors[skin.inverseBindMatricesIndex];
                if (skin.skeleton == null) {
                    skin.skeletonIndex = skin.joints[0];
                    skin.skeleton = gltfJson.nodes[skin.skeletonIndex];
                }
                skin.jointsIndices = skin.joints;
                skin.joints = [];
                for (let jointIndex of skin.jointsIndices) {
                    skin.joints.push(gltfJson.nodes[jointIndex]);
                }
            }
        }
    }
    _loadDependenciesOfAnimations(gltfJson) {
        if (gltfJson.animations) {
            for (let animation of gltfJson.animations) {
                for (let channel of animation.channels) {
                    channel.samplerIndex = channel.sampler;
                    channel.sampler = animation.samplers[channel.samplerIndex];
                    channel.target.nodeIndex = channel.target.node;
                    channel.target.node = gltfJson.nodes[channel.target.nodeIndex];
                }
                for (let channel of animation.channels) {
                    channel.sampler.inputIndex = channel.sampler.input;
                    channel.sampler.outputIndex = channel.sampler.output;
                    channel.sampler.input = gltfJson.accessors[channel.sampler.inputIndex];
                    channel.sampler.output = gltfJson.accessors[channel.sampler.outputIndex];
                    if (channel.sampler.output.extras === void 0) {
                        channel.sampler.output.extras = {};
                    }
                    if (channel.target.path === 'rotation') {
                        channel.sampler.output.extras.quaternionIfVec4 = true;
                    }
                    if (channel.target.path === 'weights') {
                        const weightCount = channel.sampler.output.count / channel.sampler.input.count;
                        channel.sampler.output.extras.weightCount = weightCount;
                    }
                }
            }
        }
    }
    _loadDependenciesOfAccessors(gltfJson) {
        // Accessor
        for (let accessor of gltfJson.accessors) {
            if (accessor.bufferView == null) {
                accessor.bufferView = 0;
            }
            accessor.bufferViewIndex = accessor.bufferView;
            accessor.bufferView = gltfJson.bufferViews[accessor.bufferViewIndex];
            if (accessor.sparse != null) {
                const sparse = accessor.sparse;
                sparse.indices.indicesIndex = sparse.indices.bufferView;
                sparse.indices.bufferView = gltfJson.bufferViews[sparse.indices.indicesIndex];
                sparse.values.valuesIndex = sparse.values.bufferView;
                sparse.values.bufferView = gltfJson.bufferViews[sparse.values.valuesIndex];
            }
        }
    }
    _loadDependenciesOfBufferViews(gltfJson) {
        // BufferView
        for (let bufferView of gltfJson.bufferViews) {
            if (bufferView.buffer !== void 0) {
                bufferView.bufferIndex = bufferView.buffer;
                bufferView.buffer = gltfJson.buffers[bufferView.bufferIndex];
            }
        }
    }
    _mergeExtendedJson(gltfJson, extendedData) {
        let extendedJson = null;
        if (extendedData instanceof ArrayBuffer) {
            const extendedJsonStr = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].arrayBufferToString(extendedData);
            extendedJson = JSON.parse(extendedJsonStr);
        }
        else if (typeof extendedData === 'string') {
            extendedJson = JSON.parse(extendedData);
            extendedJson = extendedJson;
        }
        else if (typeof extendedData === 'object') {
            extendedJson = extendedData;
        }
        else {
        }
        Object.assign(gltfJson, extendedJson);
    }
    _loadResources(uint8Array, basePath, gltfJson, options, resources) {
        let promisesToLoadResources = [];
        // Shaders Async load
        // for (let _i in gltfJson.shaders) {
        //   const i = _i as any as number;
        //   resources.shaders[i] = {};
        //   let shaderJson = gltfJson.shaders[i];
        //   let shaderType = shaderJson.type;
        //   if (typeof shaderJson.extensions !== 'undefined' && typeof shaderJson.extensions.KHR_binary_glTF !== 'undefined') {
        //     resources.shaders[i].shaderText = this._accessBinaryAsShader(shaderJson.extensions.KHR_binary_glTF.bufferView, gltfJson, arrayBufferBinary);
        //     resources.shaders[i].shaderType = shaderType;
        //     continue;
        //   }
        //   let shaderUri = shaderJson.uri;
        //   if (options.files) {
        //     const splitted = shaderUri.split('/');
        //     const filename = splitted[splitted.length - 1];
        //     if (options.files[filename]) {
        //       const arrayBuffer = options.files[filename];
        //       resources.shaders[i].shaderText = DataUtil.arrayBufferToString(arrayBuffer);
        //       resources.shaders[i].shaderType = shaderType;
        //       continue;
        //     }
        //   }
        //   if (shaderUri.match(/^data:/)) {
        //     promisesToLoadResources.push(
        //       new Promise((resolve, rejected) => {
        //         let arrayBuffer = DataUtil.dataUriToArrayBuffer(shaderUri);
        //         resources.shaders[i].shaderText = DataUtil.arrayBufferToString(arrayBuffer);
        //         resources.shaders[i].shaderType = shaderType;
        //         resolve();
        //       })
        //     );
        //   } else {
        //     shaderUri = basePath + shaderUri;
        //     promisesToLoadResources.push(
        //       DataUtil.loadResourceAsync(shaderUri, false,
        //         (resolve:Function, response:any)=>{
        //           resources.shaders[i].shaderText = response;
        //           resources.shaders[i].shaderType = shaderType;
        //           resolve(gltfJson);
        //         },
        //         (reject:Function, error:any)=>{
        //         }
        //       )
        //     );
        //   }
        // }
        // Buffers Async load
        let rnpArrayBuffer;
        for (let i in gltfJson.buffers) {
            let bufferInfo = gltfJson.buffers[i];
            let splitted;
            let filename;
            if (bufferInfo.uri) {
                splitted = bufferInfo.uri.split('/');
                filename = splitted[splitted.length - 1];
            }
            if (typeof bufferInfo.uri === 'undefined') {
                rnpArrayBuffer = new _misc_RnPromise__WEBPACK_IMPORTED_MODULE_6__["default"]((resolve, rejected) => {
                    resources.buffers[i] = uint8Array;
                    bufferInfo.buffer = uint8Array;
                    resolve(uint8Array);
                });
            }
            else if (bufferInfo.uri.match(/^data:application\/(.*);base64,/)) {
                rnpArrayBuffer = new _misc_RnPromise__WEBPACK_IMPORTED_MODULE_6__["default"]((resolve, rejected) => {
                    let arrayBuffer = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].dataUriToArrayBuffer(bufferInfo.uri);
                    resources.buffers[i] = new Uint8Array(arrayBuffer);
                    bufferInfo.buffer = new Uint8Array(arrayBuffer);
                    resolve(arrayBuffer);
                });
            }
            else if (options.files && options.files[filename]) {
                rnpArrayBuffer = new _misc_RnPromise__WEBPACK_IMPORTED_MODULE_6__["default"]((resolve, rejected) => {
                    const arrayBuffer = options.files[filename];
                    resources.buffers[i] = new Uint8Array(arrayBuffer);
                    bufferInfo.buffer = new Uint8Array(arrayBuffer);
                    resolve(arrayBuffer);
                });
            }
            else {
                rnpArrayBuffer = new _misc_RnPromise__WEBPACK_IMPORTED_MODULE_6__["default"](_misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].loadResourceAsync(basePath + bufferInfo.uri, true, (resolve, response) => {
                    resources.buffers[i] = new Uint8Array(response);
                    bufferInfo.buffer = new Uint8Array(response);
                    resolve(response);
                }, (reject, error) => {
                }));
            }
            bufferInfo.bufferPromise = rnpArrayBuffer;
            promisesToLoadResources.push(rnpArrayBuffer);
        }
        // Textures Async load
        for (let _i in gltfJson.images) {
            const i = _i;
            let imageJson = gltfJson.images[i];
            //let imageJson = gltfJson.images[textureJson.source];
            //let samplerJson = gltfJson.samplers[textureJson.sampler];
            let imageUri;
            if (typeof imageJson.uri === 'undefined') {
                let arrayBuffer = uint8Array;
                if (uint8Array == null) {
                    const bufferView = gltfJson.bufferViews[imageJson.bufferView];
                    arrayBuffer = bufferView.buffer.buffer;
                }
                const imageUint8Array = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createUint8ArrayFromBufferViewInfo(gltfJson, imageJson.bufferView, uint8Array);
                imageUri = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createBlobImageUriFromUint8Array(imageUint8Array, imageJson.mimeType);
            }
            else {
                let imageFileStr = imageJson.uri;
                const splitted = imageFileStr.split('/');
                const filename = splitted[splitted.length - 1];
                if (options.files && options.files[filename]) {
                    const arrayBuffer = options.files[filename];
                    imageUri = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createBlobImageUriFromUint8Array(new Uint8Array(arrayBuffer), imageJson.mimeType);
                }
                else if (imageFileStr.match(/^data:/)) {
                    imageUri = imageFileStr;
                }
                else {
                    imageUri = basePath + imageFileStr;
                }
            }
            // if (options.extensionLoader && options.extensionLoader.setUVTransformToTexture) {
            //   options.extensionLoader.setUVTransformToTexture(texture, samplerJson);
            //
            const promise = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createImageFromUri(imageUri, imageJson.mimeType).then(function (image) {
                image.crossOrigin = 'Anonymous';
                resources.images[i] = image;
                imageJson.image = image;
            });
            promisesToLoadResources.push(promise);
        }
        if (options.defaultTextures) {
            const basePath = options.defaultTextures.basePath;
            const textureInfos = options.defaultTextures.textureInfos;
            for (let textureInfo of textureInfos) {
                const fileName = textureInfo.fileName;
                const uri = basePath + fileName;
                const fileExtension = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].getExtension(fileName);
                const mimeType = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].getMimeTypeFromExtension(fileExtension);
                const promise = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createImageFromUri(uri, mimeType).then(function (image) {
                    image.crossOrigin = 'Anonymous';
                    textureInfo.image = { image: image };
                });
                promisesToLoadResources.push(promise);
            }
        }
        return Promise.all(promisesToLoadResources).catch((err) => {
            console.log('Promise.all error', err);
        });
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new DrcPointCloudImporter();
        }
        return this.__instance;
    }
    __decodeDraco(arrayBuffer, defaultOptions, basePath, options) {
        return this.__decodeBuffer(arrayBuffer).then((json) => {
            const gotText = JSON.stringify(json);
            const gltfJson = JSON.parse(gotText);
            return this._loadAsTextJson(gltfJson, options, defaultOptions, basePath).catch((err) => {
                console.log('this.__loadAsTextJson error', err);
            });
        });
    }
    __decodeBuffer(arrayBuffer) {
        const draco = new DracoDecoderModule();
        const decoder = new draco.Decoder();
        const dracoGeometry = this.__getGeometryFromDracoBuffer(draco, decoder, arrayBuffer);
        if (dracoGeometry == null) {
            throw new Error('invalid dracoGeometry.');
        }
        if (dracoGeometry.geometryType !== draco.POINT_CLOUD) {
            throw new Error('invalid geometryType of drc file.');
        }
        const posAttId = decoder.GetAttributeId(dracoGeometry, draco.POSITION);
        if (posAttId === -1) {
            draco.destroy(decoder);
            draco.destroy(dracoGeometry);
            throw new Error('Draco: No position attribute found.');
        }
        const attributeNames = ['POSITION', 'NORMAL', 'COLOR', 'TEX_COORD', 'GENERIC'];
        const numPoints = dracoGeometry.num_points();
        const attributeDataAll = [];
        const attributeComponents = [];
        let bufferLength = 0;
        for (let i = 0; i < attributeNames.length; i++) {
            const attId = decoder.GetAttributeId(dracoGeometry, draco[attributeNames[i]]);
            if (attId === -1) {
                attributeNames.splice(i, 1);
                i--;
                continue;
            }
            const attribute = decoder.GetAttribute(dracoGeometry, attId);
            const attributeData = new draco.DracoFloat32Array();
            decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);
            attributeDataAll[i] = attributeData;
            const numComponent = attribute.num_components();
            attributeComponents[i] = numComponent;
            if (attributeNames[i] === 'COLOR') {
                bufferLength += numPoints * 4;
            }
            else {
                bufferLength += numPoints * numComponent;
            }
        }
        const buffer = new Float32Array(bufferLength);
        for (let i = 0, currentBufferIndex = 0; i < attributeNames.length; i++) {
            if (attributeNames[i] === 'COLOR' && attributeComponents[i] === 3) {
                for (var j = 0; j < numPoints; currentBufferIndex += 4, j += 3) {
                    buffer[currentBufferIndex] = attributeDataAll[i].GetValue(j);
                    buffer[currentBufferIndex + 1] = attributeDataAll[i].GetValue(j + 1);
                    buffer[currentBufferIndex + 2] = attributeDataAll[i].GetValue(j + 2);
                    buffer[currentBufferIndex + 3] = 1.0; // alpha value
                }
            }
            else if (attributeNames[i] === 'TEX_COORD') {
                for (var j = 0; j < numPoints; currentBufferIndex += 2, j++) {
                    buffer[currentBufferIndex] = attributeDataAll[i].GetValue(2 * j);
                    buffer[currentBufferIndex + 1] = 1.0 - attributeDataAll[i].GetValue(2 * j + 1);
                }
            }
            else {
                for (var j = 0; j < numPoints * attributeComponents[i]; currentBufferIndex++, j++) {
                    buffer[currentBufferIndex] = attributeDataAll[i].GetValue(j);
                }
            }
            draco.destroy(attributeDataAll[i]);
        }
        draco.destroy(decoder);
        draco.destroy(dracoGeometry);
        return this.__decodedBufferToJSON(buffer, numPoints, attributeNames, attributeComponents);
    }
    async __decodedBufferToJSON(buffer, numPoints, attributeNames, attributeComponents) {
        const json = {
            "asset": {
                version: "2.0"
            },
            "extensionsUsed": [
                "KHR_materials_unlit"
            ],
            "extensionsRequired": [
                "KHR_materials_unlit"
            ],
            "nodes": [
                {
                    "name": "Node",
                    "mesh": 0
                }
            ],
            "scenes": [
                {
                    "nodes": [0]
                }
            ],
            "materials": [
                {
                    "name": "point-cloud_material",
                    "pbrMetallicRoughness": {
                        "baseColorFactor": [1.0, 1.0, 1.0, 1.0]
                    },
                    "extensions": {
                        "KHR_materials_unlit": {}
                    }
                },
            ]
        };
        await this.__setBuffersToJSON(buffer, json);
        this.__setAccessorsAndBufferViewsToJSON(numPoints, attributeNames, attributeComponents, json);
        this.__setMeshesToJSON(attributeNames, json);
        return new Promise((resolve, reject) => {
            resolve(json);
        });
    }
    __setBuffersToJSON(buffer, json) {
        return this.__convertBufferToURI(buffer.buffer).then((uri) => {
            json["buffers"] = [
                {
                    "name": "input",
                    "byteLength": buffer.byteLength,
                    "uri": uri
                }
            ];
        }).catch((err) => {
            console.log('this.__convertBufferToURI error:', err);
        });
    }
    __convertBufferToURI(arrayBuffer) {
        return new Promise((resolve, reject) => {
            const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });
            const fr = new FileReader();
            fr.onload = () => {
                resolve(fr.result);
            };
            fr.onerror = () => {
                reject(fr.error);
            };
            fr.readAsDataURL(blob);
        });
    }
    __setAccessorsAndBufferViewsToJSON(numPoints, attributeNames, attributeComponents, json) {
        const accessors = [];
        const bufferViews = [];
        let byteOffsetOfBufferView = 0;
        for (let i = 0, indexOfBufferView = 0; i < attributeNames.length; indexOfBufferView++) {
            const numOfComponents = attributeComponents[i];
            let type;
            if (numOfComponents === 1) {
                type = "SCALAR";
            }
            else {
                type = "VEC" + numOfComponents;
            }
            let byteOffsetOfAccessor = 0;
            const attributeName = attributeNames[i];
            while (i < attributeNames.length) {
                accessors.push({
                    "name": "point-cloud_" + attributeName + "_" + i,
                    "componentType": 5126,
                    "count": numPoints,
                    "type": type,
                    "bufferView": indexOfBufferView,
                    "byteOffset": byteOffsetOfAccessor
                });
                if (attributeNames[i] === 'COLOR') {
                    byteOffsetOfAccessor += numPoints * 4 * 4;
                }
                else {
                    byteOffsetOfAccessor += numPoints * numOfComponents * 4;
                }
                i++;
                if (attributeName != attributeNames[i]) {
                    break;
                }
            }
            bufferViews[indexOfBufferView] = {
                "name": "bufferView_" + attributeName,
                "buffer": 0,
                "byteLength": byteOffsetOfAccessor,
                "byteOffset": byteOffsetOfBufferView,
                "byteStride": numOfComponents * 4,
                "target": 34962 // gl.ARRAY_BUFFER
            };
            byteOffsetOfBufferView += byteOffsetOfAccessor;
        }
        json["accessors"] = accessors;
        json["bufferViews"] = bufferViews;
    }
    __setMeshesToJSON(attributeNames, json) {
        const attributes = {};
        for (let i = 0; i < attributeNames.length; i++) {
            if (attributeNames[i] === 'TEX_COORD') {
                attributes['TEXCOORD_0'] = i;
            }
            else if (attributeNames[i] === 'GENERIC') {
                attributes['TANGENT'] = i;
            }
            else {
                attributes[attributeNames[i]] = i;
            }
        }
        const mesh = {
            "name": "Node-Mesh",
            "primitives": [
                {
                    "mode": 0,
                    "material": 0,
                    "attributes": attributes
                }
            ]
        };
        json["meshes"] = [mesh];
    }
    /**
     * Import Draco file of point cloud type.
     * WEIGHTS_0 and JOINTS_0 attribute and all the mesh type and is not support yet.
     * @param uri - uri of glTF file
     * @param options - options for loading process
     * @returns a primitive of Rhodonite object
     */
    async importPointCloudToPrimitive(uri, options) {
        const basePath = uri.substring(0, uri.lastIndexOf('/')) + '/'; // location of model file as basePath
        const defaultOptions = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createDefaultGltfOptions();
        if (options && options.files) {
            for (let fileName in options.files) {
                const fileExtension = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].getExtension(fileName);
                if (fileExtension === 'gltf' || fileExtension === 'glb') {
                    return await this.__loadFromArrayBuffer(options.files[fileName], defaultOptions, basePath, options).catch((err) => {
                        console.log('this.__loadFromArrayBuffer error', err);
                    });
                }
            }
        }
        const arrayBuffer = await _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].fetchArrayBuffer(uri);
        return this.__decodeDracoDirect(arrayBuffer, options);
    }
    // tangent is not available
    __decodeDracoDirect(arrayBuffer, options) {
        const draco = new DracoDecoderModule();
        const decoder = new draco.Decoder();
        const dracoGeometry = this.__getGeometryFromDracoBuffer(draco, decoder, arrayBuffer);
        if (dracoGeometry == null) {
            throw new Error('invalid dracoGeometry.');
        }
        if (dracoGeometry.geometryType !== draco.POINT_CLOUD) {
            throw new Error('invalid geometryType of drc file.');
        }
        const attributeCompositionTypes = [];
        const attributeSemantics = [];
        const attributes = [];
        this.__getPositions(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes);
        this.__getColors(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes);
        this.__getNormals(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes);
        this.__getTextureCoords(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes);
        const primitive = _geometry_Primitive__WEBPACK_IMPORTED_MODULE_1__["default"].createPrimitive({
            attributeCompositionTypes: attributeCompositionTypes,
            attributeSemantics: attributeSemantics,
            attributes: attributes,
            material: _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_2__["default"].createClassicUberMaterial({ isSkinning: false, isLighting: true }),
            primitiveMode: _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_4__["PrimitiveMode"].Points
        });
        draco.destroy(decoder);
        draco.destroy(dracoGeometry);
        return new Promise((resolve, reject) => {
            resolve(primitive);
        });
    }
    __getGeometryFromDracoBuffer(draco, decoder, arrayBuffer) {
        const buffer = new draco.DecoderBuffer();
        buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);
        const geometryType = decoder.GetEncodedGeometryType(buffer);
        let dracoGeometry;
        let decodingStatus;
        if (geometryType === draco.TRIANGULAR_MESH) {
            dracoGeometry = new draco.Mesh();
            decodingStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);
        }
        else if (geometryType === draco.POINT_CLOUD) {
            dracoGeometry = new draco.PointCloud();
            decodingStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
        }
        else {
            const errorMsg = 'Unknown geometry type.';
            console.error(errorMsg);
        }
        dracoGeometry.geometryType = geometryType; // store
        if (!decodingStatus.ok() || dracoGeometry.ptr == 0) {
            let errorMsg = 'Decoding failed: ';
            errorMsg += decodingStatus.error_msg();
            console.error(errorMsg);
            draco.destroy(decoder);
            draco.destroy(dracoGeometry);
            return void 0;
        }
        draco.destroy(buffer);
        return dracoGeometry;
    }
    __getPositions(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes) {
        const posAttId = decoder.GetAttributeId(dracoGeometry, draco.POSITION);
        if (posAttId === -1) {
            draco.destroy(decoder);
            draco.destroy(dracoGeometry);
            throw new Error('Draco: No position attribute found.');
        }
        const posAttribute = decoder.GetAttribute(dracoGeometry, posAttId);
        const posAttributeData = new draco.DracoFloat32Array();
        decoder.GetAttributeFloatForAllPoints(dracoGeometry, posAttribute, posAttributeData);
        const numPoints = dracoGeometry.num_points();
        const numVertices = numPoints * 3;
        const positions = new Float32Array(numVertices);
        for (var i = 0; i < numVertices; i += 1) {
            positions[i] = posAttributeData.GetValue(i); // XYZ XYZ
        }
        attributeCompositionTypes.push(_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec3);
        attributeSemantics.push(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_5__["VertexAttribute"].Position);
        attributes.push(positions);
        draco.destroy(posAttributeData);
        return positions;
    }
    __getColors(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes) {
        // Get color attributes if exists.
        const colorAttId = decoder.GetAttributeId(dracoGeometry, draco.COLOR);
        if (colorAttId === -1) {
            return null;
        }
        else {
            //console.log('Loaded color attribute.');
            const colAttribute = decoder.GetAttribute(dracoGeometry, colorAttId);
            const colAttributeData = new draco.DracoFloat32Array();
            decoder.GetAttributeFloatForAllPoints(dracoGeometry, colAttribute, colAttributeData);
            const numPoints = dracoGeometry.num_points();
            const numComponents = colAttribute.num_components();
            const numVertices = numPoints * 4;
            const colors = new Float32Array(numVertices);
            for (let i = 0; i < numVertices; i += numComponents) {
                colors[i] = colAttributeData.GetValue(i);
                colors[i + 1] = colAttributeData.GetValue(i + 1);
                colors[i + 2] = colAttributeData.GetValue(i + 2);
                if (numComponents == 4) {
                    colors[i + 3] = colAttributeData.GetValue(i + 3);
                }
                else {
                    colors[i + 3] = 1.0;
                }
            }
            attributeCompositionTypes.push(_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec3);
            attributeSemantics.push(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_5__["VertexAttribute"].Color0);
            attributes.push(colors);
            draco.destroy(colAttributeData);
            return colors;
        }
    }
    __getNormals(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes) {
        // Get normal attributes if exists.
        const normalAttId = decoder.GetAttributeId(dracoGeometry, draco.NORMAL);
        if (normalAttId === -1) {
            return null;
        }
        else {
            //console.log('Loaded normal attribute.');
            const norAttribute = decoder.GetAttribute(dracoGeometry, normalAttId);
            const norAttributeData = new draco.DracoFloat32Array();
            decoder.GetAttributeFloatForAllPoints(dracoGeometry, norAttribute, norAttributeData);
            const numPoints = dracoGeometry.num_points();
            const numVertices = numPoints * 3;
            const normals = new Float32Array(numVertices);
            for (var i = 0; i < numVertices; i += 1) {
                normals[i] = norAttributeData.GetValue(i); // XYZ XYZ
            }
            attributeCompositionTypes.push(_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec3);
            attributeSemantics.push(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_5__["VertexAttribute"].Normal);
            attributes.push(normals);
            draco.destroy(norAttributeData);
            return normals;
        }
    }
    __getTextureCoords(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes) {
        // Get texture coordinate attributes if exists.
        const texCoordAttId = decoder.GetAttributeId(dracoGeometry, draco.TEX_COORD);
        if (texCoordAttId === -1) {
            return null;
        }
        else {
            const texCoordAttribute = decoder.GetAttribute(dracoGeometry, texCoordAttId);
            const texCoordAttributeData = new draco.DracoFloat32Array();
            decoder.GetAttributeFloatForAllPoints(dracoGeometry, texCoordAttribute, texCoordAttributeData);
            const numPoints = dracoGeometry.num_points();
            const numVertices = numPoints * 2;
            const texCoords = new Float32Array(numVertices);
            for (var i = 0; i < numVertices; i += 1) {
                texCoords[i] = texCoordAttributeData.GetValue(i); // XYZ XYZ
            }
            attributeCompositionTypes.push(_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec2);
            attributeSemantics.push(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_5__["VertexAttribute"].Texcoord0);
            attributes.push(texCoords);
            draco.destroy(texCoordAttributeData);
            return texCoords;
        }
    }
}


/***/ }),

/***/ "./src/foundation/importer/FormatDetector.ts":
/*!***************************************************!*\
  !*** ./src/foundation/importer/FormatDetector.ts ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return detectFormat; });
/* harmony import */ var _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/DataUtil */ "./src/foundation/misc/DataUtil.ts");

async function detectFormat(uri, files) {
    if (files) {
        for (let fileName in files) {
            const fileExtension = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].getExtension(fileName);
            if (fileExtension === 'gltf' || fileExtension === 'glb') {
                return new Promise((resolve, reject) => {
                    checkArrayBufferOfGltf(files[fileName], resolve);
                });
            }
            else if (fileExtension === 'drc') {
                return new Promise((resolve, reject) => {
                    resolve('Draco');
                });
            }
            else if (fileExtension === 'vrm') {
                return new Promise((resolve, reject) => {
                    resolve('VRM');
                });
            }
        }
    }
    const splitted = uri.split('.');
    const fileExtension = splitted[splitted.length - 1];
    if (fileExtension === 'efk') {
        return new Promise((resolve, reject) => {
            resolve('Effekseer');
        });
    }
    else if (fileExtension === 'drc') {
        return new Promise((resolve, reject) => {
            resolve('Draco');
        });
    }
    else if (fileExtension === 'vrm') {
        return new Promise((resolve, reject) => {
            resolve('VRM');
        });
    }
    // glTF
    return _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].loadResourceAsync(uri, true, (resolve, response) => {
        const arrayBuffer = response;
        checkArrayBufferOfGltf(arrayBuffer, resolve);
        console.warn('discard downloaded arrayBuffer');
    }, (rejects, status) => {
        console.log(status);
    });
}
function checkArrayBufferOfGltf(arrayBuffer, resolve) {
    const isLittleEndian = true;
    const dataView = new DataView(arrayBuffer, 0, 20);
    // Magic field
    const magic = dataView.getUint32(0, isLittleEndian);
    // 0x46546C67 is 'glTF' in ASCII codes.
    if (magic !== 0x46546C67) {
        // It must be normal glTF (NOT binary) file...
        let gotText = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].arrayBufferToString(arrayBuffer);
        let gltfJson = JSON.parse(gotText);
        let glTFVer = checkGLTFVersion(gltfJson);
        resolve("glTF" + glTFVer);
        return;
    }
    let glTFVer = dataView.getUint32(4, isLittleEndian);
    resolve("glTF" + glTFVer);
}
function checkGLTFVersion(gltfJson) {
    let glTFVer = 1.0;
    if (gltfJson.asset && gltfJson.asset.version) {
        glTFVer = parseFloat(gltfJson.asset.version);
    }
    return glTFVer;
}


/***/ }),

/***/ "./src/foundation/importer/Gltf1Importer.ts":
/*!**************************************************!*\
  !*** ./src/foundation/importer/Gltf1Importer.ts ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Gltf1Importer; });
/* harmony import */ var _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/DataUtil */ "./src/foundation/misc/DataUtil.ts");

class Gltf1Importer {
    constructor() {
    }
    /**
     * the method to load glTF1 file.
     * @param uri - uri of glTF file
     * @param options - options for loading process
     * @returns a glTF2 based JSON pre-processed
     */
    async import(uri, options) {
        const basePath = uri.substring(0, uri.lastIndexOf('/')) + '/'; // location of model file as basePath
        const defaultOptions = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createDefaultGltfOptions();
        if (options && options.files) {
            for (let fileName in options.files) {
                const fileExtension = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].getExtension(fileName);
                if (fileExtension === 'gltf' || fileExtension === 'glb') {
                    return await this.__loadFromArrayBuffer(options.files[fileName], defaultOptions, basePath, options);
                }
            }
        }
        const arrayBuffer = await _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].fetchArrayBuffer(uri);
        return await this.__loadFromArrayBuffer(arrayBuffer, defaultOptions, basePath, options);
    }
    /**
     * Import glTF1 file
     * @param uri - uri of glTF file
     * @param arrayBuffer - fetched glTF file
     * @param options - options for loading process
     * @returns a glTF2 based JSON pre-processed
     */
    importArrayBuffer(uri, arrayBuffer, options) {
        const basePath = uri.substring(0, uri.lastIndexOf('/')) + '/'; // location of model file as basePath
        const defaultOptions = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createDefaultGltfOptions();
        return this.__loadFromArrayBuffer(arrayBuffer, defaultOptions, basePath, options).catch((err) => {
            console.log('__loadFromArrayBuffer error', err);
        });
    }
    async __loadFromArrayBuffer(arrayBuffer, defaultOptions, basePath, options) {
        const dataView = new DataView(arrayBuffer, 0, 20);
        const isLittleEndian = true;
        // Magic field
        const magic = dataView.getUint32(0, isLittleEndian);
        let result;
        // 0x46546C67 is 'glTF' in ASCII codes.
        if (magic !== 0x46546C67) {
            //const json = await response.json();
            const gotText = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].arrayBufferToString(arrayBuffer);
            const json = JSON.parse(gotText);
            result = await this._loadAsTextJson(json, options, defaultOptions, basePath);
        }
        else {
            result = await this._loadAsBinaryJson(dataView, isLittleEndian, arrayBuffer, options, defaultOptions, basePath);
        }
        return result;
    }
    _getOptions(defaultOptions, json, options) {
        if (json.asset && json.asset.extras && json.asset.extras.rnLoaderOptions) {
            for (let optionName in json.asset.extras.rnLoaderOptions) {
                defaultOptions[optionName] = json.asset.extras.rnLoaderOptions[optionName];
            }
        }
        for (let optionName in options) {
            defaultOptions[optionName] = options[optionName];
        }
        if (options && options.loaderExtension && typeof options.loaderExtension === "string") {
            if (Rn[options.loaderExtension] != null) {
                defaultOptions.loaderExtension = Rn[options.loaderExtension].getInstance();
            }
            else {
                console.error(`${options.loaderExtension} not found!`);
                defaultOptions.loaderExtension = void 0;
            }
        }
        return defaultOptions;
    }
    async _loadAsBinaryJson(dataView, isLittleEndian, arrayBuffer, options, defaultOptions, basePath) {
        let gltfVer = dataView.getUint32(4, isLittleEndian);
        if (gltfVer !== 1) {
            throw new Error('invalid version field in this binary glTF file.');
        }
        let lengthOfJSonChunkData = dataView.getUint32(12, isLittleEndian);
        let chunkType = dataView.getUint32(16, isLittleEndian);
        // 0 means JSON format
        if (chunkType !== 0) {
            throw new Error('invalid chunkType of chunk0 in this binary glTF file.');
        }
        let uint8ArrayJSonContent = new Uint8Array(arrayBuffer, 20, lengthOfJSonChunkData);
        let gotText = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].uint8ArrayToString(uint8ArrayJSonContent);
        let gltfJson = JSON.parse(gotText);
        options = this._getOptions(defaultOptions, gltfJson, options);
        let uint8array = new Uint8Array(arrayBuffer, 20 + lengthOfJSonChunkData);
        if (gltfJson.asset === undefined) {
            gltfJson.asset = {};
        }
        if (gltfJson.asset.extras === undefined) {
            gltfJson.asset.extras = { fileType: "glTF", version: "1" };
        }
        this._mergeExtendedJson(gltfJson, options.extendedJson);
        gltfJson.asset.extras.basePath = basePath;
        gltfJson.asset.extras.rnLoaderOptions = options;
        const result = await this._loadInner(uint8array, basePath, gltfJson, options);
        return result[0][0];
    }
    async _loadAsTextJson(gltfJson, options, defaultOptions, basePath) {
        if (gltfJson.asset === undefined) {
            gltfJson.asset = {};
        }
        if (gltfJson.asset.extras === undefined) {
            gltfJson.asset.extras = { fileType: "glTF", version: "1" };
        }
        options = this._getOptions(defaultOptions, gltfJson, options);
        this._mergeExtendedJson(gltfJson, options.extendedJson);
        gltfJson.asset.extras.basePath = basePath;
        gltfJson.asset.extras.rnLoaderOptions = options;
        const result = await this._loadInner(undefined, basePath, gltfJson, options);
        return result[0][0];
    }
    _loadInner(uint8array, basePath, gltfJson, options) {
        let promises = [];
        let resources = {
            shaders: [],
            buffers: [],
            images: []
        };
        promises.push(this._loadResources(uint8array, basePath, gltfJson, options, resources));
        promises.push(new Promise((resolve, reject) => {
            this._loadJsonContent(gltfJson, options);
            resolve();
        }));
        return Promise.all(promises);
    }
    _loadJsonContent(gltfJson, options) {
        this._convertToGltf2LikeStructure(gltfJson);
        // Scene
        this._loadDependenciesOfScenes(gltfJson);
        // Node
        this._loadDependenciesOfNodes(gltfJson);
        // Mesh
        this._loadDependenciesOfMeshes(gltfJson);
        // Material
        this._loadDependenciesOfMaterials(gltfJson);
        // Texture
        this._loadDependenciesOfTextures(gltfJson);
        // Joint
        this._loadDependenciesOfJoints(gltfJson);
        // Animation
        this._loadDependenciesOfAnimations(gltfJson);
        // Accessor
        this._loadDependenciesOfAccessors(gltfJson);
        // BufferView
        this._loadDependenciesOfBufferViews(gltfJson);
    }
    _convertToGltf2LikeStructure(gltfJson) {
        gltfJson.bufferDic = gltfJson.buffers;
        this.__createProperty(gltfJson, gltfJson.bufferDic, "buffers");
        gltfJson.sceneDic = gltfJson.scenes;
        this.__createProperty(gltfJson, gltfJson.sceneDic, "scenes");
        gltfJson.meshDic = gltfJson.meshes;
        {
            let count = 0;
            gltfJson.nodeDic = gltfJson.nodes;
            gltfJson.nodes = [];
            gltfJson.nodesIndices = [];
            for (let nodeName in gltfJson.nodeDic) {
                gltfJson.nodesIndices.push(count);
                const node = gltfJson.nodeDic[nodeName];
                node._index = count++;
                gltfJson.nodes.push(node);
            }
        }
        gltfJson.skinDic = gltfJson.skins;
        this.__createProperty(gltfJson, gltfJson.skinDic, "skins");
        gltfJson.materialDic = gltfJson.materials;
        this.__createProperty(gltfJson, gltfJson.materialDic, "materials");
        gltfJson.animationDic = gltfJson.animations;
        this.__createProperty(gltfJson, gltfJson.animationDic, "animations");
        gltfJson.accessorDic = gltfJson.accessors;
        gltfJson.bufferViewDic = gltfJson.bufferViews;
        gltfJson.cameraDic = gltfJson.cameras;
        gltfJson.imageDic = gltfJson.images;
        gltfJson.samplerDic = gltfJson.samplers;
        gltfJson.shaderDic = gltfJson.shaders;
        gltfJson.textureDic = gltfJson.textures;
    }
    __createProperty(gltfJson, gltfPropertyDic, gltfPropertyName) {
        if (gltfJson[gltfPropertyName] == null) {
            return;
        }
        const propertyNumber = Object.keys(gltfPropertyDic).length;
        const propertyArray = gltfJson[gltfPropertyName] = new Array(propertyNumber);
        let i = 0;
        for (let propertyName in gltfPropertyDic) {
            propertyArray[i] = gltfPropertyDic[propertyName];
            i++;
        }
    }
    _loadDependenciesOfScenes(gltfJson) {
        for (let sceneName in gltfJson.sceneDic) {
            const scene = gltfJson.sceneDic[sceneName];
            scene.nodeNames = scene.nodes;
            scene.nodes = [];
            scene.nodesIndices = [];
            for (let name of scene.nodeNames) {
                scene.nodes.push(gltfJson.nodeDic[name]);
                // calc index of 'name' in gltfJson.nodeDic enumerate
                let count = 0;
                for (let nodeName in gltfJson.nodeDic) {
                    if (nodeName === name) {
                        break;
                    }
                    count++;
                }
                scene.nodesIndices.push(count);
            }
        }
    }
    _loadDependenciesOfNodes(gltfJson) {
        for (let node of gltfJson.nodes) {
            //const node = (gltfJson.nodeDic as any)[nodeName];
            // Hierarchy
            if (node.children) {
                node.childrenNames = node.children.concat();
                node.children = [];
                node.childrenIndices = [];
                for (let name of node.childrenNames) {
                    const childNode = gltfJson.nodeDic[name];
                    node.children.push(childNode);
                    node.childrenIndices.push(childNode._index);
                }
            }
            // Mesh
            if (node.meshes !== void 0 && gltfJson.meshes !== void 0) {
                node.meshNames = node.meshes;
                node.meshes = [];
                for (let name of node.meshNames) {
                    node.meshes.push(gltfJson.meshDic[name]);
                }
                node.mesh = node.meshes[1];
                if (node.meshes == null || node.meshes.length === 0) {
                    node.mesh = node.meshes[0];
                }
                else {
                    const mergedMesh = {
                        name: '',
                        primitives: []
                    };
                    for (let i = 0; i < node.meshes.length; i++) {
                        mergedMesh.name += '_' + node.meshes[i].name;
                        Array.prototype.push.apply(mergedMesh.primitives, node.meshes[i].primitives);
                    }
                    mergedMesh.name += '_merged';
                    node.mesh = mergedMesh;
                    node.meshes = void 0;
                }
            }
            // Skin
            if (node.skin !== void 0 && gltfJson.skins !== void 0) {
                if (typeof node.skin === 'string') {
                    node.skinName = node.skin;
                    node.skin = gltfJson.skinDic[node.skinName];
                }
                // if (node.mesh.extras === void 0) {
                //   node.mesh.extras = {};
                // }
                //node.mesh.extras._skin = node.skin;
            }
            // Camera
            if (node.camera !== void 0 && gltfJson.cameras !== void 0) {
                node.cameraName = node.camera;
                node.camera = gltfJson.cameraDic[node.cameraName];
            }
        }
    }
    _loadDependenciesOfMeshes(gltfJson) {
        // Mesh
        for (let meshName in gltfJson.meshDic) {
            const mesh = gltfJson.meshDic[meshName];
            for (let primitive of mesh.primitives) {
                if (primitive.material !== void 0) {
                    primitive.materialName = primitive.material;
                    primitive.material = gltfJson.materialDic[primitive.materialName];
                    primitive.materialIndex = gltfJson.materials.indexOf(primitive.material);
                }
                primitive.attributeNames = Object.assign({}, primitive.attributes);
                primitive.attributes = [];
                for (let attributeName in primitive.attributeNames) {
                    if (primitive.attributeNames[attributeName] != null) {
                        const accessorName = primitive.attributeNames[attributeName];
                        let accessor = gltfJson.accessorDic[accessorName];
                        if (attributeName === 'JOINT') {
                            attributeName = 'JOINTS_0';
                            delete primitive.attributes['JOINT'];
                        }
                        else if (attributeName === 'WEIGHT') {
                            attributeName = 'WEIGHTS_0';
                            delete primitive.attributes['WEIGHT'];
                        }
                        accessor.extras = {
                            toGetAsTypedArray: true,
                            attributeName: attributeName
                        };
                        primitive.attributes.push(accessor);
                    }
                    else {
                        //primitive.attributes[attributeName] = void 0;
                    }
                }
                if (primitive.indices !== void 0) {
                    primitive.indicesName = primitive.indices;
                    primitive.indices = gltfJson.accessorDic[primitive.indicesName];
                }
            }
        }
    }
    _isKHRMaterialsCommon(materialJson) {
        if (typeof materialJson.extensions !== 'undefined' && typeof materialJson.extensions.KHR_materials_common !== 'undefined') {
            return true;
        }
        else {
            return false;
        }
    }
    _loadDependenciesOfMaterials(gltfJson) {
        // Material
        if (gltfJson.materials) {
            for (let materialStr in gltfJson.materials) {
                let material = gltfJson.materials[materialStr];
                const origMaterial = material;
                if (this._isKHRMaterialsCommon(material)) {
                    material = material.extensions.KHR_materials_common;
                }
                const setParameters = (values, isParameter) => {
                    for (let valueName in values) {
                        let value = null;
                        if (isParameter) {
                            value = values[valueName].value;
                            if (typeof value === 'undefined') {
                                continue;
                            }
                        }
                        else {
                            value = values[valueName];
                        }
                        if (typeof value === 'string') {
                            let textureStr = value;
                            let texturePurpose;
                            if (valueName === 'diffuse' || (material.technique === "CONSTANT" && valueName === 'ambient')) {
                                origMaterial.diffuseColorTexture = {};
                                origMaterial.diffuseColorTexture.texture = gltfJson.textures[value];
                            }
                            else if (valueName === 'emission' && textureStr.match(/_normal$/)) {
                                origMaterial.emissionTexture = {};
                                origMaterial.emissionTexture.texture = gltfJson.textures[value];
                            }
                            origMaterial.extras = {};
                            origMaterial.extras.technique = material.technique;
                        }
                        else {
                            if (valueName === 'diffuse') {
                                origMaterial.diffuseColorFactor = value;
                            }
                        }
                    }
                };
                setParameters(material.values, false);
                if (material.technique && gltfJson.techniques) {
                    if (typeof gltfJson.techniques[material.technique] !== "undefined") {
                        setParameters(gltfJson.techniques[material.technique].parameters, true);
                    }
                }
            }
        }
    }
    _loadDependenciesOfTextures(gltfJson) {
        // Texture
        if (gltfJson.textures) {
            for (let textureName in gltfJson.textureDic) {
                const texture = gltfJson.textureDic[textureName];
                if (texture.sampler !== void 0) {
                    texture.samplerName = texture.sampler;
                    texture.sampler = gltfJson.samplerDic[texture.samplerName];
                }
                if (texture.source !== void 0) {
                    texture.sourceName = texture.source;
                    texture.image = gltfJson.imageDic[texture.sourceName];
                }
            }
        }
    }
    _loadDependenciesOfJoints(gltfJson) {
        if (gltfJson.skins) {
            for (let skinName in gltfJson.skinDic) {
                const skin = gltfJson.skinDic[skinName];
                skin.joints = [];
                skin.jointsIndices = [];
                for (let jointName of skin.jointNames) {
                    const joint = gltfJson.nodeDic[jointName];
                    skin.joints.push(joint);
                    skin.jointsIndices.push(joint._index);
                }
                skin.skeletonNames = skin.skeletons;
                if (skin.skeletonNames) {
                    for (let name of skin.skeletonNames) {
                        skin.skeleton = skin.skeletons.push(gltfJson.nodeDic[name]);
                    }
                }
                else {
                    skin.skeleton = skin.joints[0];
                }
                skin.skeletonIndex = skin.skeleton._index;
                skin.inverseBindMatricesName = skin.inverseBindMatrices;
                skin.inverseBindMatrices = gltfJson.accessorDic[skin.inverseBindMatricesName];
                skin.joints_tmp = skin.joints;
                skin.joints = [];
                for (let joint of skin.joints_tmp) {
                    skin.joints.push(gltfJson.nodeDic[joint.name]);
                }
                skin.joints_tmp = void 0;
            }
        }
    }
    _loadDependenciesOfAnimations(gltfJson) {
        if (gltfJson.animations) {
            for (let animationName in gltfJson.animationDic) {
                const animation = gltfJson.animationDic[animationName];
                animation.samplerDic = animation.samplers;
                animation.samplers = [];
                for (let channel of animation.channels) {
                    channel.sampler = animation.samplerDic[channel.sampler];
                    channel.target.node = gltfJson.nodeDic[channel.target.id];
                    channel.target.nodeIndex = channel.target.node._index;
                    channel.sampler.input = gltfJson.accessors[animation.parameters['TIME']];
                    channel.sampler.output = gltfJson.accessors[animation.parameters[channel.target.path]];
                    animation.samplers.push(channel.sampler);
                    if (channel.target.path === 'rotation') {
                        if (channel.sampler.output.extras === void 0) {
                            channel.sampler.output.extras = {};
                        }
                        channel.sampler.output.extras.quaternionIfVec4 = true;
                    }
                }
                animation.channelDic = animation.channels;
                animation.channels = [];
                for (let channel of animation.channelDic) {
                    animation.channels.push(channel);
                }
            }
        }
    }
    _loadDependenciesOfAccessors(gltfJson) {
        // Accessor
        for (let accessorName in gltfJson.accessorDic) {
            const accessor = gltfJson.accessorDic[accessorName];
            if (accessor.bufferView !== void 0) {
                accessor.bufferViewName = accessor.bufferView;
                accessor.bufferView = gltfJson.bufferViewDic[accessor.bufferViewName];
            }
        }
    }
    _loadDependenciesOfBufferViews(gltfJson) {
        // BufferView
        for (let bufferViewName in gltfJson.bufferViewDic) {
            const bufferView = gltfJson.bufferViewDic[bufferViewName];
            if (bufferView.buffer !== void 0) {
                bufferView.bufferName = bufferView.buffer;
                bufferView.buffer = gltfJson.bufferDic[bufferView.bufferName];
                let bufferIdx = 0;
                for (let bufferName in gltfJson.bufferDic) {
                    if (bufferName === bufferView.bufferName) {
                        bufferView.bufferIndex = bufferIdx;
                    }
                    bufferIdx++;
                }
            }
        }
    }
    _mergeExtendedJson(gltfJson, extendedData) {
        let extendedJson = null;
        if (extendedData instanceof ArrayBuffer) {
            const extendedJsonStr = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].arrayBufferToString(extendedData);
            extendedJson = JSON.parse(extendedJsonStr);
        }
        else if (typeof extendedData === 'string') {
            extendedJson = JSON.parse(extendedData);
            extendedJson = extendedJson;
        }
        else if (typeof extendedData === 'object') {
            extendedJson = extendedData;
        }
        else {
        }
        Object.assign(gltfJson, extendedJson);
    }
    _loadResources(uint8Array, basePath, gltfJson, options, resources) {
        let promisesToLoadResources = [];
        // Shaders Async load
        // for (let _i in gltfJson.shaders) {
        //   const i = _i as any as number;
        //   resources.shaders[i] = {};
        //   let shaderJson = gltfJson.shaders[i];
        //   let shaderType = shaderJson.type;
        //   if (typeof shaderJson.extensions !== 'undefined' && typeof shaderJson.extensions.KHR_binary_glTF !== 'undefined') {
        //     resources.shaders[i].shaderText = this._accessBinaryAsShader(shaderJson.extensions.KHR_binary_glTF.bufferView, gltfJson, arrayBufferBinary);
        //     resources.shaders[i].shaderType = shaderType;
        //     continue;
        //   }
        //   let shaderUri = shaderJson.uri;
        //   if (options.files) {
        //     const splitted = shaderUri.split('/');
        //     const filename = splitted[splitted.length - 1];
        //     if (options.files[filename]) {
        //       const arrayBuffer = options.files[filename];
        //       resources.shaders[i].shaderText = DataUtil.arrayBufferToString(arrayBuffer);
        //       resources.shaders[i].shaderType = shaderType;
        //       continue;
        //     }
        //   }
        //   if (shaderUri.match(/^data:/)) {
        //     promisesToLoadResources.push(
        //       new Promise((resolve, rejected) => {
        //         let arrayBuffer = DataUtil.dataUriToArrayBuffer(shaderUri);
        //         resources.shaders[i].shaderText = DataUtil.arrayBufferToString(arrayBuffer);
        //         resources.shaders[i].shaderType = shaderType;
        //         resolve();
        //       })
        //     );
        //   } else {
        //     shaderUri = basePath + shaderUri;
        //     promisesToLoadResources.push(
        //       DataUtil.loadResourceAsync(shaderUri, false,
        //         (resolve:Function, response:any)=>{
        //           resources.shaders[i].shaderText = response;
        //           resources.shaders[i].shaderType = shaderType;
        //           resolve(gltfJson);
        //         },
        //         (reject:Function, error:any)=>{
        //         }
        //       )
        //     );
        //   }
        // }
        // Buffers Async load
        for (let i in gltfJson.buffers) {
            let bufferInfo = gltfJson.buffers[i];
            let filename = '';
            if (bufferInfo.uri) {
                const splitUri = bufferInfo.uri.split('/');
                filename = splitUri[splitUri.length - 1];
            }
            if (typeof bufferInfo.uri === 'undefined') {
                promisesToLoadResources.push(new Promise((resolve, rejected) => {
                    resources.buffers[i] = uint8Array;
                    bufferInfo.buffer = uint8Array;
                    resolve(gltfJson);
                }));
            }
            else if (bufferInfo.uri === '' || bufferInfo.uri === 'data:,') {
                promisesToLoadResources.push(new Promise((resolve, rejected) => {
                    resources.buffers[i] = uint8Array;
                    bufferInfo.buffer = uint8Array;
                    resolve(gltfJson);
                }));
            }
            else if (bufferInfo.uri.match(/^data:application\/(.*);base64,/)) {
                promisesToLoadResources.push(new Promise((resolve, rejected) => {
                    const arrayBuffer = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].dataUriToArrayBuffer(bufferInfo.uri);
                    resources.buffers[i] = new Uint8Array(arrayBuffer);
                    bufferInfo.buffer = new Uint8Array(arrayBuffer);
                    resolve(gltfJson);
                }));
            }
            else if (options.files && this.__containsFileName(options.files, filename)) {
                promisesToLoadResources.push(new Promise((resolve, reject) => {
                    const fullPath = this.__getFullPathOfFileName(options.files, filename);
                    const arrayBuffer = options.files[fullPath];
                    resources.buffers[i] = new Uint8Array(arrayBuffer);
                    bufferInfo.buffer = new Uint8Array(arrayBuffer);
                    resolve(gltfJson);
                }));
            }
            else {
                promisesToLoadResources.push(_misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].loadResourceAsync(basePath + bufferInfo.uri, true, (resolve, response) => {
                    resources.buffers[i] = new Uint8Array(response);
                    bufferInfo.buffer = new Uint8Array(response);
                    resolve(gltfJson);
                }, (reject, error) => {
                }));
            }
        }
        // Textures Async load
        for (let _i in gltfJson.images) {
            const i = _i;
            let imageJson = gltfJson.images[i];
            //let imageJson = gltfJson.images[textureJson.source];
            //let samplerJson = gltfJson.samplers[textureJson.sampler];
            let imageUri;
            if (typeof imageJson.extensions !== 'undefined' && typeof imageJson.extensions.KHR_binary_glTF !== 'undefined') {
                const imageUint8Array = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createUint8ArrayFromBufferViewInfo(gltfJson, imageJson.extensions.KHR_binary_glTF.bufferView, uint8Array);
                imageUri = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createBlobImageUriFromUint8Array(imageUint8Array, imageJson.extensions.KHR_binary_glTF.mimeType);
            }
            else if (typeof imageJson.uri === 'undefined') {
                const imageUint8Array = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createUint8ArrayFromBufferViewInfo(gltfJson, imageJson.bufferView, uint8Array);
                imageUri = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createBlobImageUriFromUint8Array(imageUint8Array, imageJson.mimeType);
            }
            else {
                const imageFileStr = imageJson.uri;
                const splitUri = imageFileStr.split('/');
                const filename = splitUri[splitUri.length - 1];
                if (options.files && this.__containsFileName(options.files, filename)) {
                    const fullPath = this.__getFullPathOfFileName(options.files, filename);
                    const arrayBuffer = options.files[fullPath];
                    imageUri = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createBlobImageUriFromUint8Array(new Uint8Array(arrayBuffer), imageJson.mimeType);
                }
                else if (imageFileStr.match(/^data:/)) {
                    imageUri = imageFileStr;
                }
                else {
                    imageUri = basePath + imageFileStr;
                }
            }
            if (imageUri.match(/basis$/)) {
                const promise = new Promise(async (resolve) => {
                    const response = await fetch(imageUri);
                    const buffer = await response.arrayBuffer();
                    const uint8Array = new Uint8Array(buffer);
                    imageJson.basis = uint8Array;
                    resolve();
                });
                promisesToLoadResources.push(promise);
            }
            else if (imageJson.uri != null && imageJson.uri.match(/basis$/)) {
                const promise = new Promise((resolve) => {
                    imageJson.basis = new Uint8Array(options.files[imageJson.uri]);
                    resolve();
                });
                promisesToLoadResources.push(promise);
            }
            else {
                const promise = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createImageFromUri(imageUri, imageJson.mimeType).then(function (image) {
                    image.crossOrigin = 'Anonymous';
                    resources.images[i] = image;
                    imageJson.image = image;
                });
                promisesToLoadResources.push(promise);
            }
        }
        if (options.defaultTextures) {
            const basePath = options.defaultTextures.basePath;
            const textureInfos = options.defaultTextures.textureInfos;
            for (let textureInfo of textureInfos) {
                const fileName = textureInfo.fileName;
                const uri = basePath + fileName;
                const fileExtension = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].getExtension(fileName);
                const mimeType = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].getMimeTypeFromExtension(fileExtension);
                const promise = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createImageFromUri(uri, mimeType).then(function (image) {
                    image.crossOrigin = 'Anonymous';
                    textureInfo.image = { image: image };
                });
                promisesToLoadResources.push(promise);
            }
        }
        return Promise.all(promisesToLoadResources);
    }
    __containsFileName(optionsFiles, filename) {
        for (let key in optionsFiles) {
            const split = key.split('/');
            const last = split[split.length - 1];
            if (last === filename) {
                return true;
            }
        }
        return false;
    }
    __getFullPathOfFileName(optionsFiles, filename) {
        for (let key in optionsFiles) {
            const split = key.split('/');
            const last = split[split.length - 1];
            if (last === filename) {
                return key;
            }
        }
        return undefined;
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new Gltf1Importer();
        }
        return this.__instance;
    }
}


/***/ }),

/***/ "./src/foundation/importer/Gltf2Importer.ts":
/*!**************************************************!*\
  !*** ./src/foundation/importer/Gltf2Importer.ts ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Gltf2Importer; });
/* harmony import */ var _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/DataUtil */ "./src/foundation/misc/DataUtil.ts");
/* harmony import */ var _misc_RnPromise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc/RnPromise */ "./src/foundation/misc/RnPromise.ts");


/**
 * The glTF2 Importer class.
 */
class Gltf2Importer {
    constructor() {
    }
    /**
     * Import glTF2 file
     * @param uri - uri of glTF file
     * @param options - options for loading process
     * @returns a glTF2 based JSON pre-processed
     */
    async import(uri, options) {
        const basePath = uri.substring(0, uri.lastIndexOf('/')) + '/'; // location of model file as basePath
        const defaultOptions = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createDefaultGltfOptions();
        if (options && options.files) {
            for (let fileName in options.files) {
                const fileExtension = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].getExtension(fileName);
                if (fileExtension === 'gltf' || fileExtension === 'glb') {
                    return await this.__loadFromArrayBuffer(options.files[fileName], defaultOptions, basePath, options).catch((err) => {
                        console.log('this.__loadFromArrayBuffer error', err);
                    });
                }
            }
        }
        const arrayBuffer = await _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].fetchArrayBuffer(uri);
        const glTFJson = await this.__loadFromArrayBuffer(arrayBuffer, defaultOptions, basePath, options).catch((err) => {
            console.log('this.__loadFromArrayBuffer error', err);
        });
        return glTFJson;
    }
    /**
     * Import glTF2 array buffer.
     * @param uri - uri of glTF file
     * @param arrayBuffer - fetched glTF file
     * @param options - options for loading process
     * @returns a glTF2 based JSON pre-processed
     */
    importArrayBuffer(uri, arrayBuffer, options) {
        const basePath = uri.substring(0, uri.lastIndexOf('/')) + '/'; // location of model file as basePath
        const defaultOptions = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createDefaultGltfOptions();
        return this.__loadFromArrayBuffer(arrayBuffer, defaultOptions, basePath, options).catch((err) => {
            console.log('__loadFromArrayBuffer error', err);
        });
    }
    async __loadFromArrayBuffer(arrayBuffer, defaultOptions, basePath, options) {
        const dataView = new DataView(arrayBuffer, 0, 20);
        const isLittleEndian = true;
        // Magic field
        const magic = dataView.getUint32(0, isLittleEndian);
        let result;
        // 0x46546C67 is 'glTF' in ASCII codes.
        if (magic !== 0x46546C67) {
            //const json = await response.json();
            const gotText = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].arrayBufferToString(arrayBuffer);
            const json = JSON.parse(gotText);
            result = await this._loadAsTextJson(json, options, defaultOptions, basePath).catch((err) => {
                console.log('this.__loadAsTextJson error', err);
            });
        }
        else {
            result = await this._loadAsBinaryJson(dataView, isLittleEndian, arrayBuffer, options, defaultOptions, basePath).catch((err) => {
                console.log('this.__loadAsBinaryJson error', err);
            });
        }
        return result;
    }
    _getOptions(defaultOptions, json, options) {
        if (json.asset && json.asset.extras && json.asset.extras.rnLoaderOptions) {
            for (let optionName in json.asset.extras.rnLoaderOptions) {
                defaultOptions[optionName] = json.asset.extras.rnLoaderOptions[optionName];
            }
        }
        for (let optionName in options) {
            defaultOptions[optionName] = options[optionName];
        }
        if (options && options.loaderExtension && typeof options.loaderExtension === "string") {
            if (Rn[options.loaderExtension] != null) {
                defaultOptions.loaderExtension = Rn[options.loaderExtension].getInstance();
            }
            else {
                console.error(`${options.loaderExtension} not found!`);
                defaultOptions.loaderExtension = void 0;
            }
        }
        return defaultOptions;
    }
    async _loadAsBinaryJson(dataView, isLittleEndian, arrayBuffer, options, defaultOptions, basePath) {
        let gltfVer = dataView.getUint32(4, isLittleEndian);
        if (gltfVer !== 2) {
            throw new Error('invalid version field in this binary glTF file.');
        }
        let lengthOfJSonChunkData = dataView.getUint32(12, isLittleEndian);
        let chunkType = dataView.getUint32(16, isLittleEndian);
        // 0x4E4F534A means JSON format (0x4E4F534A is 'JSON' in ASCII codes)
        if (chunkType !== 0x4E4F534A) {
            throw new Error('invalid chunkType of chunk0 in this binary glTF file.');
        }
        let uint8ArrayJSonContent = new Uint8Array(arrayBuffer, 20, lengthOfJSonChunkData);
        let gotText = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].uint8ArrayToString(uint8ArrayJSonContent);
        let gltfJson = JSON.parse(gotText);
        options = this._getOptions(defaultOptions, gltfJson, options);
        let uint8array = new Uint8Array(arrayBuffer, 20 + lengthOfJSonChunkData + 8);
        if (gltfJson.asset.extras === undefined) {
            gltfJson.asset.extras = { fileType: "glTF", version: "2" };
        }
        this._mergeExtendedJson(gltfJson, options.extendedJson);
        gltfJson.asset.extras.basePath = basePath;
        gltfJson.asset.extras.rnLoaderOptions = options;
        try {
            await this._loadInner(uint8array, basePath, gltfJson, options);
        }
        catch (err) {
            console.log("this._loadInner error in _loadAsBinaryJson", err);
        }
        return gltfJson;
    }
    async _loadAsTextJson(gltfJson, options, defaultOptions, basePath) {
        if (gltfJson.asset.extras === undefined) {
            gltfJson.asset.extras = { fileType: "glTF", version: "2" };
        }
        options = this._getOptions(defaultOptions, gltfJson, options);
        this._mergeExtendedJson(gltfJson, options.extendedJson);
        gltfJson.asset.extras.basePath = basePath;
        gltfJson.asset.extras.rnLoaderOptions = options;
        try {
            await this._loadInner(undefined, basePath, gltfJson, options);
        }
        catch (err) {
            console.log('this._loadInner error in _loadAsTextJson', err);
        }
        return gltfJson;
    }
    _loadInner(uint8array, basePath, gltfJson, options) {
        let promises = [];
        let resources = {
            shaders: [],
            buffers: [],
            images: []
        };
        promises.push(this._loadResources(uint8array, basePath, gltfJson, options, resources));
        promises.push(new Promise((resolve, reject) => {
            this._loadJsonContent(gltfJson, options);
            resolve();
        }));
        return Promise.all(promises);
    }
    _loadJsonContent(gltfJson, options) {
        // Scene
        this._loadDependenciesOfScenes(gltfJson);
        // Node
        this._loadDependenciesOfNodes(gltfJson);
        // Mesh
        this._loadDependenciesOfMeshes(gltfJson);
        // Material
        this._loadDependenciesOfMaterials(gltfJson);
        // Texture
        this._loadDependenciesOfTextures(gltfJson);
        // Joint
        this._loadDependenciesOfJoints(gltfJson);
        // Animation
        this._loadDependenciesOfAnimations(gltfJson);
        // Accessor
        this._loadDependenciesOfAccessors(gltfJson);
        // BufferView
        this._loadDependenciesOfBufferViews(gltfJson);
        if (gltfJson.asset === void 0) {
            gltfJson.asset = {};
        }
        if (gltfJson.asset.extras === void 0) {
            gltfJson.asset.extras = {};
        }
    }
    _loadDependenciesOfScenes(gltfJson) {
        for (let scene of gltfJson.scenes) {
            scene.nodesIndices = scene.nodes.concat();
            for (let i in scene.nodesIndices) {
                scene.nodes[i] = gltfJson.nodes[scene.nodes[i]];
            }
        }
    }
    _loadDependenciesOfNodes(gltfJson) {
        for (let node of gltfJson.nodes) {
            // Hierarchy
            if (node.children) {
                node.childrenIndices = node.children.concat();
                node.children = [];
                for (let i in node.childrenIndices) {
                    node.children[i] = gltfJson.nodes[node.childrenIndices[i]];
                }
            }
            // Mesh
            if (node.mesh !== void 0 && gltfJson.meshes !== void 0) {
                node.meshIndex = node.mesh;
                node.mesh = gltfJson.meshes[node.meshIndex];
            }
            // Skin
            if (node.skin !== void 0 && gltfJson.skins !== void 0) {
                node.skinIndex = node.skin;
                node.skin = gltfJson.skins[node.skinIndex];
                if (node.mesh.extras === void 0) {
                    node.mesh.extras = {};
                }
                node.mesh.extras._skin = node.skin;
            }
            // Camera
            if (node.camera !== void 0 && gltfJson.cameras !== void 0) {
                node.cameraIndex = node.camera;
                node.camera = gltfJson.cameras[node.cameraIndex];
            }
            // Lights
            if (node.extensions !== void 0 && gltfJson.extensions !== void 0 && gltfJson.extensions.KHR_lights_punctual !== void 0) {
                node.extensions.KHR_lights_punctual.lightIndex = node.extensions.KHR_lights_punctual.light;
                node.extensions.KHR_lights_punctual.light = gltfJson.extensions.KHR_lights_punctual.lights[node.extensions.KHR_lights_punctual.lightIndex];
            }
        }
    }
    _loadDependenciesOfMeshes(gltfJson) {
        // Mesh
        for (let mesh of gltfJson.meshes) {
            for (let primitive of mesh.primitives) {
                if (primitive.material !== void 0) {
                    primitive.materialIndex = primitive.material;
                    primitive.material = gltfJson.materials[primitive.materialIndex];
                }
                primitive.attributesIndex = Object.assign({}, primitive.attributes);
                for (let attributeName in primitive.attributesIndex) {
                    if (primitive.attributesIndex[attributeName] >= 0) {
                        let accessor = gltfJson.accessors[primitive.attributesIndex[attributeName]];
                        accessor.extras = {
                            toGetAsTypedArray: true,
                            attributeName: attributeName
                        };
                        primitive.attributes[attributeName] = accessor;
                    }
                    else {
                        primitive.attributes[attributeName] = void 0;
                    }
                }
                if (primitive.indices != null) {
                    primitive.indicesIndex = primitive.indices;
                    primitive.indices = gltfJson.accessors[primitive.indicesIndex];
                }
                if (primitive.targets != null) {
                    primitive.targetIndices = primitive.targets;
                    primitive.targets = [];
                    for (let target of primitive.targetIndices) {
                        const attributes = {};
                        for (let attributeName in target) {
                            if (target[attributeName] >= 0) {
                                let accessor = gltfJson.accessors[target[attributeName]];
                                accessor.extras = {
                                    toGetAsTypedArray: true,
                                    attributeName: attributeName
                                };
                                attributes[attributeName] = accessor;
                            }
                            else {
                                attributes[attributeName] = void 0;
                            }
                        }
                        primitive.targets.push(attributes);
                    }
                }
            }
        }
    }
    _checkRnGltfLoaderOptionsExist(gltfModel) {
        if (gltfModel.asset.extras && gltfModel.asset.extras.rnLoaderOptions) {
            return true;
        }
        else {
            return false;
        }
    }
    _loadDependenciesOfMaterials(gltfJson) {
        if (!gltfJson.textures)
            gltfJson.textures = [];
        // Material
        if (gltfJson.materials) {
            for (let material of gltfJson.materials) {
                if (material.pbrMetallicRoughness) {
                    let baseColorTexture = material.pbrMetallicRoughness.baseColorTexture;
                    if (baseColorTexture !== void 0) {
                        baseColorTexture.texture = gltfJson.textures[baseColorTexture.index];
                    }
                    let metallicRoughnessTexture = material.pbrMetallicRoughness.metallicRoughnessTexture;
                    if (metallicRoughnessTexture !== void 0) {
                        metallicRoughnessTexture.texture = gltfJson.textures[metallicRoughnessTexture.index];
                    }
                }
                let normalTexture = material.normalTexture;
                if (normalTexture !== void 0) {
                    normalTexture.texture = gltfJson.textures[normalTexture.index];
                }
                const occlusionTexture = material.occlusionTexture;
                if (occlusionTexture !== void 0) {
                    occlusionTexture.texture = gltfJson.textures[occlusionTexture.index];
                }
                const emissiveTexture = material.emissiveTexture;
                if (emissiveTexture !== void 0) {
                    emissiveTexture.texture = gltfJson.textures[emissiveTexture.index];
                }
                if (this._checkRnGltfLoaderOptionsExist(gltfJson) &&
                    gltfJson.asset.extras.rnLoaderOptions.loaderExtension &&
                    gltfJson.asset.extras.rnLoaderOptions.loaderExtension.setTextures) {
                    gltfJson.asset.extras.rnLoaderOptions.loaderExtension.setTextures(gltfJson, material);
                }
            }
        }
    }
    _loadDependenciesOfTextures(gltfJson) {
        // Texture
        if (gltfJson.textures) {
            for (let texture of gltfJson.textures) {
                if (texture.sampler !== void 0) {
                    texture.samplerIndex = texture.sampler;
                    texture.sampler = gltfJson.samplers[texture.samplerIndex];
                }
                if (texture.source !== void 0) {
                    texture.sourceIndex = texture.source;
                    texture.image = gltfJson.images[texture.sourceIndex];
                }
            }
        }
    }
    _loadDependenciesOfJoints(gltfJson) {
        if (gltfJson.skins) {
            for (let skin of gltfJson.skins) {
                skin.skeletonIndex = skin.skeleton;
                skin.skeleton = gltfJson.nodes[skin.skeletonIndex];
                skin.inverseBindMatricesIndex = skin.inverseBindMatrices;
                skin.inverseBindMatrices = gltfJson.accessors[skin.inverseBindMatricesIndex];
                if (skin.skeleton == null) {
                    skin.skeletonIndex = skin.joints[0];
                    skin.skeleton = gltfJson.nodes[skin.skeletonIndex];
                }
                skin.jointsIndices = skin.joints;
                skin.joints = [];
                for (let jointIndex of skin.jointsIndices) {
                    skin.joints.push(gltfJson.nodes[jointIndex]);
                }
            }
        }
    }
    _loadDependenciesOfAnimations(gltfJson) {
        if (gltfJson.animations) {
            for (let animation of gltfJson.animations) {
                for (let channel of animation.channels) {
                    channel.samplerIndex = channel.sampler;
                    channel.sampler = animation.samplers[channel.samplerIndex];
                    channel.target.nodeIndex = channel.target.node;
                    channel.target.node = gltfJson.nodes[channel.target.nodeIndex];
                }
                for (let channel of animation.channels) {
                    channel.sampler.inputIndex = channel.sampler.input;
                    channel.sampler.outputIndex = channel.sampler.output;
                    channel.sampler.input = gltfJson.accessors[channel.sampler.inputIndex];
                    channel.sampler.output = gltfJson.accessors[channel.sampler.outputIndex];
                    if (channel.sampler.output.extras === void 0) {
                        channel.sampler.output.extras = {};
                    }
                    if (channel.target.path === 'rotation') {
                        channel.sampler.output.extras.quaternionIfVec4 = true;
                    }
                    if (channel.target.path === 'weights') {
                        const weightCount = channel.sampler.output.count / channel.sampler.input.count;
                        channel.sampler.output.extras.weightCount = weightCount;
                    }
                }
            }
        }
    }
    _loadDependenciesOfAccessors(gltfJson) {
        // Accessor
        for (let accessor of gltfJson.accessors) {
            if (accessor.bufferView == null) {
                accessor.bufferView = 0;
            }
            accessor.bufferViewIndex = accessor.bufferView;
            accessor.bufferView = gltfJson.bufferViews[accessor.bufferViewIndex];
            if (accessor.sparse != null) {
                const sparse = accessor.sparse;
                sparse.indices.indicesIndex = sparse.indices.bufferView;
                sparse.indices.bufferView = gltfJson.bufferViews[sparse.indices.indicesIndex];
                sparse.values.valuesIndex = sparse.values.bufferView;
                sparse.values.bufferView = gltfJson.bufferViews[sparse.values.valuesIndex];
            }
        }
    }
    _loadDependenciesOfBufferViews(gltfJson) {
        // BufferView
        for (let bufferView of gltfJson.bufferViews) {
            if (bufferView.buffer !== void 0) {
                bufferView.bufferIndex = bufferView.buffer;
                bufferView.buffer = gltfJson.buffers[bufferView.bufferIndex];
            }
        }
    }
    _mergeExtendedJson(gltfJson, extendedData) {
        let extendedJson = null;
        if (extendedData instanceof ArrayBuffer) {
            const extendedJsonStr = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].arrayBufferToString(extendedData);
            extendedJson = JSON.parse(extendedJsonStr);
        }
        else if (typeof extendedData === 'string') {
            extendedJson = JSON.parse(extendedData);
            extendedJson = extendedJson;
        }
        else if (typeof extendedData === 'object') {
            extendedJson = extendedData;
        }
        else {
        }
        Object.assign(gltfJson, extendedJson);
    }
    _loadResources(uint8Array, basePath, gltfJson, options, resources) {
        let promisesToLoadResources = [];
        // Shaders Async load
        // for (let _i in gltfJson.shaders) {
        //   const i = _i as any as number;
        //   resources.shaders[i] = {};
        //   let shaderJson = gltfJson.shaders[i];
        //   let shaderType = shaderJson.type;
        //   if (typeof shaderJson.extensions !== 'undefined' && typeof shaderJson.extensions.KHR_binary_glTF !== 'undefined') {
        //     resources.shaders[i].shaderText = this._accessBinaryAsShader(shaderJson.extensions.KHR_binary_glTF.bufferView, gltfJson, arrayBufferBinary);
        //     resources.shaders[i].shaderType = shaderType;
        //     continue;
        //   }
        //   let shaderUri = shaderJson.uri;
        //   if (options.files) {
        //     const splitted = shaderUri.split('/');
        //     const filename = splitted[splitted.length - 1];
        //     if (options.files[filename]) {
        //       const arrayBuffer = options.files[filename];
        //       resources.shaders[i].shaderText = DataUtil.arrayBufferToString(arrayBuffer);
        //       resources.shaders[i].shaderType = shaderType;
        //       continue;
        //     }
        //   }
        //   if (shaderUri.match(/^data:/)) {
        //     promisesToLoadResources.push(
        //       new Promise((resolve, rejected) => {
        //         let arrayBuffer = DataUtil.dataUriToArrayBuffer(shaderUri);
        //         resources.shaders[i].shaderText = DataUtil.arrayBufferToString(arrayBuffer);
        //         resources.shaders[i].shaderType = shaderType;
        //         resolve();
        //       })
        //     );
        //   } else {
        //     shaderUri = basePath + shaderUri;
        //     promisesToLoadResources.push(
        //       DataUtil.loadResourceAsync(shaderUri, false,
        //         (resolve:Function, response:any)=>{
        //           resources.shaders[i].shaderText = response;
        //           resources.shaders[i].shaderType = shaderType;
        //           resolve(gltfJson);
        //         },
        //         (reject:Function, error:any)=>{
        //         }
        //       )
        //     );
        //   }
        // }
        // Buffers Async load
        let rnpArrayBuffer;
        for (let i in gltfJson.buffers) {
            let bufferInfo = gltfJson.buffers[i];
            let filename = '';
            if (bufferInfo.uri) {
                const splitUri = bufferInfo.uri.split('/');
                filename = splitUri[splitUri.length - 1];
            }
            if (typeof bufferInfo.uri === 'undefined') {
                rnpArrayBuffer = new _misc_RnPromise__WEBPACK_IMPORTED_MODULE_1__["default"]((resolve, rejected) => {
                    resources.buffers[i] = uint8Array;
                    bufferInfo.buffer = uint8Array;
                    resolve(uint8Array);
                });
            }
            else if (bufferInfo.uri.match(/^data:application\/(.*);base64,/)) {
                rnpArrayBuffer = new _misc_RnPromise__WEBPACK_IMPORTED_MODULE_1__["default"]((resolve, rejected) => {
                    let arrayBuffer = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].dataUriToArrayBuffer(bufferInfo.uri);
                    resources.buffers[i] = new Uint8Array(arrayBuffer);
                    bufferInfo.buffer = new Uint8Array(arrayBuffer);
                    resolve(arrayBuffer);
                });
            }
            else if (options.files && this.__containsFileName(options.files, filename)) {
                rnpArrayBuffer = new _misc_RnPromise__WEBPACK_IMPORTED_MODULE_1__["default"]((resolve, rejected) => {
                    const fullPath = this.__getFullPathOfFileName(options.files, filename);
                    const arrayBuffer = options.files[fullPath];
                    resources.buffers[i] = new Uint8Array(arrayBuffer);
                    bufferInfo.buffer = new Uint8Array(arrayBuffer);
                    resolve(arrayBuffer);
                });
            }
            else {
                rnpArrayBuffer = new _misc_RnPromise__WEBPACK_IMPORTED_MODULE_1__["default"](_misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].loadResourceAsync(basePath + bufferInfo.uri, true, (resolve, response) => {
                    resources.buffers[i] = new Uint8Array(response);
                    bufferInfo.buffer = new Uint8Array(response);
                    resolve(response);
                }, (reject, error) => {
                }));
            }
            bufferInfo.bufferPromise = rnpArrayBuffer;
            promisesToLoadResources.push(rnpArrayBuffer);
        }
        // Textures Async load
        for (let _i in gltfJson.images) {
            const i = _i;
            let imageJson = gltfJson.images[i];
            //let imageJson = gltfJson.images[textureJson.source];
            //let samplerJson = gltfJson.samplers[textureJson.sampler];
            let imageUri;
            if (typeof imageJson.uri === 'undefined') {
                let arrayBuffer = uint8Array;
                if (uint8Array == null) {
                    const bufferView = gltfJson.bufferViews[imageJson.bufferView];
                    arrayBuffer = bufferView.buffer.buffer;
                }
                const imageUint8Array = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createUint8ArrayFromBufferViewInfo(gltfJson, imageJson.bufferView, uint8Array);
                imageUri = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createBlobImageUriFromUint8Array(imageUint8Array, imageJson.mimeType);
            }
            else {
                const imageFileStr = imageJson.uri;
                const splitUri = imageFileStr.split('/');
                const filename = splitUri[splitUri.length - 1];
                if (options.files && this.__containsFileName(options.files, filename)) {
                    const fullPath = this.__getFullPathOfFileName(options.files, filename);
                    const arrayBuffer = options.files[fullPath];
                    imageUri = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createBlobImageUriFromUint8Array(new Uint8Array(arrayBuffer), imageJson.mimeType);
                }
                else if (imageFileStr.match(/^data:/)) {
                    imageUri = imageFileStr;
                }
                else {
                    imageUri = basePath + imageFileStr;
                }
            }
            // if (options.extensionLoader && options.extensionLoader.setUVTransformToTexture) {
            //   options.extensionLoader.setUVTransformToTexture(texture, samplerJson);
            // }
            if (imageUri.match(/basis$/)) {
                const promise = new Promise(async (resolve) => {
                    const response = await fetch(imageUri);
                    const buffer = await response.arrayBuffer();
                    const uint8Array = new Uint8Array(buffer);
                    imageJson.basis = uint8Array;
                    resolve();
                });
                promisesToLoadResources.push(promise);
            }
            else if (imageJson.uri != null && imageJson.uri.match(/basis$/)) {
                const promise = new Promise((resolve) => {
                    imageJson.basis = new Uint8Array(options.files[imageJson.uri]);
                    resolve();
                });
                promisesToLoadResources.push(promise);
            }
            else {
                const promise = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createImageFromUri(imageUri, imageJson.mimeType).then(function (image) {
                    image.crossOrigin = 'Anonymous';
                    resources.images[i] = image;
                    imageJson.image = image;
                });
                promisesToLoadResources.push(promise);
            }
        }
        if (options.defaultTextures) {
            const basePath = options.defaultTextures.basePath;
            const textureInfos = options.defaultTextures.textureInfos;
            for (let textureInfo of textureInfos) {
                const fileName = textureInfo.fileName;
                const uri = basePath + fileName;
                const fileExtension = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].getExtension(fileName);
                const mimeType = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].getMimeTypeFromExtension(fileExtension);
                const promise = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_0__["default"].createImageFromUri(uri, mimeType).then(function (image) {
                    image.crossOrigin = 'Anonymous';
                    textureInfo.image = { image: image };
                });
                promisesToLoadResources.push(promise);
            }
        }
        return Promise.all(promisesToLoadResources).catch((err) => {
            console.log('Promise.all error', err);
        });
    }
    __containsFileName(optionsFiles, filename) {
        for (let key in optionsFiles) {
            const split = key.split('/');
            const last = split[split.length - 1];
            if (last === filename) {
                return true;
            }
        }
        return false;
    }
    __getFullPathOfFileName(optionsFiles, filename) {
        for (let key in optionsFiles) {
            const split = key.split('/');
            const last = split[split.length - 1];
            if (last === filename) {
                return key;
            }
        }
        return undefined;
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new Gltf2Importer();
        }
        return this.__instance;
    }
}


/***/ }),

/***/ "./src/foundation/importer/GltfImporter.ts":
/*!*************************************************!*\
  !*** ./src/foundation/importer/GltfImporter.ts ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GltfImporter; });
/* harmony import */ var _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EntityRepository */ "./src/foundation/core/EntityRepository.ts");
/* harmony import */ var _FormatDetector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FormatDetector */ "./src/foundation/importer/FormatDetector.ts");
/* harmony import */ var _Gltf2Importer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Gltf2Importer */ "./src/foundation/importer/Gltf2Importer.ts");
/* harmony import */ var _ModelConverter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ModelConverter */ "./src/foundation/importer/ModelConverter.ts");
/* harmony import */ var _components_PhysicsComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/PhysicsComponent */ "./src/foundation/components/PhysicsComponent.ts");
/* harmony import */ var _physics_SphereCollider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../physics/SphereCollider */ "./src/foundation/physics/SphereCollider.ts");
/* harmony import */ var _textures_Texture__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../textures/Texture */ "./src/foundation/textures/Texture.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _physics_VRMColliderGroup__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../physics/VRMColliderGroup */ "./src/foundation/physics/VRMColliderGroup.ts");
/* harmony import */ var _physics_VRMSpringBoneGroup__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../physics/VRMSpringBoneGroup */ "./src/foundation/physics/VRMSpringBoneGroup.ts");
/* harmony import */ var _physics_VRMSpringBonePhysicsStrategy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../physics/VRMSpringBonePhysicsStrategy */ "./src/foundation/physics/VRMSpringBonePhysicsStrategy.ts");
/* harmony import */ var _Gltf1Importer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Gltf1Importer */ "./src/foundation/importer/Gltf1Importer.ts");
/* harmony import */ var _DrcPointCloudImporter__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./DrcPointCloudImporter */ "./src/foundation/importer/DrcPointCloudImporter.ts");
/* harmony import */ var _renderer_Expression__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../renderer/Expression */ "./src/foundation/renderer/Expression.ts");
/* harmony import */ var _renderer_RenderPass__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../renderer/RenderPass */ "./src/foundation/renderer/RenderPass.ts");
/* harmony import */ var _misc_DataUtil__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../misc/DataUtil */ "./src/foundation/misc/DataUtil.ts");
















/**
 * Importer class which can import GLTF and VRM.
 */
class GltfImporter {
    constructor() { }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new GltfImporter();
        }
        return this.__instance;
    }
    /**
     * For VRM file only
     * Generate JSON.
     */
    async importJsonOfVRM(uri, options) {
        options = this._getOptions(options);
        const gltf2Importer = _Gltf2Importer__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance();
        const gltfModel = await gltf2Importer.import(uri, options);
        this._readVRMHumanoidInfo(gltfModel);
        return gltfModel;
    }
    /**
     * Import GLTF or VRM file.
     * @param uris uri or array of uri of glTF file
     * @param options options for loading process where if you use files option, key name of files must be uri of the value array buffer
     * @returns gltf expression where:
     *            renderPasses[0]: model entities
     *            renderPasses[1]: model outlines
     */
    async import(uris, options) {
        if (!Array.isArray(uris)) {
            uris = [uris];
        }
        options = this.__initOptions(options);
        const renderPasses = await this.__importMultipleModels(uris, options);
        if (options && options.cameraComponent) {
            for (let renderPass of renderPasses) {
                renderPass.cameraComponent = options.cameraComponent;
            }
        }
        return this.__setRenderPassesToExpression(renderPasses, options);
    }
    __initOptions(options) {
        var _a;
        if (options == null) {
            options = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_15__["default"].createDefaultGltfOptions();
        }
        else {
            if (options.files == null) {
                options.files = {};
            }
            for (let file in options.files) {
                if (file.match(/.*\.vrm$/) == null) {
                    continue;
                }
                const fileName = file.split('.vrm')[0];
                if (fileName) {
                    const arraybuffer = options.files[file];
                    options.files[fileName + '.glb'] = arraybuffer;
                    delete options.files[file];
                }
            }
            if (Array.isArray(options.defaultMaterialHelperArgumentArray) === false) {
                options.defaultMaterialHelperArgumentArray = [{}];
            }
            else {
                // avoid needless processing
                if (((_a = options.defaultMaterialHelperArgumentArray[0]) === null || _a === void 0 ? void 0 : _a.isMorphing) === false) {
                    options.maxMorphTargetNumber = 0;
                }
            }
        }
        return options;
    }
    __setRenderPassesToExpression(renderPasses, options) {
        var _a;
        const expression = (_a = options.expression) !== null && _a !== void 0 ? _a : new _renderer_Expression__WEBPACK_IMPORTED_MODULE_13__["default"]();
        if (expression.renderPasses !== renderPasses) {
            expression.clearRenderPasses();
            expression.addRenderPasses(renderPasses);
        }
        return expression;
    }
    __importMultipleModels(uris, options) {
        var _a;
        const importPromises = [];
        const renderPasses = ((_a = options.expression) === null || _a === void 0 ? void 0 : _a.renderPasses) || [];
        if (renderPasses.length === 0) {
            renderPasses.push(new _renderer_RenderPass__WEBPACK_IMPORTED_MODULE_14__["default"]());
        }
        for (let fileName in options.files) { // filename is uri
            const fileExtension = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_15__["default"].getExtension(fileName);
            if (this.__isValidExtension(fileExtension)) {
                importPromises.push(this.__importToRenderPassesFromArrayBufferPromise(fileName, renderPasses, options, fileName));
            }
        }
        for (let uri of uris) {
            if (uri.length === 0 || options.files[uri] != null) {
                // import from uri where the file is not fetched yet
                continue;
            }
            importPromises.push(this.__importToRenderPassesFromUriPromise(uri, renderPasses, options));
        }
        return Promise.all(importPromises).then(() => {
            return renderPasses;
        });
    }
    __isValidExtension(fileExtension) {
        if (fileExtension === 'gltf' || fileExtension === 'glb' ||
            fileExtension === 'vrm' || fileExtension === 'drc') {
            return true;
        }
        else {
            return false;
        }
    }
    __importToRenderPassesFromUriPromise(uri, renderPasses, options) {
        return _misc_DataUtil__WEBPACK_IMPORTED_MODULE_15__["default"].fetchArrayBuffer(uri).then((arrayBuffer) => {
            options.files[uri] = arrayBuffer;
            return this.__importToRenderPassesFromArrayBufferPromise(uri, renderPasses, options, uri);
        });
    }
    __importToRenderPassesFromArrayBufferPromise(fileName, renderPasses, options, uri) {
        const optionalFileType = options.fileType;
        return this.__getFileTypeFromFilePromise(fileName, options, optionalFileType).then((fileType) => {
            return new Promise((resolve, reject) => {
                let importer;
                const modelConverter = _ModelConverter__WEBPACK_IMPORTED_MODULE_3__["default"].getInstance();
                const file = options.files[fileName];
                options.isImportVRM = false;
                switch (fileType) {
                    case 'glTF1':
                        importer = _Gltf1Importer__WEBPACK_IMPORTED_MODULE_11__["default"].getInstance();
                        importer.importArrayBuffer(uri, file, options).then((gltfModel) => {
                            const rootGroup = modelConverter.convertToRhodoniteObject(gltfModel);
                            renderPasses[0].addEntities([rootGroup]);
                            resolve();
                        });
                        break;
                    case 'glTF2':
                        importer = _Gltf2Importer__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance();
                        importer.importArrayBuffer(uri, file, options).then((gltfModel) => {
                            const rootGroup = modelConverter.convertToRhodoniteObject(gltfModel);
                            renderPasses[0].addEntities([rootGroup]);
                            resolve();
                        });
                        break;
                    case 'Draco':
                        importer = _DrcPointCloudImporter__WEBPACK_IMPORTED_MODULE_12__["default"].getInstance();
                        importer.importArrayBuffer(uri, file, options).then((gltfModel) => {
                            if (gltfModel == null) {
                                console.error('importArrayBuffer error is occurred');
                                reject();
                            }
                            else {
                                const rootGroup = modelConverter.convertToRhodoniteObject(gltfModel);
                                renderPasses[0].addEntities([rootGroup]);
                                resolve();
                            }
                        });
                        break;
                    case 'VRM':
                        options.isImportVRM = true;
                        this.__importVRM(uri, file, renderPasses, options).then(() => {
                            resolve();
                        });
                        break;
                    default:
                        console.error('detect invalid format');
                        reject();
                }
            });
        });
    }
    __getFileTypeFromFilePromise(fileName, options, optionalFileType) {
        return new Promise((resolve) => {
            if (optionalFileType != null) {
                resolve(optionalFileType);
            }
            else {
                Object(_FormatDetector__WEBPACK_IMPORTED_MODULE_1__["default"])('', { [fileName]: options.files[fileName] }).then((fileType) => {
                    resolve(fileType);
                });
            }
        });
    }
    __importVRM(uri, file, renderPasses, options) {
        const gltf2Importer = _Gltf2Importer__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance();
        return gltf2Importer.importArrayBuffer(uri, file, options).then((gltfModel) => {
            var _a;
            const textures = this._createTextures(gltfModel);
            const defaultMaterialHelperArgumentArray = gltfModel.asset.extras.rnLoaderOptions.defaultMaterialHelperArgumentArray;
            defaultMaterialHelperArgumentArray[0].textures = textures;
            this._initializeMaterialProperties(gltfModel, textures.length);
            let rootGroup;
            const modelConverter = _ModelConverter__WEBPACK_IMPORTED_MODULE_3__["default"].getInstance();
            const existOutline = this._existOutlineMaterial(gltfModel.extensions.VRM);
            if (existOutline) {
                renderPasses[1] = (_a = renderPasses[1]) !== null && _a !== void 0 ? _a : new _renderer_RenderPass__WEBPACK_IMPORTED_MODULE_14__["default"]();
                const renderPassOutline = renderPasses[1];
                renderPassOutline.toClearColorBuffer = false;
                renderPassOutline.toClearDepthBuffer = false;
                gltfModel.extensions.VRM.rnExtension = { renderPassOutline: renderPassOutline };
                rootGroup = modelConverter.convertToRhodoniteObject(gltfModel);
                renderPassOutline.addEntities([rootGroup]);
            }
            else {
                rootGroup = modelConverter.convertToRhodoniteObject(gltfModel);
            }
            const renderPassMain = renderPasses[0];
            renderPassMain.addEntities([rootGroup]);
            this._readSpringBone(rootGroup, gltfModel);
            this._readVRMHumanoidInfo(gltfModel, rootGroup);
        });
    }
    _getOptions(options) {
        if (options != null) {
            for (let file in options.files) {
                const fileName = file.split('.vrm')[0];
                if (fileName) {
                    const arraybuffer = options.files[file];
                    options.files[fileName + '.glb'] = arraybuffer;
                    delete options.files[file];
                }
            }
            //set default values
            options.isImportVRM = true;
            if (options.defaultMaterialHelperArgumentArray == null) {
                options.defaultMaterialHelperArgumentArray = [{}];
            }
            if (!options.defaultMaterialHelperArgumentArray[0].isMorphing) {
                options.maxMorphTargetNumber = 0;
            }
        }
        else {
            options = {
                files: {},
                loaderExtension: undefined,
                defaultMaterialHelperName: undefined,
                defaultMaterialHelperArgumentArray: [{ isLighting: true, isMorphing: true, isSkinning: true }],
                statesOfElements: [
                    {
                        targets: [],
                        states: {
                            enable: [],
                            functions: {}
                        },
                        isTransparent: true,
                        opacity: 1.0,
                        isTextureImageToLoadPreMultipliedAlpha: false,
                    }
                ],
                isImportVRM: true,
            };
        }
        return options;
    }
    _readVRMHumanoidInfo(gltfModel, rootEntity) {
        const humanBones = gltfModel.extensions.VRM.humanoid.humanBones;
        const mapNameNodeId = new Map();
        // const mapNameNodeName: Map<string, string> = new Map();
        for (let bone of humanBones) {
            mapNameNodeId.set(bone.bone, bone.node);
            const boneNode = gltfModel.nodes[bone.node];
            bone.name = boneNode.name;
        }
        if (rootEntity != null) {
            rootEntity.tryToSetTag({
                tag: 'humanoid_map_name_nodeId',
                value: mapNameNodeId
            });
        }
        // rootEntity.tryToSetTag({
        //   tag: 'humanoid_map_name_nodeName',
        //   value: mapNameNodeName
        // });
    }
    _readSpringBone(rootEntity, gltfModel) {
        const entityRepository = _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
        const boneGroups = [];
        for (let boneGroup of gltfModel.extensions.VRM.secondaryAnimation.boneGroups) {
            const vrmSpringBoneGroup = new _physics_VRMSpringBoneGroup__WEBPACK_IMPORTED_MODULE_9__["default"]();
            vrmSpringBoneGroup.tryToSetUniqueName(boneGroup.comment, true);
            vrmSpringBoneGroup.dragForce = boneGroup.dragForce;
            vrmSpringBoneGroup.stiffnessForce = boneGroup.stiffiness;
            vrmSpringBoneGroup.gravityPower = boneGroup.gravityPower;
            vrmSpringBoneGroup.gravityDir = new _math_Vector3__WEBPACK_IMPORTED_MODULE_7__["default"](boneGroup.gravityDir.x, boneGroup.gravityDir.y, boneGroup.gravityDir.z);
            vrmSpringBoneGroup.colliderGroupIndices = boneGroup.colliderGroups;
            vrmSpringBoneGroup.hitRadius = boneGroup.hitRadius;
            for (let idxOfArray in boneGroup.bones) {
                const boneNodeIndex = boneGroup.bones[idxOfArray];
                const entity = gltfModel.asset.extras.rnEntities[boneNodeIndex];
                vrmSpringBoneGroup.rootBones.push(entity.getSceneGraph());
                // const boneNodeIndex = boneGroup.bones[idxOfArray];
                // const entity = gltfModel.asset.extras!.rnEntities![boneNodeIndex];
                // entityRepository.addComponentsToEntity([PhysicsComponent], entity.entityUID);
            }
            boneGroups.push(vrmSpringBoneGroup);
        }
        _physics_VRMSpringBonePhysicsStrategy__WEBPACK_IMPORTED_MODULE_10__["default"].setBoneGroups(boneGroups);
        for (let boneGroup of boneGroups) {
            for (let sg of boneGroup.rootBones) {
                this.addPhysicsComponentRecursively(entityRepository, sg);
            }
        }
        const colliderGroups = [];
        for (let colliderGroupIdx in gltfModel.extensions.VRM.secondaryAnimation.colliderGroups) {
            const colliderGroup = gltfModel.extensions.VRM.secondaryAnimation.colliderGroups[colliderGroupIdx];
            const vrmColliderGroup = new _physics_VRMColliderGroup__WEBPACK_IMPORTED_MODULE_8__["default"]();
            colliderGroups.push(vrmColliderGroup);
            const colliders = [];
            for (let collider of colliderGroup.colliders) {
                const sphereCollider = new _physics_SphereCollider__WEBPACK_IMPORTED_MODULE_5__["default"]();
                sphereCollider.position = new _math_Vector3__WEBPACK_IMPORTED_MODULE_7__["default"](collider.offset.x, collider.offset.y, collider.offset.z);
                sphereCollider.radius = collider.radius;
                colliders.push(sphereCollider);
            }
            vrmColliderGroup.colliders = colliders;
            const baseSg = gltfModel.asset.extras.rnEntities[colliderGroup.node].getSceneGraph();
            vrmColliderGroup.baseSceneGraph = baseSg;
            _physics_VRMSpringBonePhysicsStrategy__WEBPACK_IMPORTED_MODULE_10__["default"].addColliderGroup(parseInt(colliderGroupIdx), vrmColliderGroup);
        }
    }
    addPhysicsComponentRecursively(entityRepository, sg) {
        const entity = sg.entity;
        entityRepository.addComponentsToEntity([_components_PhysicsComponent__WEBPACK_IMPORTED_MODULE_4__["default"]], entity.entityUID);
        _physics_VRMSpringBonePhysicsStrategy__WEBPACK_IMPORTED_MODULE_10__["default"].initialize(sg);
        if (sg.children.length > 0) {
            for (let child of sg.children) {
                this.addPhysicsComponentRecursively(entityRepository, child);
            }
        }
    }
    _createTextures(gltfModel) {
        if (!gltfModel.textures)
            gltfModel.textures = [];
        const gltfTextures = gltfModel.textures;
        const rnTextures = [];
        for (let i = 0; i < gltfTextures.length; i++) {
            const rnTexture = _ModelConverter__WEBPACK_IMPORTED_MODULE_3__["default"]._createTexture({ texture: gltfTextures[i] }, gltfModel);
            rnTextures[i] = rnTexture;
        }
        const dummyWhiteTexture = new _textures_Texture__WEBPACK_IMPORTED_MODULE_6__["default"]();
        dummyWhiteTexture.generate1x1TextureFrom();
        rnTextures.push(dummyWhiteTexture);
        const dummyBlackTexture = new _textures_Texture__WEBPACK_IMPORTED_MODULE_6__["default"]();
        dummyBlackTexture.generate1x1TextureFrom("rgba(0, 0, 0, 1)");
        rnTextures.push(dummyBlackTexture);
        return rnTextures;
    }
    _existOutlineMaterial(extensionsVRM) {
        const materialProperties = extensionsVRM.materialProperties;
        if (materialProperties != null) {
            for (let materialProperty of materialProperties) {
                if (materialProperty.floatProperties._OutlineWidthMode !== 0) {
                    return true;
                }
            }
        }
        return false;
    }
    _initializeMaterialProperties(gltfModel, texturesLength) {
        const materialProperties = gltfModel.extensions.VRM.materialProperties;
        for (let materialProperty of materialProperties) {
            if (materialProperty.shader === "VRM/MToon") {
                this.__initializeMToonMaterialProperties(gltfModel, texturesLength);
                break;
            }
        }
    }
    __initializeMToonMaterialProperties(gltfModel, texturesLength) {
        const materialProperties = gltfModel.extensions.VRM.materialProperties;
        const dummyWhiteTextureNumber = texturesLength - 2;
        const dummyBlackTextureNumber = texturesLength - 1;
        for (let i = 0; i < materialProperties.length; i++) {
            const floatProperties = materialProperties[i].floatProperties;
            this.__initializeForUndefinedProperty(floatProperties, "_BlendMode", 0.0);
            this.__initializeForUndefinedProperty(floatProperties, "_BumpScale", 1.0);
            this.__initializeForUndefinedProperty(floatProperties, "_CullMode", 2.0);
            this.__initializeForUndefinedProperty(floatProperties, "_Cutoff", 0.5);
            this.__initializeForUndefinedProperty(floatProperties, "_DebugMode", 0.0);
            this.__initializeForUndefinedProperty(floatProperties, "_DstBlend", 0.0);
            this.__initializeForUndefinedProperty(floatProperties, "_IndirectLightIntensity", 0.1);
            this.__initializeForUndefinedProperty(floatProperties, "_LightColorAttenuation", 0.0);
            this.__initializeForUndefinedProperty(floatProperties, "_OutlineColorMode", 0.0);
            this.__initializeForUndefinedProperty(floatProperties, "_OutlineCullMode", 1.0);
            this.__initializeForUndefinedProperty(floatProperties, "_OutlineLightingMix", 1.0);
            this.__initializeForUndefinedProperty(floatProperties, "_OutlineScaledMaxDistance", 1.0);
            this.__initializeForUndefinedProperty(floatProperties, "_OutlineWidth", 0.5);
            this.__initializeForUndefinedProperty(floatProperties, "_OutlineWidthMode", 0.0);
            this.__initializeForUndefinedProperty(floatProperties, "_ReceiveShadowRate", 1.0);
            this.__initializeForUndefinedProperty(floatProperties, "_RimFresnelPower", 1.0);
            this.__initializeForUndefinedProperty(floatProperties, "_RimLift", 0.0);
            this.__initializeForUndefinedProperty(floatProperties, "_RimLightingMix", 0.0);
            this.__initializeForUndefinedProperty(floatProperties, "_ShadeShift", 0.0);
            this.__initializeForUndefinedProperty(floatProperties, "_ShadeToony", 0.9);
            this.__initializeForUndefinedProperty(floatProperties, "_ShadingGradeRate", 1.0);
            this.__initializeForUndefinedProperty(floatProperties, "_SrcBlend", 1.0);
            this.__initializeForUndefinedProperty(floatProperties, "_ZWrite", 1.0);
            // this.__initializeForUndefinedProperty(floatProperties,"_UvAnimScrollX", 0.0);
            // this.__initializeForUndefinedProperty(floatProperties,"_UvAnimScrollY", 0.0);
            // this.__initializeForUndefinedProperty(floatProperties,"_UvAnimRotation", 0.0);
            const vectorProperties = materialProperties[i].vectorProperties;
            this.__initializeForUndefinedProperty(vectorProperties, "_Color", [1, 1, 1, 1]);
            this.__initializeForUndefinedProperty(vectorProperties, "_EmissionColor", [0, 0, 0]);
            this.__initializeForUndefinedProperty(vectorProperties, "_OutlineColor", [0, 0, 0, 1]);
            this.__initializeForUndefinedProperty(vectorProperties, "_ShadeColor", [0.97, 0.81, 0.86, 1]);
            this.__initializeForUndefinedProperty(vectorProperties, "_RimColor", [0, 0, 0]);
            // this.__initializeForUndefinedProperty(vectorProperties, "_BumpMap", [0, 0, 1, 1]);
            // this.__initializeForUndefinedProperty(vectorProperties, "_EmissionMap", [0, 0, 1, 1]);
            // this.__initializeForUndefinedProperty(vectorProperties, "_MainTex", [0, 0, 1, 1]);
            // this.__initializeForUndefinedProperty(vectorProperties, "_OutlineWidthTexture", [0, 0, 1, 1]);
            // this.__initializeForUndefinedProperty(vectorProperties, "_ReceiveShadowTexture", [0, 0, 1, 1]);
            // this.__initializeForUndefinedProperty(vectorProperties, "_ShadeTexture", [0, 0, 1, 1]);
            // this.__initializeForUndefinedProperty(vectorProperties, "_ShadingGradeTexture", [0, 0, 1, 1]);
            // this.__initializeForUndefinedProperty(vectorProperties, "_SphereAdd", [0, 0, 1, 1]);
            // set num of texture array
            const textureProperties = materialProperties[i].textureProperties;
            this.__initializeForUndefinedProperty(textureProperties, "_BumpMap", dummyWhiteTextureNumber);
            this.__initializeForUndefinedProperty(textureProperties, "_EmissionMap", dummyBlackTextureNumber);
            this.__initializeForUndefinedProperty(textureProperties, "_MainTex", dummyWhiteTextureNumber);
            this.__initializeForUndefinedProperty(textureProperties, "_OutlineWidthTexture", dummyWhiteTextureNumber);
            this.__initializeForUndefinedProperty(textureProperties, "_ReceiveShadowTexture", dummyWhiteTextureNumber);
            this.__initializeForUndefinedProperty(textureProperties, "_RimTexture", dummyBlackTextureNumber);
            this.__initializeForUndefinedProperty(textureProperties, "_ShadeTexture", dummyWhiteTextureNumber);
            this.__initializeForUndefinedProperty(textureProperties, "_ShadingGradeTexture", dummyWhiteTextureNumber);
            this.__initializeForUndefinedProperty(textureProperties, "_SphereAdd", dummyBlackTextureNumber);
            // this.__initializeForUndefinedProperty(textureProperties, "_UvAnimMaskTexture", dummyWhiteTextureNumber);
        }
    }
    __initializeForUndefinedProperty(object, propertyName, initialValue) {
        if (object[propertyName] == null)
            object[propertyName] = initialValue;
    }
}


/***/ }),

/***/ "./src/foundation/importer/ModelConverter.ts":
/*!***************************************************!*\
  !*** ./src/foundation/importer/ModelConverter.ts ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelConverter; });
/* harmony import */ var _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EntityRepository */ "./src/foundation/core/EntityRepository.ts");
/* harmony import */ var _components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/TransformComponent */ "./src/foundation/components/TransformComponent.ts");
/* harmony import */ var _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _components_MeshComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/MeshComponent */ "./src/foundation/components/MeshComponent.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_Quaternion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Quaternion */ "./src/foundation/math/Quaternion.ts");
/* harmony import */ var _math_Matrix44__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/MeshRendererComponent */ "./src/foundation/components/MeshRendererComponent.ts");
/* harmony import */ var _geometry_Primitive__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geometry/Primitive */ "./src/foundation/geometry/Primitive.ts");
/* harmony import */ var _memory_Buffer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../memory/Buffer */ "./src/foundation/memory/Buffer.ts");
/* harmony import */ var _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../definitions/PrimitiveMode */ "./src/foundation/definitions/PrimitiveMode.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _definitions_CameraType__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../definitions/CameraType */ "./src/foundation/definitions/CameraType.ts");
/* harmony import */ var _textures_Texture__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../textures/Texture */ "./src/foundation/textures/Texture.ts");
/* harmony import */ var _math_Vector4__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _components_AnimationComponent__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../components/AnimationComponent */ "./src/foundation/components/AnimationComponent.ts");
/* harmony import */ var _definitions_AnimationInterpolation__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../definitions/AnimationInterpolation */ "./src/foundation/definitions/AnimationInterpolation.ts");
/* harmony import */ var _math_MathUtil__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../math/MathUtil */ "./src/foundation/math/MathUtil.ts");
/* harmony import */ var _components_SkeletalComponent__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../components/SkeletalComponent */ "./src/foundation/components/SkeletalComponent.ts");
/* harmony import */ var _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../definitions/AlphaMode */ "./src/foundation/definitions/AlphaMode.ts");
/* harmony import */ var _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../helpers/MaterialHelper */ "./src/foundation/helpers/MaterialHelper.ts");
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../math/Vector2 */ "./src/foundation/math/Vector2.ts");
/* harmony import */ var _definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../definitions/ShadingModel */ "./src/foundation/definitions/ShadingModel.ts");
/* harmony import */ var _geometry_Mesh__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../geometry/Mesh */ "./src/foundation/geometry/Mesh.ts");
/* harmony import */ var _math_MutableVector4__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../math/MutableVector4 */ "./src/foundation/math/MutableVector4.ts");
/* harmony import */ var _components_LightComponent__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../components/LightComponent */ "./src/foundation/components/LightComponent.ts");
/* harmony import */ var _definitions_LightType__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../definitions/LightType */ "./src/foundation/definitions/LightType.ts");
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _definitions_BufferUse__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../definitions/BufferUse */ "./src/foundation/definitions/BufferUse.ts");
/* harmony import */ var _core_MemoryManager__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../components/BlendShapeComponent */ "./src/foundation/components/BlendShapeComponent.ts");
/* harmony import */ var _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ../core/GlobalDataRepository */ "./src/foundation/core/GlobalDataRepository.ts");
/* harmony import */ var _materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ../materials/singles/PbrShadingSingleMaterialNode */ "./src/foundation/materials/singles/PbrShadingSingleMaterialNode.ts");
/* harmony import */ var _math_Scalar__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ../math/Scalar */ "./src/foundation/math/Scalar.ts");
/* harmony import */ var _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ../definitions/TextureParameter */ "./src/foundation/definitions/TextureParameter.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");








































/**
 * A converter class from glTF2 model to Rhodonite Native data
 */
class ModelConverter {
    constructor() {
    }
    /**
     * The static method to get singleton instance of this class.
     * @return The singleton instance of ModelConverter class
     */
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new ModelConverter();
        }
        return this.__instance;
    }
    _getDefaultShader(options) {
        let defaultShader = null;
        // if (options && typeof options.defaultShaderClass !== "undefined") {
        //   if (typeof options.defaultShaderClass === "string") {
        //     defaultShader = GLBoost[options.defaultShaderClass];
        //   } else {
        //     defaultShader = options.defaultShaderClass;
        //   }
        // }
        return defaultShader;
    }
    __generateEntity(components, gltfModel) {
        const repo = _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
        const entity = repo.createEntity(components);
        entity.tryToSetTag({ tag: 'SourceType', value: gltfModel.asset.extras.fileType });
        entity.tryToSetTag({ tag: 'SourceTypeVersion', value: gltfModel.asset.extras.version });
        return entity;
    }
    __generateGroupEntity(gltfModel) {
        const entity = this.__generateEntity([_components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__["default"], _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_2__["default"]], gltfModel);
        return entity;
    }
    __generateMeshEntity(gltfModel) {
        const entity = this.__generateEntity([_components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__["default"], _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_2__["default"], _components_MeshComponent__WEBPACK_IMPORTED_MODULE_3__["default"], _components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_7__["default"]], gltfModel);
        return entity;
    }
    __generateCameraEntity(gltfModel) {
        const entity = this.__generateEntity([_components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__["default"], _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_2__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_14__["default"]], gltfModel);
        return entity;
    }
    __generateLightEntity(gltfModel) {
        const entity = this.__generateEntity([_components_TransformComponent__WEBPACK_IMPORTED_MODULE_1__["default"], _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_2__["default"], _components_LightComponent__WEBPACK_IMPORTED_MODULE_29__["default"]], gltfModel);
        return entity;
    }
    convertToRhodoniteObject(gltfModel) {
        var _a;
        gltfModel.asset.extras.rnMeshesAtGltMeshIdx = [];
        const rnBuffers = this.createRnBuffer(gltfModel);
        gltfModel.asset.extras.rnMaterials = [];
        // Mesh, Camera, Group, ...
        const { rnEntities, rnEntitiesByNames } = this.__setupObjects(gltfModel, rnBuffers);
        gltfModel.asset.extras.rnEntities = rnEntities;
        // Transform
        this._setupTransform(gltfModel, rnEntities);
        // Skeleton
        this._setupSkeleton(gltfModel, rnEntities);
        // Hierarchy
        this._setupHierarchy(gltfModel, rnEntities);
        // Camera
        //this._setupCamera(gltfModel, groups);
        // Animation
        this._setupAnimation(gltfModel, rnEntities);
        // Root Group
        const rootGroup = this.__generateGroupEntity(gltfModel);
        rootGroup.tryToSetUniqueName('FileRoot', true);
        rootGroup.tryToSetTag({ tag: 'ObjectType', value: 'top' });
        if (gltfModel.scenes[0].nodesIndices) {
            for (let nodesIndex of gltfModel.scenes[0].nodesIndices) {
                rootGroup.getSceneGraph().addChild(rnEntities[nodesIndex].getSceneGraph());
            }
        }
        if (gltfModel.asset.extras && gltfModel.asset.extras.rnLoaderOptions) {
            let options = gltfModel.asset.extras.rnLoaderOptions;
            if (options && options.loaderExtension && ((_a = options === null || options === void 0 ? void 0 : options.loaderExtension) === null || _a === void 0 ? void 0 : _a.loadExtensionInfoAndSetToRootGroup)) {
                options.loaderExtension.loadExtensionInfoAndSetToRootGroup(rootGroup, gltfModel);
            }
        }
        // rootGroup.allMeshes = rootGroup.searchElementsByType(M_Mesh);
        rootGroup.tryToSetTag({ tag: 'rnEntities', value: rnEntities });
        rootGroup.tryToSetTag({ tag: 'rnEntitiesByNames', value: rnEntitiesByNames });
        rootGroup.tryToSetTag({ tag: 'gltfModel', value: gltfModel });
        return rootGroup;
    }
    _setupCamera(gltfModel) {
    }
    createRnBuffer(gltfModel) {
        const rnBuffers = [];
        for (let buffer of gltfModel.buffers) {
            const rnBuffer = new _memory_Buffer__WEBPACK_IMPORTED_MODULE_9__["default"]({
                byteLength: buffer.byteLength,
                buffer: buffer.buffer,
                name: `gltf2Buffer_0_(${buffer.uri})`
            });
            rnBuffers.push(rnBuffer);
        }
        return rnBuffers;
    }
    _setupTransform(gltfModel, groups) {
        for (let node_i in gltfModel.nodes) {
            let group = groups[node_i];
            let nodeJson = gltfModel.nodes[node_i];
            if (nodeJson.translation) {
                group.getTransform().translate = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](nodeJson.translation[0], nodeJson.translation[1], nodeJson.translation[2]);
            }
            if (nodeJson.scale) {
                group.getTransform().scale = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](nodeJson.scale[0], nodeJson.scale[1], nodeJson.scale[2]);
            }
            if (nodeJson.rotation) {
                group.getTransform().quaternion = new _math_Quaternion__WEBPACK_IMPORTED_MODULE_5__["default"](nodeJson.rotation[0], nodeJson.rotation[1], nodeJson.rotation[2], nodeJson.rotation[3]);
            }
            if (nodeJson.matrix) {
                group.getTransform().matrix = new _math_Matrix44__WEBPACK_IMPORTED_MODULE_6__["default"](nodeJson.matrix, true);
            }
        }
    }
    _setupHierarchy(gltfModel, rnEntities) {
        const groupSceneComponents = rnEntities.map(group => { return group.getSceneGraph(); });
        for (let node_i in gltfModel.nodes) {
            const parentNode_i = parseInt(node_i);
            let node = gltfModel.nodes[parentNode_i];
            if (node.childrenIndices) {
                let parentGroup = groupSceneComponents[parentNode_i];
                for (let childNode_i of node.childrenIndices) {
                    let childGroup = groupSceneComponents[childNode_i];
                    parentGroup.addChild(childGroup);
                }
            }
        }
    }
    /**
     * @private
     */
    _setupAnimation(gltfModel, rnEntities) {
        var _a;
        if (gltfModel.animations) {
            for (let animation of gltfModel.animations) {
                for (let sampler of animation.samplers) {
                    this._accessBinaryWithAccessor(sampler.input);
                    this._accessBinaryWithAccessor(sampler.output);
                }
            }
        }
        const entityRepository = _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
        if (gltfModel.animations) {
            for (let animation of gltfModel.animations) {
                for (let channel of animation.channels) {
                    const animInputArray = channel.sampler.input.extras.typedDataArray;
                    const animOutputArray = channel.sampler.output.extras.typedDataArray;
                    const interpolation = (_a = channel.sampler.interpolation) !== null && _a !== void 0 ? _a : 'LINEAR';
                    let animationAttributeName = '';
                    if (channel.target.path === 'translation') {
                        animationAttributeName = 'translate';
                    }
                    else if (channel.target.path === 'rotation') {
                        animationAttributeName = 'quaternion';
                    }
                    else {
                        animationAttributeName = channel.target.path;
                    }
                    let rnEntity = rnEntities[channel.target.nodeIndex];
                    if (rnEntity) {
                        entityRepository.addComponentsToEntity([_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_18__["default"]], rnEntity.entityUID);
                        const animationComponent = rnEntity.getComponent(_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_18__["default"]);
                        if (animationComponent) {
                            animationComponent.setAnimation(animationAttributeName, animInputArray, animOutputArray, _definitions_AnimationInterpolation__WEBPACK_IMPORTED_MODULE_19__["AnimationInterpolation"].fromString(interpolation));
                        }
                    }
                }
            }
        }
    }
    _setupSkeleton(gltfModel, rnEntities) {
        var _a, _b, _c;
        if (gltfModel.skins == null) {
            return;
        }
        const globalDataRepository = _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_35__["default"].getInstance();
        const entityRepository = _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
        for (let skin of gltfModel.skins) {
            // globalDataRepository.takeOne(ShaderSemantics.BoneQuaternion);
            // globalDataRepository.takeOne(ShaderSemantics.BoneTranslateScale);
            if (skin.inverseBindMatrices) {
                this._accessBinaryWithAccessor(skin.inverseBindMatrices);
            }
        }
        for (let node_i in gltfModel.nodes) {
            let node = gltfModel.nodes[node_i];
            let sg = rnEntities[node_i].getSceneGraph();
            let skeletalComponent;
            if (node.skin != null) {
                let rnEntity = rnEntities[node_i];
                entityRepository.addComponentsToEntity([_components_SkeletalComponent__WEBPACK_IMPORTED_MODULE_21__["default"]], rnEntity.entityUID);
                skeletalComponent = rnEntity.getComponent(_components_SkeletalComponent__WEBPACK_IMPORTED_MODULE_21__["default"]);
                //        skeletalComponent.isSkinning = false;
                skeletalComponent._jointIndices = node.skin.jointsIndices;
                if (node.skin.bindShapeMatrix != null) {
                    skeletalComponent._bindShapeMatrix = new _math_Matrix44__WEBPACK_IMPORTED_MODULE_6__["default"](node.skin.bindShapeMatrix, true);
                }
            }
            if ((_a = node.skin) === null || _a === void 0 ? void 0 : _a.skeleton) {
                sg.isRootJoint = true;
                // if (node.meshes) {
                //   // let rnEntity = rnEntities[node_i];
                //   // entityRepository
                //   // for (let mesh of node.meshes) {
                //   //   mesh
                //   //   const entity = this.__generateMeshEntity() {
                //   //   }
                //   // }
                //   // skeletalComponent!.jointsHierarchy = rnEntities[node.skin.skeletonIndex].getSceneGraph();
                // } else 
                if (node.mesh) {
                    const joints = [];
                    for (let i of node.skin.jointsIndices) {
                        joints.push(rnEntities[i].getSceneGraph());
                    }
                    skeletalComponent.joints = joints;
                    if (node.skin.skeletonIndex != null) {
                        skeletalComponent.jointsHierarchy = rnEntities[node.skin.skeletonIndex].getSceneGraph();
                    }
                    else {
                        skeletalComponent.jointsHierarchy = joints[0];
                    }
                }
            }
            if ((_b = node.skin) === null || _b === void 0 ? void 0 : _b.joints) {
                for (let joint_i of node.skin.jointsIndices) {
                    let sg = rnEntities[joint_i].getSceneGraph();
                    sg.jointIndex = joint_i;
                }
            }
            if (((_c = node.skin) === null || _c === void 0 ? void 0 : _c.inverseBindMatrices) != null) {
                skeletalComponent._inverseBindMatrices = node.skin.inverseBindMatrices.extras.typedDataArray;
            }
        }
    }
    __setupObjects(gltfModel, rnBuffers) {
        var _a, _b;
        const rnEntities = [];
        const rnEntitiesByNames = new Map();
        for (let node_i in gltfModel.nodes) {
            let node = gltfModel.nodes[parseInt(node_i)];
            let entity;
            if (node.mesh != null) {
                let meshIdxOrName = node.meshIndex;
                if (meshIdxOrName == null) {
                    meshIdxOrName = node.meshNames[0];
                }
                const meshEntity = this.__setupMesh(node, node.mesh, meshIdxOrName, rnBuffers, gltfModel);
                if (node.name) {
                    meshEntity.tryToSetUniqueName(node.name, true);
                }
                if (node.mesh.name) {
                    const meshComponent = meshEntity.getComponent(_components_MeshComponent__WEBPACK_IMPORTED_MODULE_3__["default"]);
                    meshComponent.tryToSetUniqueName(node.mesh.name, true);
                }
                entity = meshEntity;
            }
            else if (node.camera != null) {
                const cameraEntity = this.__setupCamera(node.camera, gltfModel);
                if (node.name) {
                    cameraEntity.tryToSetUniqueName(node.name, true);
                }
                entity = cameraEntity;
            }
            else if ((_a = node.extensions) === null || _a === void 0 ? void 0 : _a.KHR_lights_punctual) {
                const lightEntity = this.__setupLight(node.extensions.KHR_lights_punctual.light, gltfModel);
                entity = lightEntity;
            }
            else {
                const group = this.__generateGroupEntity(gltfModel);
                if (node.name) {
                    group.tryToSetUniqueName(node.name, true);
                }
                entity = group;
            }
            entity.tryToSetTag({ tag: 'gltf_node_index', value: '' + node_i });
            rnEntities.push(entity);
            rnEntitiesByNames.set(node.name, entity);
            if (this.__isMorphing(node, gltfModel)) {
                let weights;
                if (node.weights) {
                    weights = node.weights;
                }
                else if (node.mesh.weights) {
                    weights = node.mesh.weights;
                }
                else {
                    weights = new Array(node.mesh.primitives[0].targets.length);
                    for (let i = 0; i < weights.length; i++) {
                        weights[i] = 0;
                    }
                }
                const entityRepository = _core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
                entityRepository.addComponentsToEntity([_components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_34__["default"]], entity.entityUID);
                const blendShapeComponent = entity.getComponent(_components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_34__["default"]);
                blendShapeComponent.weights = weights;
                if ((_b = node.mesh.primitives[0].extras) === null || _b === void 0 ? void 0 : _b.targetNames) {
                    blendShapeComponent.targetNames = node.mesh.primitives[0].extras.targetNames;
                }
            }
        }
        return { rnEntities, rnEntitiesByNames };
    }
    __isMorphing(node, gltfModel) {
        var _a, _b, _c;
        const argument = (_c = (_b = (_a = gltfModel === null || gltfModel === void 0 ? void 0 : gltfModel.asset) === null || _a === void 0 ? void 0 : _a.extras) === null || _b === void 0 ? void 0 : _b.rnLoaderOptions) === null || _c === void 0 ? void 0 : _c.defaultMaterialHelperArgumentArray[0];
        if ((argument === null || argument === void 0 ? void 0 : argument.isMorphing) === false) {
            return false;
        }
        else {
            return node.mesh != null && node.mesh.primitives[0].targets != null;
        }
    }
    __setupLight(light, gltfModel) {
        const lightEntity = this.__generateLightEntity(gltfModel);
        const lightComponent = lightEntity.getComponent(_components_LightComponent__WEBPACK_IMPORTED_MODULE_29__["default"]);
        if (light.name != null) {
            lightComponent.tryToSetUniqueName(light.name, true);
            lightComponent.type = _definitions_LightType__WEBPACK_IMPORTED_MODULE_30__["LightType"].fromString(light.type);
            let color = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](1, 1, 1);
            let intensity = 1;
            if (light.color != null) {
                color = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](light.color);
            }
            if (light.intensity != null) {
                intensity = light.intensity;
            }
            lightComponent.intensity = _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"].multiply(color, intensity);
            if (light.range != null) {
                lightComponent.range = light.range;
            }
        }
        return lightEntity;
    }
    __setupCamera(camera, gltfModel) {
        const cameraEntity = this.__generateCameraEntity(gltfModel);
        const cameraComponent = cameraEntity.getComponent(_components_CameraComponent__WEBPACK_IMPORTED_MODULE_14__["default"]);
        cameraComponent.direction = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](0, 0, -1);
        if (gltfModel.asset && gltfModel.asset.LastSaved_ApplicationVendor) {
            // For an old exporter compatibility
            cameraComponent.direction = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](1, 0, 0);
            cameraComponent.directionInner = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](1, 0, 0);
        }
        cameraComponent.up = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](0, 1, 0);
        cameraComponent.type = _definitions_CameraType__WEBPACK_IMPORTED_MODULE_15__["CameraType"].fromString(camera.type);
        if (cameraComponent.type === _definitions_CameraType__WEBPACK_IMPORTED_MODULE_15__["CameraType"].Perspective) {
            cameraComponent.aspect = camera.perspective.aspectRatio ? camera.perspective.aspectRatio : 1;
            cameraComponent.setFovyAndChangeFocalLength(_math_MathUtil__WEBPACK_IMPORTED_MODULE_20__["MathUtil"].radianToDegree(camera.perspective.yfov));
            cameraComponent.zNear = camera.perspective.znear;
            cameraComponent.zFar = camera.perspective.zfar ? camera.perspective.zfar : 100000;
        }
        else if (cameraComponent.type === _definitions_CameraType__WEBPACK_IMPORTED_MODULE_15__["CameraType"].Orthographic) {
            cameraComponent.xMag = camera.orthographic.zmag;
            cameraComponent.yMag = camera.orthographic.ymag;
            cameraComponent.zNear = camera.orthographic.znear;
            cameraComponent.zFar = camera.orthographic.zfar;
        }
        return cameraEntity;
    }
    __setupMesh(node, mesh, meshIndex, rnBuffers, gltfModel) {
        var _a;
        const meshEntity = this.__generateMeshEntity(gltfModel);
        const existingRnMesh = gltfModel.asset.extras.rnMeshesAtGltMeshIdx[meshIndex];
        let rnPrimitiveMode = _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_10__["PrimitiveMode"].Triangles;
        const meshComponent = meshEntity.getMesh();
        const rnMesh = new _geometry_Mesh__WEBPACK_IMPORTED_MODULE_27__["default"]();
        const rnLoaderOptions = gltfModel.asset.extras.rnLoaderOptions;
        if ((rnLoaderOptions === null || rnLoaderOptions === void 0 ? void 0 : rnLoaderOptions.tangentCalculationMode) != null) {
            rnMesh.tangentCalculationMode = rnLoaderOptions.tangentCalculationMode;
        }
        if ((rnLoaderOptions === null || rnLoaderOptions === void 0 ? void 0 : rnLoaderOptions.isPreComputeForRayCastPickingEnable) != null) {
            rnMesh.isPreComputeForRayCastPickingEnable = rnLoaderOptions.isPreComputeForRayCastPickingEnable;
        }
        let originalRnMesh = rnMesh;
        if (existingRnMesh != null) {
            rnMesh.setOriginalMesh(existingRnMesh);
            originalRnMesh = existingRnMesh;
        }
        else {
            for (let i in mesh.primitives) {
                let primitive = mesh.primitives[i];
                if (primitive.mode != null) {
                    rnPrimitiveMode = _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_10__["PrimitiveMode"].from(primitive.mode);
                }
                const rnPrimitive = new _geometry_Primitive__WEBPACK_IMPORTED_MODULE_8__["default"]();
                const material = this.__setupMaterial(rnPrimitive, node, gltfModel, primitive, primitive.material);
                if (material.isEmptyMaterial() === false) {
                    ModelConverter.setDefaultTextures(material, gltfModel);
                }
                // indices
                let indicesRnAccessor;
                const map = new Map();
                if ((_a = primitive.extensions) === null || _a === void 0 ? void 0 : _a.KHR_draco_mesh_compression) {
                    indicesRnAccessor = this.__decodeDraco(primitive, rnBuffers, gltfModel, map);
                    if (indicesRnAccessor == null) {
                        break;
                    }
                }
                else {
                    // attributes
                    if (primitive.indices) {
                        indicesRnAccessor = this.__getRnAccessor(primitive.indices, rnBuffers[primitive.indices.bufferView.bufferIndex]);
                    }
                    for (let attributeName in primitive.attributes) {
                        const attributeAccessor = primitive.attributes[attributeName];
                        const attributeRnAccessor = this.__getRnAccessor(attributeAccessor, rnBuffers[attributeAccessor.bufferView.bufferIndex]);
                        if (attributeAccessor.sparse) {
                            this.setSparseAccessor(attributeAccessor, attributeRnAccessor);
                        }
                        map.set(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_13__["VertexAttribute"].fromString(attributeAccessor.extras.attributeName), attributeRnAccessor);
                    }
                }
                rnPrimitive.setData(map, rnPrimitiveMode, material, indicesRnAccessor);
                // morph targets
                if (primitive.targets != null) {
                    // set default number
                    let maxMorphTargetNumber = 4;
                    if ((rnLoaderOptions === null || rnLoaderOptions === void 0 ? void 0 : rnLoaderOptions.maxMorphTargetNumber) != null) {
                        maxMorphTargetNumber = rnLoaderOptions.maxMorphTargetNumber;
                    }
                    const targets = [];
                    for (let i = 0; i < primitive.targets.length; i++) {
                        if (i >= maxMorphTargetNumber) {
                            break;
                        }
                        const target = primitive.targets[i];
                        const targetMap = new Map();
                        for (let attributeName in target) {
                            let attributeAccessor = target[attributeName];
                            const attributeRnAccessor = this.__getRnAccessor(attributeAccessor, rnBuffers[attributeAccessor.bufferView.bufferIndex]);
                            const attributeRnAccessorInGPUVertexData = this.__copyRnAccessorAndBufferView(attributeRnAccessor);
                            targetMap.set(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_13__["VertexAttribute"].fromString(attributeName), attributeRnAccessorInGPUVertexData);
                        }
                        targets.push(targetMap);
                    }
                    rnPrimitive.setTargets(targets);
                }
                rnMesh.addPrimitive(rnPrimitive);
            }
            if (mesh.weights) {
                rnMesh.weights = mesh.weights;
            }
        }
        meshComponent.setMesh(rnMesh);
        gltfModel.asset.extras.rnMeshesAtGltMeshIdx[meshIndex] = originalRnMesh;
        return meshEntity;
    }
    setSparseAccessor(accessor, rnAccessor) {
        var _a, _b, _c, _d;
        const uint8Array = accessor.bufferView.buffer.buffer;
        const count = accessor.sparse.count;
        // indices
        const accessorIndices = accessor.sparse.indices;
        const bufferViewIndices = accessorIndices.bufferView;
        const byteOffsetIndices = ((_a = bufferViewIndices.byteOffset) !== null && _a !== void 0 ? _a : 0) + ((_b = accessorIndices.byteOffset) !== null && _b !== void 0 ? _b : 0);
        const componentBytesIndices = this._checkBytesPerComponent(accessorIndices);
        const byteLengthIndices = componentBytesIndices * count; // index is scalar
        const dataViewIndices = new DataView(uint8Array.buffer, byteOffsetIndices + uint8Array.byteOffset, byteLengthIndices);
        const dataViewMethodIndices = this._checkDataViewMethod(accessorIndices);
        // sparse values
        const accessorValues = accessor.sparse.values;
        const bufferViewValues = accessorValues.bufferView;
        const byteOffsetValues = ((_c = bufferViewValues.byteOffset) !== null && _c !== void 0 ? _c : 0) + ((_d = accessorValues.byteOffset) !== null && _d !== void 0 ? _d : 0);
        const componentBytesValues = this._checkBytesPerComponent(accessor);
        const componentNValues = this._checkComponentNumber(accessor);
        const byteLengthValues = componentBytesValues * componentNValues * count;
        const dataViewValues = new DataView(uint8Array.buffer, byteOffsetValues + uint8Array.byteOffset, byteLengthValues);
        const dataViewMethodValues = this._checkDataViewMethod(accessor);
        // set sparse values
        const typedArray = rnAccessor.getTypedArray();
        const littleEndian = true;
        for (let i = 0; i < count; i++) {
            const index = dataViewIndices[dataViewMethodIndices](componentBytesIndices * i, littleEndian);
            for (let j = 0; j < componentNValues; j++) {
                const value = dataViewValues[dataViewMethodValues](componentBytesValues * componentNValues * i + componentBytesValues * j, littleEndian);
                typedArray[index * componentNValues + j] = value;
            }
        }
    }
    static setDefaultTextures(material, gltfModel) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (((_b = (_a = gltfModel.asset.extras) === null || _a === void 0 ? void 0 : _a.rnLoaderOptions) === null || _b === void 0 ? void 0 : _b.defaultTextures) == null) {
            return;
        }
        const options = gltfModel.asset.extras.rnLoaderOptions;
        const defaultTextures = gltfModel.asset.extras.rnLoaderOptions.defaultTextures;
        const basePath = defaultTextures.basePath;
        const textureInfos = defaultTextures.textureInfos;
        for (let textureInfo of textureInfos) {
            const rnTexture = new _textures_Texture__WEBPACK_IMPORTED_MODULE_16__["default"]();
            //options
            rnTexture.autoDetectTransparency = options.autoDetectTextureTransparency === true;
            rnTexture.autoResize = options.autoResizeTexture === true;
            const textureOption = {
                magFilter: (_d = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].from((_c = textureInfo.sampler) === null || _c === void 0 ? void 0 : _c.magFilter)) !== null && _d !== void 0 ? _d : _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].Linear,
                minFilter: (_f = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].from((_e = textureInfo.sampler) === null || _e === void 0 ? void 0 : _e.minFilter)) !== null && _f !== void 0 ? _f : _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].Linear,
                wrapS: (_h = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].from((_g = textureInfo.sampler) === null || _g === void 0 ? void 0 : _g.wrapS)) !== null && _h !== void 0 ? _h : _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].Repeat,
                wrapT: (_k = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].from((_j = textureInfo.sampler) === null || _j === void 0 ? void 0 : _j.wrapT)) !== null && _k !== void 0 ? _k : _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].Repeat
            };
            const fileName = textureInfo.fileName;
            const uri = basePath + fileName;
            rnTexture.name = uri;
            const image = textureInfo.image;
            if (image === null || image === void 0 ? void 0 : image.image) {
                const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_39__["default"].getWebGLResourceRepository();
                const isWebGL1 = !((_l = webglResourceRepository.currentWebGLContextWrapper) === null || _l === void 0 ? void 0 : _l.isWebGL2);
                if (isWebGL1 && !this.__sizeIsPowerOfTwo(image.image) && this.__needResizeToPowerOfTwoOnWebGl1(textureOption)) {
                    rnTexture.autoResize = true;
                }
                rnTexture.generateTextureFromImage(image.image, textureOption);
            }
            else if (image === null || image === void 0 ? void 0 : image.basis) {
                rnTexture.generateTextureFromBasis(image.basis, textureOption);
            }
            else {
                console.warn("default image not found");
                continue;
            }
            const shaderSemantics = textureInfo.shaderSemantics;
            material.setTextureParameter(shaderSemantics, rnTexture);
        }
    }
    __setMorphingAndSkinningArgument(node, argumentOfMaterialHelper, isMorphingOriginal, isSkinningOriginal, gltfModel) {
        var _a;
        if (isMorphingOriginal) {
            argumentOfMaterialHelper.isMorphing = this.__isMorphing(node, gltfModel);
        }
        if (isSkinningOriginal) {
            const existSkin = node.skin != null;
            argumentOfMaterialHelper.isSkinning = existSkin;
            argumentOfMaterialHelper.additionalName = existSkin ? `skin${((_a = node.skinIndex) !== null && _a !== void 0 ? _a : node.skinName)}` : "";
        }
    }
    __setVRMMaterial(rnPrimitive, node, gltfModel, primitive, argumentArray) {
        const VRMProperties = gltfModel.extensions.VRM;
        const shaderName = VRMProperties.materialProperties[primitive.materialIndex].shader;
        if (shaderName === "VRM/MToon") {
            // argument
            const argumentOfMaterialHelper = argumentArray[0];
            const rnExtension = VRMProperties.rnExtension;
            const isMorphingOriginal = argumentOfMaterialHelper.isMorphing;
            const isSkinningOriginal = argumentOfMaterialHelper.isSkinning;
            this.__setMorphingAndSkinningArgument(node, argumentOfMaterialHelper, isMorphingOriginal, isSkinningOriginal, gltfModel);
            const materialProperties = gltfModel.extensions.VRM.materialProperties[primitive.materialIndex];
            argumentOfMaterialHelper.materialProperties = materialProperties;
            // outline
            let renderPassOutline;
            if (rnExtension) {
                renderPassOutline = rnExtension.renderPassOutline;
            }
            //exist outline
            if (renderPassOutline != null) {
                let outlineMaterial;
                if (materialProperties.floatProperties._OutlineWidthMode !== 0) {
                    argumentOfMaterialHelper.isOutline = true;
                    outlineMaterial = _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_23__["default"].createMToonMaterial(argumentOfMaterialHelper);
                    argumentOfMaterialHelper.isOutline = false;
                }
                else {
                    outlineMaterial = _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_23__["default"].createEmptyMaterial();
                }
                renderPassOutline.setMaterialForPrimitive(outlineMaterial, rnPrimitive);
            }
            const material = _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_23__["default"].createMToonMaterial(argumentOfMaterialHelper);
            argumentOfMaterialHelper.isMorphing = isMorphingOriginal;
            argumentOfMaterialHelper.isSkinning = isSkinningOriginal;
            return material;
        }
        else if (argumentArray[0].isOutline) {
            return _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_23__["default"].createEmptyMaterial();
            ;
        }
        // use another material
        return undefined;
    }
    __generateAppropriateMaterial(rnPrimitive, node, gltfModel, primitive, materialJson) {
        var _a, _b, _c, _d, _e, _f;
        if (((_a = gltfModel.asset.extras) === null || _a === void 0 ? void 0 : _a.rnLoaderOptions) != null) {
            const rnLoaderOptions = gltfModel.asset.extras.rnLoaderOptions;
            if (((_b = rnLoaderOptions === null || rnLoaderOptions === void 0 ? void 0 : rnLoaderOptions.loaderExtension) === null || _b === void 0 ? void 0 : _b.isNeededToUseThisMaterial) != null && rnLoaderOptions.loaderExtension.isNeededToUseThisMaterial(gltfModel)) {
                const loaderExtension = (_d = (_c = gltfModel.asset.extras) === null || _c === void 0 ? void 0 : _c.rnLoaderOptions) === null || _d === void 0 ? void 0 : _d.loaderExtension;
                if ((loaderExtension === null || loaderExtension === void 0 ? void 0 : loaderExtension.generateMaterial) != null) {
                    return loaderExtension.generateMaterial(materialJson);
                }
            }
            const argumentArray = rnLoaderOptions.defaultMaterialHelperArgumentArray;
            if (rnLoaderOptions.isImportVRM) {
                const material = this.__setVRMMaterial(rnPrimitive, node, gltfModel, primitive, argumentArray);
                if (material != null)
                    return material;
            }
            const materialHelperName = rnLoaderOptions.defaultMaterialHelperName;
            if (materialHelperName != null) {
                return _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_23__["default"][materialHelperName](...argumentArray);
            }
        }
        let maxMaterialInstanceNumber = _core_Config__WEBPACK_IMPORTED_MODULE_31__["default"].maxMaterialInstanceForEachType;
        if (gltfModel.meshes.length > _core_Config__WEBPACK_IMPORTED_MODULE_31__["default"].maxMaterialInstanceForEachType) {
            maxMaterialInstanceNumber = gltfModel.meshes.length + _core_Config__WEBPACK_IMPORTED_MODULE_31__["default"].maxMaterialInstanceForEachType / 2;
        }
        const isMorphing = this.__isMorphing(node, gltfModel);
        const isSkinning = this.__isSkinning(node, gltfModel);
        const isLighting = this.__isLighting(gltfModel, materialJson);
        const alphaMode = _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_22__["AlphaMode"].fromGlTFString((materialJson === null || materialJson === void 0 ? void 0 : materialJson.alphaMode) || 'OPAQUE');
        const additionalName = (node.skin != null) ? `skin${((_e = node.skinIndex) !== null && _e !== void 0 ? _e : node.skinName)}` : void 0;
        if (parseFloat((_f = gltfModel.asset) === null || _f === void 0 ? void 0 : _f.version) >= 2) {
            return _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_23__["default"].createPbrUberMaterial({
                isMorphing, isSkinning, isLighting, alphaMode,
                additionalName: additionalName, maxInstancesNumber: maxMaterialInstanceNumber
            });
        }
        else {
            return _helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_23__["default"].createClassicUberMaterial({
                isSkinning, isLighting, alphaMode,
                additionalName: additionalName, maxInstancesNumber: maxMaterialInstanceNumber
            });
        }
    }
    __isLighting(gltfModel, materialJson) {
        var _a, _b, _c, _d;
        const argument = (_c = (_b = (_a = gltfModel === null || gltfModel === void 0 ? void 0 : gltfModel.asset) === null || _a === void 0 ? void 0 : _a.extras) === null || _b === void 0 ? void 0 : _b.rnLoaderOptions) === null || _c === void 0 ? void 0 : _c.defaultMaterialHelperArgumentArray[0];
        if ((argument === null || argument === void 0 ? void 0 : argument.isLighting) != null) {
            return argument.isLighting;
        }
        else {
            return (((_d = materialJson === null || materialJson === void 0 ? void 0 : materialJson.extensions) === null || _d === void 0 ? void 0 : _d.KHR_materials_unlit) != null) ? false : true;
        }
    }
    __isSkinning(node, gltfModel) {
        var _a, _b, _c;
        const argument = (_c = (_b = (_a = gltfModel === null || gltfModel === void 0 ? void 0 : gltfModel.asset) === null || _a === void 0 ? void 0 : _a.extras) === null || _b === void 0 ? void 0 : _b.rnLoaderOptions) === null || _c === void 0 ? void 0 : _c.defaultMaterialHelperArgumentArray[0];
        if ((argument === null || argument === void 0 ? void 0 : argument.isSkinning) === false) {
            return false;
        }
        else {
            return (node.skin != null) ? true : false;
        }
    }
    __setupMaterial(rnPrimitive, node, gltfModel, primitive, materialJson) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        let material = (_a = gltfModel.asset.extras) === null || _a === void 0 ? void 0 : _a.rnMaterials[primitive.materialIndex];
        if ((material === null || material === void 0 ? void 0 : material.isSkinning) === this.__isSkinning(node, gltfModel) && material.isMorphing === this.__isMorphing(node, gltfModel)) {
            return material;
        }
        else {
            const newMaterial = this.__generateAppropriateMaterial(rnPrimitive, node, gltfModel, primitive, materialJson);
            gltfModel.asset.extras.rnMaterials[primitive.materialIndex] = newMaterial;
            material = newMaterial;
        }
        // avoid unexpected initialization
        if (!this.__needParameterInitialization(materialJson, material.materialTypeName))
            return material;
        const pbrMetallicRoughness = materialJson.pbrMetallicRoughness;
        if (pbrMetallicRoughness != null) {
            const baseColorFactor = pbrMetallicRoughness.baseColorFactor;
            if (baseColorFactor != null) {
                material.setParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_24__["ShaderSemantics"].BaseColorFactor, new _math_Vector4__WEBPACK_IMPORTED_MODULE_17__["default"](baseColorFactor));
            }
            const baseColorTexture = pbrMetallicRoughness.baseColorTexture;
            if (baseColorTexture != null) {
                const rnTexture = ModelConverter._createTexture(baseColorTexture, gltfModel);
                material.setTextureParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_24__["ShaderSemantics"].BaseColorTexture, rnTexture);
                if (baseColorTexture.texCoord != null) {
                    material.setParameter(_materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_36__["default"].BaseColorTexcoordIndex, baseColorTexture.texCoord);
                }
            }
            ModelConverter._setupTextureTransform(baseColorTexture, material, _materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_36__["default"].BaseColorTextureTransform, _materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_36__["default"].BaseColorTextureRotation);
            const occlusionTexture = materialJson.occlusionTexture;
            if (occlusionTexture != null) {
                const rnTexture = ModelConverter._createTexture(occlusionTexture, gltfModel);
                material.setTextureParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_24__["ShaderSemantics"].OcclusionTexture, rnTexture);
                if (occlusionTexture.texCoord != null) {
                    material.setParameter(_materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_36__["default"].OcclusionTexcoordIndex, occlusionTexture.texCoord);
                }
            }
            let metallicFactor = pbrMetallicRoughness.metallicFactor;
            metallicFactor = metallicFactor !== null && metallicFactor !== void 0 ? metallicFactor : 1;
            let roughnessFactor = pbrMetallicRoughness.roughnessFactor;
            roughnessFactor = roughnessFactor !== null && roughnessFactor !== void 0 ? roughnessFactor : 1;
            material.setParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_24__["ShaderSemantics"].MetallicRoughnessFactor, new _math_Vector2__WEBPACK_IMPORTED_MODULE_25__["default"](metallicFactor, roughnessFactor));
            const metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
            if (metallicRoughnessTexture != null) {
                const rnTexture = ModelConverter._createTexture(metallicRoughnessTexture, gltfModel);
                material.setTextureParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_24__["ShaderSemantics"].MetallicRoughnessTexture, rnTexture);
                if (metallicRoughnessTexture.texCoord != null) {
                    material.setParameter(_materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_36__["default"].MetallicRoughnessTexcoordIndex, metallicRoughnessTexture.texCoord);
                }
            }
            ModelConverter._setupTextureTransform(metallicRoughnessTexture, material, _materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_36__["default"].MetallicRoughnessTextureTransform, _materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_36__["default"].MetallicRoughnessTextureRotation);
        }
        else {
            let param = _definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_26__["ShadingModel"].Phong.index;
            if ((_b = materialJson.extras) === null || _b === void 0 ? void 0 : _b.technique) {
                switch (materialJson.extras.technique) {
                    case _definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_26__["ShadingModel"].Constant.str:
                        param = _definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_26__["ShadingModel"].Constant.index;
                        break;
                    case _definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_26__["ShadingModel"].Lambert.str:
                        param = _definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_26__["ShadingModel"].Lambert.index;
                        break;
                    case _definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_26__["ShadingModel"].BlinnPhong.str:
                        param = _definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_26__["ShadingModel"].BlinnPhong.index;
                        break;
                    case _definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_26__["ShadingModel"].Phong.str:
                        param = _definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_26__["ShadingModel"].Phong.index;
                        break;
                }
                material.setParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_24__["ShaderSemantics"].ShadingModel, new _math_Scalar__WEBPACK_IMPORTED_MODULE_37__["default"](param));
            }
        }
        const emissiveTexture = materialJson.emissiveTexture;
        if (emissiveTexture != null) {
            const rnTexture = ModelConverter._createTexture(emissiveTexture, gltfModel);
            material.setTextureParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_24__["ShaderSemantics"].EmissiveTexture, rnTexture);
            if (parseFloat((_c = gltfModel.asset) === null || _c === void 0 ? void 0 : _c.version) >= 2 && emissiveTexture.texCoord != null) {
                material.setParameter(_materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_36__["default"].EmissiveTexcoordIndex, emissiveTexture.texCoord);
            }
        }
        const options = gltfModel.asset.extras.rnLoaderOptions;
        let alphaMode = materialJson.alphaMode;
        if (options === null || options === void 0 ? void 0 : options.alphaMode) {
            alphaMode = options.alphaMode;
        }
        if (alphaMode != null) {
            material.alphaMode = _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_22__["AlphaMode"].fromGlTFString(alphaMode);
            // set alpha threshold except for VRM
            if (material.alphaMode === _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_22__["AlphaMode"].Mask
                && !((_e = (_d = gltfModel.asset.extras) === null || _d === void 0 ? void 0 : _d.rnLoaderOptions) === null || _e === void 0 ? void 0 : _e.isImportVRM)) {
                material.setParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_24__["ShaderSemantics"].AlphaCutoff, new _math_Scalar__WEBPACK_IMPORTED_MODULE_37__["default"]((_f = materialJson.alphaCutoff) !== null && _f !== void 0 ? _f : 0.5));
            }
        }
        const doubleSided = materialJson.doubleSided;
        if (doubleSided != null) {
            material.cullFace = !doubleSided;
        }
        // For glTF1.0
        const diffuseColorTexture = materialJson.diffuseColorTexture;
        if (diffuseColorTexture != null) {
            const rnTexture = ModelConverter._createTexture(diffuseColorTexture, gltfModel);
            material.setTextureParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_24__["ShaderSemantics"].DiffuseColorTexture, rnTexture);
            if (this._checkRnGltfLoaderOptionsExist(gltfModel) && ((_h = (_g = gltfModel.asset.extras) === null || _g === void 0 ? void 0 : _g.rnLoaderOptions) === null || _h === void 0 ? void 0 : _h.loaderExtension)) {
                const loaderExtension = gltfModel.asset.extras.rnLoaderOptions.loaderExtension;
                if (loaderExtension.setUVTransformToTexture) {
                    loaderExtension.setUVTransformToTexture(material, diffuseColorTexture.texture.sampler);
                }
            }
        }
        const diffuseColorFactor = materialJson.diffuseColorFactor;
        if (diffuseColorFactor != null) {
            material.setParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_24__["ShaderSemantics"].DiffuseColorFactor, new _math_Vector4__WEBPACK_IMPORTED_MODULE_17__["default"](diffuseColorFactor));
        }
        const normalTexture = materialJson.normalTexture;
        if (normalTexture != null) {
            const rnTexture = ModelConverter._createTexture(normalTexture, gltfModel);
            material.setTextureParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_24__["ShaderSemantics"].NormalTexture, rnTexture);
            if (parseFloat((_j = gltfModel.asset) === null || _j === void 0 ? void 0 : _j.version) >= 2 && normalTexture.texCoord != null) {
                material.setParameter(_materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_36__["default"].NormalTexcoordIndex, normalTexture.texCoord);
            }
        }
        ModelConverter._setupTextureTransform(normalTexture, material, _materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_36__["default"].NormalTextureTransform, _materials_singles_PbrShadingSingleMaterialNode__WEBPACK_IMPORTED_MODULE_36__["default"].NormalTextureRotation);
        // ModelConverter._setupTextureTransform(normalTexture, material, 'normalTextureTransform', 'normalTextureRotation')
        // For Extension
        if (this._checkRnGltfLoaderOptionsExist(gltfModel)) {
            const loaderExtension = (_l = (_k = gltfModel.asset.extras) === null || _k === void 0 ? void 0 : _k.rnLoaderOptions) === null || _l === void 0 ? void 0 : _l.loaderExtension;
            if ((loaderExtension === null || loaderExtension === void 0 ? void 0 : loaderExtension.setupMaterial) != null) {
                loaderExtension.setupMaterial(gltfModel, materialJson, material);
            }
        }
        return material;
    }
    static _createTexture(textureType, gltfModel) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const options = (_a = gltfModel.asset.extras) === null || _a === void 0 ? void 0 : _a.rnLoaderOptions;
        const rnTexture = new _textures_Texture__WEBPACK_IMPORTED_MODULE_16__["default"]();
        rnTexture.autoDetectTransparency = (options === null || options === void 0 ? void 0 : options.autoDetectTextureTransparency) === true;
        rnTexture.autoResize = (options === null || options === void 0 ? void 0 : options.autoResizeTexture) === true;
        const texture = textureType.texture;
        const textureOption = {
            magFilter: (_c = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].from((_b = texture.sampler) === null || _b === void 0 ? void 0 : _b.magFilter)) !== null && _c !== void 0 ? _c : _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].Linear,
            minFilter: (_e = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].from((_d = texture.sampler) === null || _d === void 0 ? void 0 : _d.minFilter)) !== null && _e !== void 0 ? _e : _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].Linear,
            wrapS: (_g = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].from((_f = texture.sampler) === null || _f === void 0 ? void 0 : _f.wrapS)) !== null && _g !== void 0 ? _g : _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].Repeat,
            wrapT: (_j = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].from((_h = texture.sampler) === null || _h === void 0 ? void 0 : _h.wrapT)) !== null && _j !== void 0 ? _j : _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].Repeat
        };
        if (texture.image.image) {
            const image = texture.image.image;
            const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_39__["default"].getWebGLResourceRepository();
            const isWebGL1 = !((_k = webglResourceRepository.currentWebGLContextWrapper) === null || _k === void 0 ? void 0 : _k.isWebGL2);
            if (isWebGL1 && !this.__sizeIsPowerOfTwo(image) && this.__needResizeToPowerOfTwoOnWebGl1(textureOption)) {
                rnTexture.autoResize = true;
            }
            rnTexture.generateTextureFromImage(image, textureOption);
            if (texture.image.uri) {
                rnTexture.name = texture.image.url;
            }
            else {
                const ext = texture.image.mimeType.split('/')[1];
                rnTexture.name = texture.image.name + `.${ext}`;
            }
        }
        else if (texture.image.basis) {
            rnTexture.generateTextureFromBasis(texture.image.basis, textureOption);
            if (texture.image.uri) {
                rnTexture.name = texture.image.url;
            }
            else {
                const ext = texture.image.mimeType.split('/')[1];
                rnTexture.name = texture.image.name + `.${ext}`;
            }
        }
        return rnTexture;
    }
    static __needResizeToPowerOfTwoOnWebGl1(textureOption) {
        if (textureOption.wrapS !== _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].ClampToEdge ||
            textureOption.wrapT !== _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].ClampToEdge ||
            (textureOption.minFilter !== _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].Linear &&
                textureOption.minFilter !== _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_38__["TextureParameter"].Nearest)) {
            return true;
        }
        return false;
    }
    static __sizeIsPowerOfTwo(image) {
        const width = image.width;
        const height = image.height;
        if ((width & width - 1) == 0 && (height & height - 1) == 0) {
            return true;
        }
        else {
            return false;
        }
    }
    __needParameterInitialization(materialJson, materialTypeName) {
        if (materialJson == null)
            return false;
        if (materialTypeName.match(/PbrUber/) != null ||
            materialTypeName.match(/ClassicUber/) != null) {
            return true;
        }
        else {
            return false;
        }
    }
    _checkRnGltfLoaderOptionsExist(gltfModel) {
        var _a;
        if ((_a = gltfModel.asset.extras) === null || _a === void 0 ? void 0 : _a.rnLoaderOptions) {
            return true;
        }
        else {
            return false;
        }
    }
    _adjustByteAlign(typedArrayClass, uint8Array, alignSize, byteOffset, length) {
        if ((byteOffset % alignSize) != 0) {
            return new typedArrayClass(uint8Array.buffer.slice(byteOffset + uint8Array.byteOffset), 0, length);
        }
        else {
            return new typedArrayClass(uint8Array.buffer, byteOffset + uint8Array.byteOffset, length);
        }
    }
    _checkBytesPerComponent(accessor) {
        var bytesPerComponent = 0;
        switch (accessor.componentType) {
            case 5120: // gl.BYTE
                bytesPerComponent = 1;
                break;
            case 5121: // gl.UNSIGNED_BYTE
                bytesPerComponent = 1;
                break;
            case 5122: // gl.SHORT
                bytesPerComponent = 2;
                break;
            case 5123: // gl.UNSIGNED_SHORT
                bytesPerComponent = 2;
                break;
            case 5124: // gl.INT
                bytesPerComponent = 4;
                break;
            case 5125: // gl.UNSIGNED_INT
                bytesPerComponent = 4;
                break;
            case 5126: // gl.FLOAT
                bytesPerComponent = 4;
                break;
            default:
                break;
        }
        return bytesPerComponent;
    }
    _checkComponentNumber(accessor) {
        var componentN = 0;
        switch (accessor.type) {
            case 'SCALAR':
                componentN = 1;
                break;
            case 'VEC2':
                componentN = 2;
                break;
            case 'VEC3':
                componentN = 3;
                break;
            case 'VEC4':
                componentN = 4;
                break;
            case 'MAT4':
                componentN = 16;
                break;
        }
        return componentN;
    }
    _checkDataViewMethod(accessor) {
        var dataViewMethod = '';
        switch (accessor.componentType) {
            case 5120: // gl.BYTE
                dataViewMethod = 'getInt8';
                break;
            case 5121: // gl.UNSIGNED_BYTE
                dataViewMethod = 'getUint8';
                break;
            case 5122: // gl.SHORT
                dataViewMethod = 'getInt16';
                break;
            case 5123: // gl.UNSIGNED_SHORT
                dataViewMethod = 'getUint16';
                break;
            case 5124: // gl.INT
                dataViewMethod = 'getInt32';
                break;
            case 5125: // gl.UNSIGNED_INT
                dataViewMethod = 'getUint32';
                break;
            case 5126: // gl.FLOAT
                dataViewMethod = 'getFloat32';
                break;
            default:
                break;
        }
        return dataViewMethod;
    }
    static _isSystemLittleEndian() {
        return !!(new Uint8Array((new Uint16Array([0x00ff])).buffer))[0];
    }
    _accessBinaryWithAccessor(accessor) {
        var _a, _b, _c, _d, _e, _f;
        const bufferView = accessor.bufferView;
        const byteOffset = ((_a = bufferView.byteOffset) !== null && _a !== void 0 ? _a : 0) + ((_b = accessor.byteOffset) !== null && _b !== void 0 ? _b : 0);
        const buffer = bufferView.buffer;
        const uint8Array = buffer.buffer;
        const componentN = this._checkComponentNumber(accessor);
        const componentBytes = this._checkBytesPerComponent(accessor);
        const dataViewMethod = this._checkDataViewMethod(accessor);
        if (accessor.extras === void 0) {
            accessor.extras = {};
        }
        accessor.extras.componentN = componentN;
        accessor.extras.componentBytes = componentBytes;
        accessor.extras.dataViewMethod = dataViewMethod;
        const byteLength = componentBytes * componentN * accessor.count;
        let typedDataArray = [];
        if ((_c = accessor.extras) === null || _c === void 0 ? void 0 : _c.toGetAsTypedArray) {
            if (ModelConverter._isSystemLittleEndian()) {
                if (dataViewMethod === 'getFloat32') {
                    typedDataArray = this._adjustByteAlign(Float32Array, uint8Array, 4, byteOffset, byteLength / componentBytes);
                }
                else if (dataViewMethod === 'getInt8') {
                    typedDataArray = new Int8Array(uint8Array, byteOffset, byteLength / componentBytes);
                }
                else if (dataViewMethod === 'getUint8') {
                    typedDataArray = new Uint8Array(uint8Array, byteOffset, byteLength / componentBytes);
                }
                else if (dataViewMethod === 'getInt16') {
                    typedDataArray = this._adjustByteAlign(Int16Array, uint8Array, 2, byteOffset, byteLength / componentBytes);
                }
                else if (dataViewMethod === 'getUint16') {
                    typedDataArray = this._adjustByteAlign(Uint16Array, uint8Array, 2, byteOffset, byteLength / componentBytes);
                }
                else if (dataViewMethod === 'getInt32') {
                    typedDataArray = this._adjustByteAlign(Int32Array, uint8Array, 4, byteOffset, byteLength / componentBytes);
                }
                else if (dataViewMethod === 'getUint32') {
                    typedDataArray = this._adjustByteAlign(Uint32Array, uint8Array, 4, byteOffset, byteLength / componentBytes);
                }
            }
            else {
                const dataView = new DataView(uint8Array.buffer, byteOffset + uint8Array.byteOffset, byteLength);
                const byteDelta = componentBytes * componentN;
                const littleEndian = true;
                for (let pos = 0; pos < byteLength; pos += byteDelta) {
                    switch (accessor.type) {
                        case 'SCALAR':
                            typedDataArray.push(dataView[dataViewMethod](pos, littleEndian));
                            break;
                        case 'VEC2':
                            typedDataArray.push(dataView[dataViewMethod](pos, littleEndian));
                            typedDataArray.push(dataView[dataViewMethod](pos + componentBytes, littleEndian));
                            break;
                        case 'VEC3':
                            typedDataArray.push(dataView[dataViewMethod](pos, littleEndian));
                            typedDataArray.push(dataView[dataViewMethod](pos + componentBytes, littleEndian));
                            typedDataArray.push(dataView[dataViewMethod](pos + componentBytes * 2, littleEndian));
                            break;
                        case 'VEC4':
                            typedDataArray.push(dataView[dataViewMethod](pos, littleEndian));
                            typedDataArray.push(dataView[dataViewMethod](pos + componentBytes, littleEndian));
                            typedDataArray.push(dataView[dataViewMethod](pos + componentBytes * 2, littleEndian));
                            typedDataArray.push(dataView[dataViewMethod](pos + componentBytes * 3, littleEndian));
                            break;
                    }
                }
                if (dataViewMethod === 'getInt8') {
                    typedDataArray = new Int8Array(typedDataArray);
                }
                else if (dataViewMethod === 'getUint8') {
                    typedDataArray = new Uint8Array(typedDataArray);
                }
                else if (dataViewMethod === 'getInt16') {
                    typedDataArray = new Int16Array(typedDataArray);
                }
                else if (dataViewMethod === 'getUint16') {
                    typedDataArray = new Uint16Array(typedDataArray);
                }
                else if (dataViewMethod === 'getInt32') {
                    typedDataArray = new Int32Array(typedDataArray);
                }
                else if (dataViewMethod === 'getUint32') {
                    typedDataArray = new Uint32Array(typedDataArray);
                }
                else if (dataViewMethod === 'getFloat32') {
                    typedDataArray = new Float32Array(typedDataArray);
                }
            }
        }
        else {
            const dataView = new DataView(uint8Array.buffer, byteOffset + uint8Array.byteOffset, byteLength);
            let byteDelta = componentBytes * componentN;
            if ((_d = accessor.extras) === null || _d === void 0 ? void 0 : _d.weightCount) {
                byteDelta = componentBytes * componentN * accessor.extras.weightCount;
            }
            const littleEndian = true;
            for (let pos = 0; pos < byteLength; pos += byteDelta) {
                switch (accessor.type) {
                    case 'SCALAR':
                        if ((_e = accessor.extras) === null || _e === void 0 ? void 0 : _e.weightCount) {
                            const array = [];
                            for (let i = 0; i < accessor.extras.weightCount; i++) {
                                array.push(dataView[dataViewMethod](pos + componentBytes * i, littleEndian));
                            }
                            typedDataArray.push(array);
                        }
                        else {
                            typedDataArray.push(dataView[dataViewMethod](pos, littleEndian));
                        }
                        break;
                    case 'VEC2':
                        typedDataArray.push(new _math_Vector2__WEBPACK_IMPORTED_MODULE_25__["default"](dataView[dataViewMethod](pos, littleEndian), dataView[dataViewMethod](pos + componentBytes, littleEndian)));
                        break;
                    case 'VEC3':
                        typedDataArray.push(new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](dataView[dataViewMethod](pos, littleEndian), dataView[dataViewMethod](pos + componentBytes, littleEndian), dataView[dataViewMethod](pos + componentBytes * 2, littleEndian)));
                        break;
                    case 'VEC4':
                        if ((_f = accessor.extras) === null || _f === void 0 ? void 0 : _f.quaternionIfVec4) {
                            typedDataArray.push(new _math_Quaternion__WEBPACK_IMPORTED_MODULE_5__["default"](dataView[dataViewMethod](pos, littleEndian), dataView[dataViewMethod](pos + componentBytes, littleEndian), dataView[dataViewMethod](pos + componentBytes * 2, littleEndian), dataView[dataViewMethod](pos + componentBytes * 3, littleEndian)));
                        }
                        else {
                            typedDataArray.push(new _math_Vector4__WEBPACK_IMPORTED_MODULE_17__["default"](dataView[dataViewMethod](pos, littleEndian), dataView[dataViewMethod](pos + componentBytes, littleEndian), dataView[dataViewMethod](pos + componentBytes * 2, littleEndian), dataView[dataViewMethod](pos + componentBytes * 3, littleEndian)));
                        }
                        break;
                    case 'MAT4':
                        const matrixComponents = [];
                        for (let i = 0; i < 16; i++) {
                            matrixComponents[i] = dataView[dataViewMethod](pos + componentBytes * i, littleEndian);
                        }
                        typedDataArray.push(new _math_Matrix44__WEBPACK_IMPORTED_MODULE_6__["default"](matrixComponents, true));
                        break;
                }
            }
        }
        accessor.extras.typedDataArray = typedDataArray;
        return typedDataArray;
    }
    __addOffsetToIndices(meshComponent) {
        const primitiveNumber = meshComponent.mesh.getPrimitiveNumber();
        let offsetSum = 0;
        for (let i = 0; i < primitiveNumber; i++) {
            const primitive = meshComponent.mesh.getPrimitiveAt(i);
            const indicesAccessor = primitive.indicesAccessor;
            if (indicesAccessor) {
                const elementNumber = indicesAccessor.elementCount;
                for (let j = 0; j < elementNumber; j++) {
                    const index = indicesAccessor.getScalar(j, {});
                    indicesAccessor.setScalar(j, index + offsetSum, {});
                }
                offsetSum += elementNumber;
            }
        }
    }
    __getRnAccessor(accessor, rnBuffer) {
        var _a, _b, _c, _d;
        const bufferView = accessor.bufferView;
        const rnBufferView = rnBuffer.takeBufferViewWithByteOffset({
            byteLengthToNeed: bufferView.byteLength,
            byteStride: (_a = bufferView.byteStride) !== null && _a !== void 0 ? _a : 0,
            byteOffset: (_b = bufferView.byteOffset) !== null && _b !== void 0 ? _b : 0,
            isAoS: false
        });
        let rnAccessor;
        if (accessor.byteStride != null) {
            rnAccessor = rnBufferView.takeFlexibleAccessorWithByteOffset({
                compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_11__["CompositionType"].fromString(accessor.type),
                componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_12__["ComponentType"].from(accessor.componentType),
                count: accessor.count,
                byteStride: accessor.byteStride,
                byteOffset: (_c = accessor.byteOffset) !== null && _c !== void 0 ? _c : 0,
                max: accessor.max,
                min: accessor.min,
                normalized: accessor.normalized
            });
        }
        else {
            rnAccessor = rnBufferView.takeAccessorWithByteOffset({
                compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_11__["CompositionType"].fromString(accessor.type),
                componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_12__["ComponentType"].from(accessor.componentType),
                count: accessor.count,
                byteOffset: (_d = accessor.byteOffset) !== null && _d !== void 0 ? _d : 0,
                max: accessor.max,
                min: accessor.min,
                normalized: accessor.normalized
            });
        }
        return rnAccessor;
    }
    __copyRnAccessorAndBufferView(srcRnAccessor) {
        const byteSize = srcRnAccessor.elementCount * 4 /* vec4 */ * 4 /* bytes */;
        const dstRnBuffer = _core_MemoryManager__WEBPACK_IMPORTED_MODULE_33__["default"].getInstance().createOrGetBuffer(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_32__["BufferUse"].GPUVertexData);
        const dstRnBufferView = dstRnBuffer.takeBufferView({
            byteLengthToNeed: byteSize,
            byteStride: 4 /* vec4 */ * 4 /* bytes */,
            isAoS: false
        });
        const dstRnAccessor = dstRnBufferView.takeAccessor({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_11__["CompositionType"].Vec4,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_12__["ComponentType"].Float,
            count: srcRnAccessor.elementCount,
            max: srcRnAccessor.max,
            min: srcRnAccessor.min,
            normalized: srcRnAccessor.normalized
        });
        for (let i = 0; i < srcRnAccessor.elementCount; i++) {
            dstRnAccessor.setElementFromAccessor(i, srcRnAccessor);
        }
        return dstRnAccessor;
    }
    __createRnAccessor(accessor, numOfAttributes, compositionNum, rnBuffer) {
        var _a, _b;
        const rnBufferView = rnBuffer.takeBufferView({
            byteLengthToNeed: numOfAttributes * compositionNum * 4,
            byteStride: 0,
            isAoS: false
        });
        let rnAccessor;
        if (accessor.byteStride != null) {
            rnAccessor = rnBufferView.takeFlexibleAccessorWithByteOffset({
                compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_11__["CompositionType"].fromString(accessor.type),
                componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_12__["ComponentType"].from(accessor.componentType),
                count: numOfAttributes,
                byteStride: accessor.byteStride,
                byteOffset: (_a = accessor.byteOffset) !== null && _a !== void 0 ? _a : 0,
                max: accessor.max,
                min: accessor.min,
                normalized: accessor.normalized
            });
        }
        else {
            rnAccessor = rnBufferView.takeAccessorWithByteOffset({
                compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_11__["CompositionType"].fromString(accessor.type),
                componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_12__["ComponentType"].from(accessor.componentType),
                count: numOfAttributes,
                byteOffset: (_b = accessor.byteOffset) !== null && _b !== void 0 ? _b : 0,
                max: accessor.max,
                min: accessor.min,
                normalized: accessor.normalized
            });
        }
        return rnAccessor;
    }
    __getRnBufferView(bufferView, rnBuffer) {
        var _a, _b;
        const rnBufferView = rnBuffer.takeBufferViewWithByteOffset({
            byteLengthToNeed: bufferView.byteLength,
            byteStride: (_a = bufferView.byteStride) !== null && _a !== void 0 ? _a : 0,
            byteOffset: (_b = bufferView.byteOffset) !== null && _b !== void 0 ? _b : 0,
            isAoS: false
        });
        return rnBufferView;
    }
    __getGeometryFromDracoBuffer(draco, decoder, arrayBuffer) {
        const buffer = new draco.DecoderBuffer();
        buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);
        const geometryType = decoder.GetEncodedGeometryType(buffer);
        let dracoGeometry;
        let decodingStatus;
        if (geometryType === draco.TRIANGULAR_MESH) {
            dracoGeometry = new draco.Mesh();
            decodingStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);
        }
        else if (geometryType == draco.POINT_CLOUD) {
            dracoGeometry = new draco.PointCloud();
            decodingStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
        }
        else {
            const errorMsg = 'Unknown geometry type.';
            console.error(errorMsg);
        }
        dracoGeometry.geometryType = geometryType; // store
        if (!decodingStatus.ok() || dracoGeometry.ptr == 0) {
            let errorMsg = 'Decoding failed: ';
            errorMsg += decodingStatus.error_msg();
            console.error(errorMsg);
            draco.destroy(decoder);
            draco.destroy(dracoGeometry);
            return void 0;
        }
        draco.destroy(buffer);
        return dracoGeometry;
    }
    __getIndicesFromDraco(draco, decoder, dracoGeometry, triangleStripDrawMode) {
        // For mesh, we need to generate the faces.
        const geometryType = dracoGeometry.geometryType;
        if (geometryType !== draco.TRIANGULAR_MESH) {
            return void 0;
        }
        let indices;
        if (triangleStripDrawMode) {
            const stripsArray = new draco.DracoInt32Array();
            decoder.GetTriangleStripsFromMesh(dracoGeometry, stripsArray);
            indices = new Uint32Array(stripsArray.size());
            for (var i = 0; i < stripsArray.size(); ++i) {
                indices[i] = stripsArray.GetValue(i);
            }
            draco.destroy(stripsArray);
        }
        else { // TRIANGLES
            const numFaces = dracoGeometry.num_faces();
            const numIndices = numFaces * 3;
            indices = new Uint32Array(numIndices);
            const ia = new draco.DracoInt32Array();
            for (let i = 0; i < numFaces; ++i) {
                decoder.GetFaceFromMesh(dracoGeometry, i, ia);
                var index = i * 3;
                indices[index] = ia.GetValue(0);
                indices[index + 1] = ia.GetValue(1);
                indices[index + 2] = ia.GetValue(2);
            }
            draco.destroy(ia);
        }
        return indices;
    }
    __decodeDraco(primitive, rnBuffers, gltfModel, map) {
        const bufferView = gltfModel.bufferViews[primitive.extensions.KHR_draco_mesh_compression.bufferView];
        const rnBufferView = this.__getRnBufferView(bufferView, rnBuffers[bufferView.bufferIndex]);
        const arraybufferOfBufferView = new Uint8Array(rnBufferView.getUint8Array()).buffer;
        const draco = new DracoDecoderModule();
        const decoder = new draco.Decoder();
        const dracoGeometry = this.__getGeometryFromDracoBuffer(draco, decoder, arraybufferOfBufferView);
        if (dracoGeometry == null) {
            draco.destroy(dracoGeometry);
            draco.destroy(decoder);
            return void 0;
        }
        const numPoints = dracoGeometry.num_points();
        const rnBufferForDraco = this.__createBufferForDecompressedData(primitive, numPoints);
        // decode indices
        const primitiveMode = _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_10__["PrimitiveMode"].from(primitive.mode);
        let isTriangleStrip = false;
        if (primitiveMode === _definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_10__["PrimitiveMode"].TriangleStrip) {
            isTriangleStrip = true;
        }
        const indices = this.__getIndicesFromDraco(draco, decoder, dracoGeometry, isTriangleStrip);
        const indicesRnAccessor = this.__createRnAccessor(primitive.indices, indices.length, 1, rnBufferForDraco);
        for (let i = 0; i < indices.length; i++) {
            indicesRnAccessor.setScalar(i, indices[i], {});
        }
        // decode attributes
        for (let attributeName in primitive.attributes) {
            const dracoAttributeId = primitive.extensions.KHR_draco_mesh_compression.attributes[attributeName];
            const attributeGltf2Accessor = primitive.attributes[attributeName];
            let attributeRnAccessor;
            if (dracoAttributeId == null) {
                // non-encoded data
                attributeRnAccessor = this.__getRnAccessor(attributeGltf2Accessor, rnBuffers[attributeGltf2Accessor.bufferView.bufferIndex]);
            }
            else {
                // encoded data
                const compositionNum = _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_11__["CompositionType"].fromString(attributeGltf2Accessor.type).getNumberOfComponents();
                attributeRnAccessor = this.__createRnAccessor(attributeGltf2Accessor, numPoints, compositionNum, rnBufferForDraco);
                const dracoAttributePointer = decoder.GetAttributeByUniqueId(dracoGeometry, dracoAttributeId);
                const decompressedAttributeData = new draco.DracoFloat32Array();
                decoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttributePointer, decompressedAttributeData);
                for (let i = 0; i < numPoints; i++) {
                    if (compositionNum === 1) {
                        attributeRnAccessor.setScalar(i, decompressedAttributeData.GetValue(i * compositionNum), {});
                    }
                    else if (compositionNum === 2) {
                        attributeRnAccessor.setVec2(i, decompressedAttributeData.GetValue(i * compositionNum), decompressedAttributeData.GetValue(i * compositionNum + 1), {});
                    }
                    else if (compositionNum === 3) {
                        attributeRnAccessor.setVec3(i, decompressedAttributeData.GetValue(i * compositionNum), decompressedAttributeData.GetValue(i * compositionNum + 1), decompressedAttributeData.GetValue(i * compositionNum + 2), {});
                    }
                    else if (compositionNum === 4) {
                        attributeRnAccessor.setVec4(i, decompressedAttributeData.GetValue(i * compositionNum), decompressedAttributeData.GetValue(i * compositionNum + 1), decompressedAttributeData.GetValue(i * compositionNum + 2), decompressedAttributeData.GetValue(i * compositionNum + 3), {});
                    }
                }
                draco.destroy(decompressedAttributeData);
            }
            if (attributeGltf2Accessor.sparse) {
                this.setSparseAccessor(attributeGltf2Accessor, attributeRnAccessor);
            }
            map.set(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_13__["VertexAttribute"].fromString(attributeGltf2Accessor.extras.attributeName), attributeRnAccessor);
        }
        draco.destroy(dracoGeometry);
        draco.destroy(decoder);
        return indicesRnAccessor;
    }
    static _setupTextureTransform(textureJson, rnMaterial, textureTransformShaderSemantic, textureRotationShaderSemantic) {
        var _a;
        if ((_a = textureJson === null || textureJson === void 0 ? void 0 : textureJson.extensions) === null || _a === void 0 ? void 0 : _a.KHR_texture_transform) {
            const transform = new _math_MutableVector4__WEBPACK_IMPORTED_MODULE_28__["default"](1.0, 1.0, 0.0, 0.0);
            let rotation = 0;
            const transformJson = textureJson.extensions.KHR_texture_transform;
            if (transformJson.scale != null) {
                transform.x = transformJson.scale[0];
                transform.y = transformJson.scale[1];
            }
            if (transformJson.offset != null) {
                transform.z = transformJson.offset[0];
                transform.w = transformJson.offset[1];
            }
            if (transformJson.rotation != null) {
                rotation = transformJson.rotation;
            }
            rnMaterial.setParameter(textureTransformShaderSemantic, transform);
            rnMaterial.setParameter(textureRotationShaderSemantic, rotation);
        }
    }
    __createBufferForDecompressedData(primitive, numPoints) {
        let byteLengthOfBufferForDraco = 0;
        if (primitive.indices) {
            const count = primitive.indices.count;
            byteLengthOfBufferForDraco += count * 4;
        }
        const drcAttributes = primitive.extensions.KHR_draco_mesh_compression.attributes;
        for (let attributeName in primitive.attributes) {
            if (drcAttributes[attributeName] == null) {
                // non-encoded data
                continue;
            }
            const accessor = primitive.attributes[attributeName];
            const compositionNum = _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_11__["CompositionType"].fromString(accessor.type).getNumberOfComponents();
            const attributeByteLength = numPoints * compositionNum * 4;
            byteLengthOfBufferForDraco += attributeByteLength;
        }
        return new _memory_Buffer__WEBPACK_IMPORTED_MODULE_9__["default"]({
            byteLength: byteLengthOfBufferForDraco,
            buffer: new ArrayBuffer(byteLengthOfBufferForDraco),
            name: 'Draco'
        });
    }
}


/***/ }),

/***/ "./src/foundation/importer/VRMImporter.ts":
/*!************************************************!*\
  !*** ./src/foundation/importer/VRMImporter.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VRMImporter; });
/* harmony import */ var _GltfImporter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GltfImporter */ "./src/foundation/importer/GltfImporter.ts");
/* harmony import */ var _Gltf2Importer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Gltf2Importer */ "./src/foundation/importer/Gltf2Importer.ts");
/* harmony import */ var _ModelConverter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ModelConverter */ "./src/foundation/importer/ModelConverter.ts");



/**
 * The VRM Importer class.
 * This class will be integrated into GltfImporter.
 */
class VRMImporter {
    constructor() { }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new VRMImporter();
        }
        return this.__instance;
    }
    /**
     * Import VRM file.
     */
    async import(uri, options) {
        const gltfImporter = _GltfImporter__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
        options = gltfImporter._getOptions(options);
        const gltf2Importer = _Gltf2Importer__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance();
        const gltfModel = await gltf2Importer.import(uri, options);
        const textures = gltfImporter._createTextures(gltfModel);
        const defaultMaterialHelperArgumentArray = gltfModel.asset.extras.rnLoaderOptions.defaultMaterialHelperArgumentArray;
        defaultMaterialHelperArgumentArray[0].textures = textures;
        gltfImporter._initializeMaterialProperties(gltfModel, textures.length);
        // setup rootGroup
        let rootGroups;
        const modelConverter = _ModelConverter__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance();
        const rootGroupMain = modelConverter.convertToRhodoniteObject(gltfModel);
        const existOutline = gltfImporter._existOutlineMaterial(gltfModel.extensions.VRM);
        if (existOutline) {
            defaultMaterialHelperArgumentArray[0].isOutline = true;
            const rootGroupOutline = modelConverter.convertToRhodoniteObject(gltfModel);
            rootGroups = [rootGroupMain, rootGroupOutline];
        }
        else {
            rootGroups = [rootGroupMain];
        }
        gltfImporter._readSpringBone(rootGroupMain, gltfModel);
        gltfImporter._readVRMHumanoidInfo(gltfModel, rootGroupMain);
        return rootGroups;
    }
}


/***/ }),

/***/ "./src/foundation/materials/core/AbstractMaterialNode.ts":
/*!***************************************************************!*\
  !*** ./src/foundation/materials/core/AbstractMaterialNode.ts ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AbstractMaterialNode; });
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _textures_Texture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../textures/Texture */ "./src/foundation/textures/Texture.ts");
/* harmony import */ var _textures_CubeTexture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../textures/CubeTexture */ "./src/foundation/textures/CubeTexture.ts");
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _math_MutableVector2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math/MutableVector2 */ "./src/foundation/math/MutableVector2.ts");
/* harmony import */ var _math_MutableVector4__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../math/MutableVector4 */ "./src/foundation/math/MutableVector4.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _core_MemoryManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _definitions_BufferUse__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../definitions/BufferUse */ "./src/foundation/definitions/BufferUse.ts");
/* harmony import */ var _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../definitions/ProcessApproach */ "./src/foundation/definitions/ProcessApproach.ts");
/* harmony import */ var _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../definitions/BoneDataType */ "./src/foundation/definitions/BoneDataType.ts");
/* harmony import */ var _system_SystemState__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../system/SystemState */ "./src/foundation/system/SystemState.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");

















class AbstractMaterialNode extends _core_RnObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(shader, shaderFunctionName, { isMorphing = false, isSkinning = false, isLighting = false } = {}, vertexShaderityObject, pixelShaderityObject) {
        super();
        this.__semantics = [];
        this.__vertexInputs = [];
        this.__pixelInputs = [];
        this.__vertexOutputs = [];
        this.__pixelOutputs = [];
        this.__defaultInputValues = new Map();
        this.__vertexInputConnections = [];
        this.__pixelInputConnections = [];
        this.isSingleOperation = false;
        this.__definitions = '';
        this.shaderType = _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_16__["ShaderType"].VertexAndPixelShader;
        this.__shader = shader;
        this.__shaderFunctionName = shaderFunctionName;
        this.__materialNodeUid = ++AbstractMaterialNode.__invalidMaterialNodeCount;
        AbstractMaterialNode.materialNodes[AbstractMaterialNode.__invalidMaterialNodeCount] = this;
        this.__isMorphing = isMorphing;
        this.__isSkinning = isSkinning;
        this.__isLighting = isLighting;
        AbstractMaterialNode.__dummyBlackTexture.tryToSetUniqueName('dummyBlackTexture', true);
        AbstractMaterialNode.__dummyWhiteTexture.tryToSetUniqueName('dummyWhiteTexture', true);
        AbstractMaterialNode.__dummyBlueTexture.tryToSetUniqueName('dummyBlueTexture', true);
        AbstractMaterialNode.__dummyBlackCubeTexture.tryToSetUniqueName('dummyBlackCubeTexture', true);
        this.__vertexShaderityObject = vertexShaderityObject;
        this.__pixelShaderityObject = pixelShaderityObject;
        this.__webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].getWebGLResourceRepository();
        this.__definitions += `#define RN_MATERIAL_NODE_NAME ${shaderFunctionName}\n`;
    }
    get shaderFunctionName() {
        return this.__shaderFunctionName;
    }
    get shader() {
        return this.__shader;
    }
    get vertexShaderityObject() {
        return this.__vertexShaderityObject;
    }
    get pixelShaderityObject() {
        return this.__pixelShaderityObject;
    }
    get definitions() {
        return this.__definitions;
    }
    static getMaterialNode(materialNodeUid) {
        return AbstractMaterialNode.materialNodes[materialNodeUid];
    }
    get materialNodeUid() {
        return this.__materialNodeUid;
    }
    get _semanticsInfoArray() {
        return this.__semantics;
    }
    get isSkinning() {
        return this.__isSkinning;
    }
    get isMorphing() {
        return this.__isMorphing;
    }
    get isLighting() {
        return this.__isLighting;
    }
    setShaderSemanticsInfoArray(shaderSemanticsInfoArray) {
        const infoArray = [];
        for (let info of shaderSemanticsInfoArray) {
            infoArray.push(info);
        }
        this.__semantics = infoArray;
        if (!AbstractMaterialNode.__semanticsMap.has(this.shaderFunctionName)) {
            AbstractMaterialNode.__semanticsMap.set(this.shaderFunctionName, new Map());
        }
        const map = AbstractMaterialNode.__semanticsMap.get(this.shaderFunctionName);
        for (let semantic of this.__semantics) {
            map.set(semantic.semantic.str, semantic);
        }
    }
    getShaderSemanticInfoFromName(name) {
        const map = AbstractMaterialNode.__semanticsMap.get(this.shaderFunctionName);
        return map.get(name);
    }
    addVertexInputConnection(inputMaterialNode, outputNameOfPrev, inputNameOfThis) {
        this.__vertexInputConnections.push({ materialNodeUid: inputMaterialNode.materialNodeUid, outputNameOfPrev: outputNameOfPrev, inputNameOfThis: inputNameOfThis });
    }
    addPixelInputConnection(inputMaterialNode, outputNameOfPrev, inputNameOfThis) {
        this.__pixelInputConnections.push({ materialNodeUid: inputMaterialNode.materialNodeUid, outputNameOfPrev: outputNameOfPrev, inputNameOfThis: inputNameOfThis });
    }
    get vertexInputConnections() {
        return this.__vertexInputConnections;
    }
    get pixelInputConnections() {
        return this.__pixelInputConnections;
    }
    getVertexInput(name) {
        for (let input of this.__vertexInputs) {
            if (input.name === name) {
                return input;
            }
        }
        return void 0;
    }
    getVertexInputs() {
        return this.__vertexInputs;
    }
    getVertexOutput(name) {
        for (let output of this.__vertexOutputs) {
            if (output.name === name) {
                return output;
            }
        }
        return void 0;
    }
    getVertexOutputs() {
        return this.__vertexOutputs;
    }
    getPixelInput(name) {
        for (let input of this.__pixelInputs) {
            if (input.name === name) {
                return input;
            }
        }
        return void 0;
    }
    getPixelInputs() {
        return this.__pixelInputs;
    }
    getPixelOutput(name) {
        for (let output of this.__pixelOutputs) {
            if (output.name === name) {
                return output;
            }
        }
        return void 0;
    }
    getPixelOutputs() {
        return this.__pixelOutputs;
    }
    static initDefaultTextures() {
        if (this.__dummyWhiteTexture.isTextureReady) {
            return;
        }
        this.__dummyWhiteTexture.generate1x1TextureFrom();
        this.__dummyBlueTexture.generate1x1TextureFrom("rgba(127.5, 127.5, 255, 1)");
        this.__dummyBlackTexture.generate1x1TextureFrom("rgba(0, 0, 0, 1)");
        this.__dummyBlackCubeTexture.load1x1Texture("rgba(0, 0, 0, 1)");
    }
    static get dummyWhiteTexture() {
        return this.__dummyWhiteTexture;
    }
    static get dummyBlackTexture() {
        return this.__dummyBlackTexture;
    }
    static get dummyBlueTexture() {
        return this.__dummyBlueTexture;
    }
    static get dummyBlackCubeTexture() {
        return this.__dummyWhiteTexture;
    }
    setWorldMatrix(shaderProgram, worldMatrix) {
        shaderProgram._gl.uniformMatrix4fv(shaderProgram.worldMatrix, false, worldMatrix.v);
    }
    setNormalMatrix(shaderProgram, normalMatrix) {
        shaderProgram._gl.uniformMatrix3fv(shaderProgram.normalMatrix, false, normalMatrix.v);
    }
    setViewInfo(shaderProgram, cameraComponent, material, setUniform) {
        if (cameraComponent) {
            const cameraPosition = cameraComponent.worldPosition;
            if (setUniform) {
                shaderProgram._gl.uniformMatrix4fv(shaderProgram.viewMatrix, false, cameraComponent.viewMatrix.v);
                shaderProgram._gl.uniform3fv(shaderProgram.viewPosition, cameraPosition.v);
            }
            else {
                // material.setParameter(ShaderSemantics.ViewMatrix, cameraComponent.viewMatrix);
                // material.setParameter(ShaderSemantics.ViewPosition, cameraPosition);
            }
        }
        else {
            const mat = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_9__["default"].identity();
            const pos = new _math_Vector3__WEBPACK_IMPORTED_MODULE_8__["default"](0, 0, 10);
            if (setUniform) {
                shaderProgram._gl.uniformMatrix4fv(shaderProgram.viewMatrix, false, mat.v);
                shaderProgram._gl.uniform3fv(shaderProgram.viewPosition, pos.v);
            }
            else {
                // material.setParameter(ShaderSemantics.ViewMatrix, mat);
                // material.setParameter(ShaderSemantics.ViewPosition, pos);
            }
        }
    }
    setProjection(shaderProgram, cameraComponent, material, setUniform) {
        if (cameraComponent) {
            if (setUniform) {
                shaderProgram._gl.uniformMatrix4fv(shaderProgram.projectionMatrix, false, cameraComponent.projectionMatrix.v);
            }
            else {
                // material.setParameter(ShaderSemantics.ProjectionMatrix, cameraComponent.projectionMatrix);
            }
        }
        else {
            if (setUniform) {
                this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__["ShaderSemantics"].ProjectionMatrix.str, true, _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_9__["default"].identity());
            }
        }
    }
    setSkinning(shaderProgram, skeletalComponent, setUniform) {
        if (!this.__isSkinning) {
            return;
        }
        if (skeletalComponent) {
            if (setUniform) {
                if (_core_Config__WEBPACK_IMPORTED_MODULE_5__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_14__["BoneDataType"].Mat4x4) {
                    const jointMatricesArray = skeletalComponent.jointMatricesArray;
                    shaderProgram._gl.uniformMatrix4fv(shaderProgram.boneMatrix, false, jointMatricesArray);
                }
                else if (_core_Config__WEBPACK_IMPORTED_MODULE_5__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_14__["BoneDataType"].Vec4x2) {
                    const jointQuaternionArray = skeletalComponent.jointQuaternionArray;
                    const jointTranslateScaleArray = skeletalComponent.jointTranslateScaleArray;
                    shaderProgram._gl.uniform4fv(shaderProgram.boneQuaternion, jointQuaternionArray);
                    shaderProgram._gl.uniform4fv(shaderProgram.boneTranslateScale, jointTranslateScaleArray);
                }
                else if (_core_Config__WEBPACK_IMPORTED_MODULE_5__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_14__["BoneDataType"].Vec4x1) {
                    const jointCompressedChunk = skeletalComponent.jointCompressedChunk;
                    const jointCompressedInfo = skeletalComponent.jointCompressedInfo;
                    shaderProgram._gl.uniform4fv(shaderProgram.boneCompressedChunk, jointCompressedChunk);
                    shaderProgram._gl.uniform4fv(shaderProgram.boneCompressedInfo, jointCompressedInfo.v);
                }
                shaderProgram._gl.uniform1i(shaderProgram.skinningMode, 0);
            }
        }
        else {
            if (setUniform) {
                shaderProgram._gl.uniform1i(shaderProgram.skinningMode, -1);
            }
        }
    }
    setLightsInfo(shaderProgram, lightComponents, material, setUniform) {
        if (!this.__isLighting) {
            return;
        }
        if (setUniform) {
            shaderProgram._gl.uniform1i(shaderProgram.lightNumber, lightComponents.length);
            const length = Math.min(lightComponents.length, _core_Config__WEBPACK_IMPORTED_MODULE_5__["default"].maxLightNumberInShader);
            if (AbstractMaterialNode.__lightPositions.length !== 4 * length) {
                AbstractMaterialNode.__lightPositions = new Float32Array(4 * length);
                AbstractMaterialNode.__lightDirections = new Float32Array(4 * length);
                AbstractMaterialNode.__lightIntensities = new Float32Array(4 * length);
            }
            for (let i = 0; i < lightComponents.length; i++) {
                if (i >= _core_Config__WEBPACK_IMPORTED_MODULE_5__["default"].maxLightNumberInShader) {
                    break;
                }
                if (shaderProgram.lightPosition == null) {
                    break;
                }
                const lightComponent = lightComponents[i];
                const sceneGraphComponent = lightComponent.entity.getSceneGraph();
                const worldLightPosition = sceneGraphComponent.worldPosition;
                const worldLightDirection = lightComponent.direction;
                const worldLightIntensity = lightComponent.intensity;
                AbstractMaterialNode.__lightPositions[i * 4 + 0] = worldLightPosition.x;
                AbstractMaterialNode.__lightPositions[i * 4 + 1] = worldLightPosition.y;
                AbstractMaterialNode.__lightPositions[i * 4 + 2] = worldLightPosition.z;
                AbstractMaterialNode.__lightPositions[i * 4 + 3] = lightComponent.type.index;
                AbstractMaterialNode.__lightDirections[i * 4 + 0] = worldLightDirection.x;
                AbstractMaterialNode.__lightDirections[i * 4 + 1] = worldLightDirection.y;
                AbstractMaterialNode.__lightDirections[i * 4 + 2] = worldLightDirection.z;
                AbstractMaterialNode.__lightDirections[i * 4 + 3] = 0;
                AbstractMaterialNode.__lightIntensities[i * 4 + 0] = worldLightIntensity.x;
                AbstractMaterialNode.__lightIntensities[i * 4 + 1] = worldLightIntensity.y;
                AbstractMaterialNode.__lightIntensities[i * 4 + 2] = worldLightIntensity.z;
                AbstractMaterialNode.__lightIntensities[i * 4 + 3] = 0;
            }
            if (length > 0) {
                shaderProgram._gl.uniform4fv(shaderProgram.lightPosition, AbstractMaterialNode.__lightPositions);
                shaderProgram._gl.uniform4fv(shaderProgram.lightDirection, AbstractMaterialNode.__lightDirections);
                shaderProgram._gl.uniform4fv(shaderProgram.lightIntensity, AbstractMaterialNode.__lightIntensities);
            }
        }
    }
    setMorphInfo(shaderProgram, meshComponent, blendShapeComponent, primitive) {
        if (!this.__isMorphing) {
            return;
        }
        if (primitive.targets.length === 0) {
            shaderProgram._gl.uniform1i(shaderProgram.morphTargetNumber, 0);
            return;
        }
        const memoryManager = _core_MemoryManager__WEBPACK_IMPORTED_MODULE_11__["default"].getInstance();
        shaderProgram._gl.uniform1i(shaderProgram.morphTargetNumber, primitive.targets.length);
        const array = primitive.targets.map((target) => {
            const accessor = target.get(_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_10__["VertexAttribute"].Position);
            let offset = 0;
            if (_system_SystemState__WEBPACK_IMPORTED_MODULE_15__["default"].currentProcessApproach === _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_13__["ProcessApproach"].FastestWebGL1) {
                offset = memoryManager.createOrGetBuffer(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_12__["BufferUse"].GPUInstanceData).takenSizeInByte;
            }
            return (offset + accessor.byteOffsetInBuffer) / 4 / 4;
        });
        shaderProgram._gl.uniform1fv(shaderProgram.dataTextureMorphOffsetPosition, array);
        let weights;
        if (meshComponent.mesh.weights.length > 0) {
            weights = meshComponent.mesh.weights;
        }
        else if (blendShapeComponent.weights.length > 0) {
            weights = blendShapeComponent.weights;
        }
        else {
            weights = new Float32Array(primitive.targets.length);
        }
        shaderProgram._gl.uniform1fv(shaderProgram.morphWeights, weights);
    }
    setParametersForGPU({ material, shaderProgram, firstTime, args }) {
    }
    setDefaultInputValue(inputName, value) {
        this.__defaultInputValues.set(inputName, value);
    }
}
AbstractMaterialNode.__semanticsMap = new Map();
AbstractMaterialNode.__invalidMaterialNodeUid = -1;
AbstractMaterialNode.__invalidMaterialNodeCount = -1;
AbstractMaterialNode.materialNodes = [];
AbstractMaterialNode.__transposedMatrix44 = new _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_9__["default"]([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
AbstractMaterialNode.__dummyWhiteTexture = new _textures_Texture__WEBPACK_IMPORTED_MODULE_3__["default"]();
AbstractMaterialNode.__dummyBlueTexture = new _textures_Texture__WEBPACK_IMPORTED_MODULE_3__["default"]();
AbstractMaterialNode.__dummyBlackTexture = new _textures_Texture__WEBPACK_IMPORTED_MODULE_3__["default"]();
AbstractMaterialNode.__dummyBlackCubeTexture = new _textures_CubeTexture__WEBPACK_IMPORTED_MODULE_4__["default"]();
AbstractMaterialNode.__tmp_vector4 = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_7__["default"].zero();
AbstractMaterialNode.__tmp_vector2 = _math_MutableVector2__WEBPACK_IMPORTED_MODULE_6__["default"].zero();
AbstractMaterialNode.__lightPositions = new Float32Array(0);
AbstractMaterialNode.__lightDirections = new Float32Array(0);
AbstractMaterialNode.__lightIntensities = new Float32Array(0);


/***/ }),

/***/ "./src/foundation/materials/core/AbstractShaderNode.ts":
/*!*************************************************************!*\
  !*** ./src/foundation/materials/core/AbstractShaderNode.ts ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AbstractShaderNode; });
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/RnObject */ "./src/foundation/core/RnObject.ts");

class AbstractShaderNode extends _core_RnObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(shaderNodeName, shaderCode, shader) {
        super();
        this.__inputs = [];
        this.__outputs = [];
        this.__inputConnections = [];
        this.__shaderFunctionName = shaderNodeName;
        this.__shaderCode = shaderCode;
        this.__shaderNodeUid = ++AbstractShaderNode.__invalidShaderNodeCount;
        AbstractShaderNode.shaderNodes[AbstractShaderNode.__invalidShaderNodeCount] = this;
        this.__shader = shader;
    }
    get shaderFunctionName() {
        return this.__shaderFunctionName;
    }
    get shaderCode() {
        return this.__shaderCode;
    }
    get shaderNodeUid() {
        return this.__shaderNodeUid;
    }
    getInput(name) {
        for (let input of this.__inputs) {
            if (input.name === name) {
                return input;
            }
        }
        return void 0;
    }
    getInputs() {
        return this.__inputs;
    }
    getOutput(name) {
        for (let output of this.__outputs) {
            if (output.name === name) {
                return output;
            }
        }
        return void 0;
    }
    getOutputs() {
        return this.__outputs;
    }
    addInputConnection(inputShaderNode, outputNameOfPrev, inputNameOfThis) {
        this.__inputConnections.push({ shaderNodeUid: inputShaderNode.shaderNodeUid, outputNameOfPrev: outputNameOfPrev, inputNameOfThis: inputNameOfThis });
    }
    get inputConnections() {
        return this.__inputConnections;
    }
    get shader() {
        return this.__shader;
    }
}
AbstractShaderNode.shaderNodes = [];
AbstractShaderNode.__invalidShaderNodeUid = -1;
AbstractShaderNode.__invalidShaderNodeCount = -1;


/***/ }),

/***/ "./src/foundation/materials/core/Material.ts":
/*!***************************************************!*\
  !*** ./src/foundation/materials/core/Material.ts ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Material; });
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/AlphaMode */ "./src/foundation/definitions/AlphaMode.ts");
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/MathClassUtil */ "./src/foundation/math/MathClassUtil.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _core_MemoryManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _definitions_BufferUse__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../definitions/BufferUse */ "./src/foundation/definitions/BufferUse.ts");
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _misc_DataUtil__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../misc/DataUtil */ "./src/foundation/misc/DataUtil.ts");
/* harmony import */ var _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/GlobalDataRepository */ "./src/foundation/core/GlobalDataRepository.ts");
/* harmony import */ var _system_System__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../system/System */ "./src/foundation/system/System.ts");
/* harmony import */ var _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../definitions/ProcessApproach */ "./src/foundation/definitions/ProcessApproach.ts");
/* harmony import */ var _ShaderityUtility__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./ShaderityUtility */ "./src/foundation/materials/core/ShaderityUtility.ts");
/* harmony import */ var _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../definitions/BoneDataType */ "./src/foundation/definitions/BoneDataType.ts");
/* harmony import */ var _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");


















/**
 * The material class.
 * This class has one or more material nodes.
 */
class Material extends _core_RnObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(materialTid, materialTypeName, materialNodes) {
        super();
        this.__materialNodes = [];
        this.__fields = new Map();
        this.__fieldsForNonSystem = new Map();
        this.__fieldsInfo = new Map();
        this._shaderProgramUid = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_6__["default"].InvalidCGAPIResourceUid;
        this.__alphaMode = _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_1__["AlphaMode"].Opaque;
        this.__materialSid = -1;
        this.cullFace = true; // If true, enable gl.CULL_FACE
        this.cullFrontFaceCCW = true;
        this.__blendEquationMode = 32774; // gl.FUNC_ADD
        this.__blendEquationModeAlpha = 32774; // gl.FUNC_ADD
        this.__blendFuncSrcFactor = 770; // gl.SRC_ALPHA
        this.__blendFuncDstFactor = 771; // gl.ONE_MINUS_SRC_ALPHA
        this.__blendFuncAlphaSrcFactor = 1; // gl.ONE
        this.__blendFuncAlphaDstFactor = 1; // gl.ONE
        this.__materialNodes = materialNodes;
        this.__materialTid = materialTid;
        this.__materialTypeName = materialTypeName;
        Material.__materials.push(this);
        Material.__instancesByTypes.set(materialTypeName, this);
        this.tryToSetUniqueName(materialTypeName, true);
        this.initialize();
    }
    get materialTypeName() {
        return this.__materialTypeName;
    }
    /**
     * Gets materialTID.
     */
    get materialTID() {
        return this.__materialTid;
    }
    get fieldsInfoArray() {
        return Array.from(this.__fieldsInfo.values());
    }
    /**
     * Creates an instance of this Material class.
     * @param materialTypeName The material type to create.
     * @param materialNodes_ The material nodes to add to the created material.
     */
    static createMaterial(materialTypeName, materialNodes_) {
        let materialNodes = materialNodes_;
        if (!materialNodes) {
            materialNodes = Material.__materialTypes.get(materialTypeName);
        }
        return new Material(Material.__materialTids.get(materialTypeName), materialTypeName, materialNodes);
    }
    static isRegisteredMaterialType(materialTypeName) {
        return Material.__materialTypes.has(materialTypeName);
    }
    static _calcAlignedByteLength(semanticInfo) {
        const compositionNumber = semanticInfo.compositionType.getNumberOfComponents();
        const componentSizeInByte = semanticInfo.componentType.getSizeInBytes();
        const semanticInfoByte = compositionNumber * componentSizeInByte;
        let alignedByteLength = semanticInfoByte;
        if (alignedByteLength % 16 !== 0) {
            alignedByteLength = semanticInfoByte + 16 - semanticInfoByte % 16;
        }
        if (_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].isArray(semanticInfo.compositionType)) {
            const maxArrayLength = semanticInfo.maxIndex;
            if (maxArrayLength != null) {
                alignedByteLength *= maxArrayLength;
            }
            else {
                console.error('semanticInfo has invalid maxIndex!');
                alignedByteLength *= 100;
            }
        }
        return alignedByteLength;
    }
    static __allocateBufferView(materialTypeName, materialNodes) {
        let totalByteLength = 0;
        const alignedByteLengthAndSemanticInfoArray = [];
        for (let materialNode of materialNodes) {
            for (let semanticInfo of materialNode._semanticsInfoArray) {
                const alignedByteLength = Material._calcAlignedByteLength(semanticInfo);
                let dataCount = 1;
                if (!semanticInfo.soloDatum) {
                    dataCount = Material.__maxInstances.get(materialTypeName);
                }
                totalByteLength += alignedByteLength * dataCount;
                alignedByteLengthAndSemanticInfoArray.push({ alignedByte: alignedByteLength, semanticInfo: semanticInfo });
            }
        }
        if (!this.__accessors.has(materialTypeName)) {
            this.__accessors.set(materialTypeName, new Map());
        }
        const buffer = _core_MemoryManager__WEBPACK_IMPORTED_MODULE_7__["default"].getInstance().createOrGetBuffer(_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_8__["BufferUse"].GPUInstanceData);
        let bufferView;
        if (this.__bufferViews.has(materialTypeName)) {
            bufferView = this.__bufferViews.get(materialTypeName);
        }
        else {
            bufferView = buffer.takeBufferView({
                byteLengthToNeed: totalByteLength,
                byteStride: 0,
                byteAlign: 16,
                isAoS: false
            });
            this.__bufferViews.set(materialTypeName, bufferView);
        }
        for (let i = 0; i < alignedByteLengthAndSemanticInfoArray.length; i++) {
            const alignedByte = alignedByteLengthAndSemanticInfoArray[i].alignedByte;
            const semanticInfo = alignedByteLengthAndSemanticInfoArray[i].semanticInfo;
            let count = 1;
            if (!semanticInfo.soloDatum) {
                count = Material.__maxInstances.get(materialTypeName);
            }
            let maxArrayLength = semanticInfo.maxIndex;
            if (_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].isArray(semanticInfo.compositionType) && maxArrayLength == null) {
                maxArrayLength = 100;
            }
            const accessor = bufferView.takeFlexibleAccessor({
                compositionType: semanticInfo.compositionType,
                componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float,
                count: count,
                byteStride: alignedByte,
                arrayLength: maxArrayLength,
                byteAlign: 16
            });
            const propertyName = this._getPropertyIndex(semanticInfo);
            if (semanticInfo.soloDatum) {
                const typedArray = accessor.takeOne();
                let map = this.__soloDatumFields.get(materialTypeName);
                if (map == null) {
                    map = new Map();
                    this.__soloDatumFields.set(materialTypeName, map);
                }
                map.set(this._getPropertyIndex(semanticInfo), {
                    info: semanticInfo,
                    value: _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_4__["default"].initWithFloat32Array(semanticInfo.initialValue, semanticInfo.initialValue, typedArray, semanticInfo.compositionType)
                });
            }
            else {
                const properties = this.__accessors.get(materialTypeName);
                properties.set(propertyName, accessor);
            }
        }
        return bufferView;
    }
    /**
     * Registers the material type.
     * @param materialTypeName The type name of the material.
     * @param materialNodes The material nodes to register.
     * @param maxInstancesNumber The maximum number to create the material instances.
     */
    static registerMaterial(materialTypeName, materialNodes, maxInstanceNumber = _core_Config__WEBPACK_IMPORTED_MODULE_9__["default"].maxMaterialInstanceForEachType) {
        if (!Material.__materialTypes.has(materialTypeName)) {
            Material.__materialTypes.set(materialTypeName, materialNodes);
            const materialTid = ++Material.__materialTidCount;
            Material.__materialTids.set(materialTypeName, materialTid);
            Material.__maxInstances.set(materialTypeName, maxInstanceNumber);
            Material.__allocateBufferView(materialTypeName, materialNodes);
            Material.__materialInstanceCountOfType.set(materialTypeName, 0);
            return true;
        }
        else {
            console.info(`${materialTypeName} is already registered.`);
            return false;
        }
    }
    static forceRegisterMaterial(materialTypeName, materialNodes, maxInstanceNumber = _core_Config__WEBPACK_IMPORTED_MODULE_9__["default"].maxMaterialInstanceForEachType) {
        Material.__materialTypes.set(materialTypeName, materialNodes);
        const materialTid = ++Material.__materialTidCount;
        Material.__materialTids.set(materialTypeName, materialTid);
        Material.__maxInstances.set(materialTypeName, maxInstanceNumber);
        Material.__allocateBufferView(materialTypeName, materialNodes);
        Material.__materialInstanceCountOfType.set(materialTypeName, 0);
        return true;
    }
    static getAllMaterials() {
        return Material.__materials;
    }
    setMaterialNodes(materialNodes) {
        this.__materialNodes = materialNodes;
    }
    get materialSID() {
        return this.__materialSid;
    }
    get isSkinning() {
        return this.__materialNodes[0].isSkinning;
    }
    get isMorphing() {
        return this.__materialNodes[0].isMorphing;
    }
    get isLighting() {
        return this.__materialNodes[0].isLighting;
    }
    /**
     * @private
     */
    static _getPropertyIndex(semanticInfo) {
        let propertyIndex = semanticInfo.semantic.index;
        if (semanticInfo.index != null) {
            propertyIndex += semanticInfo.index;
            propertyIndex *= -1;
        }
        return propertyIndex;
    }
    /**
     * @private
     */
    static _getPropertyIndex2(shaderSemantic, index) {
        let propertyIndex = shaderSemantic.index;
        if (index != null) {
            propertyIndex += index;
            propertyIndex *= -1;
        }
        return propertyIndex;
    }
    initialize() {
        let countOfThisType = Material.__materialInstanceCountOfType.get(this.__materialTypeName);
        this.__materialSid = countOfThisType++;
        Material.__materialInstanceCountOfType.set(this.__materialTypeName, countOfThisType);
        this.__materialNodes.forEach((materialNode) => {
            const semanticsInfoArray = materialNode._semanticsInfoArray;
            const accessorMap = Material.__accessors.get(this.__materialTypeName);
            semanticsInfoArray.forEach((semanticsInfo) => {
                const propertyIndex = Material._getPropertyIndex(semanticsInfo);
                this.__fieldsInfo.set(propertyIndex, semanticsInfo);
                if (!semanticsInfo.soloDatum) {
                    const accessor = accessorMap.get(propertyIndex);
                    const typedArray = accessor.takeOne();
                    const shaderVariable = {
                        info: semanticsInfo,
                        value: _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_4__["default"].initWithFloat32Array(semanticsInfo.initialValue, semanticsInfo.initialValue, typedArray, semanticsInfo.compositionType)
                    };
                    this.__fields.set(propertyIndex, shaderVariable);
                    if (!semanticsInfo.isSystem) {
                        this.__fieldsForNonSystem.set(propertyIndex, shaderVariable);
                    }
                }
            });
        });
    }
    setParameter(shaderSemantic, value, index) {
        const propertyIndex = Material._getPropertyIndex2(shaderSemantic, index);
        const info = this.__fieldsInfo.get(propertyIndex);
        if (info != null) {
            let valueObj;
            if (info.soloDatum) {
                valueObj = Material.__soloDatumFields.get(this.__materialTypeName).get(propertyIndex);
            }
            else {
                valueObj = this.__fields.get(propertyIndex);
            }
            _math_MathClassUtil__WEBPACK_IMPORTED_MODULE_4__["default"]._setForce(valueObj.value, value);
        }
    }
    setTextureParameter(shaderSemantic, value) {
        if (this.__fieldsInfo.has(shaderSemantic.index)) {
            const array = this.__fields.get(shaderSemantic.index);
            const shaderVariable = {
                value: [array.value[0], value],
                info: array.info
            };
            this.__fields.set(shaderSemantic.index, shaderVariable);
            if (!array.info.isSystem) {
                this.__fieldsForNonSystem.set(shaderSemantic.index, shaderVariable);
            }
            if (shaderSemantic === _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_2__["ShaderSemantics"].DiffuseColorTexture || shaderSemantic === _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_2__["ShaderSemantics"].BaseColorTexture) {
                if (value.isTransparent) {
                    this.alphaMode = _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_1__["AlphaMode"].Translucent;
                }
            }
        }
    }
    getParameter(shaderSemantic) {
        var _a, _b;
        const info = this.__fieldsInfo.get(shaderSemantic.index);
        if (info != null) {
            if (info.soloDatum) {
                return (_a = Material.__soloDatumFields.get(this.__materialTypeName).get(shaderSemantic.index)) === null || _a === void 0 ? void 0 : _a.value;
            }
            else {
                return (_b = this.__fields.get(shaderSemantic.index)) === null || _b === void 0 ? void 0 : _b.value;
            }
        }
        return void 0;
    }
    setUniformLocations(shaderProgramUid) {
        const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_6__["default"].getWebGLResourceRepository();
        const map = new Map();
        let array = [];
        this.__materialNodes.forEach((materialNode) => {
            const semanticsInfoArray = materialNode._semanticsInfoArray;
            array = array.concat(semanticsInfoArray);
        });
        webglResourceRepository.setupUniformLocations(shaderProgramUid, array);
    }
    setParametersForGPU({ material, shaderProgram, firstTime, args }) {
        this.__materialNodes.forEach((materialNode) => {
            if (materialNode.setParametersForGPU) {
                materialNode.setParametersForGPU({ material, shaderProgram, firstTime, args });
            }
        });
        const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_6__["default"].getWebGLResourceRepository();
        if (args.setUniform) {
            this.__fieldsForNonSystem.forEach((value) => {
                const info = value.info;
                if (firstTime || info.updateInterval !== _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_17__["ShaderVariableUpdateInterval"].FirstTimeOnly) {
                    webglResourceRepository.setUniformValue(shaderProgram, info.semantic.str, firstTime, value.value, info.index);
                }
                else {
                    if (info.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Texture2D || info.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].TextureCube) {
                        webglResourceRepository.bindTexture(info, value.value);
                    }
                }
            });
        }
        else {
            this.__fieldsForNonSystem.forEach((value) => {
                const info = value.info;
                if (info.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Texture2D || info.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].TextureCube) {
                    if (firstTime || info.updateInterval !== _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_17__["ShaderVariableUpdateInterval"].FirstTimeOnly) {
                        webglResourceRepository.setUniformValue(shaderProgram, info.semantic.str, firstTime, value.value, info.index);
                    }
                    else {
                        webglResourceRepository.bindTexture(info, value.value);
                    }
                }
            });
        }
        this.setSoloDatumParametersForGPU({ shaderProgram, firstTime, args });
    }
    setSoloDatumParametersForGPU({ shaderProgram, firstTime, args }) {
        const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_6__["default"].getWebGLResourceRepository();
        const materialTypeName = this.__materialTypeName;
        const map = Material.__soloDatumFields.get(materialTypeName);
        if (map == null)
            return;
        map.forEach((value, key) => {
            const info = value.info;
            if (args.setUniform || info.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Texture2D || info.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].TextureCube) {
                if (!info.isSystem) {
                    if (firstTime || info.updateInterval !== _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_17__["ShaderVariableUpdateInterval"].FirstTimeOnly) {
                        webglResourceRepository.setUniformValue(shaderProgram, info.semantic.str, firstTime, value.value, info.index);
                    }
                    else {
                        webglResourceRepository.bindTexture(info, value.value);
                    }
                }
            }
        });
    }
    __setupGlobalShaderDefinition() {
        var _a, _b, _c;
        let definitions = '';
        const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_6__["default"].getWebGLResourceRepository();
        if ((_a = webglResourceRepository.currentWebGLContextWrapper) === null || _a === void 0 ? void 0 : _a.isWebGL2) {
            definitions += '#version 300 es\n#define GLSL_ES3\n';
        }
        definitions += `#define RN_MATERIAL_TYPE_NAME ${this.__materialTypeName}\n`;
        if (_system_System__WEBPACK_IMPORTED_MODULE_13__["default"].getInstance().processApproach === _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_14__["ProcessApproach"].FastestWebGL1) {
            definitions += '#define RN_IS_FASTEST_MODE\n';
        }
        if ((_b = webglResourceRepository.currentWebGLContextWrapper) === null || _b === void 0 ? void 0 : _b.webgl1ExtSTL) {
            definitions += '#define WEBGL1_EXT_SHADER_TEXTURE_LOD\n';
        }
        if ((_c = webglResourceRepository.currentWebGLContextWrapper) === null || _c === void 0 ? void 0 : _c.webgl1ExtDRV) {
            definitions += '#define WEBGL1_EXT_STANDARD_DERIVATIVES\n';
        }
        if (_core_Config__WEBPACK_IMPORTED_MODULE_9__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_16__["BoneDataType"].Mat4x4) {
            definitions += '#define RN_BONE_DATA_TYPE_MAT4X4\n';
        }
        else if (_core_Config__WEBPACK_IMPORTED_MODULE_9__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_16__["BoneDataType"].Vec4x2) {
            definitions += '#define RN_BONE_DATA_TYPE_VEC4X2\n';
        }
        else if (_core_Config__WEBPACK_IMPORTED_MODULE_9__["default"].boneDataType === _definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_16__["BoneDataType"].Vec4x1) {
            definitions += '#define RN_BONE_DATA_TYPE_VEC4X1\n';
        }
        return definitions;
    }
    createProgramAsSingleOperation(vertexShaderMethodDefinitions_uniform, propertySetter, isWebGL2) {
        const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_6__["default"].getWebGLResourceRepository();
        const materialNode = this.__materialNodes[0];
        const glslShader = materialNode.shader;
        let { vertexPropertiesStr, pixelPropertiesStr } = this._getProperties(propertySetter, isWebGL2);
        let definitions = materialNode.definitions;
        // Shader Construction
        let vertexShader = this.__setupGlobalShaderDefinition();
        let pixelShader = this.__setupGlobalShaderDefinition();
        let vertexShaderBody = '';
        let pixelShaderBody = '';
        if (materialNode.vertexShaderityObject != null) {
            vertexShaderBody = _ShaderityUtility__WEBPACK_IMPORTED_MODULE_15__["default"].getInstance().getVertexShaderBody(materialNode.vertexShaderityObject, { getters: vertexPropertiesStr, definitions: definitions, matricesGetters: vertexShaderMethodDefinitions_uniform });
            pixelShaderBody = _ShaderityUtility__WEBPACK_IMPORTED_MODULE_15__["default"].getInstance().getPixelShaderBody(materialNode.pixelShaderityObject, { getters: pixelPropertiesStr, definitions: definitions });
        }
        else {
            vertexShaderBody = glslShader.getVertexShaderBody({ getters: vertexPropertiesStr, definitions: definitions, matricesGetters: vertexShaderMethodDefinitions_uniform });
            pixelShaderBody = glslShader.getPixelShaderBody({ getters: pixelPropertiesStr, definitions: definitions, materialNode: materialNode });
        }
        vertexShader += vertexShaderBody.replace(/#version\s+300\s+es/, '');
        pixelShader += pixelShaderBody.replace(/#version\s+300\s+es/, '');
        const wholeShaderText = vertexShader + pixelShader;
        // Cache
        let shaderProgramUid = Material.__shaderStringMap.get(wholeShaderText);
        if (shaderProgramUid) {
            this._shaderProgramUid = shaderProgramUid;
            return shaderProgramUid;
        }
        const hash = _misc_DataUtil__WEBPACK_IMPORTED_MODULE_11__["default"].toCRC32(wholeShaderText);
        shaderProgramUid = Material.__shaderHashMap.get(hash);
        if (shaderProgramUid) {
            this._shaderProgramUid = shaderProgramUid;
            return this._shaderProgramUid;
        }
        else {
            let attributeNames;
            let attributeSemantics;
            if (materialNode.vertexShaderityObject != null) {
                const reflection = _ShaderityUtility__WEBPACK_IMPORTED_MODULE_15__["default"].getInstance().getReflection(materialNode.vertexShaderityObject);
                attributeNames = reflection.names;
                attributeSemantics = reflection.semantics;
            }
            else {
                attributeNames = glslShader.attributeNames;
                attributeSemantics = glslShader.attributeSemantics;
            }
            this._shaderProgramUid = webglResourceRepository.createShaderProgram({
                materialTypeName: this.__materialTypeName,
                vertexShaderStr: vertexShader,
                fragmentShaderStr: pixelShader,
                attributeNames: attributeNames,
                attributeSemantics: attributeSemantics
            });
            Material.__shaderStringMap.set(wholeShaderText, this._shaderProgramUid);
            Material.__shaderHashMap.set(hash, this._shaderProgramUid);
            return this._shaderProgramUid;
        }
    }
    /**
     * @private
     * @param propertySetter
     */
    _getProperties(propertySetter, isWebGL2) {
        let vertexPropertiesStr = '';
        let pixelPropertiesStr = '';
        this.__fieldsInfo.forEach((value, propertyIndex) => {
            const info = this.__fieldsInfo.get(propertyIndex);
            if (info.stage === _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_10__["ShaderType"].VertexShader || info.stage === _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_10__["ShaderType"].VertexAndPixelShader) {
                vertexPropertiesStr += propertySetter(this.__materialTypeName, info, propertyIndex, false, isWebGL2);
            }
            if (info.stage === _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_10__["ShaderType"].PixelShader || info.stage === _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_10__["ShaderType"].VertexAndPixelShader) {
                pixelPropertiesStr += propertySetter(this.__materialTypeName, info, propertyIndex, false, isWebGL2);
            }
        });
        const globalDataRepository = _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_12__["default"].getInstance();
        [vertexPropertiesStr, pixelPropertiesStr] = globalDataRepository.addPropertiesStr(vertexPropertiesStr, pixelPropertiesStr, propertySetter, isWebGL2);
        return { vertexPropertiesStr, pixelPropertiesStr };
    }
    createProgram(vertexShaderMethodDefinitions_uniform, propertySetter, isWebGL2) {
        return this.createProgramAsSingleOperation(vertexShaderMethodDefinitions_uniform, propertySetter, isWebGL2);
    }
    isBlend() {
        if (this.alphaMode === _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_1__["AlphaMode"].Translucent ||
            this.alphaMode === _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_1__["AlphaMode"].Additive) {
            return true;
        }
        else {
            return false;
        }
    }
    static getLocationOffsetOfMemberOfMaterial(materialTypeName, propertyIndex) {
        const material = Material.__instancesByTypes.get(materialTypeName);
        const info = material.__fieldsInfo.get(propertyIndex);
        if (info.soloDatum) {
            const value = Material.__soloDatumFields.get(material.__materialTypeName).get(propertyIndex);
            return value.value.v.byteOffset / 4 / 4;
        }
        else {
            const properties = this.__accessors.get(materialTypeName);
            const accessor = properties.get(propertyIndex);
            return accessor.byteOffsetInBuffer / 4 / 4;
        }
    }
    static getAccessorOfMemberOfMaterial(materialTypeName, propertyIndex) {
        const material = Material.__instancesByTypes.get(materialTypeName);
        const info = material.__fieldsInfo.get(propertyIndex);
        if (info.soloDatum) {
            return void 0;
        }
        else {
            const properties = this.__accessors.get(materialTypeName);
            const accessor = properties.get(propertyIndex);
            return accessor;
        }
    }
    get alphaMode() {
        return this.__alphaMode;
    }
    set alphaMode(mode) {
        this.__alphaMode = mode;
    }
    /**
     * Change the blendEquations
     * This method works only if this alphaMode is the translucent
     * @param blendEquationMode the argument of gl.blendEquation of the first argument of gl.blendEquationSeparate such as gl.FUNC_ADD
     * @param blendEquationModeAlpha the second argument of gl.blendEquationSeparate
     */
    setBlendEquationMode(blendEquationMode, blendEquationModeAlpha) {
        this.__blendEquationMode = blendEquationMode;
        this.__blendEquationModeAlpha = blendEquationModeAlpha !== null && blendEquationModeAlpha !== void 0 ? blendEquationModeAlpha : blendEquationMode;
    }
    /**
     * Change the blendFuncSeparateFactors
     * This method works only if this alphaMode is the translucent
     */
    setBlendFuncSeparateFactor(blendFuncSrcFactor, blendFuncDstFactor, blendFuncAlphaSrcFactor, blendFuncAlphaDstFactor) {
        this.__blendFuncSrcFactor = blendFuncSrcFactor;
        this.__blendFuncDstFactor = blendFuncDstFactor;
        this.__blendFuncAlphaSrcFactor = blendFuncAlphaSrcFactor;
        this.__blendFuncAlphaDstFactor = blendFuncAlphaDstFactor;
    }
    /**
     * Change the blendFuncFactors
     * This method works only if this alphaMode is the translucent
     */
    setBlendFuncFactor(blendFuncSrcFactor, blendFuncDstFactor) {
        this.__blendFuncSrcFactor = blendFuncSrcFactor;
        this.__blendFuncDstFactor = blendFuncDstFactor;
        this.__blendFuncAlphaSrcFactor = blendFuncSrcFactor;
        this.__blendFuncAlphaDstFactor = blendFuncDstFactor;
    }
    get blendEquationMode() {
        return this.__blendEquationMode;
    }
    get blendEquationModeAlpha() {
        return this.__blendEquationModeAlpha;
    }
    get blendFuncSrcFactor() {
        return this.__blendFuncSrcFactor;
    }
    get blendFuncDstFactor() {
        return this.__blendFuncDstFactor;
    }
    get blendFuncAlphaSrcFactor() {
        return this.__blendFuncAlphaSrcFactor;
    }
    get blendFuncAlphaDstFactor() {
        return this.__blendFuncAlphaDstFactor;
    }
    isEmptyMaterial() {
        if (this.__materialNodes.length === 0) {
            return true;
        }
        else {
            return false;
        }
    }
    getShaderSemanticInfoFromName(name) {
        for (let materialNode of this.__materialNodes) {
            return materialNode.getShaderSemanticInfoFromName(name);
        }
        return void 0;
    }
}
Material.__soloDatumFields = new Map();
Material.__shaderHashMap = new Map();
Material.__shaderStringMap = new Map();
Material.__materials = [];
Material.__instancesByTypes = new Map();
Material.__materialTidCount = -1;
Material.__materialTids = new Map();
Material.__materialInstanceCountOfType = new Map();
Material.__materialTypes = new Map();
Material.__maxInstances = new Map();
Material.__bufferViews = new Map();
Material.__accessors = new Map();


/***/ }),

/***/ "./src/foundation/materials/core/ShaderGraphResolver.ts":
/*!**************************************************************!*\
  !*** ./src/foundation/materials/core/ShaderGraphResolver.ts ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShaderGraphResolver; });
/* harmony import */ var _AbstractShaderNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaders_GLSLShader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../webgl/shaders/GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");
/* harmony import */ var _webgl_shaderity_shaders_common_mainPrerequisites_glsl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/common/mainPrerequisites.glsl */ "./src/webgl/shaderity_shaders/common/mainPrerequisites.glsl");
/* harmony import */ var _webgl_shaderity_shaders_common_prerequisites_glsl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/common/prerequisites.glsl */ "./src/webgl/shaderity_shaders/common/prerequisites.glsl");









class ShaderGraphResolver {
    static createVertexShaderCode(vertexNodes) {
        var _a;
        const shaderNodes = vertexNodes.concat();
        // Find Start Node
        let firstShaderNode = this.__findBeginNode(shaderNodes);
        // Topological Sorting
        const sortedShaderNodes = this.__sortTopologically(firstShaderNode, shaderNodes);
        // Add additional functions by system
        let vertexShaderPrerequisites = '';
        const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getWebGLResourceRepository();
        let in_ = 'attribute';
        if ((_a = webglResourceRepository.currentWebGLContextWrapper) === null || _a === void 0 ? void 0 : _a.isWebGL2) {
            in_ = 'in';
        }
        vertexShaderPrerequisites += `
#version 300 es
precision highp float;
precision highp int;
${_webgl_shaderity_shaders_common_prerequisites_glsl__WEBPACK_IMPORTED_MODULE_8__["default"].code}

    ${in_} float a_instanceID;\n`;
        vertexShaderPrerequisites += `
uniform bool u_vertexAttributesExistenceArray[${_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_2__["VertexAttribute"].AttributeTypeNumber}];
`;
        vertexShaderPrerequisites += '/* shaderity: @{matricesGetters} */';
        vertexShaderPrerequisites += '/* shaderity: @{getters} */';
        let shaderBody = '';
        // function definitions
        shaderBody += ShaderGraphResolver.getFunctionDefinition(sortedShaderNodes, _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_3__["ShaderType"].VertexShader);
        // main process
        shaderBody += ShaderGraphResolver.__constructShaderWithNodes(sortedShaderNodes);
        const shader = vertexShaderPrerequisites + shaderBody;
        return { shader, shaderBody };
    }
    static createPixelShaderCode(pixelNodes) {
        const shaderNodes = pixelNodes.concat();
        // Find Start Node
        let firstShaderNode = this.__findBeginNode(shaderNodes);
        // Topological Sorting
        const sortedShaderNodes = this.__sortTopologically(firstShaderNode, shaderNodes);
        // Add additional functions by system
        let pixelShaderPrerequisites = '';
        pixelShaderPrerequisites += `
#version 300 es
precision highp float;
precision highp int;
${_webgl_shaderity_shaders_common_prerequisites_glsl__WEBPACK_IMPORTED_MODULE_8__["default"].code}
`;
        pixelShaderPrerequisites += '/* shaderity: @{getters} */';
        let shaderBody = '';
        // function definitions
        shaderBody += ShaderGraphResolver.getFunctionDefinition(sortedShaderNodes, _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_3__["ShaderType"].PixelShader);
        // main process
        shaderBody += ShaderGraphResolver.__constructShaderWithNodes(sortedShaderNodes);
        const shader = pixelShaderPrerequisites + shaderBody;
        return { shader, shaderBody };
    }
    static __findBeginNode(shaderNodes) {
        let firstShaderNode;
        for (let i = 0; i < shaderNodes.length; i++) {
            const shaderNode = shaderNodes[i];
            if (shaderNode.inputConnections.length === 0) {
                firstShaderNode = shaderNode;
            }
        }
        return firstShaderNode;
    }
    static __sortTopologically(firstShaderNode, shaderNodes) {
        const ignoredInputUids = [firstShaderNode.shaderNodeUid];
        const sortedNodeArray = [firstShaderNode];
        // remove node which don't have inputConnections (except first node)
        shaderNodes.splice(shaderNodes.indexOf(firstShaderNode), 1);
        do {
            let shaderNodeWhichHasNoInputs;
            shaderNodes.forEach((shaderNode) => {
                let inputCount = 0;
                for (let inputConnection of shaderNode.inputConnections) {
                    if (ignoredInputUids.indexOf(inputConnection.shaderNodeUid) === -1) {
                        inputCount++;
                    }
                }
                if (inputCount === 0) {
                    shaderNodeWhichHasNoInputs = shaderNode;
                }
            });
            sortedNodeArray.push(shaderNodeWhichHasNoInputs);
            ignoredInputUids.push(shaderNodeWhichHasNoInputs.shaderNodeUid);
            shaderNodes.splice(shaderNodes.indexOf(shaderNodeWhichHasNoInputs), 1);
        } while (shaderNodes.length !== 0);
        return sortedNodeArray;
    }
    static getFunctionDefinition(shaderNodes, shaderType) {
        let shaderText = '';
        const existVertexFunctions = [];
        for (let i = 0; i < shaderNodes.length; i++) {
            const materialNode = shaderNodes[i];
            if (existVertexFunctions.indexOf(materialNode.shaderFunctionName) !== -1) {
                continue;
            }
            if (materialNode.shaderCode) {
                shaderText += materialNode.shaderCode;
            }
            else {
                if (shaderType === _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_3__["ShaderType"].VertexShader) {
                    shaderText += materialNode.shader.vertexShaderDefinitions;
                }
                else {
                    shaderText += materialNode.shader.pixelShaderDefinitions;
                }
            }
            existVertexFunctions.push(materialNode.shaderFunctionName);
        }
        return shaderText;
    }
    static __constructShaderWithNodes(materialNodes) {
        let shaderBody = '';
        const isAnyTypeInput = function (input) {
            return input.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Unknown ||
                input.componentType === _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Unknown;
        };
        shaderBody += _webgl_shaders_GLSLShader__WEBPACK_IMPORTED_MODULE_6__["default"].glslMainBegin;
        shaderBody += _webgl_shaderity_shaders_common_mainPrerequisites_glsl__WEBPACK_IMPORTED_MODULE_7__["default"].code;
        const varInputNames = [];
        const varOutputNames = [];
        const existingInputs = [];
        const existingOutputsVarName = new Map();
        const existingOutputs = [];
        for (let i = 1; i < materialNodes.length; i++) {
            const materialNode = materialNodes[i];
            if (varInputNames[i] == null) {
                varInputNames[i] = [];
            }
            if (i - 1 >= 0) {
                if (varOutputNames[i - 1] == null) {
                    varOutputNames[i - 1] = [];
                }
            }
            const inputConnections = materialNode.inputConnections;
            for (let j = 0; j < inputConnections.length; j++) {
                const inputConnection = inputConnections[j];
                const inputNode = _AbstractShaderNode__WEBPACK_IMPORTED_MODULE_0__["default"].shaderNodes[inputConnection.shaderNodeUid];
                if (isAnyTypeInput(materialNode.getInputs()[j])) {
                    continue;
                }
                const outputSocketOfPrev = inputNode.getOutput(inputConnection.outputNameOfPrev);
                const inputSocketOfThis = materialNode.getInput(inputConnection.inputNameOfThis);
                let varName = `${outputSocketOfPrev.name}_${inputConnection.shaderNodeUid}_to_${materialNode.shaderNodeUid}`;
                if (existingInputs.indexOf(inputNode.shaderNodeUid) === -1) {
                    const glslTypeStr = inputSocketOfThis.compositionType.getGlslStr(inputSocketOfThis.componentType);
                    const glslInitialValue = inputSocketOfThis.compositionType.getGlslInitialValue(inputSocketOfThis.componentType);
                    const rowStr = `${glslTypeStr} ${varName} = ${glslInitialValue};\n`;
                    shaderBody += rowStr;
                }
                const existVarName = existingOutputsVarName.get(inputNode.shaderNodeUid);
                if (existVarName) {
                    varName = existVarName;
                }
                varInputNames[i].push(varName);
                existingInputs.push(inputConnection.shaderNodeUid);
            }
            for (let j = i; j < materialNodes.length; j++) {
                const targetMaterialNode = materialNodes[j];
                const prevMaterialNodeInner = materialNodes[i - 1];
                const targetNodeInputConnections = targetMaterialNode.inputConnections;
                for (let k = 0; k < targetNodeInputConnections.length; k++) {
                    const inputConnection = targetNodeInputConnections[k];
                    if (prevMaterialNodeInner != null && inputConnection.shaderNodeUid !== prevMaterialNodeInner.shaderNodeUid) {
                        continue;
                    }
                    const inputNode = _AbstractShaderNode__WEBPACK_IMPORTED_MODULE_0__["default"].shaderNodes[inputConnection.shaderNodeUid];
                    if (!isAnyTypeInput(targetMaterialNode.getInputs()[k])) {
                        if (existingOutputs.indexOf(inputNode.shaderNodeUid) === -1) {
                            const outputSocketOfPrev = inputNode.getOutput(inputConnection.outputNameOfPrev);
                            const varName = `${outputSocketOfPrev.name}_${inputConnection.shaderNodeUid}_to_${targetMaterialNode.shaderNodeUid}`;
                            if (i - 1 >= 0) {
                                varOutputNames[i - 1].push(varName);
                            }
                            existingOutputsVarName.set(inputConnection.shaderNodeUid, varName);
                        }
                        existingOutputs.push(inputConnection.shaderNodeUid);
                    }
                }
            }
        }
        let ifCondition = '';
        for (let i = 0; i < materialNodes.length; i++) {
            const materialNode = materialNodes[i];
            const functionName = materialNode.shaderFunctionName;
            if (varInputNames[i] == null) {
                varInputNames[i] = [];
            }
            if (varOutputNames[i] == null) {
                varOutputNames[i] = [];
            }
            let rowStr = '';
            if (functionName === 'ifStatement') {
                ifCondition = varInputNames[i][0];
            }
            else {
                if (functionName.match(/^blockBegin_/)) {
                    rowStr += `if (${ifCondition}) {\n`;
                    ifCondition = '';
                }
                if (materialNode.getInputs().length != varInputNames[i].length ||
                    materialNode.getOutputs().length != varOutputNames[i].length) {
                    continue;
                }
                const varNames = varInputNames[i].concat(varOutputNames[i]);
                if (varNames.length > 0) {
                    // Call node functions
                    rowStr += `${functionName}(`;
                    for (let k = 0; k < varNames.length; k++) {
                        const varName = varNames[k];
                        if (varName == null) {
                            continue;
                        }
                        if (k !== 0) {
                            rowStr += ', ';
                        }
                        rowStr += varNames[k];
                    }
                    rowStr += ');\n';
                }
                if (functionName.match(/^blockEnd_/)) {
                    rowStr += `}\n`;
                }
            }
            shaderBody += rowStr;
        }
        shaderBody += _webgl_shaders_GLSLShader__WEBPACK_IMPORTED_MODULE_6__["default"].glslMainEnd;
        return shaderBody;
    }
}


/***/ }),

/***/ "./src/foundation/materials/core/ShaderityUtility.ts":
/*!***********************************************************!*\
  !*** ./src/foundation/materials/core/ShaderityUtility.ts ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShaderityUtility; });
/* harmony import */ var shaderity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shaderity */ "./node_modules/shaderity/dist/index.js");
/* harmony import */ var shaderity__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shaderity__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _webgl_WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../webgl/WebGLResourceRepository */ "./src/webgl/WebGLResourceRepository.ts");
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _math_MutableVector2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../math/MutableVector2 */ "./src/foundation/math/MutableVector2.ts");
/* harmony import */ var _math_MutableVector3__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");
/* harmony import */ var _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../math/MutableVector4 */ "./src/foundation/math/MutableVector4.ts");
/* harmony import */ var _math_MutableScalar__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../math/MutableScalar */ "./src/foundation/math/MutableScalar.ts");
/* harmony import */ var _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../math/MutableMatrix33 */ "./src/foundation/math/MutableMatrix33.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");
/* harmony import */ var _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");
















class ShaderityUtility {
    constructor() {
        this.__shaderity = shaderity__WEBPACK_IMPORTED_MODULE_0___default.a.getInstance();
        this.__webglResourceRepository = _webgl_WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getInstance();
        const attributeSemanticsMap = new Map();
        attributeSemanticsMap.set('instanceid', 'INSTANCE');
        attributeSemanticsMap.set('barycentriccoord', 'BARY_CENTRIC_COORD');
        this.__shaderity.addAttributeSemanticsMap(attributeSemanticsMap);
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new ShaderityUtility();
        }
        return this.__instance;
    }
    getVertexShaderBody(shaderityObject, args) {
        var _a, _b;
        const obj = this.__shaderity.fillTemplate(shaderityObject, {
            definitions: (typeof args.definitions !== 'undefined') ? args.definitions : '',
            matricesGetters: (typeof args.matricesGetters !== 'undefined') ? args.matricesGetters : '',
            getters: (typeof args.getters !== 'undefined') ? args.getters : '',
            WellKnownComponentTIDs: _components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_3__["WellKnownComponentTIDs"]
        });
        const isWebGL2 = (_b = (_a = this.__webglResourceRepository) === null || _a === void 0 ? void 0 : _a.currentWebGLContextWrapper) === null || _b === void 0 ? void 0 : _b.isWebGL2;
        const code = this.__shaderity.transformTo(isWebGL2 ? 'WebGL2' : 'WebGL1', obj).code;
        return code;
    }
    getPixelShaderBody(shaderityObject, args) {
        var _a, _b;
        const obj = this.__shaderity.fillTemplate(shaderityObject, {
            definitions: (typeof args.definitions !== 'undefined') ? args.definitions : '',
            getters: (typeof args.getters !== 'undefined') ? args.getters : '',
            Config: _core_Config__WEBPACK_IMPORTED_MODULE_5__["default"],
            WellKnownComponentTIDs: _components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_3__["WellKnownComponentTIDs"]
        });
        const isWebGL2 = (_b = (_a = this.__webglResourceRepository) === null || _a === void 0 ? void 0 : _a.currentWebGLContextWrapper) === null || _b === void 0 ? void 0 : _b.isWebGL2;
        const code = this.__shaderity.transformTo(isWebGL2 ? 'WebGL2' : 'WebGL1', obj).code;
        return code;
    }
    getReflection(shaderityObject) {
        const reflection = this.__shaderity.reflect(shaderityObject);
        const reflectionSoA = {};
        reflectionSoA.names = reflection.attributesNames;
        reflectionSoA.semantics = reflection.attributesSemantics.map((semantic) => { return _definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].fromString(semantic); });
        ;
        reflectionSoA.compositions = reflection.attributesTypes.map((type) => { return _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].fromGlslString(type); });
        ;
        reflectionSoA.components = reflection.attributesTypes.map((type) => { return _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].fromGlslString(type); });
        ;
        return reflectionSoA;
    }
    copyShaderityObject(obj) {
        const copiedObj = {
            code: obj.code,
            shaderStage: obj.shaderStage
        };
        return copiedObj;
    }
    getShaderDataRefection(shaderityObject, existingShaderInfoMap) {
        const copiedShaderityObject = this.copyShaderityObject(shaderityObject);
        const splitCode = shaderityObject.code.split(/\r\n|\n/);
        const uniformOmittedShaderRows = [];
        const shaderSemanticsInfoArray = [];
        for (let row of splitCode) {
            const reg = /^(?![\/])[\t ]*uniform[\t ]+(\w+)[\t ]+(\w+);[\t ]*(\/\/)*[\t ]*(.*)/;
            const match = row.match(reg);
            if (match) {
                const shaderSemanticsInfo = {};
                const type = match[1];
                let variableName = match[2];
                const u_prefixedName = variableName.match(/u_(\w+)/);
                if (u_prefixedName) {
                    variableName = u_prefixedName[1];
                    shaderSemanticsInfo.none_u_prefix = false;
                }
                else {
                    shaderSemanticsInfo.none_u_prefix = true;
                }
                const info = match[4];
                const skipProcess = info.match(/skipProcess[\t ]*=[\t ]*(\w+)[,\t ]*/);
                if (skipProcess) {
                    if (skipProcess[1] == 'true') {
                        uniformOmittedShaderRows.push(row);
                        continue;
                    }
                }
                const systemSemantic = _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemantics"].fromStringCaseSensitively(variableName);
                shaderSemanticsInfo.semantic = systemSemantic;
                if (systemSemantic == null) {
                    if (existingShaderInfoMap) {
                        const semanticInfo = existingShaderInfoMap.get(variableName);
                        if (semanticInfo != null) {
                            shaderSemanticsInfo.semantic = semanticInfo.semantic;
                        }
                        else {
                            const semantic = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemanticsClass"]({ str: variableName });
                            shaderSemanticsInfo.semantic = semantic;
                        }
                    }
                    else {
                        const semantic = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemanticsClass"]({ str: variableName });
                        shaderSemanticsInfo.semantic = semantic;
                    }
                }
                shaderSemanticsInfo.componentType = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].fromGlslString(type);
                shaderSemanticsInfo.compositionType = _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].fromGlslString(type);
                const soloDatum = info.match(/soloDatum[\t ]*=[\t ]*(\w+)[,\t ]*/);
                let bool = false;
                if (soloDatum) {
                    const soloDatumText = soloDatum[1];
                    if (soloDatumText === 'true') {
                        bool = true;
                    }
                }
                shaderSemanticsInfo.soloDatum = bool;
                const isSystem = info.match(/isSystem[\t ]*=[\t ]*(\w+)[,\t ]*/);
                let isSystemFlg = false;
                if (isSystem) {
                    const isSystemText = isSystem[1];
                    if (isSystemText === 'true') {
                        isSystemFlg = true;
                    }
                }
                shaderSemanticsInfo.isSystem = isSystemFlg;
                const updateInterval = info.match(/updateInterval[\t ]*=[\t ]*(\w+)[,\t ]*/);
                let updateIntervalObj = _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_15__["ShaderVariableUpdateInterval"].FirstTimeOnly;
                if (updateInterval) {
                    const updateIntervalText = updateInterval[1];
                    if (updateIntervalText.toLowerCase() === 'everytime') {
                        updateIntervalObj = _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_15__["ShaderVariableUpdateInterval"].EveryTime;
                    }
                }
                shaderSemanticsInfo.updateInterval = updateIntervalObj;
                const initialValue = info.match(/initialValue[\t ]*=[\t ]*(.+)[,\t ]*/);
                if (initialValue) {
                    const initialValueText = initialValue[1];
                    const tuple = initialValueText.match(/\(([\d\w., ]+)\)/);
                    const checkCompositionNumber = (expected) => {
                        if (shaderSemanticsInfo.compositionType !== expected) {
                            console.error('component number of initialValue is invalid!');
                        }
                    };
                    if (tuple) {
                        const text = tuple[1];
                        const split = text.split(',');
                        switch (split.length) {
                            case 2:
                                if (shaderSemanticsInfo.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Texture2D) {
                                    const color = split[1].charAt(0).toUpperCase() + split[1].slice(1);
                                    shaderSemanticsInfo.initialValue = [parseInt(split[0]), _AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_14__["default"][`dummy${color}Texture`]];
                                }
                                else if (shaderSemanticsInfo.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].TextureCube) {
                                    const color = split[1].charAt(0).toUpperCase() + split[1].slice(1);
                                    shaderSemanticsInfo.initialValue = [parseInt(split[0]), _AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_14__["default"][`dummy${color}CubeTexture`]];
                                }
                                else {
                                    checkCompositionNumber(_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec2);
                                    shaderSemanticsInfo.initialValue = new _math_MutableVector2__WEBPACK_IMPORTED_MODULE_8__["default"](parseFloat(split[0]), parseFloat(split[1]));
                                }
                                break;
                            case 3:
                                checkCompositionNumber(_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec3);
                                shaderSemanticsInfo.initialValue = new _math_MutableVector3__WEBPACK_IMPORTED_MODULE_9__["default"](parseFloat(split[0]), parseFloat(split[1]), parseFloat(split[2]));
                                break;
                            case 4:
                                checkCompositionNumber(_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec4);
                                shaderSemanticsInfo.initialValue = new _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__["default"](parseFloat(split[0]), parseFloat(split[1]), parseFloat(split[2]), parseFloat(split[3]));
                                break;
                            case 9:
                                checkCompositionNumber(_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Mat3);
                                shaderSemanticsInfo.initialValue = new _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_12__["default"](parseFloat(split[0]), parseFloat(split[1]), parseFloat(split[2]), parseFloat(split[3]), parseFloat(split[4]), parseFloat(split[5]), parseFloat(split[6]), parseFloat(split[7]), parseFloat(split[8]));
                                break;
                            case 16:
                                checkCompositionNumber(_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Mat4);
                                shaderSemanticsInfo.initialValue = new _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_13__["default"](parseFloat(split[0]), parseFloat(split[1]), parseFloat(split[2]), parseFloat(split[3]), parseFloat(split[4]), parseFloat(split[5]), parseFloat(split[6]), parseFloat(split[7]), parseFloat(split[8]), parseFloat(split[9]), parseFloat(split[10]), parseFloat(split[11]), parseFloat(split[12]), parseFloat(split[13]), parseFloat(split[14]), parseFloat(split[15]));
                                break;
                            default:
                                console.error('Invalid format');
                        }
                    }
                    else {
                        checkCompositionNumber(_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar);
                        shaderSemanticsInfo.initialValue = new _math_MutableScalar__WEBPACK_IMPORTED_MODULE_11__["default"](parseFloat(initialValueText));
                    }
                }
                else {
                    if (shaderSemanticsInfo.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar) {
                        shaderSemanticsInfo.initialValue = new _math_MutableScalar__WEBPACK_IMPORTED_MODULE_11__["default"](0);
                    }
                    else if (shaderSemanticsInfo.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec2) {
                        shaderSemanticsInfo.initialValue = _math_MutableVector2__WEBPACK_IMPORTED_MODULE_8__["default"].zero();
                    }
                    else if (shaderSemanticsInfo.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec3) {
                        shaderSemanticsInfo.initialValue = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_9__["default"].zero();
                    }
                    else if (shaderSemanticsInfo.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec4) {
                        shaderSemanticsInfo.initialValue = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_10__["default"].zero();
                    }
                    else if (shaderSemanticsInfo.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Mat3) {
                        shaderSemanticsInfo.initialValue = _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_12__["default"].identity();
                    }
                    else if (shaderSemanticsInfo.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Mat4) {
                        shaderSemanticsInfo.initialValue = _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_13__["default"].identity();
                    }
                    else if (shaderSemanticsInfo.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Texture2D) {
                        shaderSemanticsInfo.initialValue = [0, _AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_14__["default"].dummyWhiteTexture];
                    }
                    else if (shaderSemanticsInfo.compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].TextureCube) {
                        shaderSemanticsInfo.initialValue = [0, _AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_14__["default"].dummyBlackTexture];
                    }
                }
                shaderSemanticsInfoArray.push(shaderSemanticsInfo);
            }
            else {
                uniformOmittedShaderRows.push(row);
            }
        }
        copiedShaderityObject.code = uniformOmittedShaderRows.join('\n');
        return {
            shaderSemanticsInfoArray: shaderSemanticsInfoArray,
            shaderityObject: copiedShaderityObject
        };
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/AddShaderNode.ts":
/*!*********************************************************!*\
  !*** ./src/foundation/materials/nodes/AddShaderNode.ts ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AddShaderNode; });
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaderity_shaders_nodes_Add_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/Add.glsl */ "./src/webgl/shaderity_shaders/nodes/Add.glsl");



class AddShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(compositionType, componentType) {
        super('add', _webgl_shaderity_shaders_nodes_Add_glsl__WEBPACK_IMPORTED_MODULE_2__["default"].code);
        this.__inputs.push({
            compositionType: compositionType,
            componentType: componentType,
            name: 'lhs',
        });
        this.__inputs.push({
            compositionType: compositionType,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'rhs',
        });
        this.__outputs.push({
            compositionType: compositionType,
            componentType: componentType,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/AttributeNormalShaderNode.ts":
/*!*********************************************************************!*\
  !*** ./src/foundation/materials/nodes/AttributeNormalShaderNode.ts ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AttributePositionShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaderity_shaders_nodes_AttributeNormal_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/AttributeNormal.vert */ "./src/webgl/shaderity_shaders/nodes/AttributeNormal.vert");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");




class AttributePositionShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super('attributeNormal', _webgl_shaderity_shaders_nodes_AttributeNormal_vert__WEBPACK_IMPORTED_MODULE_2__["default"].code);
        this.__outputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Vec3,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/AttributePositionShaderNode.ts":
/*!***********************************************************************!*\
  !*** ./src/foundation/materials/nodes/AttributePositionShaderNode.ts ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AttributePositionShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaderity_shaders_nodes_AttributePosition_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/AttributePosition.vert */ "./src/webgl/shaderity_shaders/nodes/AttributePosition.vert");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");




class AttributePositionShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super('attributePosition', _webgl_shaderity_shaders_nodes_AttributePosition_vert__WEBPACK_IMPORTED_MODULE_2__["default"].code);
        this.__outputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Vec4,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/BlockBeginShaderNode.ts":
/*!****************************************************************!*\
  !*** ./src/foundation/materials/nodes/BlockBeginShaderNode.ts ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BlockBeginShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaders_nodes_BlockBeginShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaders/nodes/BlockBeginShader */ "./src/webgl/shaders/nodes/BlockBeginShader.ts");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");




class BlockBeginShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super('blockBegin');
        this.__valueInputs = [];
        this.__valueOutputs = [];
        this.__shaderFunctionName += '_' + this.__shaderNodeUid;
        this.__shader = new _webgl_shaders_nodes_BlockBeginShader__WEBPACK_IMPORTED_MODULE_2__["default"](this.__shaderFunctionName, this.__valueInputs, this.__valueOutputs);
        this.__inputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Scalar,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Bool,
            name: 'blockStart',
        });
    }
    addInputAndOutput(compositionType, componentType) {
        const input = {
            compositionType: compositionType,
            componentType: componentType,
            name: `value_${this.__valueInputs.length}`,
        };
        const output = {
            compositionType: compositionType,
            componentType: componentType,
            name: `outValue_${this.__valueOutputs.length}`,
        };
        this.__inputs.push(input);
        this.__outputs.push(output);
        this.__valueInputs.push(input);
        this.__valueOutputs.push(output);
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/BlockEndShaderNode.ts":
/*!**************************************************************!*\
  !*** ./src/foundation/materials/nodes/BlockEndShaderNode.ts ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BlockEndShaderNode; });
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");
/* harmony import */ var _webgl_shaders_nodes_BlockEndShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../webgl/shaders/nodes/BlockEndShader */ "./src/webgl/shaders/nodes/BlockEndShader.ts");


class BlockEndShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super('blockEnd');
        this.__shaderFunctionName += '_' + this.__shaderNodeUid;
        this.__shader = new _webgl_shaders_nodes_BlockEndShader__WEBPACK_IMPORTED_MODULE_1__["default"](this.__shaderFunctionName, this.__inputs, this.__outputs);
    }
    addInputAndOutput(compositionType, componentType) {
        const input = {
            compositionType: compositionType,
            componentType: componentType,
            name: `value_${this.__inputs.length}`,
        };
        const output = {
            compositionType: compositionType,
            componentType: componentType,
            name: `outValue_${this.__outputs.length}`,
        };
        this.__inputs.push(input);
        this.__outputs.push(output);
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/ConstantVariableShaderNode.ts":
/*!**********************************************************************!*\
  !*** ./src/foundation/materials/nodes/ConstantVariableShaderNode.ts ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ConstantVariableShaderNode; });
/* harmony import */ var _webgl_shaders_nodes_ConstantVariableShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../webgl/shaders/nodes/ConstantVariableShader */ "./src/webgl/shaders/nodes/ConstantVariableShader.ts");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");


class ConstantVariableShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(compositionType, componentType) {
        super('constantVariable', undefined, undefined);
        this.__shaderFunctionName += '_' + this.__shaderNodeUid;
        this.__shader = new _webgl_shaders_nodes_ConstantVariableShader__WEBPACK_IMPORTED_MODULE_0__["default"](this.__shaderFunctionName, compositionType, componentType);
        this.__outputs.push({
            compositionType: compositionType,
            componentType: componentType,
            name: 'outValue',
        });
    }
    setDefaultInputValue(inputName, value) {
        if (inputName === 'value') {
            this.__shader.setConstantValue(value);
        }
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/DotProductShaderNode.ts":
/*!****************************************************************!*\
  !*** ./src/foundation/materials/nodes/DotProductShaderNode.ts ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DotProductShaderNode; });
/* harmony import */ var _webgl_shaderity_shaders_nodes_DotProduct_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/DotProduct.glsl */ "./src/webgl/shaderity_shaders/nodes/DotProduct.glsl");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");




class DotProductShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(compositionType, componentType) {
        super('dotProduct', _webgl_shaderity_shaders_nodes_DotProduct_glsl__WEBPACK_IMPORTED_MODULE_0__["default"].code);
        this.__inputs.push({
            compositionType: compositionType,
            componentType: componentType,
            name: 'lhs',
        });
        this.__inputs.push({
            compositionType: compositionType,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float,
            name: 'rhs',
        });
        this.__outputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar,
            componentType: componentType,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/GreaterShaderNode.ts":
/*!*************************************************************!*\
  !*** ./src/foundation/materials/nodes/GreaterShaderNode.ts ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GreaterShaderNode; });
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaderity_shaders_nodes_Greater_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/Greater.glsl */ "./src/webgl/shaderity_shaders/nodes/Greater.glsl");




class GreaterShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(compositionType, componentType) {
        super('greater', _webgl_shaderity_shaders_nodes_Greater_glsl__WEBPACK_IMPORTED_MODULE_3__["default"].code);
        this.__inputs.push({
            compositionType: compositionType,
            componentType: componentType,
            name: 'lhs',
        });
        this.__inputs.push({
            compositionType: compositionType,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_2__["ComponentType"].Float,
            name: 'rhs',
        });
        this.__outputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Scalar,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_2__["ComponentType"].Bool,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/IfStatementShaderNode.ts":
/*!*****************************************************************!*\
  !*** ./src/foundation/materials/nodes/IfStatementShaderNode.ts ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IfStatementShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaders_nodes_IfStatementShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaders/nodes/IfStatementShader */ "./src/webgl/shaders/nodes/IfStatementShader.ts");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");




class IfStatementShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super('ifStatement', undefined, new _webgl_shaders_nodes_IfStatementShader__WEBPACK_IMPORTED_MODULE_2__["default"]());
        this.__inputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Scalar,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Bool,
            name: 'condition',
        });
        this.__outputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Unknown,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Unknown,
            name: 'ifStart',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/MultiplyShaderNode.ts":
/*!**************************************************************!*\
  !*** ./src/foundation/materials/nodes/MultiplyShaderNode.ts ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MultiplyShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _webgl_shaderity_shaders_nodes_Multiply_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/Multiply.glsl */ "./src/webgl/shaderity_shaders/nodes/Multiply.glsl");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");



class MultiplyShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(lhsCompositionType, lhsComponentType, rhsCompositionType, rhsComponentType) {
        super('multiply', _webgl_shaderity_shaders_nodes_Multiply_glsl__WEBPACK_IMPORTED_MODULE_1__["default"].code);
        let outValueCompositionType = _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Unknown;
        if (lhsCompositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Mat4 && rhsCompositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Mat4) {
            outValueCompositionType = _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Mat4;
        }
        else if (lhsCompositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Mat4 && rhsCompositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Vec4) {
            outValueCompositionType = _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Vec4;
        }
        else if (lhsCompositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Scalar && rhsCompositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Scalar) {
            outValueCompositionType = _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Scalar;
        }
        this.__inputs.push({
            compositionType: lhsCompositionType,
            componentType: lhsComponentType,
            name: 'lhs',
        });
        this.__inputs.push({
            compositionType: rhsCompositionType,
            componentType: rhsComponentType,
            name: 'rhs',
        });
        this.__outputs.push({
            compositionType: outValueCompositionType,
            componentType: lhsComponentType,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/NormalMatrixShaderNode.ts":
/*!******************************************************************!*\
  !*** ./src/foundation/materials/nodes/NormalMatrixShaderNode.ts ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NormalMatrixShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaderity_shaders_nodes_NormalMatrix_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/NormalMatrix.vert */ "./src/webgl/shaderity_shaders/nodes/NormalMatrix.vert");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");




class NormalMatrixShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super('normalMatrix', _webgl_shaderity_shaders_nodes_NormalMatrix_vert__WEBPACK_IMPORTED_MODULE_2__["default"].code);
        this.__outputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Mat3,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/NormalizeShaderNode.ts":
/*!***************************************************************!*\
  !*** ./src/foundation/materials/nodes/NormalizeShaderNode.ts ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NormalizeShaderNode; });
/* harmony import */ var _webgl_shaderity_shaders_nodes_Normalize_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/Normalize.glsl */ "./src/webgl/shaderity_shaders/nodes/Normalize.glsl");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");


class NormalizeShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(compositionType, componentType) {
        super('normalize', _webgl_shaderity_shaders_nodes_Normalize_glsl__WEBPACK_IMPORTED_MODULE_0__["default"].code);
        this.__inputs.push({
            compositionType: compositionType,
            componentType: componentType,
            name: 'value',
        });
        this.__outputs.push({
            compositionType: compositionType,
            componentType: componentType,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/OutColorShaderNode.ts":
/*!**************************************************************!*\
  !*** ./src/foundation/materials/nodes/OutColorShaderNode.ts ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OutColorShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaders_nodes_EndShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaders/nodes/EndShader */ "./src/webgl/shaders/nodes/EndShader.ts");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");




class OutColorShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super('outColor', undefined, _webgl_shaders_nodes_EndShader__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance());
        this.__inputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Vec4,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'value',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/OutPositionShaderNode.ts":
/*!*****************************************************************!*\
  !*** ./src/foundation/materials/nodes/OutPositionShaderNode.ts ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OutPositionShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaders_nodes_EndShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaders/nodes/EndShader */ "./src/webgl/shaders/nodes/EndShader.ts");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");




class OutPositionShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super('outPosition', undefined, _webgl_shaders_nodes_EndShader__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance());
        this.__inputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Vec4,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'value',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/ProjectionMatrixShaderNode.ts":
/*!**********************************************************************!*\
  !*** ./src/foundation/materials/nodes/ProjectionMatrixShaderNode.ts ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ProjectionMatrixShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaderity_shaders_nodes_ProjectionMatrix_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/ProjectionMatrix.vert */ "./src/webgl/shaderity_shaders/nodes/ProjectionMatrix.vert");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");




class ProjectionMatrixShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super('projectionMatrix', _webgl_shaderity_shaders_nodes_ProjectionMatrix_vert__WEBPACK_IMPORTED_MODULE_2__["default"].code);
        this.__outputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Mat4,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/ScalarToVector4ShaderNode.ts":
/*!*********************************************************************!*\
  !*** ./src/foundation/materials/nodes/ScalarToVector4ShaderNode.ts ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScalarToVector4ShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaderity_shaders_nodes_ScalarToVector4_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/ScalarToVector4.glsl */ "./src/webgl/shaderity_shaders/nodes/ScalarToVector4.glsl");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");




class ScalarToVector4ShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super('scalarToVector4', _webgl_shaderity_shaders_nodes_ScalarToVector4_glsl__WEBPACK_IMPORTED_MODULE_2__["default"].code);
        this.__inputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Scalar,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'x',
        });
        this.__inputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Scalar,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'y',
        });
        this.__inputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Scalar,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'z',
        });
        this.__inputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Scalar,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'w',
        });
        this.__outputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Vec4,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/UniformDataShaderNode.ts":
/*!*****************************************************************!*\
  !*** ./src/foundation/materials/nodes/UniformDataShaderNode.ts ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UniformDataShaderNode; });
/* harmony import */ var _webgl_shaders_nodes_UniformDataShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../webgl/shaders/nodes/UniformDataShader */ "./src/webgl/shaders/nodes/UniformDataShader.ts");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");


class UniformDataShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(compositionType, componentType) {
        super('uniformData');
        this.__shaderFunctionName += '_' + this.__shaderNodeUid;
        this.__shader = new _webgl_shaders_nodes_UniformDataShader__WEBPACK_IMPORTED_MODULE_0__["default"](this.__shaderFunctionName, compositionType, componentType);
        this.__outputs.push({
            compositionType: compositionType,
            componentType: componentType,
            name: 'outValue',
        });
    }
    setDefaultInputValue(inputName, value) {
        if (inputName === 'value') {
            this.__shader.setDefaultValue(value);
        }
    }
    setUniformDataName(value) {
        this.__shader.setVariableName(value);
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/VaryingInVariableShaderNode.ts":
/*!***********************************************************************!*\
  !*** ./src/foundation/materials/nodes/VaryingInVariableShaderNode.ts ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VaryingInVariableShaderNode; });
/* harmony import */ var _webgl_shaders_nodes_VaryingVariableShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../webgl/shaders/nodes/VaryingVariableShader */ "./src/webgl/shaders/nodes/VaryingVariableShader.ts");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");


class VaryingInVariableShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(compositionType, componentType) {
        super('varyingInVariable');
        this.__shaderFunctionName += '_' + this.__shaderNodeUid;
        this.__shader = new _webgl_shaders_nodes_VaryingVariableShader__WEBPACK_IMPORTED_MODULE_0__["default"](this.__shaderFunctionName, compositionType, componentType);
        this.__outputs.push({
            compositionType: compositionType,
            componentType: componentType,
            name: 'outValue',
            isClosed: true
        });
    }
    setVaryingVariableName(value) {
        this.__shader.setVariableName(value);
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/VaryingOutVariableShaderNode.ts":
/*!************************************************************************!*\
  !*** ./src/foundation/materials/nodes/VaryingOutVariableShaderNode.ts ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VaryingOutVariableShaderNode; });
/* harmony import */ var _webgl_shaders_nodes_VaryingVariableShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../webgl/shaders/nodes/VaryingVariableShader */ "./src/webgl/shaders/nodes/VaryingVariableShader.ts");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");


class VaryingOutVariableShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(compositionType, componentType) {
        super('varyingOutVariable');
        this.__shaderFunctionName += '_' + this.__shaderNodeUid;
        this.__shader = new _webgl_shaders_nodes_VaryingVariableShader__WEBPACK_IMPORTED_MODULE_0__["default"](this.__shaderFunctionName, compositionType, componentType);
        this.__inputs.push({
            compositionType: compositionType,
            componentType: componentType,
            name: 'value',
        });
    }
    setVaryingVariableName(value) {
        this.__shader.setVariableName(value);
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/Vector3AndScalarToVector4ShaderNode.ts":
/*!*******************************************************************************!*\
  !*** ./src/foundation/materials/nodes/Vector3AndScalarToVector4ShaderNode.ts ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector3AndScalarToVector4ShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaderity_shaders_nodes_Vector3AndScalarToVector4_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/Vector3AndScalarToVector4.glsl */ "./src/webgl/shaderity_shaders/nodes/Vector3AndScalarToVector4.glsl");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");




class Vector3AndScalarToVector4ShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super('vector3AndScalarToVector4', _webgl_shaderity_shaders_nodes_Vector3AndScalarToVector4_glsl__WEBPACK_IMPORTED_MODULE_2__["default"].code);
        this.__inputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Vec3,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'xyz',
        });
        this.__inputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Scalar,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'w',
        });
        this.__outputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Vec4,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/ViewMatrixShaderNode.ts":
/*!****************************************************************!*\
  !*** ./src/foundation/materials/nodes/ViewMatrixShaderNode.ts ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewMatrixShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaderity_shaders_nodes_ViewMatrix_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/ViewMatrix.vert */ "./src/webgl/shaderity_shaders/nodes/ViewMatrix.vert");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");




class ViewMatrixShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super('viewMatrix', _webgl_shaderity_shaders_nodes_ViewMatrix_vert__WEBPACK_IMPORTED_MODULE_2__["default"].code);
        this.__outputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Mat4,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/nodes/WorldMatrixShaderNode.ts":
/*!*****************************************************************!*\
  !*** ./src/foundation/materials/nodes/WorldMatrixShaderNode.ts ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorldMatrixShaderNode; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _webgl_shaderity_shaders_nodes_WorldMatrix_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/nodes/WorldMatrix.vert */ "./src/webgl/shaderity_shaders/nodes/WorldMatrix.vert");
/* harmony import */ var _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbstractShaderNode */ "./src/foundation/materials/core/AbstractShaderNode.ts");




class WorldMatrixShaderNode extends _core_AbstractShaderNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super('worldMatrix', _webgl_shaderity_shaders_nodes_WorldMatrix_vert__WEBPACK_IMPORTED_MODULE_2__["default"].code);
        this.__outputs.push({
            compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Mat4,
            componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Float,
            name: 'outValue',
        });
    }
}


/***/ }),

/***/ "./src/foundation/materials/singles/ClassicShadingSingleMaterialNode.ts":
/*!******************************************************************************!*\
  !*** ./src/foundation/materials/singles/ClassicShadingSingleMaterialNode.ts ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClassicShadingSingleMaterialNode; });
/* harmony import */ var _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _math_Scalar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/Scalar */ "./src/foundation/math/Scalar.ts");
/* harmony import */ var _components_SkeletalComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/SkeletalComponent */ "./src/foundation/components/SkeletalComponent.ts");
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");
/* harmony import */ var _definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../definitions/ShadingModel */ "./src/foundation/definitions/ShadingModel.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_Vector4__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _webgl_shaderity_shaders_classicSingleShader_classicSingleShader_vert__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/classicSingleShader/classicSingleShader.vert */ "./src/webgl/shaderity_shaders/classicSingleShader/classicSingleShader.vert");
/* harmony import */ var _webgl_shaderity_shaders_classicSingleShader_classicSingleShader_frag__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/classicSingleShader/classicSingleShader.frag */ "./src/webgl/shaderity_shaders/classicSingleShader/classicSingleShader.frag");















class ClassicShadingSingleMaterialNode extends _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ isSkinning, isLighting, alphaMode }) {
        super(null, "classicShading"
            + (isSkinning ? '+skinning' : '')
            + (isLighting ? '' : '-lighting')
            + ' alpha_' + alphaMode.str.toLowerCase(), { isMorphing: false, isLighting: isLighting, isSkinning: isSkinning }, _webgl_shaderity_shaders_classicSingleShader_classicSingleShader_vert__WEBPACK_IMPORTED_MODULE_13__["default"], _webgl_shaderity_shaders_classicSingleShader_classicSingleShader_frag__WEBPACK_IMPORTED_MODULE_14__["default"]);
        const shaderSemanticsInfoArray = [
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemantics"].ShadingModel, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_5__["default"](_definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_10__["ShadingModel"].Constant.index), min: 0, max: 3,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemantics"].Shininess, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_5__["default"](5), min: 0, max: Number.MAX_VALUE,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemantics"].DiffuseColorFactor, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec4,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: new _math_Vector4__WEBPACK_IMPORTED_MODULE_12__["default"](1, 1, 1, 1), min: 0, max: 2,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemantics"].DiffuseColorTexture, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Texture2D,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].EveryTime,
                initialValue: [0, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_0__["default"].__dummyWhiteTexture], min: 0, max: Number.MAX_SAFE_INTEGER,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemantics"].NormalTexture, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Texture2D,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].EveryTime,
                initialValue: [1, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_0__["default"].__dummyBlueTexture], min: 0, max: Number.MAX_SAFE_INTEGER,
            }
        ];
        shaderSemanticsInfoArray.push({
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemantics"].PointSize, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: true,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_5__["default"](30.0), min: 0, max: 100,
        }, {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemantics"].PointDistanceAttenuation, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec3,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: true,
            initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_11__["default"](0.0, 0.1, 0.01), min: 0, max: 1,
        });
        if (isLighting) {
            this.__definitions += '#define RN_IS_LIGHTING\n';
        }
        if (isSkinning) {
            this.__definitions += '#define RN_IS_SKINNING\n';
        }
        this.__definitions += '#define RN_IS_ALPHAMODE_' + alphaMode.str + '\n';
        shaderSemanticsInfoArray.push({
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemantics"].AlphaCutoff, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: 1.0, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].EveryTime, initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_5__["default"](0.01)
        });
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
    }
    setParametersForGPU({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
            this.setWorldMatrix(shaderProgram, args.worldMatrix);
            this.setNormalMatrix(shaderProgram, args.normalMatrix);
        }
        /// Matrices
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
            cameraComponent = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance().getComponent(_components_CameraComponent__WEBPACK_IMPORTED_MODULE_1__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_1__["default"].main);
        }
        this.setViewInfo(shaderProgram, cameraComponent, material, args.setUniform);
        this.setProjection(shaderProgram, cameraComponent, material, args.setUniform);
        /// Skinning
        const skeletalComponent = args.entity.getComponent(_components_SkeletalComponent__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.setSkinning(shaderProgram, skeletalComponent, args.setUniform);
        // Lights
        this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
    }
}


/***/ }),

/***/ "./src/foundation/materials/singles/CustomSingleMaterialNode.ts":
/*!**********************************************************************!*\
  !*** ./src/foundation/materials/singles/CustomSingleMaterialNode.ts ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CustomSingleMaterialNode; });
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../definitions/HdriFormat */ "./src/foundation/definitions/HdriFormat.ts");
/* harmony import */ var _components_MeshComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/MeshComponent */ "./src/foundation/components/MeshComponent.ts");
/* harmony import */ var _components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../components/BlendShapeComponent */ "./src/foundation/components/BlendShapeComponent.ts");
/* harmony import */ var _core_ShaderityUtility__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/ShaderityUtility */ "./src/foundation/materials/core/ShaderityUtility.ts");










class CustomSingleMaterialNode extends _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor({ name, isMorphing, isSkinning, isLighting, alphaMode, vertexShader, pixelShader }) {
        super(null, name
            + (isMorphing ? '+morphing' : '')
            + (isSkinning ? '+skinning' : '')
            + (isLighting ? '' : '-lighting')
            + ' alpha_' + alphaMode.str.toLowerCase(), { isMorphing, isSkinning, isLighting });
        const vertexShaderData = CustomSingleMaterialNode.__shaderityUtility.getShaderDataRefection(vertexShader, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__semanticsMap.get(this.shaderFunctionName));
        const pixelShaderData = CustomSingleMaterialNode.__shaderityUtility.getShaderDataRefection(pixelShader, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__semanticsMap.get(this.shaderFunctionName));
        this.__vertexShaderityObject = vertexShaderData.shaderityObject;
        this.__pixelShaderityObject = pixelShaderData.shaderityObject;
        const shaderSemanticsInfoArray = [];
        for (let vertexShaderSemanticsInfo of vertexShaderData.shaderSemanticsInfoArray) {
            vertexShaderSemanticsInfo.stage = _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_3__["ShaderType"].VertexShader;
            shaderSemanticsInfoArray.push(vertexShaderSemanticsInfo);
        }
        for (let pixelShaderSemanticsInfo of pixelShaderData.shaderSemanticsInfoArray) {
            const foundShaderSemanticsInfo = shaderSemanticsInfoArray.find((vertexInfo) => {
                if (vertexInfo.semantic.str === pixelShaderSemanticsInfo.semantic.str) {
                    return true;
                }
                else {
                    return false;
                }
            });
            if (foundShaderSemanticsInfo) {
                foundShaderSemanticsInfo.stage = _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_3__["ShaderType"].VertexAndPixelShader;
            }
            else {
                pixelShaderSemanticsInfo.stage = _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_3__["ShaderType"].PixelShader;
                shaderSemanticsInfoArray.push(pixelShaderSemanticsInfo);
            }
        }
        if (isLighting) {
            this.__definitions += '#define RN_IS_LIGHTING\n';
        }
        if (isSkinning) {
            this.__definitions += '#define RN_IS_SKINNING\n';
        }
        if (isMorphing) {
            this.__definitions += '#define RN_IS_MORPHING\n';
        }
        this.__definitions += '#define RN_IS_ALPHAMODE_' + alphaMode.str + '\n';
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
    }
    setParametersForGPU({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
            this.setWorldMatrix(shaderProgram, args.worldMatrix);
            this.setNormalMatrix(shaderProgram, args.normalMatrix);
            if (firstTime) {
                /// Matrices
                let cameraComponent = args.renderPass.cameraComponent;
                if (cameraComponent == null) {
                    cameraComponent = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getInstance().getComponent(_components_CameraComponent__WEBPACK_IMPORTED_MODULE_5__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_5__["default"].main);
                }
                this.setViewInfo(shaderProgram, cameraComponent, material, args.setUniform);
                this.setProjection(shaderProgram, cameraComponent, material, args.setUniform);
                // Lights
                this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
            }
            /// Skinning
            const skeletalComponent = args.entity.getSkeletal();
            this.setSkinning(shaderProgram, skeletalComponent, args.setUniform);
        }
        // Env map
        if (args.diffuseCube && args.diffuseCube.isTextureReady) {
            this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].DiffuseEnvTexture.str, firstTime, [5, args.diffuseCube]);
        }
        else {
            this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].DiffuseEnvTexture.str, firstTime, [5, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyBlackCubeTexture]);
        }
        if (args.specularCube && args.specularCube.isTextureReady) {
            this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].SpecularEnvTexture.str, firstTime, [6, args.specularCube]);
        }
        else {
            this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].SpecularEnvTexture.str, firstTime, [6, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyBlackCubeTexture]);
        }
        if (args.setUniform) {
            if (firstTime) {
                const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = this.setupHdriParameters(args);
                this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].IBLParameter.str, firstTime, {
                    x: mipmapLevelNumber,
                    y: meshRenderComponent.diffuseCubeMapContribution,
                    z: meshRenderComponent.specularCubeMapContribution, w: meshRenderComponent.rotationOfCubeMap
                });
                this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].HDRIFormat.str, firstTime, { x: diffuseHdriType, y: specularHdriType });
            }
        }
        else {
            const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = this.setupHdriParameters(args);
            const tmp_vector4 = _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__tmp_vector4;
            tmp_vector4.x = mipmapLevelNumber;
            tmp_vector4.y = meshRenderComponent.diffuseCubeMapContribution;
            tmp_vector4.z = meshRenderComponent.specularCubeMapContribution;
            tmp_vector4.w = meshRenderComponent.rotationOfCubeMap;
            material.setParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].IBLParameter, tmp_vector4);
            const tmp_vector2 = _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__tmp_vector2;
            tmp_vector2.x = diffuseHdriType;
            tmp_vector2.y = specularHdriType;
            material.setParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].HDRIFormat, tmp_vector2);
        }
        // Morph
        this.setMorphInfo(shaderProgram, args.entity.getComponent(_components_MeshComponent__WEBPACK_IMPORTED_MODULE_7__["default"]), args.entity.getComponent(_components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_8__["default"]), args.primitive);
    }
    setupHdriParameters(args) {
        let mipmapLevelNumber = 1;
        if (args.specularCube) {
            mipmapLevelNumber = args.specularCube.mipmapLevelNumber;
        }
        const meshRenderComponent = args.entity.getMeshRenderer();
        let diffuseHdriType = _definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_6__["HdriFormat"].LDR_SRGB.index;
        let specularHdriType = _definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_6__["HdriFormat"].LDR_SRGB.index;
        if (meshRenderComponent.diffuseCubeMap) {
            diffuseHdriType = meshRenderComponent.diffuseCubeMap.hdriFormat.index;
        }
        if (meshRenderComponent.specularCubeMap) {
            specularHdriType = meshRenderComponent.specularCubeMap.hdriFormat.index;
        }
        return { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType };
    }
}
CustomSingleMaterialNode.__pbrCookTorranceBrdfLutDataUrlUid = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].InvalidCGAPIResourceUid;
CustomSingleMaterialNode.IsOutputHDR = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'isOutputHDR' });
CustomSingleMaterialNode.BaseColorTextureTransform = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'baseColorTextureTransform' });
CustomSingleMaterialNode.BaseColorTextureRotation = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'baseColorTextureRotation' });
CustomSingleMaterialNode.NormalTextureTransform = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'normalTextureTransform' });
CustomSingleMaterialNode.NormalTextureRotation = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'normalTextureRotation' });
CustomSingleMaterialNode.MetallicRoughnessTextureTransform = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'metallicRoughnessTextureTransform' });
CustomSingleMaterialNode.MetallicRoughnessTextureRotation = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'metallicRoughnessTextureRotation' });
CustomSingleMaterialNode.__shaderityUtility = _core_ShaderityUtility__WEBPACK_IMPORTED_MODULE_9__["default"].getInstance();


/***/ }),

/***/ "./src/foundation/materials/singles/DepthEncodeSingleMaterialNode.ts":
/*!***************************************************************************!*\
  !*** ./src/foundation/materials/singles/DepthEncodeSingleMaterialNode.ts ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DepthEncodeSingleMaterialNode; });
/* harmony import */ var _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _webgl_shaders_DepthEncodeShader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../webgl/shaders/DepthEncodeShader */ "./src/webgl/shaders/DepthEncodeShader.ts");
/* harmony import */ var _math_Scalar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math/Scalar */ "./src/foundation/math/Scalar.ts");
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");
/* harmony import */ var _components_SkeletalComponent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../components/SkeletalComponent */ "./src/foundation/components/SkeletalComponent.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../math/Vector3 */ "./src/foundation/math/Vector3.ts");












class DepthEncodeSingleMaterialNode extends _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ isSkinning }) {
        super(_webgl_shaders_DepthEncodeShader__WEBPACK_IMPORTED_MODULE_5__["default"].getInstance(), 'depthEncodeShading' + (isSkinning ? '+skinning' : ''), { isMorphing: false, isSkinning, isLighting: false });
        const shaderSemanticsInfoArray = [
            {
                semantic: DepthEncodeSingleMaterialNode.zNearInner, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_6__["default"](0.1), min: 0.0001, max: Number.MAX_SAFE_INTEGER
            },
            {
                semantic: DepthEncodeSingleMaterialNode.zFarInner, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_6__["default"](10000.0), min: 0.0001, max: Number.MAX_SAFE_INTEGER
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemantics"].PointSize, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: true,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_6__["default"](30.0), min: 0, max: 100,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemantics"].PointDistanceAttenuation, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec3,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: true,
                initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_11__["default"](0.0, 0.1, 0.01), min: 0, max: 1,
            }
        ];
        if (isSkinning) {
            this.__definitions += '#define RN_IS_SKINNING';
        }
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
    }
    setParametersForGPU({ material, shaderProgram, firstTime, args }) {
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
            cameraComponent = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance().getComponent(_components_CameraComponent__WEBPACK_IMPORTED_MODULE_1__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_1__["default"].main);
        }
        if (args.setUniform) {
            this.setWorldMatrix(shaderProgram, args.worldMatrix);
            this.setNormalMatrix(shaderProgram, args.normalMatrix);
            this.setViewInfo(shaderProgram, cameraComponent, material, args.setUniform);
            this.setProjection(shaderProgram, cameraComponent, material, args.setUniform);
            if (DepthEncodeSingleMaterialNode.__lastZNear !== cameraComponent.zNearInner) {
                shaderProgram._gl.uniform1f(shaderProgram.zNearInner, cameraComponent.zNearInner);
                DepthEncodeSingleMaterialNode.__lastZNear = cameraComponent.zNearInner;
            }
            if (DepthEncodeSingleMaterialNode.__lastZFar !== cameraComponent.zFarInner) {
                shaderProgram._gl.uniform1f(shaderProgram.zFarInner, cameraComponent.zFarInner);
                DepthEncodeSingleMaterialNode.__lastZFar = cameraComponent.zFarInner;
            }
        }
        else {
            material.setParameter(DepthEncodeSingleMaterialNode.zNearInner, cameraComponent.zNearInner);
            material.setParameter(DepthEncodeSingleMaterialNode.zFarInner, cameraComponent.zFarInner);
        }
        /// Skinning
        const skeletalComponent = args.entity.getComponent(_components_SkeletalComponent__WEBPACK_IMPORTED_MODULE_10__["default"]);
        this.setSkinning(shaderProgram, skeletalComponent, args.setUniform);
    }
}
DepthEncodeSingleMaterialNode.zNearInner = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemanticsClass"]({ str: 'zNearInner' });
DepthEncodeSingleMaterialNode.zFarInner = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_7__["ShaderSemanticsClass"]({ str: 'zFarInner' });
DepthEncodeSingleMaterialNode.__lastZNear = 0.0;
DepthEncodeSingleMaterialNode.__lastZFar = 0.0;


/***/ }),

/***/ "./src/foundation/materials/singles/EntityUIDOutputSingleMaterialNode.ts":
/*!*******************************************************************************!*\
  !*** ./src/foundation/materials/singles/EntityUIDOutputSingleMaterialNode.ts ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EntityUIDOutputSingleMaterialNode; });
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _math_Scalar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math/Scalar */ "./src/foundation/math/Scalar.ts");
/* harmony import */ var _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _components_SkeletalComponent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../components/SkeletalComponent */ "./src/foundation/components/SkeletalComponent.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../math/MutableMatrix33 */ "./src/foundation/math/MutableMatrix33.ts");
/* harmony import */ var _webgl_shaderity_shaders_EntityUIDOutputSingleShader_EntityUIDOutputSingleShader_vert__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/EntityUIDOutputSingleShader/EntityUIDOutputSingleShader.vert */ "./src/webgl/shaderity_shaders/EntityUIDOutputSingleShader/EntityUIDOutputSingleShader.vert");
/* harmony import */ var _webgl_shaderity_shaders_EntityUIDOutputSingleShader_EntityUIDOutputSingleShader_frag__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/EntityUIDOutputSingleShader/EntityUIDOutputSingleShader.frag */ "./src/webgl/shaderity_shaders/EntityUIDOutputSingleShader/EntityUIDOutputSingleShader.frag");















class EntityUIDOutputSingleMaterialNode extends _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(null, "entityUidOutputShading"
            + (true ? '+skinning' : undefined)
            + (false ? undefined : '-lighting'), { isMorphing: false, isSkinning: true, isLighting: false }, _webgl_shaderity_shaders_EntityUIDOutputSingleShader_EntityUIDOutputSingleShader_vert__WEBPACK_IMPORTED_MODULE_13__["default"], _webgl_shaderity_shaders_EntityUIDOutputSingleShader_EntityUIDOutputSingleShader_frag__WEBPACK_IMPORTED_MODULE_14__["default"]);
        const shaderSemanticsInfoArray = [
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].WorldMatrix, isComponentData: true, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Mat4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_5__["ShaderType"].VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_7__["ShaderVariableUpdateInterval"].EveryTime, initialValue: _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_11__["default"].zero()
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].NormalMatrix, isComponentData: true, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Mat3, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_5__["ShaderType"].VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_7__["ShaderVariableUpdateInterval"].EveryTime, initialValue: _math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_12__["default"].zero()
            },
            // {semantic: ShaderSemantics.ViewMatrix, isComponentData: true, compositionType: CompositionType.Mat4, componentType: ComponentType.Float,
            //   stage: ShaderType.VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: ShaderVariableUpdateInterval.FirstTimeOnly, initialValue: MutableMatrix44.zero() },
            // {semantic: ShaderSemantics.ProjectionMatrix, isComponentData: true, compositionType: CompositionType.Mat4, componentType: ComponentType.Float,
            //   stage: ShaderType.VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: ShaderVariableUpdateInterval.FirstTimeOnly, initialValue: MutableMatrix44.zero() },
            // {
            //   semantic: ShaderSemantics.ViewPosition,
            //   compositionType: CompositionType.Vec3,
            //   componentType: ComponentType.Float,
            //   stage: ShaderType.VertexShader,
            //   min: -Number.MAX_VALUE,
            //   max: Number.MAX_VALUE,
            //   isSystem: true,
            //   updateInterval: ShaderVariableUpdateInterval.FirstTimeOnly,
            //   initialValue: new Vector3(0, 0, 0),
            //   soloDatum: true
            // },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].PointSize, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_5__["ShaderType"].VertexShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_7__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: true,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_6__["default"](30.0), min: 0, max: 100,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].PointDistanceAttenuation, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec3,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_5__["ShaderType"].VertexShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_7__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: true,
                initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](0.0, 0.1, 0.01), min: 0, max: 1,
            },
        ];
        if (true) {
            this.__definitions += '#define RN_IS_SKINNING\n';
        }
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
    }
    setParametersForGPU({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
            this.setWorldMatrix(shaderProgram, args.worldMatrix);
            this.setNormalMatrix(shaderProgram, args.normalMatrix);
        }
        /// Matrices
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
            cameraComponent = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_8__["default"].getInstance().getComponent(_components_CameraComponent__WEBPACK_IMPORTED_MODULE_9__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_9__["default"].main);
        }
        this.setViewInfo(shaderProgram, cameraComponent, material, args.setUniform);
        this.setProjection(shaderProgram, cameraComponent, material, args.setUniform);
        /// Skinning
        const skeletalComponent = args.entity.getComponent(_components_SkeletalComponent__WEBPACK_IMPORTED_MODULE_10__["default"]);
        this.setSkinning(shaderProgram, skeletalComponent, args.setUniform);
        // Lights
        this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
    }
}


/***/ }),

/***/ "./src/foundation/materials/singles/EnvConstantSingleMaterialNode.ts":
/*!***************************************************************************!*\
  !*** ./src/foundation/materials/singles/EnvConstantSingleMaterialNode.ts ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EnvConstantSingleMaterialNode; });
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _math_Vector4__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _webgl_shaders_EnvConstantShader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../webgl/shaders/EnvConstantShader */ "./src/webgl/shaders/EnvConstantShader.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _math_Scalar__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../math/Scalar */ "./src/foundation/math/Scalar.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");











class EnvConstantSingleMaterialNode extends _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(_webgl_shaders_EnvConstantShader__WEBPACK_IMPORTED_MODULE_5__["default"].getInstance(), "envConstantShading");
        const shaderSemanticsInfoArray = [
            {
                semantic: EnvConstantSingleMaterialNode.EnvHdriFormat, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_6__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_7__["default"](0), min: 0, max: 5,
            },
            {
                semantic: EnvConstantSingleMaterialNode.envRotation, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_6__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_7__["default"](0), min: -Math.PI, max: Math.PI,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].DiffuseColorFactor, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec4,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_6__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: new _math_Vector4__WEBPACK_IMPORTED_MODULE_4__["default"](1, 1, 1, 1), min: 0, max: 2,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].ColorEnvTexture, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].TextureCube,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_6__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_10__["ShaderVariableUpdateInterval"].EveryTime,
                initialValue: [0, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyBlackCubeTexture], min: 0, max: Number.MAX_SAFE_INTEGER,
            },
        ];
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
    }
    setParametersForGPU({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
            this.setWorldMatrix(shaderProgram, args.worldMatrix);
            this.setNormalMatrix(shaderProgram, args.normalMatrix);
        }
        /// Matrices
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
            cameraComponent = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_8__["default"].getInstance().getComponent(_components_CameraComponent__WEBPACK_IMPORTED_MODULE_9__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_9__["default"].main);
        }
        if (cameraComponent) {
            this.setViewInfo(shaderProgram, cameraComponent, material, args.setUniform);
            this.setProjection(shaderProgram, cameraComponent, material, args.setUniform);
        }
    }
}
EnvConstantSingleMaterialNode.envRotation = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'envRotation' });
EnvConstantSingleMaterialNode.EnvHdriFormat = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'EnvHdriFormat' });


/***/ }),

/***/ "./src/foundation/materials/singles/FXAA3QualitySingleMaterialNode.ts":
/*!****************************************************************************!*\
  !*** ./src/foundation/materials/singles/FXAA3QualitySingleMaterialNode.ts ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FXAA3QualitySingleMaterialNode; });
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Vector2 */ "./src/foundation/math/Vector2.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");
/* harmony import */ var _webgl_shaderity_shaders_FXAA3QualityShader_FXAA3QualitySingleShader_vert__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/FXAA3QualityShader/FXAA3QualitySingleShader.vert */ "./src/webgl/shaderity_shaders/FXAA3QualityShader/FXAA3QualitySingleShader.vert");
/* harmony import */ var _webgl_shaderity_shaders_FXAA3QualityShader_FXAA3QualitySingleShader_frag__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/FXAA3QualityShader/FXAA3QualitySingleShader.frag */ "./src/webgl/shaderity_shaders/FXAA3QualityShader/FXAA3QualitySingleShader.frag");











class FXAA3QualitySingleMaterialNode extends _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(null, "FXAA3QualityShading", { isMorphing: false, isSkinning: false, isLighting: false }, _webgl_shaderity_shaders_FXAA3QualityShader_FXAA3QualitySingleShader_vert__WEBPACK_IMPORTED_MODULE_9__["default"], _webgl_shaderity_shaders_FXAA3QualityShader_FXAA3QualitySingleShader_frag__WEBPACK_IMPORTED_MODULE_10__["default"]);
        const shaderSemanticsInfoArray = [
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].BaseColorTexture, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Texture2D, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_5__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_8__["ShaderVariableUpdateInterval"].EveryTime,
                initialValue: [0, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyWhiteTexture], min: 0, max: Number.MAX_SAFE_INTEGER,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].ScreenInfo, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec2, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_5__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_8__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: false,
                initialValue: new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["default"](0, 0), min: 0, max: Number.MAX_SAFE_INTEGER,
            },
        ];
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
    }
    setParametersForGPU({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
            this.setWorldMatrix(shaderProgram, args.worldMatrix);
        }
        /// Matrices
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
            cameraComponent = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_6__["default"].getInstance().getComponent(_components_CameraComponent__WEBPACK_IMPORTED_MODULE_7__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_7__["default"].main);
        }
        if (cameraComponent) {
            this.setViewInfo(shaderProgram, cameraComponent, material, args.setUniform);
            this.setProjection(shaderProgram, cameraComponent, material, args.setUniform);
        }
    }
}


/***/ }),

/***/ "./src/foundation/materials/singles/GammaCorrectionSingleMaterialNode.ts":
/*!*******************************************************************************!*\
  !*** ./src/foundation/materials/singles/GammaCorrectionSingleMaterialNode.ts ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GammaCorrectionSingleMaterialNode; });
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");
/* harmony import */ var _webgl_shaderity_shaders_GammaCorrectionShader_GammaCorrectionShader_vert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.vert */ "./src/webgl/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.vert");
/* harmony import */ var _webgl_shaderity_shaders_GammaCorrectionShader_GammaCorrectionShader_frag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.frag */ "./src/webgl/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.frag");










class GammaCorrectionSingleMaterialNode extends _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(null, "GammaCorrection", {}, _webgl_shaderity_shaders_GammaCorrectionShader_GammaCorrectionShader_vert__WEBPACK_IMPORTED_MODULE_8__["default"], _webgl_shaderity_shaders_GammaCorrectionShader_GammaCorrectionShader_frag__WEBPACK_IMPORTED_MODULE_9__["default"]);
        const shaderSemanticsInfoArray = [
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].BaseColorTexture, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Texture2D, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_4__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_7__["ShaderVariableUpdateInterval"].EveryTime,
                initialValue: [0, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyWhiteTexture], min: 0, max: 10,
            }
        ];
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
    }
    setParametersForGPU({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
            this.setWorldMatrix(shaderProgram, args.worldMatrix);
        }
        /// Matrices
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
            cameraComponent = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_5__["default"].getInstance().getComponent(_components_CameraComponent__WEBPACK_IMPORTED_MODULE_6__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_6__["default"].main);
        }
        if (cameraComponent) {
            this.setViewInfo(shaderProgram, cameraComponent, material, args.setUniform);
            this.setProjection(shaderProgram, cameraComponent, material, args.setUniform);
        }
    }
}


/***/ }),

/***/ "./src/foundation/materials/singles/MToonSingleMaterialNode.ts":
/*!*********************************************************************!*\
  !*** ./src/foundation/materials/singles/MToonSingleMaterialNode.ts ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MToonSingleMaterialNode; });
/* harmony import */ var _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");
/* harmony import */ var _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../definitions/AlphaMode */ "./src/foundation/definitions/AlphaMode.ts");
/* harmony import */ var _components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/BlendShapeComponent */ "./src/foundation/components/BlendShapeComponent.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _components_MeshComponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../components/MeshComponent */ "./src/foundation/components/MeshComponent.ts");
/* harmony import */ var _webgl_shaders_MToonShader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../webgl/shaders/MToonShader */ "./src/webgl/shaders/MToonShader.ts");
/* harmony import */ var _math_Scalar__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../math/Scalar */ "./src/foundation/math/Scalar.ts");
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_Vector4__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _math_VectorN__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../math/VectorN */ "./src/foundation/math/VectorN.ts");
/* harmony import */ var _webgl_WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../../webgl/WebGLResourceRepository */ "./src/webgl/WebGLResourceRepository.ts");



















class MToonSingleMaterialNode extends _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(isOutline, materialProperties, textures, isMorphing, isSkinning, isLighting, debugMode) {
        super(_webgl_shaders_MToonShader__WEBPACK_IMPORTED_MODULE_10__["default"].getInstance(), 'MToonShading'
            + (isMorphing ? '+morphing' : '')
            + (isSkinning ? '+skinning' : '')
            + (isLighting ? '' : '-lighting'), { isMorphing: isMorphing, isSkinning: isSkinning, isLighting: isLighting });
        this.__OutlineWidthModeIsScreen = false;
        this.__floatProperties = {};
        this.__vectorProperties = {};
        this.__textureProperties = {};
        const shaderSemanticsInfoArray = [];
        if (materialProperties != null) {
            this.__floatProperties = materialProperties.floatProperties;
            this.__vectorProperties = materialProperties.vectorProperties;
            this.__textureProperties = materialProperties.textureProperties;
        }
        else {
            this.__floatProperties._BlendMode = 0.0;
            this.__floatProperties._BumpScale = 1.0;
            this.__floatProperties._CullMode = 2.0;
            this.__floatProperties._Cutoff = 0.5;
            this.__floatProperties._DebugMode = 0.0;
            this.__floatProperties._DstBlend = 0.0;
            this.__floatProperties._IndirectLightIntensity = 0.1;
            this.__floatProperties._LightColorAttenuation = 0.0;
            this.__floatProperties._OutlineColorMode = 0.0;
            this.__floatProperties._OutlineCullMode = 1.0;
            this.__floatProperties._OutlineLightingMix = 1.0;
            this.__floatProperties._OutlineScaledMaxDistance = 1.0;
            this.__floatProperties._OutlineWidth = 0.5;
            this.__floatProperties._OutlineWidthMode = 0.0;
            this.__floatProperties._ReceiveShadowRate = 1.0;
            this.__floatProperties._RimFresnelPower = 1.0;
            this.__floatProperties._RimLift = 0.0;
            this.__floatProperties._RimLightingMix = 0.0;
            this.__floatProperties._ShadeShift = 0.0;
            this.__floatProperties._ShadeToony = 0.9;
            this.__floatProperties._ShadingGradeRate = 1.0;
            this.__floatProperties._SrcBlend = 1.0;
            this.__floatProperties._ZWrite = 1.0;
            // this.__floatProperties._UvAnimScrollX = 0.0;
            // this.__floatProperties._UvAnimScrollY = 0.0;
            // this.__floatProperties._UvAnimRotation = 0.0;
            this.__vectorProperties._Color = [1, 1, 1, 1];
            this.__vectorProperties._EmissionColor = [0, 0, 0];
            this.__vectorProperties._OutlineColor = [0, 0, 0, 1];
            this.__vectorProperties._ShadeColor = [0.97, 0.81, 0.86, 1];
            this.__vectorProperties._RimColor = [0, 0, 0];
            // this.__vectorProperties._BumpMap = [0, 0, 1, 1];
            // this.__vectorProperties._EmissionMap = [0, 0, 1, 1];
            // this.__vectorProperties._MainTex = [0, 0, 1, 1];
            // this.__vectorProperties._OutlineWidthTexture = [0, 0, 1, 1];
            // this.__vectorProperties._ReceiveShadowTexture = [0, 0, 1, 1];
            // this.__vectorProperties._ShadeTexture = [0, 0, 1, 1];
            // this.__vectorProperties._ShadingGradeTexture = [0, 0, 1, 1];
            // this.__vectorProperties._SphereAdd = [0, 0, 1, 1];
            this.__textureProperties._BumpMap = 0;
            this.__textureProperties._EmissionMap = 1;
            this.__textureProperties._MainTex = 0;
            this.__textureProperties._OutlineWidthTexture = 0;
            this.__textureProperties._ReceiveShadowTexture = 0;
            this.__textureProperties._RimTexture = 1;
            this.__textureProperties._ShadeTexture = 0;
            this.__textureProperties._ShadingGradeTexture = 0;
            this.__textureProperties._SphereAdd = 1;
            // this.__textureProperties._UvAnimMaskTexture = 0;
            textures = [
                _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_0__["default"].__dummyWhiteTexture,
                _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_0__["default"].__dummyBlackTexture
            ];
        }
        if (debugMode) {
            this.__floatProperties._DebugMode = debugMode;
        }
        // non-Texture
        shaderSemanticsInfoArray.push({
            semantic: MToonSingleMaterialNode._Cutoff, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._Cutoff), min: 0, max: 1
        }, {
            semantic: MToonSingleMaterialNode._Color, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Vec4,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Vector4__WEBPACK_IMPORTED_MODULE_16__["default"](this.__vectorProperties._Color), min: 0, max: 1,
        }, {
            semantic: MToonSingleMaterialNode._ShadeColor, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Vec3,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_15__["default"](this.__vectorProperties._ShadeColor), min: 0, max: 1,
        }, {
            semantic: MToonSingleMaterialNode._BumpScale, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._BumpScale), min: 0, max: 1
        }, {
            semantic: MToonSingleMaterialNode._ReceiveShadowRate, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._ReceiveShadowRate), min: 0, max: 1
        }, {
            semantic: MToonSingleMaterialNode._ShadingGradeRate, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._ShadingGradeRate), min: 0, max: 1
        }, {
            semantic: MToonSingleMaterialNode._ShadeShift, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._ShadeShift), min: 0, max: 1
        }, {
            semantic: MToonSingleMaterialNode._ShadeToony, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._ShadeToony), min: 0, max: 1
        }, {
            semantic: MToonSingleMaterialNode._LightColorAttenuation, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._LightColorAttenuation), min: 0, max: 1
        }, {
            semantic: MToonSingleMaterialNode._AmbientColor, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Vec3,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_15__["default"](0.5785, 0.5785, 0.5785), min: 0, max: 1,
        }, 
        // {
        //   semantic: MToonSingleMaterialNode._IndirectLightIntensity, componentType: ComponentType.Float, compositionType: CompositionType.Scalar,
        //   stage: ShaderType.PixelShader, isSystem: false, updateInterval: ShaderVariableUpdateInterval.EveryTime, soloDatum: false,
        //   initialValue: new Scalar(this.floatPropertiesArray._IndirectLightIntensity), min: 0, max: 1
        // },
        {
            semantic: MToonSingleMaterialNode._RimColor, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Vec3,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_15__["default"](this.__vectorProperties._RimColor), min: 0, max: 1,
        }, {
            semantic: MToonSingleMaterialNode._RimLightingMix, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._RimLightingMix), min: 0, max: 1
        }, {
            semantic: MToonSingleMaterialNode._RimFresnelPower, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._RimFresnelPower), min: 0, max: 1
        }, {
            semantic: MToonSingleMaterialNode._RimLift, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._RimLift), min: 0, max: 1
        }, {
            semantic: MToonSingleMaterialNode.CameraUp, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Vec3,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: true, soloDatum: true,
            initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_15__["default"](0, 1, 0), min: 0, max: 1,
        }, {
            semantic: MToonSingleMaterialNode._EmissionColor, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Vec3,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_15__["default"](this.__vectorProperties._EmissionColor), min: 0, max: 1,
        }, 
        // {
        //   semantic: MToonSingleMaterialNode._UvAnimScrollX, componentType: ComponentType.Float, compositionType: CompositionType.Scalar,
        //   stage: ShaderType.PixelShader, isSystem: false, updateInterval: ShaderVariableUpdateInterval.EveryTime, soloDatum: false,
        //   initialValue: new Scalar(this.floatPropertiesArray._UvAnimScrollX), min: 0, max: 1
        // },
        // {
        //   semantic: MToonSingleMaterialNode._UvAnimScrollY, componentType: ComponentType.Float, compositionType: CompositionType.Scalar,
        //   stage: ShaderType.PixelShader, isSystem: false, updateInterval: ShaderVariableUpdateInterval.EveryTime, soloDatum: false,
        //   initialValue:  new Scalar(this.floatPropertiesArray._UvAnimScrollY), min: 0, max: 1
        // },
        // {
        //   semantic: MToonSingleMaterialNode._UvAnimRotation, componentType: ComponentType.Float, compositionType: CompositionType.Scalar,
        //   stage: ShaderType.PixelShader, isSystem: false, updateInterval: ShaderVariableUpdateInterval.EveryTime, soloDatum: false,
        //   initialValue: new Scalar(this.floatPropertiesArray._UvAnimRotation), min: 0, max: 1
        // },
        {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemantics"].Wireframe, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Vec3,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
            initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_15__["default"](0, 0, 1), min: 0, max: 10,
        });
        // _DebugMode
        switch (this.__floatProperties._DebugMode) {
            case 1:
                this.__definitions += '#define RN_MTOON_DEBUG_NORMAL\n';
                break;
            case 2:
                this.__definitions += '#define RN_MTOON_DEBUG_LITSHADERATE\n';
                break;
        }
        if (isOutline) {
            this.__definitions += '#define RN_MTOON_IS_OUTLINE\n';
            // _OutlineWidthMode
            switch (this.__floatProperties._OutlineWidthMode) {
                case 0:
                    this.__definitions += '#define RN_MTOON_OUTLINE_NONE\n';
                    break;
                case 1:
                    this.__definitions += '#define RN_MTOON_OUTLINE_WIDTH_WORLD\n';
                    break;
                case 2:
                    this.__definitions += '#define RN_MTOON_OUTLINE_WIDTH_SCREEN\n';
                    this.__OutlineWidthModeIsScreen = true;
                    break;
            }
            // _OutlineColorMode
            switch (this.__floatProperties._OutlineColorMode) {
                case 0:
                    this.__definitions += '#define RN_MTOON_OUTLINE_COLOR_FIXED\n';
                    break;
                case 1:
                    this.__definitions += '#define RN_MTOON_OUTLINE_COLOR_MIXED\n';
                    break;
            }
            shaderSemanticsInfoArray.push({
                semantic: MToonSingleMaterialNode._OutlineWidth, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].VertexShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._OutlineWidth), min: 0, max: 1
            }, {
                semantic: MToonSingleMaterialNode._OutlineScaledMaxDistance, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].VertexShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._OutlineScaledMaxDistance), min: 0, max: 1
            }, {
                semantic: MToonSingleMaterialNode._OutlineColor, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Vec3,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_15__["default"](this.__vectorProperties._OutlineColor), min: 0, max: 1,
            }, {
                semantic: MToonSingleMaterialNode._OutlineLightingMix, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](this.__floatProperties._OutlineLightingMix), min: 0, max: 1
            }, {
                semantic: MToonSingleMaterialNode.Aspect, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].VertexShader, isSystem: true, soloDatum: true,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](1.0), min: 0, max: 1,
            });
        }
        if (isLighting) {
            this.__definitions += '#define RN_IS_LIGHTING\n';
        }
        if (isSkinning) {
            this.__definitions += '#define RN_IS_SKINNING\n';
        }
        if (isMorphing) {
            this.__definitions += '#define RN_IS_MORPHING\n';
            shaderSemanticsInfoArray.push({
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemantics"].MorphTargetNumber, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].VertexShader, isSystem: true, soloDatum: true,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_11__["default"](0), min: 0, max: _core_Config__WEBPACK_IMPORTED_MODULE_8__["default"].maxVertexMorphNumberInShader, needUniformInFastest: true
            }, {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemantics"].DataTextureMorphOffsetPosition, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].ScalarArray, maxIndex: _core_Config__WEBPACK_IMPORTED_MODULE_8__["default"].maxVertexMorphNumberInShader,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].VertexShader, isSystem: true, soloDatum: true,
                initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_17__["default"](new Float32Array(_core_Config__WEBPACK_IMPORTED_MODULE_8__["default"].maxVertexMorphNumberInShader)), min: -Number.MAX_VALUE, max: Number.MAX_VALUE, needUniformInFastest: true
            }, {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemantics"].MorphWeights, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].ScalarArray, maxIndex: _core_Config__WEBPACK_IMPORTED_MODULE_8__["default"].maxVertexMorphNumberInShader,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].VertexShader, isSystem: true, soloDatum: true,
                initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_17__["default"](new Float32Array(_core_Config__WEBPACK_IMPORTED_MODULE_8__["default"].maxVertexMorphNumberInShader)), min: -Number.MAX_VALUE, max: Number.MAX_VALUE, needUniformInFastest: true
            });
        }
        // Texture
        this.__setTextures(textures, shaderSemanticsInfoArray, isOutline);
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
    }
    __setTextures(textures, shaderSemanticsInfoArray, isOutline) {
        shaderSemanticsInfoArray.push({
            semantic: MToonSingleMaterialNode._MainTex, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Texture2D,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime,
            initialValue: [0, textures[this.__textureProperties._MainTex]], min: 0, max: Number.MAX_SAFE_INTEGER,
        }, {
            semantic: MToonSingleMaterialNode._ShadeTexture, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Texture2D,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime,
            initialValue: [1, textures[this.__textureProperties._ShadeTexture]], min: 0, max: Number.MAX_SAFE_INTEGER,
        }, {
            semantic: MToonSingleMaterialNode._ReceiveShadowTexture, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Texture2D,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime,
            initialValue: [2, textures[this.__textureProperties._ReceiveShadowTexture]], min: 0, max: Number.MAX_SAFE_INTEGER,
        }, {
            semantic: MToonSingleMaterialNode._ShadingGradeTexture, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Texture2D,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime,
            initialValue: [3, textures[this.__textureProperties._ShadingGradeTexture]], min: 0, max: Number.MAX_SAFE_INTEGER,
        }, {
            semantic: MToonSingleMaterialNode._RimTexture, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Texture2D,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime,
            initialValue: [4, textures[this.__textureProperties._RimTexture]], min: 0, max: Number.MAX_SAFE_INTEGER,
        }, {
            semantic: MToonSingleMaterialNode._SphereAdd, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Texture2D,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime,
            initialValue: [5, textures[this.__textureProperties._SphereAdd]], min: 0, max: Number.MAX_SAFE_INTEGER,
        }, {
            semantic: MToonSingleMaterialNode._EmissionMap, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Texture2D,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime,
            initialValue: [6, textures[this.__textureProperties._EmissionMap]], min: 0, max: Number.MAX_SAFE_INTEGER,
        });
        const glw = _webgl_WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_18__["default"].getInstance().currentWebGLContextWrapper;
        const gl = glw.getRawContext();
        const maxUsableTextureNumber = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        const support10UnitsOfTextures = maxUsableTextureNumber > 9;
        if (support10UnitsOfTextures) {
            shaderSemanticsInfoArray.push({
                semantic: MToonSingleMaterialNode._BumpMap, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Texture2D,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime,
                initialValue: [8, textures[this.__textureProperties._BumpMap]], min: 0, max: Number.MAX_SAFE_INTEGER,
            });
            if (this.__textureProperties._BumpMap !== textures.length - 2) { //textures.length - 2 is dummyTexture
                this.__definitions += '#define RN_MTOON_HAS_BUMPMAP\n';
            }
            if (isOutline) {
                shaderSemanticsInfoArray.push({
                    semantic: MToonSingleMaterialNode._OutlineWidthTexture, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_6__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_7__["CompositionType"].Texture2D,
                    stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].VertexShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_14__["ShaderVariableUpdateInterval"].EveryTime,
                    initialValue: [9, textures[this.__textureProperties._OutlineWidthTexture]], min: 0, max: Number.MAX_SAFE_INTEGER,
                });
                if (this.__textureProperties._OutlineWidthTexture !== textures.length - 2) { //textures.length - 2 is dummyTexture
                    this.__definitions += '#define RN_MTOON_HAS_OUTLINE_WIDTH_TEXTURE\n';
                }
            }
        }
    }
    setMaterialParameters(material, isOutline) {
        if (MToonSingleMaterialNode.usableBlendEquationModeAlpha == null) {
            MToonSingleMaterialNode.__initializeUsableBlendEquationModeAlpha();
        }
        if (this.__floatProperties._BlendMode !== 0) {
            switch (this.__floatProperties._BlendMode) {
                case 1:
                    this.__definitions += '#define RN_ALPHATEST_ON\n';
                    material.alphaMode = _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_1__["AlphaMode"].Mask;
                    break;
                case 2:
                    this.__definitions += '#define RN_ALPHABLEND_ON\n';
                    material.alphaMode = _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_1__["AlphaMode"].Translucent;
                    break;
                case 3:
                    this.__definitions += '#define RN_ALPHABLEND_ON\n';
                    material.alphaMode = _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_1__["AlphaMode"].Translucent;
                    break;
            }
            const blendEquationMode = 32774; // gl.FUNC_ADD
            const blendEquationModeAlpha = MToonSingleMaterialNode.usableBlendEquationModeAlpha;
            const blendFuncSrcFactor = MToonSingleMaterialNode.unityBlendEnumCorrespondence(this.__floatProperties._SrcBlend);
            const blendFuncDstFactor = MToonSingleMaterialNode.unityBlendEnumCorrespondence(this.__floatProperties._DstBlend);
            material.setBlendEquationMode(blendEquationMode, blendEquationModeAlpha);
            material.setBlendFuncFactor(blendFuncSrcFactor, blendFuncDstFactor);
        }
        if (isOutline) {
            switch (this.__floatProperties._OutlineCullMode) {
                case 0:
                    material.cullFace = false;
                    break;
                case 1:
                    material.cullFace = true;
                    material.cullFrontFaceCCW = false;
                    break;
                case 2:
                    material.cullFace = true;
                    material.cullFrontFaceCCW = true;
                    break;
            }
        }
        else {
            switch (this.__floatProperties._CullMode) {
                case 0:
                    material.cullFace = false;
                    break;
                case 1:
                    material.cullFace = true;
                    material.cullFrontFaceCCW = false;
                    break;
                case 2:
                    material.cullFace = true;
                    material.cullFrontFaceCCW = true;
                    break;
            }
        }
    }
    static __initializeUsableBlendEquationModeAlpha() {
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getWebGLResourceRepository();
        const glw = webGLResourceRepository.currentWebGLContextWrapper;
        const gl = glw.getRawContext();
        if (glw.isWebGL2) {
            MToonSingleMaterialNode.usableBlendEquationModeAlpha = gl.MAX;
        }
        else if (glw.webgl1ExtBM) {
            MToonSingleMaterialNode.usableBlendEquationModeAlpha = glw.webgl1ExtBM.MAX_EXT;
        }
        else {
            MToonSingleMaterialNode.usableBlendEquationModeAlpha = gl.FUNC_ADD;
        }
    }
    setParametersForGPU({ material, shaderProgram, firstTime, args }) {
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
            cameraComponent = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_5__["default"].getInstance().getComponent(_components_CameraComponent__WEBPACK_IMPORTED_MODULE_3__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_3__["default"].main);
        }
        if (args.setUniform) {
            /// Matrices
            this.setWorldMatrix(shaderProgram, args.worldMatrix);
            this.setNormalMatrix(shaderProgram, args.normalMatrix);
            this.setViewInfo(shaderProgram, cameraComponent, material, args.setUniform);
            this.setProjection(shaderProgram, cameraComponent, material, args.setUniform);
            /// Skinning
            const skeletalComponent = args.entity.getSkeletal();
            this.setSkinning(shaderProgram, skeletalComponent, args.setUniform);
            // Lights
            this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
            shaderProgram._gl.uniform3fv(shaderProgram.cameraUp, cameraComponent.upInner.v);
            if (this.__OutlineWidthModeIsScreen) {
                shaderProgram._gl.uniform1f(shaderProgram.aspect, cameraComponent.aspect);
            }
        }
        else {
            material.setParameter(MToonSingleMaterialNode.CameraUp, cameraComponent.upInner);
            if (this.__OutlineWidthModeIsScreen) {
                material.setParameter(MToonSingleMaterialNode.Aspect, cameraComponent.aspect);
            }
        }
        // Morph
        this.setMorphInfo(shaderProgram, args.entity.getComponent(_components_MeshComponent__WEBPACK_IMPORTED_MODULE_9__["default"]), args.entity.getComponent(_components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_2__["default"]), args.primitive);
    }
    static unityBlendEnumCorrespondence(enumNumber) {
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getWebGLResourceRepository();
        const glw = webGLResourceRepository.currentWebGLContextWrapper;
        const gl = glw.getRawContext();
        let result;
        switch (enumNumber) {
            case 0:
                result = gl.ZERO;
                break;
            case 1:
                result = gl.ONE;
                break;
            case 2:
                result = gl.DST_COLOR;
                break;
            case 3:
                result = gl.SRC_COLOR;
                break;
            case 4:
                result = gl.ONE_MINUS_DST_COLOR;
                break;
            case 5:
                result = gl.SRC_ALPHA;
                break;
            case 6:
                result = gl.ONE_MINUS_SRC_COLOR;
                break;
            case 7:
                result = gl.DST_ALPHA;
                break;
            case 8:
                result = gl.ONE_MINUS_DST_ALPHA;
                break;
            case 9:
                result = gl.SRC_ALPHA_SATURATE;
                break;
            case 10:
                result = gl.ONE_MINUS_SRC_ALPHA;
                break;
        }
        return result;
    }
}
MToonSingleMaterialNode._Cutoff = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'cutoff' });
MToonSingleMaterialNode._Color = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'litColor' });
MToonSingleMaterialNode._ShadeColor = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'shadeColor' });
MToonSingleMaterialNode._MainTex = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'litColorTexture' });
MToonSingleMaterialNode._ShadeTexture = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'shadeColorTexture' });
MToonSingleMaterialNode._BumpScale = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'normalScale' });
MToonSingleMaterialNode._BumpMap = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'normalTexture' });
MToonSingleMaterialNode._ReceiveShadowRate = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'receiveShadowRate' });
MToonSingleMaterialNode._ReceiveShadowTexture = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'receiveShadowTexture' });
MToonSingleMaterialNode._ShadingGradeRate = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'shadingGradeRate' });
MToonSingleMaterialNode._ShadingGradeTexture = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'shadingGradeTexture' });
MToonSingleMaterialNode._ShadeShift = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'shadeShift' });
MToonSingleMaterialNode._ShadeToony = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'shadeToony' });
MToonSingleMaterialNode._LightColorAttenuation = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'lightColorAttenuation' });
MToonSingleMaterialNode._AmbientColor = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'ambientColor' });
// static readonly _IndirectLightIntensity = new ShaderSemanticsClass({ str: 'indirectLightIntensity' });
MToonSingleMaterialNode._RimTexture = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'rimTexture' });
MToonSingleMaterialNode._RimColor = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'rimColor' });
MToonSingleMaterialNode._RimLightingMix = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'rimLightingMix' });
MToonSingleMaterialNode._RimFresnelPower = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'rimFresnelPower' });
MToonSingleMaterialNode._RimLift = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'rimLift' });
MToonSingleMaterialNode._SphereAdd = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'matCapTexture' });
MToonSingleMaterialNode._EmissionColor = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'emissionColor' });
MToonSingleMaterialNode._EmissionMap = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'emissionTexture' });
MToonSingleMaterialNode._OutlineWidthTexture = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'outlineWidthTexture' });
MToonSingleMaterialNode._OutlineWidth = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'outlineWidth' });
MToonSingleMaterialNode._OutlineScaledMaxDistance = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'outlineScaledMaxDistance' });
MToonSingleMaterialNode._OutlineColor = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'outlineColor' });
MToonSingleMaterialNode._OutlineLightingMix = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'outlineLightingMix' });
MToonSingleMaterialNode.Aspect = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'aspect' });
MToonSingleMaterialNode.CameraUp = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_12__["ShaderSemanticsClass"]({ str: 'cameraUp' });


/***/ }),

/***/ "./src/foundation/materials/singles/PbrShadingSingleMaterialNode.ts":
/*!**************************************************************************!*\
  !*** ./src/foundation/materials/singles/PbrShadingSingleMaterialNode.ts ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PbrShadingSingleMaterialNode; });
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Vector2 */ "./src/foundation/math/Vector2.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _math_Vector4__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../definitions/HdriFormat */ "./src/foundation/definitions/HdriFormat.ts");
/* harmony import */ var _math_Scalar__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../math/Scalar */ "./src/foundation/math/Scalar.ts");
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _math_VectorN__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../math/VectorN */ "./src/foundation/math/VectorN.ts");
/* harmony import */ var _components_MeshComponent__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../components/MeshComponent */ "./src/foundation/components/MeshComponent.ts");
/* harmony import */ var _components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../components/BlendShapeComponent */ "./src/foundation/components/BlendShapeComponent.ts");
/* harmony import */ var _webgl_shaderity_shaders_PbrSingleShader_PbrSingleShader_vert__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/PbrSingleShader/PbrSingleShader.vert */ "./src/webgl/shaderity_shaders/PbrSingleShader/PbrSingleShader.vert");
/* harmony import */ var _webgl_shaderity_shaders_PbrSingleShader_PbrSingleShader_frag__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../../webgl/shaderity_shaders/PbrSingleShader/PbrSingleShader.frag */ "./src/webgl/shaderity_shaders/PbrSingleShader/PbrSingleShader.frag");
/* harmony import */ var _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../definitions/AlphaMode */ "./src/foundation/definitions/AlphaMode.ts");





















class PbrShadingSingleMaterialNode extends _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor({ isMorphing, isSkinning, isLighting, alphaMode }) {
        super(null, 'pbrShading'
            + (isMorphing ? '+morphing' : '')
            + (isSkinning ? '+skinning' : '')
            + (isLighting ? '' : '-lighting')
            + ' alpha_' + alphaMode.str.toLowerCase(), { isMorphing, isSkinning, isLighting }, _webgl_shaderity_shaders_PbrSingleShader_PbrSingleShader_vert__WEBPACK_IMPORTED_MODULE_18__["default"], _webgl_shaderity_shaders_PbrSingleShader_PbrSingleShader_frag__WEBPACK_IMPORTED_MODULE_19__["default"]);
        const shaderSemanticsInfoArray = [
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].BaseColorFactor, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: 2, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Vector4__WEBPACK_IMPORTED_MODULE_6__["default"](1, 1, 1, 1)
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].BaseColorTexture, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Texture2D, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: Number.MAX_SAFE_INTEGER, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: [0, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyWhiteTexture]
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].MetallicRoughnessFactor, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec2, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: 2, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["default"](1, 1)
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].MetallicRoughnessTexture, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Texture2D, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: Number.MAX_SAFE_INTEGER, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: [1, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyWhiteTexture]
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].NormalTexture, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Texture2D, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: Number.MAX_SAFE_INTEGER, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: [2, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyBlueTexture]
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].OcclusionTexture, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Texture2D, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: Number.MAX_SAFE_INTEGER, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: [3, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyWhiteTexture]
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].EmissiveTexture, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Texture2D, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: Number.MAX_SAFE_INTEGER, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: [4, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyBlackTexture]
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].Wireframe, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec3, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: 10, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_7__["default"](0, 0, 1)
            },
            {
                semantic: PbrShadingSingleMaterialNode.IsOutputHDR, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Bool,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: 1, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0)
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].IBLParameter, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Vector4__WEBPACK_IMPORTED_MODULE_6__["default"](1, 1, 1, 1),
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].HDRIFormat, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec2, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: 5, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["default"](0, 0)
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].DiffuseEnvTexture, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].TextureCube, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: Number.MAX_SAFE_INTEGER, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: [5, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyWhiteTexture]
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].SpecularEnvTexture, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].TextureCube, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: Number.MAX_SAFE_INTEGER, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: [6, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyWhiteTexture]
            },
            {
                semantic: PbrShadingSingleMaterialNode.BaseColorTextureTransform, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: -10, max: 10, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Vector4__WEBPACK_IMPORTED_MODULE_6__["default"](1, 1, 0, 0)
            },
            {
                semantic: PbrShadingSingleMaterialNode.BaseColorTextureRotation, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: -Math.PI, max: Math.PI, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0)
            },
            {
                semantic: PbrShadingSingleMaterialNode.NormalTextureTransform, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: -10, max: 10, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Vector4__WEBPACK_IMPORTED_MODULE_6__["default"](1, 1, 0, 0)
            },
            {
                semantic: PbrShadingSingleMaterialNode.NormalTextureRotation, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: -Math.PI, max: Math.PI, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0)
            },
            {
                semantic: PbrShadingSingleMaterialNode.MetallicRoughnessTextureTransform, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: -10, max: 10, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Vector4__WEBPACK_IMPORTED_MODULE_6__["default"](1, 1, 0, 0)
            },
            {
                semantic: PbrShadingSingleMaterialNode.MetallicRoughnessTextureRotation, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: -Math.PI, max: Math.PI, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0)
            },
            {
                semantic: PbrShadingSingleMaterialNode.NormalTexcoordIndex, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: 1, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0)
            },
            {
                semantic: PbrShadingSingleMaterialNode.BaseColorTexcoordIndex, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: 1, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0)
            },
            {
                semantic: PbrShadingSingleMaterialNode.MetallicRoughnessTexcoordIndex, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: 1, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0)
            },
            {
                semantic: PbrShadingSingleMaterialNode.OcclusionTexcoordIndex, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: 1, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0)
            },
            {
                semantic: PbrShadingSingleMaterialNode.EmissiveTexcoordIndex, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: 1, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0)
            }
        ];
        shaderSemanticsInfoArray.push({
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].PointSize, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: true,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](30.0), min: 0, max: 100,
        }, {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].PointDistanceAttenuation, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec3,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: true,
            initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_7__["default"](0.0, 0.1, 0.01), min: 0, max: 1,
        });
        if (isLighting) {
            this.__definitions += '#define RN_IS_LIGHTING\n';
        }
        if (isSkinning) {
            this.__definitions += '#define RN_IS_SKINNING\n';
        }
        if (isMorphing) {
            this.__definitions += '#define RN_IS_MORPHING\n';
            shaderSemanticsInfoArray.push({
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].MorphTargetNumber, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, soloDatum: true,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0), min: 0, max: _core_Config__WEBPACK_IMPORTED_MODULE_14__["default"].maxVertexMorphNumberInShader, needUniformInFastest: true
            }, {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].DataTextureMorphOffsetPosition, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].ScalarArray, maxIndex: _core_Config__WEBPACK_IMPORTED_MODULE_14__["default"].maxVertexMorphNumberInShader,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, soloDatum: true,
                initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_15__["default"](new Float32Array(_core_Config__WEBPACK_IMPORTED_MODULE_14__["default"].maxVertexMorphNumberInShader)), min: -Number.MAX_VALUE, max: Number.MAX_VALUE, needUniformInFastest: true
            }, {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].MorphWeights, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].ScalarArray, maxIndex: _core_Config__WEBPACK_IMPORTED_MODULE_14__["default"].maxVertexMorphNumberInShader,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, soloDatum: true,
                initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_15__["default"](new Float32Array(_core_Config__WEBPACK_IMPORTED_MODULE_14__["default"].maxVertexMorphNumberInShader)), min: -Number.MAX_VALUE, max: Number.MAX_VALUE, needUniformInFastest: true
            });
        }
        this.__definitions += '#define RN_IS_ALPHAMODE_' + alphaMode.str + '\n';
        if (alphaMode === _definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_20__["AlphaMode"].Mask) {
            shaderSemanticsInfoArray.push({
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].AlphaCutoff, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_4__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, min: 0, max: 1.0, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].EveryTime, initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0.01)
            });
        }
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
    }
    setParametersForGPU({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
            this.setWorldMatrix(shaderProgram, args.worldMatrix);
            this.setNormalMatrix(shaderProgram, args.normalMatrix);
            if (firstTime) {
                /// Matrices
                let cameraComponent = args.renderPass.cameraComponent;
                if (cameraComponent == null) {
                    cameraComponent = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_10__["default"].getInstance().getComponent(_components_CameraComponent__WEBPACK_IMPORTED_MODULE_11__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_11__["default"].main);
                }
                this.setViewInfo(shaderProgram, cameraComponent, material, args.setUniform);
                this.setProjection(shaderProgram, cameraComponent, material, args.setUniform);
                // Lights
                this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
            }
            /// Skinning
            const skeletalComponent = args.entity.getSkeletal();
            this.setSkinning(shaderProgram, skeletalComponent, args.setUniform);
        }
        // Env map
        if (args.diffuseCube && args.diffuseCube.isTextureReady) {
            this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].DiffuseEnvTexture.str, firstTime, [5, args.diffuseCube]);
        }
        else {
            this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].DiffuseEnvTexture.str, firstTime, [5, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyBlackCubeTexture]);
        }
        if (args.specularCube && args.specularCube.isTextureReady) {
            this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].SpecularEnvTexture.str, firstTime, [6, args.specularCube]);
        }
        else {
            this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].SpecularEnvTexture.str, firstTime, [6, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyBlackCubeTexture]);
        }
        if (args.setUniform) {
            if (firstTime) {
                const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = this.setupHdriParameters(args);
                this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].IBLParameter.str, firstTime, {
                    x: mipmapLevelNumber,
                    y: meshRenderComponent.diffuseCubeMapContribution,
                    z: meshRenderComponent.specularCubeMapContribution, w: meshRenderComponent.rotationOfCubeMap
                });
                this.__webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].HDRIFormat.str, firstTime, { x: diffuseHdriType, y: specularHdriType });
            }
        }
        else {
            const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = this.setupHdriParameters(args);
            const tmp_vector4 = _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__tmp_vector4;
            tmp_vector4.x = mipmapLevelNumber;
            tmp_vector4.y = meshRenderComponent.diffuseCubeMapContribution;
            tmp_vector4.z = meshRenderComponent.specularCubeMapContribution;
            tmp_vector4.w = meshRenderComponent.rotationOfCubeMap;
            material.setParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].IBLParameter, tmp_vector4);
            const tmp_vector2 = _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__tmp_vector2;
            tmp_vector2.x = diffuseHdriType;
            tmp_vector2.y = specularHdriType;
            material.setParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].HDRIFormat, tmp_vector2);
        }
        // Morph
        this.setMorphInfo(shaderProgram, args.entity.getComponent(_components_MeshComponent__WEBPACK_IMPORTED_MODULE_16__["default"]), args.entity.getComponent(_components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_17__["default"]), args.primitive);
    }
    setupHdriParameters(args) {
        let mipmapLevelNumber = 1;
        if (args.specularCube) {
            mipmapLevelNumber = args.specularCube.mipmapLevelNumber;
        }
        const meshRenderComponent = args.entity.getMeshRenderer();
        let diffuseHdriType = _definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_12__["HdriFormat"].LDR_SRGB.index;
        let specularHdriType = _definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_12__["HdriFormat"].LDR_SRGB.index;
        if (meshRenderComponent.diffuseCubeMap) {
            diffuseHdriType = meshRenderComponent.diffuseCubeMap.hdriFormat.index;
        }
        if (meshRenderComponent.specularCubeMap) {
            specularHdriType = meshRenderComponent.specularCubeMap.hdriFormat.index;
        }
        return { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType };
    }
}
PbrShadingSingleMaterialNode.__pbrCookTorranceBrdfLutDataUrlUid = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_5__["default"].InvalidCGAPIResourceUid;
PbrShadingSingleMaterialNode.IsOutputHDR = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'isOutputHDR' });
PbrShadingSingleMaterialNode.BaseColorTextureTransform = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'baseColorTextureTransform' });
PbrShadingSingleMaterialNode.BaseColorTextureRotation = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'baseColorTextureRotation' });
PbrShadingSingleMaterialNode.NormalTextureTransform = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'normalTextureTransform' });
PbrShadingSingleMaterialNode.NormalTextureRotation = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'normalTextureRotation' });
PbrShadingSingleMaterialNode.MetallicRoughnessTextureTransform = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'metallicRoughnessTextureTransform' });
PbrShadingSingleMaterialNode.MetallicRoughnessTextureRotation = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'metallicRoughnessTextureRotation' });
PbrShadingSingleMaterialNode.NormalTexcoordIndex = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'normalTexcoordIndex' });
PbrShadingSingleMaterialNode.BaseColorTexcoordIndex = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'baseColorTexcoordIndex' });
PbrShadingSingleMaterialNode.MetallicRoughnessTexcoordIndex = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'metallicRoughnessTexcoordIndex' });
PbrShadingSingleMaterialNode.OcclusionTexcoordIndex = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'occlusionTexcoordIndex' });
PbrShadingSingleMaterialNode.EmissiveTexcoordIndex = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'emissiveTexcoordIndex' });


/***/ }),

/***/ "./src/foundation/materials/singles/ShadowMapDecodeClassicSingleMaterialNode.ts":
/*!**************************************************************************************!*\
  !*** ./src/foundation/materials/singles/ShadowMapDecodeClassicSingleMaterialNode.ts ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShadowMapDecodeClassicSingleMaterialNode; });
/* harmony import */ var _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _math_Vector4__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../definitions/ShadingModel */ "./src/foundation/definitions/ShadingModel.ts");
/* harmony import */ var _webgl_shaders_ShadowMapDecodeClassicShader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../webgl/shaders/ShadowMapDecodeClassicShader */ "./src/webgl/shaders/ShadowMapDecodeClassicShader.ts");
/* harmony import */ var _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _math_VectorN__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../math/VectorN */ "./src/foundation/math/VectorN.ts");
/* harmony import */ var _math_Scalar__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../math/Scalar */ "./src/foundation/math/Scalar.ts");
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _components_SkeletalComponent__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../components/SkeletalComponent */ "./src/foundation/components/SkeletalComponent.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _components_MeshComponent__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../components/MeshComponent */ "./src/foundation/components/MeshComponent.ts");
/* harmony import */ var _components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../components/BlendShapeComponent */ "./src/foundation/components/BlendShapeComponent.ts");




















class ShadowMapDecodeClassicSingleMaterialNode extends _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * The constructor of the ShadowMapDecodeClassicSingleMaterialNode
     * @param isMorphing True if the morphing is to be applied
     * @param isSkinning True if the skeleton is to be applied
     * @param isLighting True if the lighting is to be applied. When isLighting is false, the Shader draws the original color of the material, except for the shadow area.
     * @param isDebugging True if the shader displays the DebugColorFactor color in areas outside of the depth map.
     * @param colorAttachmentsNumber The index of colorAttachment in a framebuffer. The colorAttachment must have depth information drawn by the DepthEncodeSingleMaterialNode.
     * @param encodedDepthRenderPass The render pass where the depth information from the DepthEncodeSingleMaterialNode is drawn to the frame buffer
     */
    constructor({ isMorphing, isSkinning, isLighting, isDebugging, colorAttachmentsNumber }, encodedDepthRenderPass) {
        super(_webgl_shaders_ShadowMapDecodeClassicShader__WEBPACK_IMPORTED_MODULE_7__["default"].getInstance(), "ShadowMapDecodeClassicShading"
            + (isSkinning ? '+skinning' : '')
            + (isLighting ? '' : '-lighting'), { isMorphing, isSkinning, isLighting });
        this.__encodedDepthRenderPass = encodedDepthRenderPass;
        const encodedDepthFramebuffer = encodedDepthRenderPass.getFramebuffer();
        if (encodedDepthFramebuffer == null) {
            console.error('encodedDepthRenderPass does not have framebuffer');
            return;
        }
        const encodedDepthTexture = encodedDepthFramebuffer.colorAttachments[colorAttachmentsNumber];
        const viewport = encodedDepthRenderPass.getViewport();
        viewport.setComponents(1, 1, viewport.z - 1, viewport.w - 1);
        encodedDepthRenderPass.setViewport(viewport);
        const shaderSemanticsInfoArray = [
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].LightViewProjectionMatrix, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Mat4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_17__["default"].zero(), min: -Number.MAX_VALUE, max: Number.MAX_VALUE,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].ShadingModel, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](_definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_6__["ShadingModel"].Constant.index), min: 0, max: 3,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].Shininess, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](5), min: 0, max: Number.MAX_VALUE,
            },
            {
                semantic: ShadowMapDecodeClassicSingleMaterialNode.AllowableDepthError, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0.0001), min: 0, max: 1,
            },
            {
                semantic: ShadowMapDecodeClassicSingleMaterialNode.ShadowColorCoefficient, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: false,
                initialValue: new _math_Vector4__WEBPACK_IMPORTED_MODULE_4__["default"](0.5, 0.5, 0.5, 1), min: 0, max: 1,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].DiffuseColorFactor, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: false,
                initialValue: new _math_Vector4__WEBPACK_IMPORTED_MODULE_4__["default"](1, 1, 1, 1), min: 0, max: 2,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].DepthTexture, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Texture2D, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].EveryTime,
                initialValue: [0, encodedDepthTexture], min: 0, max: Number.MAX_SAFE_INTEGER,
            },
            {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].DiffuseColorTexture, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Texture2D, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Int,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].EveryTime,
                initialValue: [1, _core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_1__["default"].__dummyWhiteTexture], min: 0, max: Number.MAX_SAFE_INTEGER,
            },
            {
                semantic: ShadowMapDecodeClassicSingleMaterialNode.zNearInner, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0.1), min: 0.0001, max: Number.MAX_SAFE_INTEGER
            },
            {
                semantic: ShadowMapDecodeClassicSingleMaterialNode.zFarInner, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].EveryTime, soloDatum: false,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](10000.0), min: 0.0001, max: Number.MAX_SAFE_INTEGER
            }
        ];
        shaderSemanticsInfoArray.push({
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].PointSize, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: true,
            initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](30.0), min: 0, max: 100,
        }, {
            semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].PointDistanceAttenuation, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec3,
            stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: true,
            initialValue: new _math_Vector3__WEBPACK_IMPORTED_MODULE_5__["default"](0.0, 0.1, 0.01), min: 0, max: 1,
        });
        if (isSkinning) {
            this.__definitions += '#define RN_IS_SKINNING\n';
        }
        if (isLighting) {
            this.__definitions += '#define RN_IS_LIGHTING\n';
        }
        if (isMorphing) {
            this.__definitions += '#define RN_IS_MORPHING\n';
            shaderSemanticsInfoArray.push({
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].MorphTargetNumber, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Int, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Scalar,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, soloDatum: true,
                initialValue: new _math_Scalar__WEBPACK_IMPORTED_MODULE_13__["default"](0), min: 0, max: _core_Config__WEBPACK_IMPORTED_MODULE_14__["default"].maxVertexMorphNumberInShader, needUniformInFastest: true
            }, {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].DataTextureMorphOffsetPosition, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].ScalarArray, maxIndex: _core_Config__WEBPACK_IMPORTED_MODULE_14__["default"].maxVertexMorphNumberInShader,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, soloDatum: true,
                initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_12__["default"](new Float32Array(_core_Config__WEBPACK_IMPORTED_MODULE_14__["default"].maxVertexMorphNumberInShader)), min: -Number.MAX_VALUE, max: Number.MAX_VALUE, needUniformInFastest: true
            }, {
                semantic: _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].MorphWeights, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].ScalarArray, maxIndex: _core_Config__WEBPACK_IMPORTED_MODULE_14__["default"].maxVertexMorphNumberInShader,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].VertexShader, isSystem: true, soloDatum: true,
                initialValue: new _math_VectorN__WEBPACK_IMPORTED_MODULE_12__["default"](new Float32Array(_core_Config__WEBPACK_IMPORTED_MODULE_14__["default"].maxVertexMorphNumberInShader)), min: -Number.MAX_VALUE, max: Number.MAX_VALUE, needUniformInFastest: true
            });
        }
        if (isDebugging) {
            this.__definitions += '#define RN_IS_DEBUGGING\n';
            shaderSemanticsInfoArray.push({
                semantic: ShadowMapDecodeClassicSingleMaterialNode.DebugColorFactor, compositionType: _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_2__["CompositionType"].Vec4, componentType: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float,
                stage: _definitions_ShaderType__WEBPACK_IMPORTED_MODULE_8__["ShaderType"].PixelShader, isSystem: false, updateInterval: _definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_9__["ShaderVariableUpdateInterval"].FirstTimeOnly, soloDatum: false,
                initialValue: new _math_Vector4__WEBPACK_IMPORTED_MODULE_4__["default"](1, 0, 0, 1), min: 0, max: 2,
            });
        }
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
    }
    setParametersForGPU({ material, shaderProgram, firstTime, args }) {
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
            cameraComponent = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_10__["default"].getInstance().getComponent(_components_CameraComponent__WEBPACK_IMPORTED_MODULE_11__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_11__["default"].main);
        }
        const encodedDepthCameraComponent = this.__encodedDepthRenderPass.cameraComponent;
        if (args.setUniform) {
            this.setWorldMatrix(shaderProgram, args.worldMatrix);
            this.setNormalMatrix(shaderProgram, args.normalMatrix);
            this.setViewInfo(shaderProgram, cameraComponent, material, args.setUniform);
            this.setProjection(shaderProgram, cameraComponent, material, args.setUniform);
            if (ShadowMapDecodeClassicSingleMaterialNode.__lastZNear !== encodedDepthCameraComponent.zNearInner) {
                shaderProgram._gl.uniform1f(shaderProgram.zNearInner, encodedDepthCameraComponent.zNearInner);
                ShadowMapDecodeClassicSingleMaterialNode.__lastZNear = encodedDepthCameraComponent.zNearInner;
            }
            if (ShadowMapDecodeClassicSingleMaterialNode.__lastZFar !== encodedDepthCameraComponent.zFarInner) {
                shaderProgram._gl.uniform1f(shaderProgram.zFarInner, encodedDepthCameraComponent.zFarInner);
                ShadowMapDecodeClassicSingleMaterialNode.__lastZFar = encodedDepthCameraComponent.zFarInner;
            }
            const __webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_16__["default"].getWebGLResourceRepository();
            __webglResourceRepository.setUniformValue(shaderProgram, _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].LightViewProjectionMatrix.str, true, this.__encodedDepthRenderPass.cameraComponent.viewProjectionMatrix);
        }
        else {
            material.setParameter(ShadowMapDecodeClassicSingleMaterialNode.zNearInner, encodedDepthCameraComponent.zNearInner);
            material.setParameter(ShadowMapDecodeClassicSingleMaterialNode.zFarInner, encodedDepthCameraComponent.zFarInner);
            material.setParameter(_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemantics"].LightViewProjectionMatrix, this.__encodedDepthRenderPass.cameraComponent.viewProjectionMatrix);
        }
        /// Skinning
        const skeletalComponent = args.entity.getComponent(_components_SkeletalComponent__WEBPACK_IMPORTED_MODULE_15__["default"]);
        this.setSkinning(shaderProgram, skeletalComponent, args.setUniform);
        // Lights
        this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
        // Morph
        this.setMorphInfo(shaderProgram, args.entity.getComponent(_components_MeshComponent__WEBPACK_IMPORTED_MODULE_18__["default"]), args.entity.getComponent(_components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_19__["default"]), args.primitive);
    }
}
ShadowMapDecodeClassicSingleMaterialNode.ShadowColorCoefficient = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'shadowColorCoefficient' });
ShadowMapDecodeClassicSingleMaterialNode.ShadowAlpha = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'shadowAlpha' });
ShadowMapDecodeClassicSingleMaterialNode.NonShadowAlpha = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'nonShadowAlpha' });
ShadowMapDecodeClassicSingleMaterialNode.AllowableDepthError = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'allowableDepthError' });
ShadowMapDecodeClassicSingleMaterialNode.zNearInner = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'zNearInner' });
ShadowMapDecodeClassicSingleMaterialNode.zFarInner = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'zFarInner' });
ShadowMapDecodeClassicSingleMaterialNode.DebugColorFactor = new _definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_0__["ShaderSemanticsClass"]({ str: 'debugColorFactor' });
ShadowMapDecodeClassicSingleMaterialNode.__lastZNear = 0.0;
ShadowMapDecodeClassicSingleMaterialNode.__lastZFar = 0.0;


/***/ }),

/***/ "./src/foundation/math/AABB.ts":
/*!*************************************!*\
  !*** ./src/foundation/math/AABB.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AABB; });
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _MutableVector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MutableVector3 */ "./src/foundation/math/MutableVector3.ts");


class AABB {
    constructor() {
        this.__min = new _MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"](Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this.__max = new _MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"](-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        this.__centerPoint = _MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
        this.__lengthCenterToCorner = 0;
        this.__isCenterPointDirty = false;
        this.__isLengthCenterToCornerDirty = false;
    }
    clone() {
        let instance = new AABB();
        instance.__max = this.__max.clone();
        instance.__min = this.__min.clone();
        instance.__centerPoint = this.__centerPoint.clone();
        instance.__lengthCenterToCorner = this.__lengthCenterToCorner;
        instance.__isCenterPointDirty = this.__isCenterPointDirty;
        instance.__isLengthCenterToCornerDirty = this.__isLengthCenterToCornerDirty;
        return instance;
    }
    initialize() {
        this.__min.setComponents(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this.__max.setComponents(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        this.__centerPoint.zero();
        this.__lengthCenterToCorner = 0;
        this.__isCenterPointDirty = false;
        this.__isLengthCenterToCornerDirty = false;
    }
    set minPoint(val) {
        this.__min.copyComponents(val);
        this.__isCenterPointDirty = true;
        this.__isLengthCenterToCornerDirty = true;
    }
    get minPoint() {
        return this.__min;
    }
    set maxPoint(val) {
        this.__max.copyComponents(val);
        this.__isCenterPointDirty = true;
        this.__isLengthCenterToCornerDirty = true;
    }
    get maxPoint() {
        return this.__max;
    }
    isVanilla() {
        if (this.__min.x >= Number.MAX_VALUE && this.__min.y >= Number.MAX_VALUE && this.__min.z >= Number.MAX_VALUE
            && this.__max.x <= -Number.MAX_VALUE && this.__max.y <= -Number.MAX_VALUE && this.__max.z <= -Number.MAX_VALUE) {
            return true;
        }
        else {
            return false;
        }
    }
    addPosition(positionVector) {
        this.__min.x = (positionVector.x < this.__min.x) ? positionVector.x : this.__min.x;
        this.__min.y = (positionVector.y < this.__min.y) ? positionVector.y : this.__min.y;
        this.__min.z = (positionVector.z < this.__min.z) ? positionVector.z : this.__min.z;
        this.__max.x = (this.__max.x < positionVector.x) ? positionVector.x : this.__max.x;
        this.__max.y = (this.__max.y < positionVector.y) ? positionVector.y : this.__max.y;
        this.__max.z = (this.__max.z < positionVector.z) ? positionVector.z : this.__max.z;
        this.__isCenterPointDirty = true;
        this.__isLengthCenterToCornerDirty = true;
        return positionVector;
    }
    addPositionWithArray(array, index) {
        this.__min.x = (array[index + 0] < this.__min.x) ? array[index + 0] : this.__min.x;
        this.__min.y = (array[index + 1] < this.__min.y) ? array[index + 1] : this.__min.y;
        this.__min.z = (array[index + 2] < this.__min.z) ? array[index + 2] : this.__min.z;
        this.__max.x = (this.__max.x < array[index + 0]) ? array[index + 0] : this.__max.x;
        this.__max.y = (this.__max.y < array[index + 1]) ? array[index + 1] : this.__max.y;
        this.__max.z = (this.__max.z < array[index + 2]) ? array[index + 2] : this.__max.z;
        this.__isCenterPointDirty = true;
        this.__isLengthCenterToCornerDirty = true;
        return array;
    }
    mergeAABB(aabb) {
        var isUpdated = false;
        if (aabb.isVanilla()) {
            return isUpdated;
        }
        this.__isCenterPointDirty = true;
        this.__isLengthCenterToCornerDirty = true;
        if (this.isVanilla()) {
            this.__min.x = aabb.minPoint.x;
            this.__min.y = aabb.minPoint.y;
            this.__min.z = aabb.minPoint.z;
            this.__max.x = aabb.maxPoint.x;
            this.__max.y = aabb.maxPoint.y;
            this.__max.z = aabb.maxPoint.z;
            isUpdated = true;
            return isUpdated;
        }
        if (aabb.minPoint.x < this.__min.x) {
            this.__min.x = aabb.minPoint.x;
            isUpdated = true;
        }
        if (aabb.minPoint.y < this.__min.y) {
            this.__min.y = aabb.minPoint.y;
            isUpdated = true;
        }
        if (aabb.minPoint.z < this.__min.z) {
            this.__min.z = aabb.minPoint.z;
            isUpdated = true;
        }
        if (this.__max.x < aabb.maxPoint.x) {
            this.__max.x = aabb.maxPoint.x;
            isUpdated = true;
        }
        if (this.__max.y < aabb.maxPoint.y) {
            this.__max.y = aabb.maxPoint.y;
            isUpdated = true;
        }
        if (this.__max.z < aabb.maxPoint.z) {
            this.__max.z = aabb.maxPoint.z;
            isUpdated = true;
        }
        return isUpdated;
    }
    get centerPoint() {
        if (this.__isCenterPointDirty) {
            _MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].addTo(this.__min, this.__max, this.__centerPoint).divide(2);
            this.__isCenterPointDirty = false;
        }
        return this.__centerPoint;
    }
    get lengthCenterToCorner() {
        if (this.__isLengthCenterToCornerDirty) {
            this.__lengthCenterToCorner = _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].lengthBtw(this.centerPoint, this.maxPoint);
            this.__isLengthCenterToCornerDirty = false;
        }
        return this.__lengthCenterToCorner;
    }
    get sizeX() {
        return (this.__max.x - this.__min.x);
    }
    get sizeY() {
        return (this.__max.y - this.__min.y);
    }
    get sizeZ() {
        return (this.__max.z - this.__min.z);
    }
    static multiplyMatrix(matrix, aabb) {
        if (aabb.isVanilla()) {
            return aabb.clone();
        }
        var newAabb = new AABB();
        AABB.__tmpVector3.x = aabb.__min.x;
        AABB.__tmpVector3.y = aabb.__min.y;
        AABB.__tmpVector3.z = aabb.__min.z;
        newAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__max.x;
        AABB.__tmpVector3.y = aabb.__min.y;
        AABB.__tmpVector3.z = aabb.__min.z;
        newAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__min.x;
        AABB.__tmpVector3.y = aabb.__max.y;
        AABB.__tmpVector3.z = aabb.__min.z;
        newAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__min.x;
        AABB.__tmpVector3.y = aabb.__min.y;
        AABB.__tmpVector3.z = aabb.__max.z;
        newAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__min.x;
        AABB.__tmpVector3.y = aabb.__max.y;
        AABB.__tmpVector3.z = aabb.__max.z;
        newAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__max.x;
        AABB.__tmpVector3.y = aabb.__min.y;
        AABB.__tmpVector3.z = aabb.__max.z;
        newAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__max.x;
        AABB.__tmpVector3.y = aabb.__max.y;
        AABB.__tmpVector3.z = aabb.__min.z;
        newAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__max.x;
        AABB.__tmpVector3.y = aabb.__max.y;
        AABB.__tmpVector3.z = aabb.__max.z;
        newAabb.addPosition(AABB.__tmpVector3);
        return newAabb;
    }
    static multiplyMatrixTo(matrix, aabb, outAabb) {
        if (aabb.isVanilla()) {
            return aabb.clone();
        }
        AABB.__tmpVector3.x = aabb.__min.x;
        AABB.__tmpVector3.y = aabb.__min.y;
        AABB.__tmpVector3.z = aabb.__min.z;
        matrix.multiplyVector3To(AABB.__tmpVector3, AABB.__tmpVector3);
        outAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__max.x;
        AABB.__tmpVector3.y = aabb.__min.y;
        AABB.__tmpVector3.z = aabb.__min.z;
        matrix.multiplyVector3To(AABB.__tmpVector3, AABB.__tmpVector3);
        outAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__min.x;
        AABB.__tmpVector3.y = aabb.__max.y;
        AABB.__tmpVector3.z = aabb.__min.z;
        matrix.multiplyVector3To(AABB.__tmpVector3, AABB.__tmpVector3);
        outAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__min.x;
        AABB.__tmpVector3.y = aabb.__min.y;
        AABB.__tmpVector3.z = aabb.__max.z;
        matrix.multiplyVector3To(AABB.__tmpVector3, AABB.__tmpVector3);
        outAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__min.x;
        AABB.__tmpVector3.y = aabb.__max.y;
        AABB.__tmpVector3.z = aabb.__max.z;
        matrix.multiplyVector3To(AABB.__tmpVector3, AABB.__tmpVector3);
        outAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__max.x;
        AABB.__tmpVector3.y = aabb.__min.y;
        AABB.__tmpVector3.z = aabb.__max.z;
        matrix.multiplyVector3To(AABB.__tmpVector3, AABB.__tmpVector3);
        outAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__max.x;
        AABB.__tmpVector3.y = aabb.__max.y;
        AABB.__tmpVector3.z = aabb.__min.z;
        matrix.multiplyVector3To(AABB.__tmpVector3, AABB.__tmpVector3);
        outAabb.addPosition(AABB.__tmpVector3);
        AABB.__tmpVector3.x = aabb.__max.x;
        AABB.__tmpVector3.y = aabb.__max.y;
        AABB.__tmpVector3.z = aabb.__max.z;
        matrix.multiplyVector3To(AABB.__tmpVector3, AABB.__tmpVector3);
        outAabb.addPosition(AABB.__tmpVector3);
        return outAabb;
    }
    toString() {
        return 'AABB_min: ' + this.__min + '\n' + 'AABB_max: ' + this.__max + '\n'
            + 'centerPoint: ' + this.__centerPoint + '\n' + 'lengthCenterToCorner: ' + this.__lengthCenterToCorner;
    }
}
AABB.__tmpVector3 = _MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();


/***/ }),

/***/ "./src/foundation/math/LogQuaternion.ts":
/*!**********************************************!*\
  !*** ./src/foundation/math/LogQuaternion.ts ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LogQuaternion; });
/* harmony import */ var _Quaternion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Quaternion */ "./src/foundation/math/Quaternion.ts");

class LogQuaternion {
    constructor(x, y, z) {
        if (ArrayBuffer.isView(x)) {
            this.v = x;
            return;
        }
        else if (x == null) {
            this.v = new Float32Array(0);
            return;
        }
        else {
            this.v = new Float32Array(3);
        }
        if (x instanceof _Quaternion__WEBPACK_IMPORTED_MODULE_0__["default"]) {
            // for IQuaternion
            const theta = Math.acos(x.w);
            const sin = Math.sin(theta);
            this.v[0] = x.x * (theta / sin);
            this.v[1] = x.y * (theta / sin);
            this.v[2] = x.z * (theta / sin);
        }
        else if (Array.isArray(x)) {
            this.v[0] = x[0];
            this.v[1] = x[1];
            this.v[2] = x[2];
        }
        else if (typeof x === 'number') {
            this.v[0] = x;
            this.v[1] = y;
            this.v[2] = z;
        }
        else {
            this.v[0] = x.v[0];
            this.v[1] = x.v[1];
            this.v[2] = x.v[2];
        }
    }
    get x() {
        return this.v[0];
    }
    get y() {
        return this.v[1];
    }
    get z() {
        return this.v[2];
    }
    get w() {
        return 1;
    }
    get className() {
        return this.constructor.name;
    }
}


/***/ }),

/***/ "./src/foundation/math/MathClassUtil.ts":
/*!**********************************************!*\
  !*** ./src/foundation/math/MathClassUtil.ts ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MathClassUtil; });
/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector2 */ "./src/foundation/math/Vector2.ts");
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _Vector4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _Quaternion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Quaternion */ "./src/foundation/math/Quaternion.ts");
/* harmony import */ var _Matrix33__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Matrix33 */ "./src/foundation/math/Matrix33.ts");
/* harmony import */ var _Matrix44__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _MutableMatrix33__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MutableMatrix33 */ "./src/foundation/math/MutableMatrix33.ts");
/* harmony import */ var _MutableVector4__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./MutableVector4 */ "./src/foundation/math/MutableVector4.ts");
/* harmony import */ var _MutableVector3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./MutableVector3 */ "./src/foundation/math/MutableVector3.ts");
/* harmony import */ var _MutableVector2__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./MutableVector2 */ "./src/foundation/math/MutableVector2.ts");
/* harmony import */ var _Scalar__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Scalar */ "./src/foundation/math/Scalar.ts");
/* harmony import */ var _MutableQuaternion__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./MutableQuaternion */ "./src/foundation/math/MutableQuaternion.ts");
/* harmony import */ var _MutableScalar__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./MutableScalar */ "./src/foundation/math/MutableScalar.ts");
/* harmony import */ var _VectorN__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./VectorN */ "./src/foundation/math/VectorN.ts");
















class MathClassUtil {
    constructor() {
    }
    static arrayToVector(element) {
        if (Array.isArray(element)) {
            if (typeof (element[3]) !== 'undefined') {
                return new _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"](element[0], element[1], element[2], element[3]);
            }
            else if (typeof (element[2]) !== 'undefined') {
                return new _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"](element[0], element[1], element[2]);
            }
            else {
                return new _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"](element[0], element[1]);
            }
        }
        else {
            return element;
        }
    }
    static arrayToVectorOrMatrix(element) {
        if (Array.isArray(element)) {
            if (typeof (element[15]) !== 'undefined') {
                return new _Matrix44__WEBPACK_IMPORTED_MODULE_5__["default"](element);
            }
            else if (typeof (element[8]) !== 'undefined') {
                return new _Matrix33__WEBPACK_IMPORTED_MODULE_4__["default"](element);
            }
            else if (typeof (element[3]) !== 'undefined') {
                return new _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"](element[0], element[1], element[2], element[3]);
            }
            else if (typeof (element[2]) !== 'undefined') {
                return new _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"](element[0], element[1], element[2]);
            }
            else {
                return new _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"](element[0], element[1]);
            }
        }
        else {
            return element;
        }
    }
    static getImmutableValueClass(compositionType) {
        if (compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_6__["CompositionType"].Vec2) {
            return _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"];
        }
        else if (compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_6__["CompositionType"].Vec3) {
            return _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"];
        }
        else if (compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_6__["CompositionType"].Vec4) {
            return _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"];
        }
        else if (compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_6__["CompositionType"].Mat3) {
            return _Matrix33__WEBPACK_IMPORTED_MODULE_4__["default"];
        }
        else if (compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_6__["CompositionType"].Mat4) {
            return _Matrix44__WEBPACK_IMPORTED_MODULE_5__["default"];
        }
        return void 0;
    }
    static getMutableValueClass(compositionType) {
        if (compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_6__["CompositionType"].Vec2) {
            return _MutableVector2__WEBPACK_IMPORTED_MODULE_11__["default"];
        }
        else if (compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_6__["CompositionType"].Vec3) {
            return _MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"];
        }
        else if (compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_6__["CompositionType"].Vec4) {
            return _MutableVector4__WEBPACK_IMPORTED_MODULE_9__["default"];
        }
        else if (compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_6__["CompositionType"].Mat3) {
            return _MutableMatrix33__WEBPACK_IMPORTED_MODULE_8__["default"];
        }
        else if (compositionType === _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_6__["CompositionType"].Mat4) {
            return _MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__["default"];
        }
        else {
            return void 0;
        }
    }
    static cloneOfMathObjects(element) {
        if (element instanceof _Matrix44__WEBPACK_IMPORTED_MODULE_5__["default"]) {
            return element.clone();
        }
        else if (element instanceof _Matrix33__WEBPACK_IMPORTED_MODULE_4__["default"]) {
            return element.clone();
        }
        else if (element instanceof _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            return element.clone();
        }
        else if (element instanceof _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            return element.clone();
        }
        else if (element instanceof _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"]) {
            return element.clone();
        }
        else {
            return element;
        }
    }
    static isAcceptableArrayForQuaternion(element) {
        if (Array.isArray(element)) {
            if (typeof (element[3]) !== 'undefined') {
                return true;
            }
        }
        return false;
    }
    static arrayToQuaternion(element) {
        return new _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"](element[0], element[1], element[2], element[3]);
    }
    static makeSubArray(array, componentN) {
        if (componentN === 4) {
            return [array[0], array[1], array[2], array[3]];
        }
        else if (componentN === 3) {
            return [array[0], array[1], array[2]];
        }
        else if (componentN === 2) {
            return [array[0], array[1]];
        }
        else {
            return array[0];
        }
    }
    static vectorToArray(element) {
        if (element instanceof _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"]) {
            return [element.x, element.v];
        }
        else if (element instanceof _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            return [element.x, element.v, element.z];
        }
        else if (element instanceof _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"] || element instanceof _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"]) {
            return [element.x, element.v, element.z, element.w];
        }
        else {
            return element;
        }
    }
    /**
     * discriminate which Vector instance
     * @param element any Vector instance
     * @return number of Vector instance
     */
    static componentNumberOfVector(element) {
        if (element instanceof _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"]) {
            return 2;
        }
        else if (element instanceof _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            return 3;
        }
        else if (element instanceof _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"] || element instanceof _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"]) {
            return 4;
        }
        else if (Array.isArray(element)) {
            return element.length;
        }
        else {
            return 0;
        }
    }
    // values range must be [-1, 1]
    static packNormalizedVec4ToVec2(x, y, z, w, criteria) {
        let v0 = 0.0;
        let v1 = 0.0;
        x = (x + 1) / 2.0;
        y = (y + 1) / 2.0;
        z = (z + 1) / 2.0;
        w = (w + 1) / 2.0;
        let ir = Math.floor(x * (criteria - 1.0));
        let ig = Math.floor(y * (criteria - 1.0));
        let irg = ir * criteria + ig;
        v0 = irg / criteria;
        let ib = Math.floor(z * (criteria - 1.0));
        let ia = Math.floor(w * (criteria - 1.0));
        let iba = ib * criteria + ia;
        v1 = iba / criteria;
        return [v0, v1];
    }
    static unProjectTo(windowPosX, windowPosY, windowPosZ, inversePVMat44, viewportVec4, out) {
        const input = this.__tmpVector4_0.setComponents((windowPosX - viewportVec4.x) / viewportVec4.z * 2 - 1.0, (windowPosY - viewportVec4.y) / viewportVec4.w * 2 - 1.0, 2 * windowPosZ - 1.0, 1.0);
        const outNonNormalized = inversePVMat44.multiplyVectorTo(input, this.__tmpVector4_1);
        if (outNonNormalized.w === 0) {
            console.error("0 division occurred!");
        }
        return _MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"].multiplyTo(outNonNormalized, 1.0 / outNonNormalized.w, out);
    }
    static add(lhs, rhs) {
        if (isFinite(lhs)) { // number?
            return lhs + rhs;
        }
        else if (lhs instanceof _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"]) {
            return _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"].add(lhs, rhs);
        }
        else if (lhs instanceof _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            return _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"].add(lhs, rhs);
        }
        else if (lhs instanceof _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            return _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"].add(lhs, rhs);
        }
        else if (lhs instanceof _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"]) {
            return _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"].add(lhs, rhs);
        }
        else if (Array.isArray(lhs)) {
            const arr = [];
            for (let i = 0; i < lhs.length; i++) {
                arr[i] = lhs[i] + rhs[i];
            }
            return arr;
        }
        else {
            console.error('Non supported type!');
            return;
        }
    }
    static subtract(lhs, rhs) {
        if (isFinite(lhs)) { // number?
            return lhs - rhs;
        }
        else if (lhs instanceof _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"]) {
            return _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"].subtract(lhs, rhs);
        }
        else if (lhs instanceof _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            return _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"].subtract(lhs, rhs);
        }
        else if (lhs instanceof _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            return _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"].subtract(lhs, rhs);
        }
        else if (lhs instanceof _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"]) {
            return _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"].subtract(lhs, rhs);
        }
        else if (Array.isArray(lhs)) {
            const arr = [];
            for (let i = 0; i < lhs.length; i++) {
                arr[i] = lhs[i] - rhs[i];
            }
            return arr;
        }
        else {
            console.error('Non supported type!');
            return;
        }
    }
    static multiplyNumber(lhs, rhs) {
        if (isFinite(lhs)) { // number?
            return lhs * rhs;
        }
        else if (lhs instanceof _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"]) {
            return _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"].multiply(lhs, rhs);
        }
        else if (lhs instanceof _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            return _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"].multiply(lhs, rhs);
        }
        else if (lhs instanceof _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            return _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"].multiply(lhs, rhs);
        }
        else if (lhs instanceof _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"]) {
            return _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"].multiplyNumber(lhs, rhs);
        }
        else if (Array.isArray(lhs)) {
            const arr = [];
            for (let i = 0; i < lhs.length; i++) {
                arr[i] = lhs[i] * rhs;
            }
            return arr;
        }
        else {
            console.error('Non supported type!');
            return;
        }
    }
    static divideNumber(lhs, rhs) {
        if (isFinite(lhs)) { // number?
            return lhs / rhs;
        }
        else if (lhs instanceof _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"]) {
            return _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"].multiply(lhs, 1 / rhs);
        }
        else if (lhs instanceof _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            return _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"].multiply(lhs, 1 / rhs);
        }
        else if (lhs instanceof _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            return _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"].multiply(lhs, 1 / rhs);
        }
        else if (lhs instanceof _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"]) {
            return _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"].multiplyNumber(lhs, 1 / rhs);
        }
        else if (Array.isArray(lhs)) {
            const arr = [];
            for (let i = 0; i < lhs.length; i++) {
                arr[i] = lhs[i] / rhs;
            }
            return arr;
        }
        else {
            console.error('Non supported type!');
            return;
        }
    }
    static initWithScalar(objForDetectType, val) {
        if (isFinite(objForDetectType)) { // number?
            return val;
        }
        else if (objForDetectType instanceof _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"]) {
            return new _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"](val, val);
        }
        else if (objForDetectType instanceof _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            return new _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"](val, val, val);
        }
        else if (objForDetectType instanceof _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            return new _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"](val, val, val, val);
        }
        else if (objForDetectType instanceof _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"]) {
            return new _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"](0, 0, 0, 1);
        }
        else if (Array.isArray(objForDetectType)) {
            const arr = [];
            for (let i = 0; i < objForDetectType.length; i++) {
                arr[i] = val;
            }
            return arr;
        }
        else {
            console.error('Non supported type!');
            return void 0;
        }
    }
    static initWithFloat32Array(objForDetectType, val, floatArray, compositionType) {
        let obj;
        if (isFinite(objForDetectType)) { // number?
            const array = new Float32Array(floatArray);
            floatArray.v = void 0;
            array[0] = val;
            return new _Scalar__WEBPACK_IMPORTED_MODULE_12__["default"](array);
        }
        else if (objForDetectType instanceof _Scalar__WEBPACK_IMPORTED_MODULE_12__["default"] || objForDetectType instanceof _MutableScalar__WEBPACK_IMPORTED_MODULE_14__["default"]) {
            floatArray[0] = val.x;
            obj = new _MutableScalar__WEBPACK_IMPORTED_MODULE_14__["default"](floatArray);
        }
        else if (objForDetectType instanceof _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"] || objForDetectType instanceof _MutableVector2__WEBPACK_IMPORTED_MODULE_11__["default"]) {
            floatArray[0] = val.x;
            floatArray[1] = val.y;
            obj = new _MutableVector2__WEBPACK_IMPORTED_MODULE_11__["default"](floatArray);
        }
        else if (objForDetectType instanceof _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"] || objForDetectType instanceof _MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"]) {
            floatArray[0] = val.x;
            floatArray[1] = val.y;
            floatArray[2] = val.z;
            obj = new _MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"](floatArray);
        }
        else if (objForDetectType instanceof _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"] || objForDetectType instanceof _MutableVector4__WEBPACK_IMPORTED_MODULE_9__["default"]) {
            floatArray[0] = val.x;
            floatArray[1] = val.y;
            floatArray[2] = val.z;
            floatArray[3] = val.w;
            obj = new _MutableVector4__WEBPACK_IMPORTED_MODULE_9__["default"](floatArray);
        }
        else if (objForDetectType instanceof _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"] || objForDetectType instanceof _MutableQuaternion__WEBPACK_IMPORTED_MODULE_13__["default"]) {
            floatArray[0] = val.x;
            floatArray[1] = val.y;
            floatArray[2] = val.z;
            floatArray[3] = val.w;
            obj = new _MutableQuaternion__WEBPACK_IMPORTED_MODULE_13__["default"](floatArray);
        }
        else if (objForDetectType instanceof _Matrix33__WEBPACK_IMPORTED_MODULE_4__["default"] || objForDetectType instanceof _MutableMatrix33__WEBPACK_IMPORTED_MODULE_8__["default"]) {
            obj = (obj == null) ? new _MutableMatrix33__WEBPACK_IMPORTED_MODULE_8__["default"](floatArray, false, true) : obj;
            obj.m00 = val.m00;
            obj.m01 = val.m01;
            obj.m02 = val.m02;
            obj.m10 = val.m10;
            obj.m11 = val.m11;
            obj.m12 = val.m12;
            obj.m20 = val.m20;
            obj.m21 = val.m21;
            obj.m22 = val.m22;
        }
        else if (objForDetectType instanceof _Matrix44__WEBPACK_IMPORTED_MODULE_5__["default"] || objForDetectType instanceof _MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__["default"]) {
            obj = new _MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__["default"](floatArray, false, true);
            obj.m00 = val.m00;
            obj.m01 = val.m01;
            obj.m02 = val.m02;
            obj.m03 = val.m03;
            obj.m10 = val.m10;
            obj.m11 = val.m11;
            obj.m12 = val.m12;
            obj.m13 = val.m13;
            obj.m20 = val.m20;
            obj.m21 = val.m21;
            obj.m22 = val.m22;
            obj.m23 = val.m23;
            obj.m30 = val.m30;
            obj.m31 = val.m31;
            obj.m32 = val.m32;
            obj.m33 = val.m33;
        }
        else if (objForDetectType instanceof _VectorN__WEBPACK_IMPORTED_MODULE_15__["default"]) {
            obj = new _VectorN__WEBPACK_IMPORTED_MODULE_15__["default"](floatArray);
        }
        else if (objForDetectType == null) {
            let vec;
            switch (floatArray.length) {
                case 4:
                    vec = new _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"](floatArray);
                    break;
                case 3:
                    vec = new _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"](floatArray);
                    break;
                case 2:
                    vec = new _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"](floatArray);
                    break;
                case 1:
                    vec = new _Scalar__WEBPACK_IMPORTED_MODULE_12__["default"](floatArray);
                    break;
            }
            floatArray.v = void 0;
            return vec;
        }
        else if (Array.isArray(objForDetectType) || ArrayBuffer.isView(objForDetectType) || ArrayBuffer.isView(objForDetectType.v)) {
            return objForDetectType;
        }
        else {
            console.error('Non supported type!');
            return void 0;
        }
        floatArray.v = void 0;
        return obj;
    }
    static _setForce(objForDetectType, val) {
        let obj = objForDetectType;
        if (objForDetectType instanceof _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"] || objForDetectType instanceof _MutableVector4__WEBPACK_IMPORTED_MODULE_9__["default"]) {
            objForDetectType.v[0] = val.v[0];
            objForDetectType.v[1] = val.v[1];
            objForDetectType.v[2] = val.v[2];
            objForDetectType.v[3] = val.v[3];
        }
        else if (objForDetectType instanceof _Vector3__WEBPACK_IMPORTED_MODULE_1__["default"] || objForDetectType instanceof _MutableVector3__WEBPACK_IMPORTED_MODULE_10__["default"]) {
            objForDetectType.v[0] = val.v[0];
            objForDetectType.v[1] = val.v[1];
            objForDetectType.v[2] = val.v[2];
        }
        else if (objForDetectType instanceof _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"] || objForDetectType instanceof _MutableVector2__WEBPACK_IMPORTED_MODULE_11__["default"]) {
            objForDetectType.v[0] = val.v[0];
            objForDetectType.v[1] = val.v[1];
        }
        else if (objForDetectType instanceof _Scalar__WEBPACK_IMPORTED_MODULE_12__["default"] || objForDetectType instanceof _MutableScalar__WEBPACK_IMPORTED_MODULE_14__["default"]) {
            if (typeof val.v === 'undefined') {
                objForDetectType.v[0] = val;
            }
            else {
                objForDetectType.v[0] = val.v[0];
            }
        }
        else if (objForDetectType instanceof _Matrix33__WEBPACK_IMPORTED_MODULE_4__["default"] || objForDetectType instanceof _MutableMatrix33__WEBPACK_IMPORTED_MODULE_8__["default"]) {
            objForDetectType.v[0] = val.v[0];
            objForDetectType.v[1] = val.v[1];
            objForDetectType.v[2] = val.v[2];
            objForDetectType.v[3] = val.v[3];
            objForDetectType.v[4] = val.v[4];
            objForDetectType.v[5] = val.v[5];
            objForDetectType.v[6] = val.v[6];
            objForDetectType.v[7] = val.v[7];
            objForDetectType.v[8] = val.v[8];
        }
        else if (objForDetectType instanceof _Matrix44__WEBPACK_IMPORTED_MODULE_5__["default"] || objForDetectType instanceof _MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__["default"]) {
            objForDetectType.v[0] = val.v[0];
            objForDetectType.v[1] = val.v[1];
            objForDetectType.v[2] = val.v[2];
            objForDetectType.v[3] = val.v[3];
            objForDetectType.v[4] = val.v[4];
            objForDetectType.v[5] = val.v[5];
            objForDetectType.v[6] = val.v[6];
            objForDetectType.v[7] = val.v[7];
            objForDetectType.v[8] = val.v[8];
            objForDetectType.v[9] = val.v[9];
            objForDetectType.v[10] = val.v[10];
            objForDetectType.v[11] = val.v[11];
            objForDetectType.v[12] = val.v[12];
            objForDetectType.v[13] = val.v[13];
            objForDetectType.v[14] = val.v[14];
            objForDetectType.v[15] = val.v[15];
        }
        else if (objForDetectType instanceof _Quaternion__WEBPACK_IMPORTED_MODULE_3__["default"] || objForDetectType instanceof _MutableQuaternion__WEBPACK_IMPORTED_MODULE_13__["default"]) {
            objForDetectType.v[0] = val.v[0];
            objForDetectType.v[1] = val.v[1];
            objForDetectType.v[2] = val.v[2];
            objForDetectType.v[3] = val.v[3];
        }
        else if (objForDetectType instanceof _VectorN__WEBPACK_IMPORTED_MODULE_15__["default"]) {
            let valArray;
            if (val instanceof _VectorN__WEBPACK_IMPORTED_MODULE_15__["default"]) {
                valArray = val.v;
            }
            else {
                valArray = val;
            }
            for (let i = 0; i < valArray.length; i++) {
                objForDetectType.v[i] = valArray[i];
            }
        }
        else if (Array.isArray(objForDetectType)) {
            for (let i = 0; i < objForDetectType.length; i++) {
                objForDetectType[i] = val.v[i];
            }
        }
        else if (!isNaN(objForDetectType.v.length)) {
            for (let i = 0; i < objForDetectType.v.length; i++) {
                if (Array.isArray(val)) {
                    objForDetectType.v[i] = val[i];
                }
                else {
                    objForDetectType.v[i] = val.v[i];
                }
            }
        }
        else {
            console.warn('Unknown type _setForce');
        }
        // maybe objForDetectType is number
    }
}
MathClassUtil.__tmpVector4_0 = _MutableVector4__WEBPACK_IMPORTED_MODULE_9__["default"].zero();
MathClassUtil.__tmpVector4_1 = _MutableVector4__WEBPACK_IMPORTED_MODULE_9__["default"].zero();


/***/ }),

/***/ "./src/foundation/math/MathUtil.ts":
/*!*****************************************!*\
  !*** ./src/foundation/math/MathUtil.ts ***!
  \*****************************************/
/*! exports provided: MathUtil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MathUtil", function() { return MathUtil; });
//import GLBoost from '../../globals';
function radianToDegree(rad) {
    return rad * 180 / Math.PI;
}
function degreeToRadian(deg) {
    return deg * Math.PI / 180;
}
// https://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410
const toHalfFloat = (function () {
    var floatView = new Float32Array(1);
    var int32View = new Int32Array(floatView.buffer);
    /* This method is faster than the OpenEXR implementation (very often
      * used, eg. in Ogre), with the additional benefit of rounding, inspired
      * by James Tursa?s half-precision code. */
    return function toHalf(val) {
        floatView[0] = val;
        var x = int32View[0];
        var bits = (x >> 16) & 0x8000; /* Get the sign */
        var m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */
        var e = (x >> 23) & 0xff; /* Using int is faster here */
        /* If zero, or denormal, or exponent underflows too much for a denormal
          * half, return signed zero. */
        if (e < 103) {
            return bits;
        }
        /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
        if (e > 142) {
            bits |= 0x7c00;
            /* If exponent was 0xff and one mantissa bit was set, it means NaN,
                  * not Inf, so make sure we set one mantissa bit too. */
            bits |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);
            return bits;
        }
        /* If exponent underflows but not too much, return a denormal */
        if (e < 113) {
            m |= 0x0800;
            /* Extra rounding may overflow and set mantissa to 0 and exponent
              * to 1, which is OK. */
            bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
            return bits;
        }
        bits |= ((e - 112) << 10) | (m >> 1);
        /* Extra rounding. An overflow will set mantissa to 0 and increment
          * the exponent, which is OK. */
        bits += m & 1;
        return bits;
    };
}());
/**
 * check whether or not this texture size is power of two.
 *
 * @param x texture size.
 * @returns check whether or not the size x is power of two.
 */
function isPowerOfTwo(x) {
    return (x & (x - 1)) == 0;
}
function isPowerOfTwoTexture(width, height) {
    return isPowerOfTwo(width) && isPowerOfTwo(height);
}
// values range must be [-1, 1]
function packNormalizedVec4ToVec2(x, y, z, w, criteria) {
    // range to [0, s1]
    x = (x + 1) / 2.0;
    y = (y + 1) / 2.0;
    z = (z + 1) / 2.0;
    w = (w + 1) / 2.0;
    const ir = Math.floor(x * (criteria - 1.0));
    const ig = Math.floor(y * (criteria - 1.0));
    const irg = ir * criteria + ig;
    const v0 = irg / criteria;
    const ib = Math.floor(z * (criteria - 1.0));
    const ia = Math.floor(w * (criteria - 1.0));
    const iba = ib * criteria + ia;
    const v1 = iba / criteria;
    return [v0, v1];
}
function convertToStringAsGLSLFloat(value) {
    if (Number.isInteger(value)) {
        return `${value}.0`;
    }
    else {
        return '' + value;
    }
}
function nearZeroToZero(value) {
    if (Math.abs(value) < 0.00001) {
        value = 0;
    }
    else if (0.99999 < value && value < 1.00001) {
        value = 1;
    }
    else if (-1.00001 < value && value < -0.99999) {
        value = -1;
    }
    return value;
}
const MathUtil = Object.freeze({
    radianToDegree, degreeToRadian, toHalfFloat, isPowerOfTwo, isPowerOfTwoTexture,
    packNormalizedVec4ToVec2, convertToStringAsGLSLFloat, nearZeroToZero
});


/***/ }),

/***/ "./src/foundation/math/Matrix22.ts":
/*!*****************************************!*\
  !*** ./src/foundation/math/Matrix22.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix22; });
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector2 */ "./src/foundation/math/Vector2.ts");
/* harmony import */ var _MathUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MathUtil */ "./src/foundation/math/MathUtil.ts");



class Matrix22 {
    constructor(m0, m1, m2, m3, isColumnMajor = false, notCopyFloatArray = false) {
        const _isColumnMajor = (arguments.length === 5) ? isColumnMajor : m1;
        const _notCopyFloatArray = (arguments.length === 3) ? notCopyFloatArray : m2;
        const m = m0;
        if (m == null) {
            this.v = new Float32Array(0);
            return;
        }
        if (4 <= arguments.length && arguments.length <= 5 && m3 != null) {
            this.v = new Float32Array(4);
            if (_isColumnMajor === true) {
                let m = arguments;
                this.v[0] = m[0];
                this.v[2] = m[2];
                this.v[1] = m[1];
                this.v[3] = m[3];
            }
            else {
                let m = arguments;
                // arguments[0-3] must be row major values if isColumnMajor is false
                this.v[0] = m[0];
                this.v[2] = m[1];
                this.v[1] = m[2];
                this.v[3] = m[3];
            }
        }
        else if (Array.isArray(m)) {
            this.v = new Float32Array(4);
            if (_isColumnMajor === true) {
                this.v[0] = m[0];
                this.v[2] = m[2];
                this.v[1] = m[1];
                this.v[3] = m[3];
            }
            else {
                // 'm' must be row major array if isColumnMajor is false
                this.v[0] = m[0];
                this.v[2] = m[1];
                this.v[1] = m[2];
                this.v[3] = m[3];
            }
        }
        else if (m instanceof Float32Array) {
            if (_notCopyFloatArray) {
                this.v = m;
            }
            else {
                this.v = new Float32Array(4);
                if (_isColumnMajor === true) {
                    this.v[0] = m[0];
                    this.v[2] = m[2];
                    this.v[1] = m[1];
                    this.v[3] = m[3];
                }
                else {
                    // 'm' must be row major array if isColumnMajor is false
                    this.v[0] = m[0];
                    this.v[2] = m[1];
                    this.v[1] = m[2];
                    this.v[3] = m[3];
                }
            }
        }
        else if (!!m && m.v != null && m.v[3] !== null) {
            if (_notCopyFloatArray) {
                this.v = m.v;
            }
            else {
                this.v = new Float32Array(4);
                if (_isColumnMajor === true) {
                    const v = m.v;
                    this.v[0] = m[0];
                    this.v[2] = m[2];
                    this.v[1] = m[1];
                    this.v[3] = m[3];
                }
                else {
                    const v = m.v;
                    // 'm' must be row major array if isColumnMajor is false
                    this.v[0] = m[0];
                    this.v[2] = m[1];
                    this.v[1] = m[2];
                    this.v[3] = m[3];
                }
            }
        }
        else {
            this.v = new Float32Array(4);
            this.v[0] = 1;
            this.v[2] = 0;
            this.v[1] = 0;
            this.v[3] = 1;
        }
    }
    get m00() {
        return this.v[0];
    }
    get m10() {
        return this.v[1];
    }
    get m01() {
        return this.v[2];
    }
    get m11() {
        return this.v[3];
    }
    get className() {
        return this.constructor.name;
    }
    static get compositionType() {
        return _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_0__["CompositionType"].Mat2;
    }
    /**
     * Create zero matrix
     */
    static zero() {
        return new this(0, 0, 0, 0);
    }
    /**
     * Create identity matrix
     */
    static identity() {
        return new this(1, 0, 0, 1);
    }
    static dummy() {
        return new this(null);
    }
    /**
     * Create transpose matrix
     */
    static transpose(mat) {
        return new this(mat.v[0], mat.v[1], mat.v[2], mat.v[3]);
    }
    /**
     * Create invert matrix
     */
    static invert(mat) {
        const det = mat.determinant();
        if (det === 0) {
            console.error("the determinant is 0!");
        }
        const m00 = mat.v[3] / det;
        const m01 = mat.v[2] / det * (-1.0);
        const m10 = mat.v[1] / det * (-1.0);
        const m11 = mat.v[0] / det;
        return new this(m00, m01, m10, m11);
    }
    static invertTo(mat, outMat) {
        const det = mat.determinant();
        if (det === 0) {
            console.error("the determinant is 0!");
        }
        const m00 = mat.v[3] / det;
        const m01 = mat.v[2] / det * (-1.0);
        const m10 = mat.v[1] / det * (-1.0);
        const m11 = mat.v[0] / det;
        return outMat.setComponents(m00, m01, m10, m11);
    }
    /**
     * Create Rotation Matrix
     */
    static rotate(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return new this(cos, -sin, sin, cos);
    }
    /**
     * Create Scale Matrix
     */
    static scale(vec) {
        return new this(vec.v[0], 0, 0, vec.v[1]);
    }
    /**
     * multiply matrixes
     */
    static multiply(l_mat, r_mat) {
        const m00 = l_mat.v[0] * r_mat.v[0] + l_mat.v[2] * r_mat.v[1];
        const m10 = l_mat.v[1] * r_mat.v[0] + l_mat.v[3] * r_mat.v[1];
        const m01 = l_mat.v[0] * r_mat.v[2] + l_mat.v[2] * r_mat.v[3];
        const m11 = l_mat.v[1] * r_mat.v[2] + l_mat.v[3] * r_mat.v[3];
        return new this(m00, m01, m10, m11);
    }
    /**
     * multiply matrixes
     */
    static multiplyTo(l_mat, r_mat, outMat) {
        const m00 = l_mat.v[0] * r_mat.v[0] + l_mat.v[2] * r_mat.v[1];
        const m10 = l_mat.v[1] * r_mat.v[0] + l_mat.v[3] * r_mat.v[1];
        const m01 = l_mat.v[0] * r_mat.v[2] + l_mat.v[2] * r_mat.v[3];
        const m11 = l_mat.v[1] * r_mat.v[2] + l_mat.v[3] * r_mat.v[3];
        return outMat.setComponents(m00, m01, m10, m11);
    }
    toString() {
        return this.v[0] + ' ' + this.v[2] + '\n' +
            this.v[1] + ' ' + this.v[3] + ' \n';
    }
    toStringApproximately() {
        return _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[0]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[2]) + '\n' +
            _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[1]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[3]) + ' \n';
    }
    flattenAsArray() {
        return [this.v[0], this.v[1],
            this.v[2], this.v[3]];
    }
    isDummy() {
        if (this.v.length === 0) {
            return true;
        }
        else {
            return false;
        }
    }
    isEqual(mat, delta = Number.EPSILON) {
        if (Math.abs(mat.v[0] - this.v[0]) < delta &&
            Math.abs(mat.v[1] - this.v[1]) < delta &&
            Math.abs(mat.v[2] - this.v[2]) < delta &&
            Math.abs(mat.v[3] - this.v[3]) < delta) {
            return true;
        }
        else {
            return false;
        }
    }
    isStrictEqual(mat) {
        if (mat.v[0] === this.v[0] && mat.v[1] === this.v[1] &&
            mat.v[2] === this.v[2] && mat.v[3] === this.v[3]) {
            return true;
        }
        else {
            return false;
        }
    }
    at(row_i, column_i) {
        return this.v[row_i + column_i * 2];
    }
    determinant() {
        return this.v[0] * this.v[3] - this.v[1] * this.v[2];
    }
    multiplyVector(vec) {
        const x = this.v[0] * vec.v[0] + this.v[2] * vec.v[1];
        const y = this.v[1] * vec.v[0] + this.v[3] * vec.v[1];
        return new vec.constructor(x, y);
    }
    multiplyVectorTo(vec, outVec) {
        const x = this.v[0] * vec.v[0] + this.v[2] * vec.v[1];
        const y = this.v[1] * vec.v[0] + this.v[3] * vec.v[1];
        outVec.v[0] = x;
        outVec.v[1] = y;
        return outVec;
    }
    getScale() {
        return new _Vector2__WEBPACK_IMPORTED_MODULE_1__["default"](Math.hypot(this.m00, this.m01), Math.hypot(this.m10, this.m11));
    }
    getScaleTo(outVec) {
        outVec.v[0] = Math.hypot(this.v[0], this.v[2]);
        outVec.v[1] = Math.hypot(this.v[1], this.v[3]);
        return outVec;
    }
    clone() {
        return new this.constructor(this.v[0], this.v[2], this.v[1], this.v[3]);
    }
}


/***/ }),

/***/ "./src/foundation/math/Matrix33.ts":
/*!*****************************************!*\
  !*** ./src/foundation/math/Matrix33.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix33; });
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _MathUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MathUtil */ "./src/foundation/math/MathUtil.ts");



class Matrix33 {
    constructor(m0, m1, m2, m3, m4, m5, m6, m7, m8, isColumnMajor = false, notCopyFloatArray = false) {
        const _isColumnMajor = (arguments.length === 10) ? isColumnMajor : m1;
        const _notCopyFloatArray = (arguments.length === 3) ? notCopyFloatArray : m2;
        const m = m0;
        if (m == null) {
            this.v = new Float32Array(0);
            return;
        }
        if (9 <= arguments.length && arguments.length <= 10 && m8 != null) {
            this.v = new Float32Array(9);
            if (_isColumnMajor === true) {
                let m = arguments;
                this.v[0] = m[0];
                this.v[3] = m[3];
                this.v[6] = m[6];
                this.v[1] = m[1];
                this.v[4] = m[4];
                this.v[7] = m[7];
                this.v[2] = m[2];
                this.v[5] = m[5];
                this.v[8] = m[8];
            }
            else {
                let m = arguments;
                // arguments[0-8] must be row major values if isColumnMajor is false
                this.v[0] = m[0];
                this.v[3] = m[1];
                this.v[6] = m[2];
                this.v[1] = m[3];
                this.v[4] = m[4];
                this.v[7] = m[5];
                this.v[2] = m[6];
                this.v[5] = m[7];
                this.v[8] = m[8];
            }
        }
        else if (Array.isArray(m)) {
            this.v = new Float32Array(9);
            if (_isColumnMajor === true) {
                this.v[0] = m[0];
                this.v[3] = m[3];
                this.v[6] = m[6];
                this.v[1] = m[1];
                this.v[4] = m[4];
                this.v[7] = m[7];
                this.v[2] = m[2];
                this.v[5] = m[5];
                this.v[8] = m[8];
            }
            else {
                // 'm' must be row major array if isColumnMajor is false
                this.v[0] = m[0];
                this.v[3] = m[1];
                this.v[6] = m[2];
                this.v[1] = m[3];
                this.v[4] = m[4];
                this.v[7] = m[5];
                this.v[2] = m[6];
                this.v[5] = m[7];
                this.v[8] = m[8];
            }
        }
        else if (m instanceof Float32Array) {
            if (_notCopyFloatArray) {
                this.v = m;
            }
            else {
                this.v = new Float32Array(9);
                if (_isColumnMajor === true) {
                    this.v[0] = m[0];
                    this.v[3] = m[3];
                    this.v[6] = m[6];
                    this.v[1] = m[1];
                    this.v[4] = m[4];
                    this.v[7] = m[7];
                    this.v[2] = m[2];
                    this.v[5] = m[5];
                    this.v[8] = m[8];
                }
                else {
                    // 'm' must be row major array if isColumnMajor is false
                    this.v[0] = m[0];
                    this.v[3] = m[1];
                    this.v[6] = m[2];
                    this.v[1] = m[3];
                    this.v[4] = m[4];
                    this.v[7] = m[5];
                    this.v[2] = m[6];
                    this.v[5] = m[7];
                    this.v[8] = m[8];
                }
            }
        }
        else if (!!m && m.v != null && m.v[8] !== null) {
            if (_notCopyFloatArray) {
                this.v = m.v;
            }
            else {
                this.v = new Float32Array(9);
                const v = m.v;
                this.v[0] = v[0];
                this.v[3] = v[3];
                this.v[6] = v[6];
                this.v[1] = v[1];
                this.v[4] = v[4];
                this.v[7] = v[7];
                this.v[2] = v[2];
                this.v[5] = v[5];
                this.v[8] = v[8];
            }
        }
        else if (!!m && typeof m.className !== 'undefined' && m.className === 'Quaternion') {
            this.v = new Float32Array(9);
            const q = m;
            const sx = q.v[0] * q.v[0];
            const sy = q.v[1] * q.v[1];
            const sz = q.v[2] * q.v[2];
            const cx = q.v[1] * q.v[2];
            const cy = q.v[0] * q.v[2];
            const cz = q.v[0] * q.v[1];
            const wx = q.v[3] * q.v[0];
            const wy = q.v[3] * q.v[1];
            const wz = q.v[3] * q.v[2];
            this.v[0] = 1.0 - 2.0 * (sy + sz);
            this.v[3] = 2.0 * (cz - wz);
            this.v[6] = 2.0 * (cy + wy);
            this.v[1] = 2.0 * (cz + wz);
            this.v[4] = 1.0 - 2.0 * (sx + sz);
            this.v[7] = 2.0 * (cx - wx);
            this.v[2] = 2.0 * (cy - wy);
            this.v[5] = 2.0 * (cx + wx);
            this.v[8] = 1.0 - 2.0 * (sx + sy);
        }
        else {
            this.v = new Float32Array(9);
            this.v[0] = 1;
            this.v[3] = 0;
            this.v[6] = 0;
            this.v[1] = 0;
            this.v[4] = 1;
            this.v[7] = 0;
            this.v[2] = 0;
            this.v[5] = 0;
            this.v[8] = 1;
        }
    }
    get m00() {
        return this.v[0];
    }
    get m10() {
        return this.v[1];
    }
    get m20() {
        return this.v[2];
    }
    get m01() {
        return this.v[3];
    }
    get m11() {
        return this.v[4];
    }
    get m21() {
        return this.v[5];
    }
    get m02() {
        return this.v[6];
    }
    get m12() {
        return this.v[7];
    }
    get m22() {
        return this.v[8];
    }
    get className() {
        return this.constructor.name;
    }
    static get compositionType() {
        return _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Mat3;
    }
    /**
     * zero matrix(static version)
     */
    static zero() {
        return new this(0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * Create identity matrix
     */
    static identity() {
        return new this(1, 0, 0, 0, 1, 0, 0, 0, 1);
    }
    static dummy() {
        return new this(null);
    }
    /**
     * Create transpose matrix
     */
    static transpose(mat) {
        return new this(mat.v[0], mat.v[1], mat.v[2], mat.v[3], mat.v[4], mat.v[5], mat.v[6], mat.v[7], mat.v[8]);
    }
    /**
     * Create invert matrix
     */
    static invert(mat) {
        const det = mat.determinant();
        if (det === 0) {
            console.error("the determinant is 0!");
        }
        const m00 = (mat.v[4] * mat.v[8] - mat.v[7] * mat.v[5]) / det;
        const m01 = (mat.v[6] * mat.v[5] - mat.v[3] * mat.v[8]) / det;
        const m02 = (mat.v[3] * mat.v[7] - mat.v[6] * mat.v[4]) / det;
        const m10 = (mat.v[7] * mat.v[2] - mat.v[1] * mat.v[8]) / det;
        const m11 = (mat.v[0] * mat.v[8] - mat.v[6] * mat.v[2]) / det;
        const m12 = (mat.v[6] * mat.v[1] - mat.v[0] * mat.v[7]) / det;
        const m20 = (mat.v[1] * mat.v[5] - mat.v[4] * mat.v[2]) / det;
        const m21 = (mat.v[3] * mat.v[2] - mat.v[0] * mat.v[5]) / det;
        const m22 = (mat.v[0] * mat.v[4] - mat.v[3] * mat.v[1]) / det;
        return new this(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    static invertTo(mat, outMat) {
        const det = mat.determinant();
        if (det === 0) {
            console.error("the determinant is 0!");
        }
        const m00 = (mat.v[4] * mat.v[8] - mat.v[7] * mat.v[5]) / det;
        const m01 = (mat.v[6] * mat.v[5] - mat.v[3] * mat.v[8]) / det;
        const m02 = (mat.v[3] * mat.v[7] - mat.v[6] * mat.v[4]) / det;
        const m10 = (mat.v[7] * mat.v[2] - mat.v[1] * mat.v[8]) / det;
        const m11 = (mat.v[0] * mat.v[8] - mat.v[6] * mat.v[2]) / det;
        const m12 = (mat.v[6] * mat.v[1] - mat.v[0] * mat.v[7]) / det;
        const m20 = (mat.v[1] * mat.v[5] - mat.v[4] * mat.v[2]) / det;
        const m21 = (mat.v[3] * mat.v[2] - mat.v[0] * mat.v[5]) / det;
        const m22 = (mat.v[0] * mat.v[4] - mat.v[3] * mat.v[1]) / det;
        return outMat.setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    /**
   * Create X oriented Rotation Matrix
   */
    static rotateX(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return new this(1, 0, 0, 0, cos, -sin, 0, sin, cos);
    }
    /**
     * Create Y oriented Rotation Matrix
     */
    static rotateY(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return new this(cos, 0, sin, 0, 1, 0, -sin, 0, cos);
    }
    /**
     * Create Z oriented Rotation Matrix
     */
    static rotateZ(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return new this(cos, -sin, 0, sin, cos, 0, 0, 0, 1);
    }
    static rotateXYZ(x, y, z) {
        const cosX = Math.cos(x);
        const sinX = Math.sin(x);
        const cosY = Math.cos(y);
        const sinY = Math.sin(y);
        const cosZ = Math.cos(z);
        const sinZ = Math.sin(z);
        // const x00 = 1;
        // const x01 = 0;
        // const x02 = 0;
        // const x10 = 0;
        const x11 = cosX;
        const x12 = -sinX;
        // const x20 = 0;
        const x21 = sinX;
        const x22 = cosX;
        const y00 = cosY;
        // const y01 = 0;
        const y02 = sinY;
        // const y10 = 0;
        // const y11 = 1;
        // const y12 = 0;
        const y20 = -sinY;
        // const y21 = 0;
        const y22 = cosY;
        const z00 = cosZ;
        const z01 = -sinZ;
        // const z02 = 0;
        const z10 = sinZ;
        const z11 = cosZ;
        // const z12 = 0;
        // const z20 = 0;
        // const z21 = 0;
        // const z22 = 1;
        // calculate this.multiply(this.rotateY(y), this.rotateX(x))
        const yx00 = y00;
        const yx01 = y02 * x21;
        const yx02 = y02 * x22;
        //const yx10 = 0;
        const yx11 = x11;
        const yx12 = x12;
        const yx20 = y20;
        const yx21 = y22 * x21;
        const yx22 = y22 * x22;
        // calculate this.multiply(this.rotateZ(z), this.multiply(this.rotateY(y), this.rotateX(x)))
        const m00 = z00 * yx00;
        const m01 = z00 * yx01 + z01 * yx11;
        const m02 = z00 * yx02 + z01 * yx12;
        const m10 = z10 * yx00;
        const m11 = z10 * yx01 + z11 * yx11;
        const m12 = z10 * yx02 + z11 * yx12;
        const m20 = yx20;
        const m21 = yx21;
        const m22 = yx22;
        return new this(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    static rotate(vec) {
        return this.rotateXYZ(vec.v[0], vec.v[1], vec.v[2]);
    }
    /**
     * Create Scale Matrix
     */
    static scale(vec) {
        return new this(vec.v[0], 0, 0, 0, vec.v[1], 0, 0, 0, vec.v[2]);
    }
    /**
     * multiply matrixes
     */
    static multiply(l_mat, r_mat) {
        const m00 = l_mat.v[0] * r_mat.v[0] + l_mat.v[3] * r_mat.v[1] + l_mat.v[6] * r_mat.v[2];
        const m10 = l_mat.v[1] * r_mat.v[0] + l_mat.v[4] * r_mat.v[1] + l_mat.v[7] * r_mat.v[2];
        const m20 = l_mat.v[2] * r_mat.v[0] + l_mat.v[5] * r_mat.v[1] + l_mat.v[8] * r_mat.v[2];
        const m01 = l_mat.v[0] * r_mat.v[3] + l_mat.v[3] * r_mat.v[4] + l_mat.v[6] * r_mat.v[5];
        const m11 = l_mat.v[1] * r_mat.v[3] + l_mat.v[4] * r_mat.v[4] + l_mat.v[7] * r_mat.v[5];
        const m21 = l_mat.v[2] * r_mat.v[3] + l_mat.v[5] * r_mat.v[4] + l_mat.v[8] * r_mat.v[5];
        const m02 = l_mat.v[0] * r_mat.v[6] + l_mat.v[3] * r_mat.v[7] + l_mat.v[6] * r_mat.v[8];
        const m12 = l_mat.v[1] * r_mat.v[6] + l_mat.v[4] * r_mat.v[7] + l_mat.v[7] * r_mat.v[8];
        const m22 = l_mat.v[2] * r_mat.v[6] + l_mat.v[5] * r_mat.v[7] + l_mat.v[8] * r_mat.v[8];
        return new this(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    /**
     * multiply matrixes
     */
    static multiplyTo(l_mat, r_mat, outMat) {
        const m00 = l_mat.v[0] * r_mat.v[0] + l_mat.v[3] * r_mat.v[1] + l_mat.v[6] * r_mat.v[2];
        const m10 = l_mat.v[1] * r_mat.v[0] + l_mat.v[4] * r_mat.v[1] + l_mat.v[7] * r_mat.v[2];
        const m20 = l_mat.v[2] * r_mat.v[0] + l_mat.v[5] * r_mat.v[1] + l_mat.v[8] * r_mat.v[2];
        const m01 = l_mat.v[0] * r_mat.v[3] + l_mat.v[3] * r_mat.v[4] + l_mat.v[6] * r_mat.v[5];
        const m11 = l_mat.v[1] * r_mat.v[3] + l_mat.v[4] * r_mat.v[4] + l_mat.v[7] * r_mat.v[5];
        const m21 = l_mat.v[2] * r_mat.v[3] + l_mat.v[5] * r_mat.v[4] + l_mat.v[8] * r_mat.v[5];
        const m02 = l_mat.v[0] * r_mat.v[6] + l_mat.v[3] * r_mat.v[7] + l_mat.v[6] * r_mat.v[8];
        const m12 = l_mat.v[1] * r_mat.v[6] + l_mat.v[4] * r_mat.v[7] + l_mat.v[7] * r_mat.v[8];
        const m22 = l_mat.v[2] * r_mat.v[6] + l_mat.v[5] * r_mat.v[7] + l_mat.v[8] * r_mat.v[8];
        return outMat.setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    toString() {
        return this.v[0] + ' ' + this.v[3] + ' ' + this.v[6] + '\n' +
            this.v[1] + ' ' + this.v[4] + ' ' + this.v[7] + '\n' +
            this.v[2] + ' ' + this.v[5] + ' ' + this.v[8] + '\n';
    }
    toStringApproximately() {
        return _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[0]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[3]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[6]) + '\n' +
            _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[1]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[4]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[7]) + ' \n' +
            _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[2]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[5]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].nearZeroToZero(this.v[8]) + '\n';
    }
    flattenAsArray() {
        return [this.v[0], this.v[1], this.v[2],
            this.v[3], this.v[4], this.v[5],
            this.v[6], this.v[7], this.v[8]];
    }
    isDummy() {
        if (this.v.length === 0) {
            return true;
        }
        else {
            return false;
        }
    }
    isEqual(mat, delta = Number.EPSILON) {
        if (Math.abs(mat.v[0] - this.v[0]) < delta &&
            Math.abs(mat.v[1] - this.v[1]) < delta &&
            Math.abs(mat.v[2] - this.v[2]) < delta &&
            Math.abs(mat.v[3] - this.v[3]) < delta &&
            Math.abs(mat.v[4] - this.v[4]) < delta &&
            Math.abs(mat.v[5] - this.v[5]) < delta &&
            Math.abs(mat.v[6] - this.v[6]) < delta &&
            Math.abs(mat.v[7] - this.v[7]) < delta &&
            Math.abs(mat.v[8] - this.v[8]) < delta) {
            return true;
        }
        else {
            return false;
        }
    }
    isStrictEqual(mat) {
        if (mat.v[0] === this.v[0] && mat.v[1] === this.v[1] && mat.v[2] === this.v[2] &&
            mat.v[3] === this.v[3] && mat.v[4] === this.v[4] && mat.v[5] === this.v[5] &&
            mat.v[6] === this.v[6] && mat.v[7] === this.v[7] && mat.v[8] === this.v[8]) {
            return true;
        }
        else {
            return false;
        }
    }
    at(row_i, column_i) {
        return this.v[row_i + column_i * 3];
    }
    determinant() {
        return this.v[0] * this.v[4] * this.v[8] + this.v[1] * this.v[5] * this.v[6] + this.v[2] * this.v[3] * this.v[7]
            - this.v[0] * this.v[5] * this.v[7] - this.v[2] * this.v[4] * this.v[6] - this.v[1] * this.v[3] * this.v[8];
    }
    multiplyVector(vec) {
        const x = this.v[0] * vec.v[0] + this.v[3] * vec.v[1] + this.v[6] * vec.v[2];
        const y = this.v[1] * vec.v[0] + this.v[4] * vec.v[1] + this.v[7] * vec.v[2];
        const z = this.v[2] * vec.v[0] + this.v[5] * vec.v[1] + this.v[8] * vec.v[2];
        return new vec.constructor(x, y, z);
    }
    multiplyVectorTo(vec, outVec) {
        const x = this.v[0] * vec.v[0] + this.v[3] * vec.v[1] + this.v[6] * vec.v[2];
        const y = this.v[1] * vec.v[0] + this.v[4] * vec.v[1] + this.v[7] * vec.v[2];
        const z = this.v[2] * vec.v[0] + this.v[5] * vec.v[1] + this.v[8] * vec.v[2];
        outVec.v[0] = x;
        outVec.v[1] = y;
        outVec.v[2] = z;
        return outVec;
    }
    getScale() {
        return new _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](Math.hypot(this.v[0], this.v[3], this.v[6]), Math.hypot(this.v[1], this.v[4], this.v[7]), Math.hypot(this.v[2], this.v[5], this.v[8]));
    }
    getScaleTo(outVec) {
        outVec.v[0] = Math.hypot(this.v[0], this.v[3], this.v[6]);
        outVec.v[1] = Math.hypot(this.v[1], this.v[4], this.v[7]);
        outVec.v[2] = Math.hypot(this.v[2], this.v[5], this.v[8]);
        return outVec;
    }
    clone() {
        return new this.constructor(this.v[0], this.v[3], this.v[6], this.v[1], this.v[4], this.v[7], this.v[2], this.v[5], this.v[8]);
    }
}


/***/ }),

/***/ "./src/foundation/math/Matrix44.ts":
/*!*****************************************!*\
  !*** ./src/foundation/math/Matrix44.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix44; });
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _Quaternion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion */ "./src/foundation/math/Quaternion.ts");
/* harmony import */ var _Vector4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _MathUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MathUtil */ "./src/foundation/math/MathUtil.ts");





const FloatArray = Float32Array;
class Matrix44 {
    constructor(m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15, isColumnMajor = false, notCopyFloatArray = false) {
        const _isColumnMajor = (arguments.length >= 16) ? isColumnMajor : m1;
        const _notCopyFloatArray = (arguments.length >= 16) ? notCopyFloatArray : m2;
        const m = m0;
        if (m == null) {
            this.v = new FloatArray(0);
            return;
        }
        if (arguments.length >= 16 && arguments[3] != null) {
            this.v = new FloatArray(16); // Data order is column major
            let m = arguments;
            if (_isColumnMajor === true) {
                this.v[0] = m[0];
                this.v[4] = m[4];
                this.v[8] = m[8];
                this.v[12] = m[12];
                this.v[1] = m[1];
                this.v[5] = m[5];
                this.v[9] = m[9];
                this.v[13] = m[13];
                this.v[2] = m[2];
                this.v[6] = m[6];
                this.v[10] = m[10];
                this.v[14] = m[14];
                this.v[3] = m[3];
                this.v[7] = m[7];
                this.v[11] = m[11];
                this.v[15] = m[15];
            }
            else {
                // arguments[0-15] must be row major values if isColumnMajor is false
                this.v[0] = m[0];
                this.v[4] = m[1];
                this.v[8] = m[2];
                this.v[12] = m[3];
                this.v[1] = m[4];
                this.v[5] = m[5];
                this.v[9] = m[6];
                this.v[13] = m[7];
                this.v[2] = m[8];
                this.v[6] = m[9];
                this.v[10] = m[10];
                this.v[14] = m[11];
                this.v[3] = m[12];
                this.v[7] = m[13];
                this.v[11] = m[14];
                this.v[15] = m[15];
            }
        }
        else if (Array.isArray(m)) {
            this.v = new FloatArray(16);
            if (_isColumnMajor === true) {
                this.v[0] = m[0];
                this.v[4] = m[4];
                this.v[8] = m[8];
                this.v[12] = m[12];
                this.v[1] = m[1];
                this.v[5] = m[5];
                this.v[9] = m[9];
                this.v[13] = m[13];
                this.v[2] = m[2];
                this.v[6] = m[6];
                this.v[10] = m[10];
                this.v[14] = m[14];
                this.v[3] = m[3];
                this.v[7] = m[7];
                this.v[11] = m[11];
                this.v[15] = m[15];
            }
            else {
                // 'm' must be row major values if isColumnMajor is false
                this.v[0] = m[0];
                this.v[4] = m[1];
                this.v[8] = m[2];
                this.v[12] = m[3];
                this.v[1] = m[4];
                this.v[5] = m[5];
                this.v[9] = m[6];
                this.v[13] = m[7];
                this.v[2] = m[8];
                this.v[6] = m[9];
                this.v[10] = m[10];
                this.v[14] = m[11];
                this.v[3] = m[12];
                this.v[7] = m[13];
                this.v[11] = m[14];
                this.v[15] = m[15];
            }
        }
        else if (m instanceof FloatArray) {
            if (_notCopyFloatArray) {
                this.v = m;
            }
            else {
                this.v = new FloatArray(16);
                if (_isColumnMajor === true) {
                    this.v[0] = m[0];
                    this.v[4] = m[4];
                    this.v[8] = m[8];
                    this.v[12] = m[12];
                    this.v[1] = m[1];
                    this.v[5] = m[5];
                    this.v[9] = m[9];
                    this.v[13] = m[13];
                    this.v[2] = m[2];
                    this.v[6] = m[6];
                    this.v[10] = m[10];
                    this.v[14] = m[14];
                    this.v[3] = m[3];
                    this.v[7] = m[7];
                    this.v[11] = m[11];
                    this.v[15] = m[15];
                }
                else {
                    // 'm' must be row major values if isColumnMajor is false
                    this.v[0] = m[0];
                    this.v[4] = m[1];
                    this.v[8] = m[2];
                    this.v[12] = m[3];
                    this.v[1] = m[4];
                    this.v[5] = m[5];
                    this.v[9] = m[6];
                    this.v[13] = m[7];
                    this.v[2] = m[8];
                    this.v[6] = m[9];
                    this.v[10] = m[10];
                    this.v[14] = m[11];
                    this.v[3] = m[12];
                    this.v[7] = m[13];
                    this.v[11] = m[14];
                    this.v[15] = m[15];
                }
            }
        }
        else if (!!m && typeof m.v[15] !== 'undefined' && typeof m.v[10] !== 'undefined') {
            if (_notCopyFloatArray) {
                this.v = m.v;
            }
            else {
                this.v = new FloatArray(16);
                const v = m.v;
                this.v[0] = v[0];
                this.v[4] = v[4];
                this.v[8] = v[8];
                this.v[12] = v[12];
                this.v[1] = v[1];
                this.v[5] = v[5];
                this.v[9] = v[9];
                this.v[13] = v[13];
                this.v[2] = v[2];
                this.v[6] = v[6];
                this.v[10] = v[10];
                this.v[14] = v[14];
                this.v[3] = v[3];
                this.v[7] = v[7];
                this.v[11] = v[11];
                this.v[15] = v[15];
            }
        }
        else if (!!m && typeof m.v[15] === 'undefined' && typeof m.v[10] !== 'undefined') {
            if (_notCopyFloatArray) {
                this.v = m.v;
            }
            else {
                this.v = new FloatArray(16);
                const v = m.v;
                this.v[0] = v[0];
                this.v[4] = v[3];
                this.v[8] = v[6];
                this.v[12] = 0;
                this.v[1] = v[1];
                this.v[5] = v[4];
                this.v[9] = v[7];
                this.v[13] = 0;
                this.v[2] = v[2];
                this.v[6] = v[5];
                this.v[10] = v[8];
                this.v[14] = 0;
                this.v[3] = 0;
                this.v[7] = 0;
                this.v[11] = 0;
                this.v[15] = 1;
            }
        }
        else if (!!m && typeof m.className !== 'undefined' && m instanceof _Quaternion__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            this.v = new FloatArray(16);
            const sx = m.v[0] * m.v[0];
            const sy = m.v[1] * m.v[1];
            const sz = m.v[2] * m.v[2];
            const cx = m.v[1] * m.v[2];
            const cy = m.v[0] * m.v[2];
            const cz = m.v[0] * m.v[1];
            const wx = m.v[3] * m.v[0];
            const wy = m.v[3] * m.v[1];
            const wz = m.v[3] * m.v[2];
            this.v[0] = 1.0 - 2.0 * (sy + sz);
            this.v[4] = 2.0 * (cz - wz);
            this.v[8] = 2.0 * (cy + wy);
            this.v[12] = 0;
            this.v[1] = 2.0 * (cz + wz);
            this.v[5] = 1.0 - 2.0 * (sx + sz);
            this.v[9] = 2.0 * (cx - wx);
            this.v[13] = 0;
            this.v[2] = 2.0 * (cy - wy);
            this.v[6] = 2.0 * (cx + wx);
            this.v[10] = 1.0 - 2.0 * (sx + sy);
            this.v[14] = 0;
            this.v[3] = 0;
            this.v[7] = 0;
            this.v[11] = 0;
            this.v[15] = 1;
        }
        else {
            this.v = new FloatArray(16);
            this.v[0] = 1;
            this.v[4] = 0;
            this.v[8] = 0;
            this.v[12] = 0;
            this.v[1] = 0;
            this.v[5] = 1;
            this.v[9] = 0;
            this.v[13] = 0;
            this.v[2] = 0;
            this.v[6] = 0;
            this.v[10] = 1;
            this.v[14] = 0;
            this.v[3] = 0;
            this.v[7] = 0;
            this.v[11] = 0;
            this.v[15] = 1;
        }
    }
    get m00() {
        return this.v[0];
    }
    get m10() {
        return this.v[1];
    }
    get m20() {
        return this.v[2];
    }
    get m30() {
        return this.v[3];
    }
    get m01() {
        return this.v[4];
    }
    get m11() {
        return this.v[5];
    }
    get m21() {
        return this.v[6];
    }
    get m31() {
        return this.v[7];
    }
    get m02() {
        return this.v[8];
    }
    get m12() {
        return this.v[9];
    }
    get m22() {
        return this.v[10];
    }
    get m32() {
        return this.v[11];
    }
    get m03() {
        return this.v[12];
    }
    get m13() {
        return this.v[13];
    }
    get m23() {
        return this.v[14];
    }
    get m33() {
        return this.v[15];
    }
    get className() {
        return this.constructor.name;
    }
    static get compositionType() {
        return _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Mat4;
    }
    /**
     * zero matrix(static version)
     */
    static zero() {
        return new this(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * Create identity matrix
     */
    static identity() {
        return new this(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    static dummy() {
        return new this(null);
    }
    /**
     * Create transpose matrix
     */
    static transpose(mat) {
        return new this(mat.v[0], mat.v[1], mat.v[2], mat.v[3], mat.v[4], mat.v[5], mat.v[6], mat.v[7], mat.v[8], mat.v[9], mat.v[10], mat.v[11], mat.v[12], mat.v[13], mat.v[14], mat.v[15]);
    }
    /**
     * Create invert matrix
     */
    static invert(mat) {
        const n00 = mat.v[0] * mat.v[5] - mat.v[4] * mat.v[1];
        const n01 = mat.v[0] * mat.v[9] - mat.v[8] * mat.v[1];
        const n02 = mat.v[0] * mat.v[13] - mat.v[12] * mat.v[1];
        const n03 = mat.v[4] * mat.v[9] - mat.v[8] * mat.v[5];
        const n04 = mat.v[4] * mat.v[13] - mat.v[12] * mat.v[5];
        const n05 = mat.v[8] * mat.v[13] - mat.v[12] * mat.v[9];
        const n06 = mat.v[2] * mat.v[7] - mat.v[6] * mat.v[3];
        const n07 = mat.v[2] * mat.v[11] - mat.v[10] * mat.v[3];
        const n08 = mat.v[2] * mat.v[15] - mat.v[14] * mat.v[3];
        const n09 = mat.v[6] * mat.v[11] - mat.v[10] * mat.v[7];
        const n10 = mat.v[6] * mat.v[15] - mat.v[14] * mat.v[7];
        const n11 = mat.v[10] * mat.v[15] - mat.v[14] * mat.v[11];
        const det = n00 * n11 - n01 * n10 + n02 * n09 + n03 * n08 - n04 * n07 + n05 * n06;
        if (det === 0) {
            console.error("the determinant is 0!");
        }
        const m00 = (mat.v[5] * n11 - mat.v[9] * n10 + mat.v[13] * n09) / det;
        const m01 = (mat.v[8] * n10 - mat.v[4] * n11 - mat.v[12] * n09) / det;
        const m02 = (mat.v[7] * n05 - mat.v[11] * n04 + mat.v[15] * n03) / det;
        const m03 = (mat.v[10] * n04 - mat.v[6] * n05 - mat.v[14] * n03) / det;
        const m10 = (mat.v[9] * n08 - mat.v[1] * n11 - mat.v[13] * n07) / det;
        const m11 = (mat.v[0] * n11 - mat.v[8] * n08 + mat.v[12] * n07) / det;
        const m12 = (mat.v[11] * n02 - mat.v[3] * n05 - mat.v[15] * n01) / det;
        const m13 = (mat.v[2] * n05 - mat.v[10] * n02 + mat.v[14] * n01) / det;
        const m20 = (mat.v[1] * n10 - mat.v[5] * n08 + mat.v[13] * n06) / det;
        const m21 = (mat.v[4] * n08 - mat.v[0] * n10 - mat.v[12] * n06) / det;
        const m22 = (mat.v[3] * n04 - mat.v[7] * n02 + mat.v[15] * n00) / det;
        const m23 = (mat.v[6] * n02 - mat.v[2] * n04 - mat.v[14] * n00) / det;
        const m30 = (mat.v[5] * n07 - mat.v[1] * n09 - mat.v[9] * n06) / det;
        const m31 = (mat.v[0] * n09 - mat.v[4] * n07 + mat.v[8] * n06) / det;
        const m32 = (mat.v[7] * n01 - mat.v[3] * n03 - mat.v[11] * n00) / det;
        const m33 = (mat.v[2] * n03 - mat.v[6] * n01 + mat.v[10] * n00) / det;
        return new this(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
    static invertTo(mat, outMat) {
        const n00 = mat.v[0] * mat.v[5] - mat.v[4] * mat.v[1];
        const n01 = mat.v[0] * mat.v[9] - mat.v[8] * mat.v[1];
        const n02 = mat.v[0] * mat.v[13] - mat.v[12] * mat.v[1];
        const n03 = mat.v[4] * mat.v[9] - mat.v[8] * mat.v[5];
        const n04 = mat.v[4] * mat.v[13] - mat.v[12] * mat.v[5];
        const n05 = mat.v[8] * mat.v[13] - mat.v[12] * mat.v[9];
        const n06 = mat.v[2] * mat.v[7] - mat.v[6] * mat.v[3];
        const n07 = mat.v[2] * mat.v[11] - mat.v[10] * mat.v[3];
        const n08 = mat.v[2] * mat.v[15] - mat.v[14] * mat.v[3];
        const n09 = mat.v[6] * mat.v[11] - mat.v[10] * mat.v[7];
        const n10 = mat.v[6] * mat.v[15] - mat.v[14] * mat.v[7];
        const n11 = mat.v[10] * mat.v[15] - mat.v[14] * mat.v[11];
        const det = n00 * n11 - n01 * n10 + n02 * n09 + n03 * n08 - n04 * n07 + n05 * n06;
        if (det === 0) {
            console.error("the determinant is 0!");
        }
        const m00 = (mat.v[5] * n11 - mat.v[9] * n10 + mat.v[13] * n09) / det;
        const m01 = (mat.v[8] * n10 - mat.v[4] * n11 - mat.v[12] * n09) / det;
        const m02 = (mat.v[7] * n05 - mat.v[11] * n04 + mat.v[15] * n03) / det;
        const m03 = (mat.v[10] * n04 - mat.v[6] * n05 - mat.v[14] * n03) / det;
        const m10 = (mat.v[9] * n08 - mat.v[1] * n11 - mat.v[13] * n07) / det;
        const m11 = (mat.v[0] * n11 - mat.v[8] * n08 + mat.v[12] * n07) / det;
        const m12 = (mat.v[11] * n02 - mat.v[3] * n05 - mat.v[15] * n01) / det;
        const m13 = (mat.v[2] * n05 - mat.v[10] * n02 + mat.v[14] * n01) / det;
        const m20 = (mat.v[1] * n10 - mat.v[5] * n08 + mat.v[13] * n06) / det;
        const m21 = (mat.v[4] * n08 - mat.v[0] * n10 - mat.v[12] * n06) / det;
        const m22 = (mat.v[3] * n04 - mat.v[7] * n02 + mat.v[15] * n00) / det;
        const m23 = (mat.v[6] * n02 - mat.v[2] * n04 - mat.v[14] * n00) / det;
        const m30 = (mat.v[5] * n07 - mat.v[1] * n09 - mat.v[9] * n06) / det;
        const m31 = (mat.v[0] * n09 - mat.v[4] * n07 + mat.v[8] * n06) / det;
        const m32 = (mat.v[7] * n01 - mat.v[3] * n03 - mat.v[11] * n00) / det;
        const m33 = (mat.v[2] * n03 - mat.v[6] * n01 + mat.v[10] * n00) / det;
        return outMat.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
    /**
     * Create translation Matrix
     */
    static translate(vec) {
        return new this(1, 0, 0, vec.v[0], 0, 1, 0, vec.v[1], 0, 0, 1, vec.v[2], 0, 0, 0, 1);
    }
    /**
     * Create X oriented Rotation Matrix
     */
    static rotateX(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return new this(1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1);
    }
    /**
     * Create Y oriented Rotation Matrix
     */
    static rotateY(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return new this(cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0, 0, 0, 0, 1);
    }
    /**
     * Create Z oriented Rotation Matrix
     */
    static rotateZ(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return new this(cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    static rotateXYZ(x, y, z) {
        const cosX = Math.cos(x);
        const sinX = Math.sin(x);
        const cosY = Math.cos(y);
        const sinY = Math.sin(y);
        const cosZ = Math.cos(z);
        const sinZ = Math.sin(z);
        // const x00 = 1;
        // const x01 = 0;
        // const x02 = 0;
        // const x10 = 0;
        const x11 = cosX;
        const x12 = -sinX;
        // const x20 = 0;
        const x21 = sinX;
        const x22 = cosX;
        const y00 = cosY;
        // const y01 = 0;
        const y02 = sinY;
        // const y10 = 0;
        // const y11 = 1;
        // const y12 = 0;
        const y20 = -sinY;
        // const y21 = 0;
        const y22 = cosY;
        const z00 = cosZ;
        const z01 = -sinZ;
        // const z02 = 0;
        const z10 = sinZ;
        const z11 = cosZ;
        // const z12 = 0;
        // const z20 = 0;
        // const z21 = 0;
        // const z22 = 1;
        // Y * X
        const yx00 = y00;
        const yx01 = y02 * x21;
        const yx02 = y02 * x22;
        //const yx10 = 0;
        const yx11 = x11;
        const yx12 = x12;
        const yx20 = y20;
        const yx21 = y22 * x21;
        const yx22 = y22 * x22;
        // Z * Y * X
        const m00 = z00 * yx00;
        const m01 = z00 * yx01 + z01 * yx11;
        const m02 = z00 * yx02 + z01 * yx12;
        const m10 = z10 * yx00;
        const m11 = z10 * yx01 + z11 * yx11;
        const m12 = z10 * yx02 + z11 * yx12;
        const m20 = yx20;
        const m21 = yx21;
        const m22 = yx22;
        const m03 = 0;
        const m13 = 0;
        const m23 = 0;
        const m30 = 0;
        const m31 = 0;
        const m32 = 0;
        const m33 = 1;
        return new this(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
    static rotate(vec) {
        return this.rotateXYZ(vec.v[0], vec.v[1], vec.v[2]);
    }
    /**
     * Create Scale Matrix
     */
    static scale(vec) {
        return new this(vec.v[0], 0, 0, 0, 0, vec.v[1], 0, 0, 0, 0, vec.v[2], 0, 0, 0, 0, 1);
    }
    /**
     * multiply matrixes
     */
    static multiply(l_mat, r_mat) {
        const m00 = l_mat.v[0] * r_mat.v[0] + l_mat.v[4] * r_mat.v[1] + l_mat.v[8] * r_mat.v[2] + l_mat.v[12] * r_mat.v[3];
        const m10 = l_mat.v[1] * r_mat.v[0] + l_mat.v[5] * r_mat.v[1] + l_mat.v[9] * r_mat.v[2] + l_mat.v[13] * r_mat.v[3];
        const m20 = l_mat.v[2] * r_mat.v[0] + l_mat.v[6] * r_mat.v[1] + l_mat.v[10] * r_mat.v[2] + l_mat.v[14] * r_mat.v[3];
        const m30 = l_mat.v[3] * r_mat.v[0] + l_mat.v[7] * r_mat.v[1] + l_mat.v[11] * r_mat.v[2] + l_mat.v[15] * r_mat.v[3];
        const m01 = l_mat.v[0] * r_mat.v[4] + l_mat.v[4] * r_mat.v[5] + l_mat.v[8] * r_mat.v[6] + l_mat.v[12] * r_mat.v[7];
        const m11 = l_mat.v[1] * r_mat.v[4] + l_mat.v[5] * r_mat.v[5] + l_mat.v[9] * r_mat.v[6] + l_mat.v[13] * r_mat.v[7];
        const m21 = l_mat.v[2] * r_mat.v[4] + l_mat.v[6] * r_mat.v[5] + l_mat.v[10] * r_mat.v[6] + l_mat.v[14] * r_mat.v[7];
        const m31 = l_mat.v[3] * r_mat.v[4] + l_mat.v[7] * r_mat.v[5] + l_mat.v[11] * r_mat.v[6] + l_mat.v[15] * r_mat.v[7];
        const m02 = l_mat.v[0] * r_mat.v[8] + l_mat.v[4] * r_mat.v[9] + l_mat.v[8] * r_mat.v[10] + l_mat.v[12] * r_mat.v[11];
        const m12 = l_mat.v[1] * r_mat.v[8] + l_mat.v[5] * r_mat.v[9] + l_mat.v[9] * r_mat.v[10] + l_mat.v[13] * r_mat.v[11];
        const m22 = l_mat.v[2] * r_mat.v[8] + l_mat.v[6] * r_mat.v[9] + l_mat.v[10] * r_mat.v[10] + l_mat.v[14] * r_mat.v[11];
        const m32 = l_mat.v[3] * r_mat.v[8] + l_mat.v[7] * r_mat.v[9] + l_mat.v[11] * r_mat.v[10] + l_mat.v[15] * r_mat.v[11];
        const m03 = l_mat.v[0] * r_mat.v[12] + l_mat.v[4] * r_mat.v[13] + l_mat.v[8] * r_mat.v[14] + l_mat.v[12] * r_mat.v[15];
        const m13 = l_mat.v[1] * r_mat.v[12] + l_mat.v[5] * r_mat.v[13] + l_mat.v[9] * r_mat.v[14] + l_mat.v[13] * r_mat.v[15];
        const m23 = l_mat.v[2] * r_mat.v[12] + l_mat.v[6] * r_mat.v[13] + l_mat.v[10] * r_mat.v[14] + l_mat.v[14] * r_mat.v[15];
        const m33 = l_mat.v[3] * r_mat.v[12] + l_mat.v[7] * r_mat.v[13] + l_mat.v[11] * r_mat.v[14] + l_mat.v[15] * r_mat.v[15];
        return new this(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
    /**
     * multiply matrixes
     */
    static multiplyTo(l_mat, r_mat, outMat) {
        const m00 = l_mat.v[0] * r_mat.v[0] + l_mat.v[4] * r_mat.v[1] + l_mat.v[8] * r_mat.v[2] + l_mat.v[12] * r_mat.v[3];
        const m10 = l_mat.v[1] * r_mat.v[0] + l_mat.v[5] * r_mat.v[1] + l_mat.v[9] * r_mat.v[2] + l_mat.v[13] * r_mat.v[3];
        const m20 = l_mat.v[2] * r_mat.v[0] + l_mat.v[6] * r_mat.v[1] + l_mat.v[10] * r_mat.v[2] + l_mat.v[14] * r_mat.v[3];
        const m30 = l_mat.v[3] * r_mat.v[0] + l_mat.v[7] * r_mat.v[1] + l_mat.v[11] * r_mat.v[2] + l_mat.v[15] * r_mat.v[3];
        const m01 = l_mat.v[0] * r_mat.v[4] + l_mat.v[4] * r_mat.v[5] + l_mat.v[8] * r_mat.v[6] + l_mat.v[12] * r_mat.v[7];
        const m11 = l_mat.v[1] * r_mat.v[4] + l_mat.v[5] * r_mat.v[5] + l_mat.v[9] * r_mat.v[6] + l_mat.v[13] * r_mat.v[7];
        const m21 = l_mat.v[2] * r_mat.v[4] + l_mat.v[6] * r_mat.v[5] + l_mat.v[10] * r_mat.v[6] + l_mat.v[14] * r_mat.v[7];
        const m31 = l_mat.v[3] * r_mat.v[4] + l_mat.v[7] * r_mat.v[5] + l_mat.v[11] * r_mat.v[6] + l_mat.v[15] * r_mat.v[7];
        const m02 = l_mat.v[0] * r_mat.v[8] + l_mat.v[4] * r_mat.v[9] + l_mat.v[8] * r_mat.v[10] + l_mat.v[12] * r_mat.v[11];
        const m12 = l_mat.v[1] * r_mat.v[8] + l_mat.v[5] * r_mat.v[9] + l_mat.v[9] * r_mat.v[10] + l_mat.v[13] * r_mat.v[11];
        const m22 = l_mat.v[2] * r_mat.v[8] + l_mat.v[6] * r_mat.v[9] + l_mat.v[10] * r_mat.v[10] + l_mat.v[14] * r_mat.v[11];
        const m32 = l_mat.v[3] * r_mat.v[8] + l_mat.v[7] * r_mat.v[9] + l_mat.v[11] * r_mat.v[10] + l_mat.v[15] * r_mat.v[11];
        const m03 = l_mat.v[0] * r_mat.v[12] + l_mat.v[4] * r_mat.v[13] + l_mat.v[8] * r_mat.v[14] + l_mat.v[12] * r_mat.v[15];
        const m13 = l_mat.v[1] * r_mat.v[12] + l_mat.v[5] * r_mat.v[13] + l_mat.v[9] * r_mat.v[14] + l_mat.v[13] * r_mat.v[15];
        const m23 = l_mat.v[2] * r_mat.v[12] + l_mat.v[6] * r_mat.v[13] + l_mat.v[10] * r_mat.v[14] + l_mat.v[14] * r_mat.v[15];
        const m33 = l_mat.v[3] * r_mat.v[12] + l_mat.v[7] * r_mat.v[13] + l_mat.v[11] * r_mat.v[14] + l_mat.v[15] * r_mat.v[15];
        return outMat.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
    static fromQuaternionTo(quat, outMat) {
        const sx = quat.v[0] * quat.v[0];
        const sy = quat.v[1] * quat.v[1];
        const sz = quat.v[2] * quat.v[2];
        const cx = quat.v[1] * quat.v[2];
        const cy = quat.v[0] * quat.v[2];
        const cz = quat.v[0] * quat.v[1];
        const wx = quat.v[3] * quat.v[0];
        const wy = quat.v[3] * quat.v[1];
        const wz = quat.v[3] * quat.v[2];
        const m00 = 1.0 - 2.0 * (sy + sz);
        const m01 = 2.0 * (cz - wz);
        const m02 = 2.0 * (cy + wy);
        const m03 = 0;
        const m10 = 2.0 * (cz + wz);
        const m11 = 1.0 - 2.0 * (sx + sz);
        const m12 = 2.0 * (cx - wx);
        const m13 = 0;
        const m20 = 2.0 * (cy - wy);
        const m21 = 2.0 * (cx + wx);
        const m22 = 1.0 - 2.0 * (sx + sy);
        const m23 = 0;
        const m30 = 0;
        const m31 = 0;
        const m32 = 0;
        const m33 = 1;
        return outMat.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
    toString() {
        return this.v[0] + ' ' + this.v[4] + ' ' + this.v[8] + ' ' + this.v[12] + ' \n' +
            this.v[1] + ' ' + this.v[5] + ' ' + this.v[9] + ' ' + this.v[13] + ' \n' +
            this.v[2] + ' ' + this.v[6] + ' ' + this.v[10] + ' ' + this.v[14] + ' \n' +
            this.v[3] + ' ' + this.v[7] + ' ' + this.v[11] + ' ' + this.v[15] + ' \n';
    }
    toStringApproximately() {
        return _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[0]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[4]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[8]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[12]) + ' \n' +
            _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[1]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[5]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[9]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[13]) + ' \n' +
            _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[2]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[6]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[10]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[14]) + ' \n' +
            _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[3]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[7]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[11]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].nearZeroToZero(this.v[15]) + ' \n';
    }
    flattenAsArray() {
        return [this.v[0], this.v[1], this.v[2], this.v[3],
            this.v[4], this.v[5], this.v[6], this.v[7],
            this.v[8], this.v[9], this.v[10], this.v[11],
            this.v[12], this.v[13], this.v[14], this.v[15]];
    }
    isDummy() {
        if (this.v.length === 0) {
            return true;
        }
        else {
            return false;
        }
    }
    isEqual(mat, delta = Number.EPSILON) {
        if (Math.abs(mat.v[0] - this.v[0]) < delta &&
            Math.abs(mat.v[1] - this.v[1]) < delta &&
            Math.abs(mat.v[2] - this.v[2]) < delta &&
            Math.abs(mat.v[3] - this.v[3]) < delta &&
            Math.abs(mat.v[4] - this.v[4]) < delta &&
            Math.abs(mat.v[5] - this.v[5]) < delta &&
            Math.abs(mat.v[6] - this.v[6]) < delta &&
            Math.abs(mat.v[7] - this.v[7]) < delta &&
            Math.abs(mat.v[8] - this.v[8]) < delta &&
            Math.abs(mat.v[9] - this.v[9]) < delta &&
            Math.abs(mat.v[10] - this.v[10]) < delta &&
            Math.abs(mat.v[11] - this.v[11]) < delta &&
            Math.abs(mat.v[12] - this.v[12]) < delta &&
            Math.abs(mat.v[13] - this.v[13]) < delta &&
            Math.abs(mat.v[14] - this.v[14]) < delta &&
            Math.abs(mat.v[15] - this.v[15]) < delta) {
            return true;
        }
        else {
            return false;
        }
    }
    isStrictEqual(mat) {
        if (mat.v[0] === this.v[0] && mat.v[1] === this.v[1] && mat.v[2] === this.v[2] && mat.v[3] === this.v[3] &&
            mat.v[4] === this.v[4] && mat.v[5] === this.v[5] && mat.v[6] === this.v[6] && mat.v[7] === this.v[7] &&
            mat.v[8] === this.v[8] && mat.v[9] === this.v[9] && mat.v[10] === this.v[10] && mat.v[11] === this.v[11] &&
            mat.v[12] === this.v[12] && mat.v[13] === this.v[13] && mat.v[14] === this.v[14] && mat.v[15] === this.v[15]) {
            return true;
        }
        else {
            return false;
        }
    }
    at(row_i, column_i) {
        return this.v[row_i + column_i * 4];
    }
    determinant() {
        return this.v[0] * this.v[5] * this.v[10] * this.v[15] + this.v[0] * this.v[9] * this.v[14] * this.v[7] + this.v[0] * this.v[13] * this.v[6] * this.v[11] +
            this.v[4] * this.v[1] * this.v[14] * this.v[11] + this.v[4] * this.v[9] * this.v[2] * this.v[15] + this.v[4] * this.v[13] * this.v[10] * this.v[3] +
            this.v[8] * this.v[1] * this.v[6] * this.v[15] + this.v[8] * this.v[5] * this.v[14] * this.v[3] + this.v[8] * this.v[13] * this.v[2] * this.v[7] +
            this.v[12] * this.v[1] * this.v[10] * this.v[7] + this.v[12] * this.v[5] * this.v[2] * this.v[11] + this.v[12] * this.v[9] * this.v[6] * this.v[3] -
            this.v[0] * this.v[5] * this.v[14] * this.v[11] - this.v[0] * this.v[9] * this.v[6] * this.v[15] - this.v[0] * this.v[13] * this.v[10] * this.v[7] -
            this.v[4] * this.v[1] * this.v[10] * this.v[15] - this.v[4] * this.v[9] * this.v[14] * this.v[3] - this.v[4] * this.v[13] * this.v[2] * this.v[11] -
            this.v[8] * this.v[1] * this.v[14] * this.v[7] - this.v[8] * this.v[5] * this.v[2] * this.v[15] - this.v[8] * this.v[13] * this.v[6] * this.v[3] -
            this.v[12] * this.v[1] * this.v[6] * this.v[11] - this.v[12] * this.v[5] * this.v[10] * this.v[3] - this.v[12] * this.v[9] * this.v[2] * this.v[7];
    }
    multiplyVector(vec) {
        const x = this.v[0] * vec.v[0] + this.v[4] * vec.v[1] + this.v[8] * vec.v[2] + this.v[12] * vec.v[3];
        const y = this.v[1] * vec.v[0] + this.v[5] * vec.v[1] + this.v[9] * vec.v[2] + this.v[13] * vec.v[3];
        const z = this.v[2] * vec.v[0] + this.v[6] * vec.v[1] + this.v[10] * vec.v[2] + this.v[14] * vec.v[3];
        const w = this.v[3] * vec.v[0] + this.v[7] * vec.v[1] + this.v[11] * vec.v[2] + this.v[15] * vec.v[3];
        return new _Vector4__WEBPACK_IMPORTED_MODULE_2__["default"](x, y, z, w);
    }
    multiplyVectorTo(vec, outVec) {
        const x = this.v[0] * vec.v[0] + this.v[4] * vec.v[1] + this.v[8] * vec.v[2] + this.v[12] * vec.v[3];
        const y = this.v[1] * vec.v[0] + this.v[5] * vec.v[1] + this.v[9] * vec.v[2] + this.v[13] * vec.v[3];
        const z = this.v[2] * vec.v[0] + this.v[6] * vec.v[1] + this.v[10] * vec.v[2] + this.v[14] * vec.v[3];
        const w = this.v[3] * vec.v[0] + this.v[7] * vec.v[1] + this.v[11] * vec.v[2] + this.v[15] * vec.v[3];
        outVec.v[0] = x;
        outVec.v[1] = y;
        outVec.v[2] = z;
        outVec.v[3] = w;
        return outVec;
    }
    multiplyVectorToVec3(vec, outVec) {
        const x = this.v[0] * vec.v[0] + this.v[4] * vec.v[1] + this.v[8] * vec.v[2] + this.v[12] * vec.v[3];
        const y = this.v[1] * vec.v[0] + this.v[5] * vec.v[1] + this.v[9] * vec.v[2] + this.v[13] * vec.v[3];
        const z = this.v[2] * vec.v[0] + this.v[6] * vec.v[1] + this.v[10] * vec.v[2] + this.v[14] * vec.v[3];
        outVec.v[0] = x;
        outVec.v[1] = y;
        outVec.v[2] = z;
        return outVec;
    }
    multiplyVector3(vec) {
        const x = this.v[0] * vec.v[0] + this.v[4] * vec.v[1] + this.v[8] * vec.v[2] + this.v[12]; // regards vec.w(vec.v[3]) as 1
        const y = this.v[1] * vec.v[0] + this.v[5] * vec.v[1] + this.v[9] * vec.v[2] + this.v[13];
        const z = this.v[2] * vec.v[0] + this.v[6] * vec.v[1] + this.v[10] * vec.v[2] + this.v[14];
        return new _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](x, y, z);
    }
    multiplyVector3To(vec, outVec) {
        const x = this.v[0] * vec.v[0] + this.v[4] * vec.v[1] + this.v[8] * vec.v[2] + this.v[12]; // regards vec.w(vec.v[3]) as 1
        const y = this.v[1] * vec.v[0] + this.v[5] * vec.v[1] + this.v[9] * vec.v[2] + this.v[13];
        const z = this.v[2] * vec.v[0] + this.v[6] * vec.v[1] + this.v[10] * vec.v[2] + this.v[14];
        outVec.v[0] = x;
        outVec.v[1] = y;
        outVec.v[2] = z;
        return outVec;
    }
    getTranslate() {
        return new _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](this.v[12], this.v[13], this.v[14]);
    }
    /**
     * get translate vector from this matrix
     */
    getTranslateTo(outVec) {
        outVec.v[0] = this.v[12];
        outVec.v[1] = this.v[13];
        outVec.v[2] = this.v[14];
        return outVec;
    }
    getScale() {
        return new _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](Math.hypot(this.v[0], this.v[4], this.v[8]), Math.hypot(this.v[1], this.v[5], this.v[9]), Math.hypot(this.v[2], this.v[6], this.v[10]));
    }
    /**
     * get scale vector from this matrix
     */
    getScaleTo(outVec) {
        outVec.v[0] = Math.hypot(this.v[0], this.v[4], this.v[8]);
        outVec.v[1] = Math.hypot(this.v[1], this.v[5], this.v[9]);
        outVec.v[2] = Math.hypot(this.v[2], this.v[6], this.v[10]);
        return outVec;
    }
    /**
     * @return Euler Angles Rotation (x, y, z)
     */
    toEulerAngles() {
        let rotate = null;
        if (Math.abs(this.v[2]) != 1.0) {
            let y = -Math.asin(this.v[2]);
            let x = Math.atan2(this.v[6] / Math.cos(y), this.v[10] / Math.cos(y));
            let z = Math.atan2(this.v[1] / Math.cos(y), this.v[0] / Math.cos(y));
            rotate = new _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](x, y, z);
        }
        else if (this.v[2] === -1.0) {
            rotate = new _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](Math.atan2(this.v[4], this.v[8]), Math.PI / 2.0, 0.0);
        }
        else {
            rotate = new _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](Math.atan2(-this.v[4], -this.v[8]), -Math.PI / 2.0, 0.0);
        }
        return rotate;
    }
    toEulerAnglesTo(outVec3) {
        if (Math.abs(this.v[2]) != 1.0) {
            let y = -Math.asin(this.v[2]);
            let x = Math.atan2(this.v[6] / Math.cos(y), this.v[10] / Math.cos(y));
            let z = Math.atan2(this.v[1] / Math.cos(y), this.v[0] / Math.cos(y));
            outVec3.v[0] = x;
            outVec3.v[1] = y;
            outVec3.v[2] = z;
        }
        else if (this.v[2] === -1.0) {
            outVec3.v[0] = Math.atan2(this.v[4], this.v[8]);
            outVec3.v[1] = Math.PI / 2.0;
            outVec3.v[2] = 0.0;
        }
        else {
            outVec3.v[0] = Math.atan2(-this.v[4], -this.v[8]);
            outVec3.v[1] = -Math.PI / 2.0;
            outVec3.v[2] = 0.0;
        }
        return outVec3;
    }
    clone() {
        return new this.constructor(this.v[0], this.v[4], this.v[8], this.v[12], this.v[1], this.v[5], this.v[9], this.v[13], this.v[2], this.v[6], this.v[10], this.v[14], this.v[3], this.v[7], this.v[11], this.v[15]);
    }
    getRotate() {
        const quat = _Quaternion__WEBPACK_IMPORTED_MODULE_1__["default"].fromMatrix(this);
        const rotateMat = new this.constructor(quat);
        return rotateMat;
    }
}


/***/ }),

/***/ "./src/foundation/math/MutableMatrix22.ts":
/*!************************************************!*\
  !*** ./src/foundation/math/MutableMatrix22.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MutableMatrix22; });
/* harmony import */ var _Matrix22__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix22 */ "./src/foundation/math/Matrix22.ts");

class MutableMatrix22 extends _Matrix22__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(m0, m1, m2, m3, isColumnMajor = false, notCopyFloatArray = false) {
        super(m0, m1, m2, m3, isColumnMajor);
    }
    set m00(val) {
        this.v[0] = val;
    }
    get m00() {
        return this.v[0];
    }
    set m10(val) {
        this.v[1] = val;
    }
    get m10() {
        return this.v[1];
    }
    set m01(val) {
        this.v[2] = val;
    }
    get m01() {
        return this.v[2];
    }
    set m11(val) {
        this.v[3] = val;
    }
    get m11() {
        return this.v[3];
    }
    /**
     * Create zero matrix
     */
    static zero() {
        return super.zero();
    }
    /**
     * Create identity matrix
     */
    static identity() {
        return super.identity();
    }
    static dummy() {
        return super.dummy();
    }
    /**
     * Create transpose matrix
     */
    static transpose(mat) {
        return super.transpose(mat);
    }
    /**
     * Create invert matrix
     */
    static invert(mat) {
        return super.invert(mat);
    }
    /**
     * Create Rotation Matrix
     */
    static rotate(radian) {
        return super.rotate(radian);
    }
    /**
     * Create Scale Matrix
     */
    static scale(vec) {
        return super.scale(vec);
    }
    /**
     * multiply matrixes
     */
    static multiply(l_mat, r_mat) {
        return super.multiply(l_mat, r_mat);
    }
    clone() {
        const result = super.clone();
        return result;
    }
    raw() {
        return this.v;
    }
    setAt(row_i, column_i, value) {
        this.v[row_i + column_i * 2] = value;
        return this;
    }
    setComponents(m00, m01, m10, m11) {
        this.v[0] = m00;
        this.v[2] = m01;
        this.v[1] = m10;
        this.v[3] = m11;
        return this;
    }
    copyComponents(mat) {
        this.v[0] = mat.m00;
        this.v[2] = mat.m01; // mat.m01 is mat.v[2 or 3 or 4]
        this.v[1] = mat.m10;
        this.v[3] = mat.m11;
        return this;
    }
    /**
     * zero matrix
     */
    zero() {
        return this.setComponents(0, 0, 0, 0);
    }
    identity() {
        return this.setComponents(1, 0, 0, 1);
    }
    _swap(l, r) {
        this.v[r] = [this.v[l], this.v[l] = this.v[r]][0];
    }
    /**
     * transpose
     */
    transpose() {
        this._swap(1, 2);
        return this;
    }
    invert() {
        const det = this.determinant();
        if (det === 0) {
            console.error("the determinant is 0!");
        }
        const m00 = this.v[3] / det;
        const m01 = this.v[2] / det * (-1.0);
        const m10 = this.v[1] / det * (-1.0);
        const m11 = this.v[0] / det;
        return this.setComponents(m00, m01, m10, m11);
    }
    /**
     * Create Rotation Matrix
     */
    rotate(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(cos, -sin, sin, cos);
    }
    scale(vec) {
        return this.setComponents(vec.v[0], 0, 0, vec.v[1]);
    }
    putScale(vec) {
        this.v[0] *= vec.v[0];
        this.v[2] *= vec.v[0];
        this.v[1] *= vec.v[1];
        this.v[3] *= vec.v[1];
        return this;
    }
    /**
      * multiply the input matrix from right side
      */
    multiply(mat) {
        const m00 = this.v[0] * mat.v[0] + this.v[2] * mat.v[1];
        const m01 = this.v[0] * mat.v[2] + this.v[2] * mat.v[3];
        const m10 = this.v[1] * mat.v[0] + this.v[3] * mat.v[1];
        const m11 = this.v[1] * mat.v[2] + this.v[3] * mat.v[3];
        return this.setComponents(m00, m01, m10, m11);
    }
    multiplyByLeft(mat) {
        const m00 = mat.v[0] * this.v[0] + mat.v[2] * this.v[1];
        const m01 = mat.v[0] * this.v[2] + mat.v[2] * this.v[3];
        const m10 = mat.v[1] * this.v[0] + mat.v[3] * this.v[1];
        const m11 = mat.v[1] * this.v[2] + mat.v[3] * this.v[3];
        return this.setComponents(m00, m01, m10, m11);
    }
}


/***/ }),

/***/ "./src/foundation/math/MutableMatrix33.ts":
/*!************************************************!*\
  !*** ./src/foundation/math/MutableMatrix33.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MutableMatrix33; });
/* harmony import */ var _Matrix33__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix33 */ "./src/foundation/math/Matrix33.ts");

class MutableMatrix33 extends _Matrix33__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(m0, m1, m2, m3, m4, m5, m6, m7, m8, isColumnMajor = false, notCopyFloatArray = false) {
        super(m0, m1, m2, m3, m4, m5, m6, m7, m8, isColumnMajor);
    }
    set m00(val) {
        this.v[0] = val;
    }
    get m00() {
        return this.v[0];
    }
    set m10(val) {
        this.v[1] = val;
    }
    get m10() {
        return this.v[1];
    }
    set m20(val) {
        this.v[2] = val;
    }
    get m20() {
        return this.v[2];
    }
    set m01(val) {
        this.v[3] = val;
    }
    get m01() {
        return this.v[3];
    }
    set m11(val) {
        this.v[4] = val;
    }
    get m11() {
        return this.v[4];
    }
    set m21(val) {
        this.v[5] = val;
    }
    get m21() {
        return this.v[5];
    }
    set m02(val) {
        this.v[6] = val;
    }
    get m02() {
        return this.v[6];
    }
    set m12(val) {
        this.v[7] = val;
    }
    get m12() {
        return this.v[7];
    }
    set m22(val) {
        this.v[8] = val;
    }
    get m22() {
        return this.v[8];
    }
    /**
     * zero matrix(static version)
     */
    static zero() {
        return super.zero();
    }
    /**
     * Create identity matrix
     */
    static identity() {
        return super.identity();
    }
    static dummy() {
        return super.dummy();
    }
    /**
     * Create transpose matrix
     */
    static transpose(mat) {
        return super.transpose(mat);
    }
    /**
     * Create invert matrix
     */
    static invert(mat) {
        return super.invert(mat);
    }
    /**
   * Create X oriented Rotation Matrix
   */
    static rotateX(radian) {
        return super.rotateX(radian);
    }
    /**
     * Create Y oriented Rotation Matrix
     */
    static rotateY(radian) {
        return super.rotateY(radian);
    }
    /**
     * Create Z oriented Rotation Matrix
     */
    static rotateZ(radian) {
        return super.rotateZ(radian);
    }
    static rotateXYZ(x, y, z) {
        return super.rotateXYZ(x, y, z);
    }
    static rotate(vec) {
        return super.rotateXYZ(vec.v[0], vec.v[1], vec.v[2]);
    }
    /**
     * Create Scale Matrix
     */
    static scale(vec) {
        return super.scale(vec);
    }
    /**
     * multiply matrixes
     */
    static multiply(l_mat, r_mat) {
        return super.multiply(l_mat, r_mat);
    }
    clone() {
        const result = super.clone();
        return result;
    }
    raw() {
        return this.v;
    }
    setAt(row_i, column_i, value) {
        this.v[row_i + column_i * 3] = value;
        return this;
    }
    setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        this.v[0] = m00;
        this.v[3] = m01;
        this.v[6] = m02;
        this.v[1] = m10;
        this.v[4] = m11;
        this.v[7] = m12;
        this.v[2] = m20;
        this.v[5] = m21;
        this.v[8] = m22;
        return this;
    }
    copyComponents(mat) {
        this.v[0] = mat.m00;
        this.v[3] = mat.m01;
        this.v[6] = mat.m02; // mat.m01 is mat.v[3 or 4]
        this.v[1] = mat.m10;
        this.v[4] = mat.m11;
        this.v[7] = mat.m12;
        this.v[2] = mat.m20;
        this.v[5] = mat.m21;
        this.v[8] = mat.m22;
        return this;
    }
    /**
     * zero matrix
     */
    zero() {
        return this.setComponents(0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    identity() {
        return this.setComponents(1, 0, 0, 0, 1, 0, 0, 0, 1);
    }
    _swap(l, r) {
        this.v[r] = [this.v[l], this.v[l] = this.v[r]][0];
    }
    /**
     * transpose
     */
    transpose() {
        this._swap(1, 3);
        this._swap(2, 6);
        this._swap(5, 8);
        return this;
    }
    invert() {
        var det = this.determinant();
        if (det === 0) {
            console.error("the determinant is 0!");
        }
        var m00 = (this.v[4] * this.v[8] - this.v[7] * this.v[5]) / det;
        var m01 = (this.v[6] * this.v[5] - this.v[3] * this.v[8]) / det;
        var m02 = (this.v[3] * this.v[7] - this.v[6] * this.v[4]) / det;
        var m10 = (this.v[7] * this.v[2] - this.v[1] * this.v[8]) / det;
        var m11 = (this.v[0] * this.v[8] - this.v[6] * this.v[2]) / det;
        var m12 = (this.v[6] * this.v[1] - this.v[0] * this.v[7]) / det;
        var m20 = (this.v[1] * this.v[5] - this.v[4] * this.v[2]) / det;
        var m21 = (this.v[3] * this.v[2] - this.v[0] * this.v[5]) / det;
        var m22 = (this.v[0] * this.v[4] - this.v[3] * this.v[1]) / det;
        return this.setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    /**
     * Create X oriented Rotation Matrix
     */
    rotateX(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(1, 0, 0, 0, cos, -sin, 0, sin, cos);
    }
    /**
     * Create Y oriented Rotation Matrix
     */
    rotateY(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(cos, 0, sin, 0, 1, 0, -sin, 0, cos);
    }
    /**
     * Create Z oriented Rotation Matrix
     */
    rotateZ(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(cos, -sin, 0, sin, cos, 0, 0, 0, 1);
    }
    rotateXYZ(x, y, z) {
        const cosX = Math.cos(x);
        const sinX = Math.sin(x);
        const cosY = Math.cos(y);
        const sinY = Math.sin(y);
        const cosZ = Math.cos(z);
        const sinZ = Math.sin(z);
        // const x00 = 1;
        // const x01 = 0;
        // const x02 = 0;
        // const x10 = 0;
        const x11 = cosX;
        const x12 = -sinX;
        // const x20 = 0;
        const x21 = sinX;
        const x22 = cosX;
        const y00 = cosY;
        // const y01 = 0;
        const y02 = sinY;
        // const y10 = 0;
        // const y11 = 1;
        // const y12 = 0;
        const y20 = -sinY;
        // const y21 = 0;
        const y22 = cosY;
        const z00 = cosZ;
        const z01 = -sinZ;
        // const z02 = 0;
        const z10 = sinZ;
        const z11 = cosZ;
        // const z12 = 0;
        // const z20 = 0;
        // const z21 = 0;
        // const z22 = 1;
        // calculate this.multiply(this.rotateY(y), this.rotateX(x))
        const yx00 = y00;
        const yx01 = y02 * x21;
        const yx02 = y02 * x22;
        //const yx10 = 0;
        const yx11 = x11;
        const yx12 = x12;
        const yx20 = y20;
        const yx21 = y22 * x21;
        const yx22 = y22 * x22;
        // calculate this.multiply(this.rotateZ(z), this.multiply(this.rotateY(y), this.rotateX(x)))
        const m00 = z00 * yx00;
        const m01 = z00 * yx01 + z01 * yx11;
        const m02 = z00 * yx02 + z01 * yx12;
        const m10 = z10 * yx00;
        const m11 = z10 * yx01 + z11 * yx11;
        const m12 = z10 * yx02 + z11 * yx12;
        const m20 = yx20;
        const m21 = yx21;
        const m22 = yx22;
        return this.setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    rotate(vec) {
        return this.rotateXYZ(vec.v[0], vec.v[1], vec.v[2]);
    }
    scale(vec) {
        return this.setComponents(vec.v[0], 0, 0, 0, vec.v[1], 0, 0, 0, vec.v[2]);
    }
    putScale(vec) {
        this.v[0] *= vec.v[0];
        this.v[3] *= vec.v[0];
        this.v[6] *= vec.v[0];
        this.v[1] *= vec.v[1];
        this.v[4] *= vec.v[1];
        this.v[7] *= vec.v[1];
        this.v[2] *= vec.v[2];
        this.v[5] *= vec.v[2];
        this.v[8] *= vec.v[2];
        return this;
    }
    /**
     * multiply the input matrix from right side
     */
    multiply(mat) {
        const m00 = this.v[0] * mat.v[0] + this.v[3] * mat.v[1] + this.v[6] * mat.v[2];
        const m01 = this.v[0] * mat.v[3] + this.v[3] * mat.v[4] + this.v[6] * mat.v[5];
        const m02 = this.v[0] * mat.v[6] + this.v[3] * mat.v[7] + this.v[6] * mat.v[8];
        const m10 = this.v[1] * mat.v[0] + this.v[4] * mat.v[1] + this.v[7] * mat.v[2];
        const m11 = this.v[1] * mat.v[3] + this.v[4] * mat.v[4] + this.v[7] * mat.v[5];
        const m12 = this.v[1] * mat.v[6] + this.v[4] * mat.v[7] + this.v[7] * mat.v[8];
        const m20 = this.v[2] * mat.v[0] + this.v[5] * mat.v[1] + this.v[8] * mat.v[2];
        const m21 = this.v[2] * mat.v[3] + this.v[5] * mat.v[4] + this.v[8] * mat.v[5];
        const m22 = this.v[2] * mat.v[6] + this.v[5] * mat.v[7] + this.v[8] * mat.v[8];
        return this.setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    multiplyByLeft(mat) {
        const m00 = mat.v[0] * this.v[0] + mat.v[3] * this.v[1] + mat.v[6] * this.v[2];
        const m01 = mat.v[0] * this.v[3] + mat.v[3] * this.v[4] + mat.v[6] * this.v[5];
        const m02 = mat.v[0] * this.v[6] + mat.v[3] * this.v[7] + mat.v[6] * this.v[8];
        const m10 = mat.v[1] * this.v[0] + mat.v[4] * this.v[1] + mat.v[7] * this.v[2];
        const m11 = mat.v[1] * this.v[3] + mat.v[4] * this.v[4] + mat.v[7] * this.v[5];
        const m12 = mat.v[1] * this.v[6] + mat.v[4] * this.v[7] + mat.v[7] * this.v[8];
        const m20 = mat.v[2] * this.v[0] + mat.v[5] * this.v[1] + mat.v[8] * this.v[2];
        const m21 = mat.v[2] * this.v[3] + mat.v[5] * this.v[4] + mat.v[8] * this.v[5];
        const m22 = mat.v[2] * this.v[6] + mat.v[5] * this.v[7] + mat.v[8] * this.v[8];
        return this.setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
}


/***/ }),

/***/ "./src/foundation/math/MutableMatrix44.ts":
/*!************************************************!*\
  !*** ./src/foundation/math/MutableMatrix44.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MutableMatrix44; });
/* harmony import */ var _Matrix44__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix44 */ "./src/foundation/math/Matrix44.ts");

const FloatArray = Float32Array;
class MutableMatrix44 extends _Matrix44__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15, isColumnMajor = false, notCopyFloatArray = false) {
        const _isColumnMajor = (arguments.length >= 16) ? isColumnMajor : m1;
        const _notCopyFloatArray = (arguments.length >= 16) ? notCopyFloatArray : m2;
        if (arguments.length >= 16) {
            super(m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15, _isColumnMajor, _notCopyFloatArray);
        }
        else {
            super(m0, _isColumnMajor, _notCopyFloatArray);
        }
    }
    set m00(val) {
        this.v[0] = val;
    }
    get m00() {
        return this.v[0];
    }
    set m10(val) {
        this.v[1] = val;
    }
    get m10() {
        return this.v[1];
    }
    set m20(val) {
        this.v[2] = val;
    }
    get m20() {
        return this.v[2];
    }
    set m30(val) {
        this.v[3] = val;
    }
    get m30() {
        return this.v[3];
    }
    set m01(val) {
        this.v[4] = val;
    }
    get m01() {
        return this.v[4];
    }
    set m11(val) {
        this.v[5] = val;
    }
    get m11() {
        return this.v[5];
    }
    set m21(val) {
        this.v[6] = val;
    }
    get m21() {
        return this.v[6];
    }
    set m31(val) {
        this.v[7] = val;
    }
    get m31() {
        return this.v[7];
    }
    set m02(val) {
        this.v[8] = val;
    }
    get m02() {
        return this.v[8];
    }
    set m12(val) {
        this.v[9] = val;
    }
    get m12() {
        return this.v[9];
    }
    set m22(val) {
        this.v[10] = val;
    }
    get m22() {
        return this.v[10];
    }
    set m32(val) {
        this.v[11] = val;
    }
    get m32() {
        return this.v[11];
    }
    set m03(val) {
        this.v[12] = val;
    }
    get m03() {
        return this.v[12];
    }
    set m13(val) {
        this.v[13] = val;
    }
    get m13() {
        return this.v[13];
    }
    set m23(val) {
        this.v[14] = val;
    }
    get m23() {
        return this.v[14];
    }
    set m33(val) {
        this.v[15] = val;
    }
    get m33() {
        return this.v[15];
    }
    /**
     * zero matrix(static version)
     */
    static zero() {
        return super.zero();
    }
    /**
     * Create identity matrix
     */
    static identity() {
        return super.identity();
    }
    static dummy() {
        return super.dummy();
    }
    /**
     * Create transpose matrix
     */
    static transpose(mat) {
        return super.transpose(mat);
    }
    /**
     * Create invert matrix
     */
    static invert(mat) {
        return super.invert(mat);
    }
    /**
     * Create translation Matrix
     */
    static translate(vec) {
        return super.translate(vec);
    }
    /**
     * Create X oriented Rotation Matrix
     */
    static rotateX(radian) {
        return super.rotateX(radian);
    }
    /**
     * Create Y oriented Rotation Matrix
     */
    static rotateY(radian) {
        return super.rotateY(radian);
    }
    /**
     * Create Z oriented Rotation Matrix
     */
    static rotateZ(radian) {
        return super.rotateZ(radian);
    }
    static rotateXYZ(x, y, z) {
        return super.rotateXYZ(x, y, z);
    }
    static rotate(vec) {
        return super.rotateXYZ(vec.v[0], vec.v[1], vec.v[2]);
    }
    /**
     * Create Scale Matrix
     */
    static scale(vec) {
        return super.scale(vec);
    }
    /**
     * multiply matrixes
     */
    static multiply(l_mat, r_mat) {
        return super.multiply(l_mat, r_mat);
    }
    clone() {
        const result = super.clone();
        return result;
    }
    getRotate() {
        const rotateMat = super.getRotate();
        return rotateMat;
    }
    raw() {
        return this.v;
    }
    setAt(row_i, column_i, value) {
        this.v[row_i + column_i * 4] = value;
        return this;
    }
    setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        this.v[0] = m00;
        this.v[4] = m01;
        this.v[8] = m02;
        this.v[12] = m03;
        this.v[1] = m10;
        this.v[5] = m11;
        this.v[9] = m12;
        this.v[13] = m13;
        this.v[2] = m20;
        this.v[6] = m21;
        this.v[10] = m22;
        this.v[14] = m23;
        this.v[3] = m30;
        this.v[7] = m31;
        this.v[11] = m32;
        this.v[15] = m33;
        return this;
    }
    copyComponents(mat) {
        this.v[0] = mat.v[0];
        this.v[4] = mat.v[4];
        this.v[8] = mat.v[8];
        this.v[12] = mat.v[12];
        this.v[1] = mat.v[1];
        this.v[5] = mat.v[5];
        this.v[9] = mat.v[9];
        this.v[13] = mat.v[13];
        this.v[2] = mat.v[2];
        this.v[6] = mat.v[6];
        this.v[10] = mat.v[10];
        this.v[14] = mat.v[14];
        this.v[3] = mat.v[3];
        this.v[7] = mat.v[7];
        this.v[11] = mat.v[11];
        this.v[15] = mat.v[15];
        return this;
    }
    /**
     * zero matrix
     */
    zero() {
        return this.setComponents(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * to the identity matrix
     */
    identity() {
        return this.setComponents(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    _swap(l, r) {
        this.v[r] = [this.v[l], this.v[l] = this.v[r]][0];
    }
    /**
     * transpose
     */
    transpose() {
        this._swap(1, 4);
        this._swap(2, 8);
        this._swap(3, 12);
        this._swap(6, 9);
        this._swap(7, 13);
        this._swap(11, 14);
        return this;
    }
    invert() {
        const n00 = this.v[0] * this.v[5] - this.v[4] * this.v[1];
        const n01 = this.v[0] * this.v[9] - this.v[8] * this.v[1];
        const n02 = this.v[0] * this.v[13] - this.v[12] * this.v[1];
        const n03 = this.v[4] * this.v[9] - this.v[8] * this.v[5];
        const n04 = this.v[4] * this.v[13] - this.v[12] * this.v[5];
        const n05 = this.v[8] * this.v[13] - this.v[12] * this.v[9];
        const n06 = this.v[2] * this.v[7] - this.v[6] * this.v[3];
        const n07 = this.v[2] * this.v[11] - this.v[10] * this.v[3];
        const n08 = this.v[2] * this.v[15] - this.v[14] * this.v[3];
        const n09 = this.v[6] * this.v[11] - this.v[10] * this.v[7];
        const n10 = this.v[6] * this.v[15] - this.v[14] * this.v[7];
        const n11 = this.v[10] * this.v[15] - this.v[14] * this.v[11];
        const det = n00 * n11 - n01 * n10 + n02 * n09 + n03 * n08 - n04 * n07 + n05 * n06;
        if (det === 0) {
            console.error("the determinant is 0!");
        }
        const m00 = (this.v[5] * n11 - this.v[9] * n10 + this.v[13] * n09) / det;
        const m01 = (this.v[8] * n10 - this.v[4] * n11 - this.v[12] * n09) / det;
        const m02 = (this.v[7] * n05 - this.v[11] * n04 + this.v[15] * n03) / det;
        const m03 = (this.v[10] * n04 - this.v[6] * n05 - this.v[14] * n03) / det;
        const m10 = (this.v[9] * n08 - this.v[1] * n11 - this.v[13] * n07) / det;
        const m11 = (this.v[0] * n11 - this.v[8] * n08 + this.v[12] * n07) / det;
        const m12 = (this.v[11] * n02 - this.v[3] * n05 - this.v[15] * n01) / det;
        const m13 = (this.v[2] * n05 - this.v[10] * n02 + this.v[14] * n01) / det;
        const m20 = (this.v[1] * n10 - this.v[5] * n08 + this.v[13] * n06) / det;
        const m21 = (this.v[4] * n08 - this.v[0] * n10 - this.v[12] * n06) / det;
        const m22 = (this.v[3] * n04 - this.v[7] * n02 + this.v[15] * n00) / det;
        const m23 = (this.v[6] * n02 - this.v[2] * n04 - this.v[14] * n00) / det;
        const m30 = (this.v[5] * n07 - this.v[1] * n09 - this.v[9] * n06) / det;
        const m31 = (this.v[0] * n09 - this.v[4] * n07 + this.v[8] * n06) / det;
        const m32 = (this.v[7] * n01 - this.v[3] * n03 - this.v[11] * n00) / det;
        const m33 = (this.v[2] * n03 - this.v[6] * n01 + this.v[10] * n00) / det;
        return this.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
    translate(vec) {
        return this.setComponents(1, 0, 0, vec.v[0], 0, 1, 0, vec.v[1], 0, 0, 1, vec.v[2], 0, 0, 0, 1);
    }
    putTranslate(vec) {
        this.v[12] = vec.v[0];
        this.v[13] = vec.v[1];
        this.v[14] = vec.v[2];
        return this;
    }
    /**
     * Create X oriented Rotation Matrix
     */
    rotateX(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1);
    }
    /**
     * Create Y oriented Rotation Matrix
     */
    rotateY(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0, 0, 0, 0, 1);
    }
    /**
   * Create Z oriented Rotation Matrix
   */
    rotateZ(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    rotateXYZ(x, y, z) {
        const cosX = Math.cos(x);
        const sinX = Math.sin(x);
        const cosY = Math.cos(y);
        const sinY = Math.sin(y);
        const cosZ = Math.cos(z);
        const sinZ = Math.sin(z);
        // const x00 = 1;
        // const x01 = 0;
        // const x02 = 0;
        // const x10 = 0;
        const x11 = cosX;
        const x12 = -sinX;
        // const x20 = 0;
        const x21 = sinX;
        const x22 = cosX;
        const y00 = cosY;
        // const y01 = 0;
        const y02 = sinY;
        // const y10 = 0;
        // const y11 = 1;
        // const y12 = 0;
        const y20 = -sinY;
        // const y21 = 0;
        const y22 = cosY;
        const z00 = cosZ;
        const z01 = -sinZ;
        // const z02 = 0;
        const z10 = sinZ;
        const z11 = cosZ;
        // const z12 = 0;
        // const z20 = 0;
        // const z21 = 0;
        // const z22 = 1;
        // Y * X
        const yx00 = y00;
        const yx01 = y02 * x21;
        const yx02 = y02 * x22;
        //const yx10 = 0;
        const yx11 = x11;
        const yx12 = x12;
        const yx20 = y20;
        const yx21 = y22 * x21;
        const yx22 = y22 * x22;
        // Z * Y * X
        const m00 = z00 * yx00;
        const m01 = z00 * yx01 + z01 * yx11;
        const m02 = z00 * yx02 + z01 * yx12;
        const m10 = z10 * yx00;
        const m11 = z10 * yx01 + z11 * yx11;
        const m12 = z10 * yx02 + z11 * yx12;
        const m20 = yx20;
        const m21 = yx21;
        const m22 = yx22;
        const m03 = 0;
        const m13 = 0;
        const m23 = 0;
        const m30 = 0;
        const m31 = 0;
        const m32 = 0;
        const m33 = 1;
        return this.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
    rotate(vec) {
        return this.rotateXYZ(vec.v[0], vec.v[1], vec.v[2]);
    }
    scale(vec) {
        return this.setComponents(vec.v[0], 0, 0, 0, 0, vec.v[1], 0, 0, 0, 0, vec.v[2], 0, 0, 0, 0, 1);
    }
    putScale(vec) {
        this.v[0] *= vec.v[0];
        this.v[4] *= vec.v[0];
        this.v[8] *= vec.v[0];
        this.v[12] *= vec.v[0];
        this.v[1] *= vec.v[1];
        this.v[5] *= vec.v[1];
        this.v[9] *= vec.v[1];
        this.v[13] *= vec.v[1];
        this.v[2] *= vec.v[2];
        this.v[6] *= vec.v[2];
        this.v[10] *= vec.v[2];
        this.v[14] *= vec.v[2];
        return this;
    }
    /**
     * multiply the input matrix from right side
     */
    multiply(mat) {
        const m00 = this.v[0] * mat.v[0] + this.v[4] * mat.v[1] + this.v[8] * mat.v[2] + this.v[12] * mat.v[3];
        const m01 = this.v[0] * mat.v[4] + this.v[4] * mat.v[5] + this.v[8] * mat.v[6] + this.v[12] * mat.v[7];
        const m02 = this.v[0] * mat.v[8] + this.v[4] * mat.v[9] + this.v[8] * mat.v[10] + this.v[12] * mat.v[11];
        const m03 = this.v[0] * mat.v[12] + this.v[4] * mat.v[13] + this.v[8] * mat.v[14] + this.v[12] * mat.v[15];
        const m10 = this.v[1] * mat.v[0] + this.v[5] * mat.v[1] + this.v[9] * mat.v[2] + this.v[13] * mat.v[3];
        const m11 = this.v[1] * mat.v[4] + this.v[5] * mat.v[5] + this.v[9] * mat.v[6] + this.v[13] * mat.v[7];
        const m12 = this.v[1] * mat.v[8] + this.v[5] * mat.v[9] + this.v[9] * mat.v[10] + this.v[13] * mat.v[11];
        const m13 = this.v[1] * mat.v[12] + this.v[5] * mat.v[13] + this.v[9] * mat.v[14] + this.v[13] * mat.v[15];
        const m20 = this.v[2] * mat.v[0] + this.v[6] * mat.v[1] + this.v[10] * mat.v[2] + this.v[14] * mat.v[3];
        const m21 = this.v[2] * mat.v[4] + this.v[6] * mat.v[5] + this.v[10] * mat.v[6] + this.v[14] * mat.v[7];
        const m22 = this.v[2] * mat.v[8] + this.v[6] * mat.v[9] + this.v[10] * mat.v[10] + this.v[14] * mat.v[11];
        const m23 = this.v[2] * mat.v[12] + this.v[6] * mat.v[13] + this.v[10] * mat.v[14] + this.v[14] * mat.v[15];
        const m30 = this.v[3] * mat.v[0] + this.v[7] * mat.v[1] + this.v[11] * mat.v[2] + this.v[15] * mat.v[3];
        const m31 = this.v[3] * mat.v[4] + this.v[7] * mat.v[5] + this.v[11] * mat.v[6] + this.v[15] * mat.v[7];
        const m32 = this.v[3] * mat.v[8] + this.v[7] * mat.v[9] + this.v[11] * mat.v[10] + this.v[15] * mat.v[11];
        const m33 = this.v[3] * mat.v[12] + this.v[7] * mat.v[13] + this.v[11] * mat.v[14] + this.v[15] * mat.v[15];
        return this.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
    multiplyByLeft(mat) {
        const m00 = mat.v[0] * this.v[0] + mat.v[4] * this.v[1] + mat.v[8] * this.v[2] + mat.v[12] * this.v[3];
        const m01 = mat.v[0] * this.v[4] + mat.v[4] * this.v[5] + mat.v[8] * this.v[6] + mat.v[12] * this.v[7];
        const m02 = mat.v[0] * this.v[8] + mat.v[4] * this.v[9] + mat.v[8] * this.v[10] + mat.v[12] * this.v[11];
        const m03 = mat.v[0] * this.v[12] + mat.v[4] * this.v[13] + mat.v[8] * this.v[14] + mat.v[12] * this.v[15];
        const m10 = mat.v[1] * this.v[0] + mat.v[5] * this.v[1] + mat.v[9] * this.v[2] + mat.v[13] * this.v[3];
        const m11 = mat.v[1] * this.v[4] + mat.v[5] * this.v[5] + mat.v[9] * this.v[6] + mat.v[13] * this.v[7];
        const m12 = mat.v[1] * this.v[8] + mat.v[5] * this.v[9] + mat.v[9] * this.v[10] + mat.v[13] * this.v[11];
        const m13 = mat.v[1] * this.v[12] + mat.v[5] * this.v[13] + mat.v[9] * this.v[14] + mat.v[13] * this.v[15];
        const m20 = mat.v[2] * this.v[0] + mat.v[6] * this.v[1] + mat.v[10] * this.v[2] + mat.v[14] * this.v[3];
        const m21 = mat.v[2] * this.v[4] + mat.v[6] * this.v[5] + mat.v[10] * this.v[6] + mat.v[14] * this.v[7];
        const m22 = mat.v[2] * this.v[8] + mat.v[6] * this.v[9] + mat.v[10] * this.v[10] + mat.v[14] * this.v[11];
        const m23 = mat.v[2] * this.v[12] + mat.v[6] * this.v[13] + mat.v[10] * this.v[14] + mat.v[14] * this.v[15];
        const m30 = mat.v[3] * this.v[0] + mat.v[7] * this.v[1] + mat.v[11] * this.v[2] + mat.v[15] * this.v[3];
        const m31 = mat.v[3] * this.v[4] + mat.v[7] * this.v[5] + mat.v[11] * this.v[6] + mat.v[15] * this.v[7];
        const m32 = mat.v[3] * this.v[8] + mat.v[7] * this.v[9] + mat.v[11] * this.v[10] + mat.v[15] * this.v[11];
        const m33 = mat.v[3] * this.v[12] + mat.v[7] * this.v[13] + mat.v[11] * this.v[14] + mat.v[15] * this.v[15];
        return this.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
    fromQuaternion(quat) {
        const sx = quat.v[0] * quat.v[0];
        const sy = quat.v[1] * quat.v[1];
        const sz = quat.v[2] * quat.v[2];
        const cx = quat.v[1] * quat.v[2];
        const cy = quat.v[0] * quat.v[2];
        const cz = quat.v[0] * quat.v[1];
        const wx = quat.v[3] * quat.v[0];
        const wy = quat.v[3] * quat.v[1];
        const wz = quat.v[3] * quat.v[2];
        const m00 = 1.0 - 2.0 * (sy + sz);
        const m01 = 2.0 * (cz - wz);
        const m02 = 2.0 * (cy + wy);
        const m03 = 0;
        const m10 = 2.0 * (cz + wz);
        const m11 = 1.0 - 2.0 * (sx + sz);
        const m12 = 2.0 * (cx - wx);
        const m13 = 0;
        const m20 = 2.0 * (cy - wy);
        const m21 = 2.0 * (cx + wx);
        const m22 = 1.0 - 2.0 * (sx + sy);
        const m23 = 0;
        const m30 = 0;
        const m31 = 0;
        const m32 = 0;
        const m33 = 1;
        return this.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
}


/***/ }),

/***/ "./src/foundation/math/MutableQuaternion.ts":
/*!**************************************************!*\
  !*** ./src/foundation/math/MutableQuaternion.ts ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MutableQuaternion; });
/* harmony import */ var _Quaternion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Quaternion */ "./src/foundation/math/Quaternion.ts");

class MutableQuaternion extends _Quaternion__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(x, y, z, w) {
        super(x, y, z, w);
    }
    set x(x) {
        this.v[0] = x;
    }
    get x() {
        return this.v[0];
    }
    set y(y) {
        this.v[1] = y;
    }
    get y() {
        return this.v[1];
    }
    set z(z) {
        this.v[2] = z;
    }
    get z() {
        return this.v[2];
    }
    set w(w) {
        this.v[3] = w;
    }
    get w() {
        return this.v[3];
    }
    static identity() {
        return super.identity();
    }
    static dummy() {
        return super.dummy();
    }
    static invert(quat) {
        return super.invert(quat);
    }
    static qlerp(l_quat, r_quat, ratio) {
        return super.qlerp(l_quat, r_quat, ratio);
    }
    static lerp(l_quat, r_quat, ratio) {
        return super.lerp(l_quat, r_quat, ratio);
    }
    static axisAngle(vec, radian) {
        return super.axisAngle(vec, radian);
    }
    static fromMatrix(mat) {
        return super.fromMatrix(mat);
    }
    static fromPosition(vec) {
        return super.fromPosition(vec);
    }
    static add(l_quat, r_quat) {
        return super.add(l_quat, r_quat);
    }
    static subtract(l_quat, r_quat) {
        return super.subtract(l_quat, r_quat);
    }
    static multiply(l_quat, r_quat) {
        return super.multiply(l_quat, r_quat);
    }
    static multiplyNumber(quat, value) {
        return super.multiplyNumber(quat, value);
    }
    static divideNumber(quat, value) {
        return super.divideNumber(quat, value);
    }
    raw() {
        return this.v;
    }
    setAt(i, value) {
        this.v[i] = value;
        return this;
    }
    setComponents(x, y, z, w) {
        this.v[0] = x;
        this.v[1] = y;
        this.v[2] = z;
        this.v[3] = w;
        return this;
    }
    copyComponents(quat) {
        return this.setComponents(quat.v[0], quat.v[1], quat.v[2], quat.v[3]);
    }
    identity() {
        return this.setComponents(0, 0, 0, 1);
    }
    normalize() {
        const norm = this.length();
        return this.divideNumber(norm);
    }
    invert() {
        const norm = this.length();
        if (norm === 0.0) {
            return this; // [0, 0, 0, 0]
        }
        this.v[0] = -this.v[0] / norm;
        this.v[1] = -this.v[1] / norm;
        this.v[2] = -this.v[2] / norm;
        this.v[3] = this.v[3] / norm;
        return this;
    }
    qlerp(l_quat, r_quat, ratio) {
        let qr = l_quat.v[3] * r_quat.v[3] + l_quat.v[0] * r_quat.v[0] + l_quat.v[1] * r_quat.v[1] + l_quat.v[2] * r_quat.v[2];
        const ss = 1.0 - qr * qr;
        if (ss === 0.0) {
            return this.copyComponents(l_quat);
        }
        else {
            if (qr > 1) {
                qr = 0.999;
            }
            else if (qr < -1) {
                qr = -0.999;
            }
            let ph = Math.acos(qr);
            let s2;
            if (qr < 0.0 && ph > Math.PI / 2.0) {
                qr = -l_quat.v[3] * r_quat.v[3] - l_quat.v[0] * r_quat.v[0] - l_quat.v[1] * r_quat.v[1] - l_quat.v[2] * r_quat.v[2];
                ph = Math.acos(qr);
                s2 = -1 * Math.sin(ph * ratio) / Math.sin(ph);
            }
            else {
                s2 = Math.sin(ph * ratio) / Math.sin(ph);
            }
            const s1 = Math.sin(ph * (1.0 - ratio)) / Math.sin(ph);
            this.v[0] = l_quat.v[0] * s1 + r_quat.v[0] * s2;
            this.v[1] = l_quat.v[1] * s1 + r_quat.v[1] * s2;
            this.v[2] = l_quat.v[2] * s1 + r_quat.v[2] * s2;
            this.v[3] = l_quat.v[3] * s1 + r_quat.v[3] * s2;
        }
        return this;
    }
    lerp(l_quat, r_quat, ratio) {
        this.v[0] = l_quat.v[0] * (1 - ratio) + r_quat.v[0] * ratio;
        this.v[1] = l_quat.v[1] * (1 - ratio) + r_quat.v[1] * ratio;
        this.v[2] = l_quat.v[2] * (1 - ratio) + r_quat.v[2] * ratio;
        this.v[3] = l_quat.v[3] * (1 - ratio) + r_quat.v[3] * ratio;
        return this;
    }
    axisAngle(vec, radian) {
        const halfAngle = 0.5 * radian;
        const sin = Math.sin(halfAngle);
        const length = vec.length();
        if (length === 0) {
            console.error("0 division occurred!");
        }
        this.v[3] = Math.cos(halfAngle);
        this.v[0] = sin * vec.v[0] / length;
        this.v[1] = sin * vec.v[1] / length;
        this.v[2] = sin * vec.v[2] / length;
        return this;
    }
    fromMatrix(mat) {
        const tr = mat.m00 + mat.m11 + mat.m22;
        if (tr > 0) {
            const S = 0.5 / Math.sqrt(tr + 1.0);
            this.v[0] = (mat.m21 - mat.m12) * S;
            this.v[1] = (mat.m02 - mat.m20) * S;
            this.v[2] = (mat.m10 - mat.m01) * S;
            this.v[3] = 0.25 / S;
        }
        else if ((mat.m00 > mat.m11) && (mat.m00 > mat.m22)) {
            const S = Math.sqrt(1.0 + mat.m00 - mat.m11 - mat.m22) * 2;
            this.v[0] = 0.25 * S;
            this.v[1] = (mat.m01 + mat.m10) / S;
            this.v[2] = (mat.m02 + mat.m20) / S;
            this.v[3] = (mat.m21 - mat.m12) / S;
        }
        else if (mat.m11 > mat.m22) {
            const S = Math.sqrt(1.0 + mat.m11 - mat.m00 - mat.m22) * 2;
            this.v[0] = (mat.m01 + mat.m10) / S;
            this.v[1] = 0.25 * S;
            this.v[2] = (mat.m12 + mat.m21) / S;
            this.v[3] = (mat.m02 - mat.m20) / S;
        }
        else {
            const S = Math.sqrt(1.0 + mat.m22 - mat.m00 - mat.m11) * 2;
            this.v[0] = (mat.m02 + mat.m20) / S;
            this.v[1] = (mat.m12 + mat.m21) / S;
            this.v[2] = 0.25 * S;
            this.v[3] = (mat.m10 - mat.m01) / S;
        }
        return this;
    }
    fromPosition(vec) {
        return this.setComponents(vec.v[0], vec.v[1], vec.v[2], 0);
    }
    add(quat) {
        this.v[0] += quat.v[0];
        this.v[1] += quat.v[1];
        this.v[2] += quat.v[2];
        this.v[3] += quat.v[3];
        return this;
    }
    subtract(quat) {
        this.v[0] -= quat.v[0];
        this.v[1] -= quat.v[1];
        this.v[2] -= quat.v[2];
        this.v[3] -= quat.v[3];
        return this;
    }
    multiply(quat) {
        const x = quat.v[3] * this.v[0] + quat.v[2] * this.v[1] + quat.v[1] * this.v[2] - quat.v[0] * this.v[3];
        const y = -quat.v[2] * this.v[0] + quat.v[3] * this.v[1] + quat.v[0] * this.v[2] - quat.v[1] * this.v[3];
        const z = quat.v[1] * this.v[0] + quat.v[0] * this.v[1] + quat.v[3] * this.v[2] - quat.v[2] * this.v[3];
        const w = -quat.v[0] * this.v[0] - quat.v[1] * this.v[1] - quat.v[2] * this.v[2] - quat.v[3] * this.v[3];
        return this.setComponents(x, y, z, w);
    }
    multiplyNumber(value) {
        this.v[0] *= value;
        this.v[1] *= value;
        this.v[2] *= value;
        this.v[3] *= value;
        return this;
    }
    divideNumber(value) {
        if (value !== 0) {
            this.v[0] /= value;
            this.v[1] /= value;
            this.v[2] /= value;
            this.v[3] /= value;
        }
        else {
            console.error("0 division occurred!");
            this.v[0] = Infinity;
            this.v[1] = Infinity;
            this.v[2] = Infinity;
            this.v[3] = Infinity;
        }
        return this;
    }
    clone() {
        return super.clone();
    }
}


/***/ }),

/***/ "./src/foundation/math/MutableScalar.ts":
/*!**********************************************!*\
  !*** ./src/foundation/math/MutableScalar.ts ***!
  \**********************************************/
/*! exports provided: MutableScalar_, default, MutableScalard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MutableScalar_", function() { return MutableScalar_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MutableScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MutableScalard", function() { return MutableScalard; });
/* harmony import */ var _Scalar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scalar */ "./src/foundation/math/Scalar.ts");

class MutableScalar_ extends _Scalar__WEBPACK_IMPORTED_MODULE_0__["Scalar_"] {
    constructor(x, { type }) {
        super(x, { type });
    }
    copyComponents(vec) {
        this.v[0] = vec.v[0];
    }
    get x() {
        return this.v[0];
    }
    set x(x) {
        this.v[0] = x;
    }
    setValue(value) {
        this.x = value;
        return this;
    }
}
class MutableScalar extends MutableScalar_ {
    constructor(x) {
        super(x, { type: Float32Array });
    }
    clone() {
        return new MutableScalar(this.x);
    }
    static one() {
        return new MutableScalar(1);
    }
    static dummy() {
        return new MutableScalar(null);
    }
    static zero() {
        return new MutableScalar(0);
    }
}
class MutableScalard extends MutableScalar_ {
    constructor(x) {
        super(x, { type: Float64Array });
    }
    clone() {
        return new MutableScalard(this.x);
    }
    static one() {
        return new MutableScalard(1);
    }
    static dummy() {
        return new MutableScalard(null);
    }
    static zero() {
        return new MutableScalard(0);
    }
}


/***/ }),

/***/ "./src/foundation/math/MutableVector2.ts":
/*!***********************************************!*\
  !*** ./src/foundation/math/MutableVector2.ts ***!
  \***********************************************/
/*! exports provided: MutableVector2_, default, MutableVector2d */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MutableVector2_", function() { return MutableVector2_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MutableVector2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MutableVector2d", function() { return MutableVector2d; });
/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector2 */ "./src/foundation/math/Vector2.ts");

class MutableVector2_ extends _Vector2__WEBPACK_IMPORTED_MODULE_0__["Vector2_"] {
    constructor(x, y, { type }) {
        super(x, y, { type });
    }
    set x(x) {
        this.v[0] = x;
    }
    get x() {
        return this.v[0];
    }
    set y(y) {
        this.v[1] = y;
    }
    get y() {
        return this.v[1];
    }
    raw() {
        return this.v;
    }
    setAt(i, value) {
        this.v[i] = value;
        return this;
    }
    setComponents(x, y) {
        this.v[0] = x;
        this.v[1] = y;
        return this;
    }
    copyComponents(vec) {
        return this.setComponents(vec.v[0], vec.v[1]);
    }
    zero() {
        return this.setComponents(0, 0);
    }
    one() {
        return this.setComponents(1, 1);
    }
    normalize() {
        const length = this.length();
        this.divide(length);
        return this;
    }
    /**
     * add value
     */
    add(vec) {
        this.v[0] += vec.v[0];
        this.v[1] += vec.v[1];
        return this;
    }
    /**
      * subtract
      */
    subtract(vec) {
        this.v[0] -= vec.v[0];
        this.v[1] -= vec.v[1];
        return this;
    }
    /**
     * multiply
     */
    multiply(value) {
        this.v[0] *= value;
        this.v[1] *= value;
        return this;
    }
    /**
     * multiply vector
     */
    multiplyVector(vec) {
        this.v[0] *= vec.v[0];
        this.v[1] *= vec.v[1];
        return this;
    }
    /**
     * divide
     */
    divide(value) {
        if (value !== 0) {
            this.v[0] /= value;
            this.v[1] /= value;
        }
        else {
            console.error("0 division occurred!");
            this.v[0] = Infinity;
            this.v[1] = Infinity;
        }
        return this;
    }
    /**
      * divide vector
      */
    divideVector(vec) {
        if (vec.v[0] !== 0 && vec.v[1] !== 0) {
            this.v[0] /= vec.v[0];
            this.v[1] /= vec.v[1];
        }
        else {
            console.error("0 division occurred!");
            this.v[0] = vec.v[0] === 0 ? Infinity : this.v[0] / vec.v[0];
            this.v[1] = vec.v[1] === 0 ? Infinity : this.v[1] / vec.v[1];
        }
        return this;
    }
}
class MutableVector2 extends MutableVector2_ {
    constructor(x, y) {
        super(x, y, { type: Float32Array });
    }
    static zero() {
        return super._zero(Float32Array);
    }
    static one() {
        return super._one(Float32Array);
    }
    static dummy() {
        return super._dummy(Float32Array);
    }
    static normalize(vec) {
        return super._normalize(vec, Float32Array);
    }
    static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
    }
    static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
    }
    static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
    }
    static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
    }
    static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
    }
    static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
    }
    clone() {
        return super.clone();
    }
}
class MutableVector2d extends MutableVector2_ {
    constructor(x, y) {
        super(x, y, { type: Float64Array });
    }
    static zero() {
        return super._zero(Float64Array);
    }
    static one() {
        return super._one(Float64Array);
    }
    static dummy() {
        return super._dummy(Float64Array);
    }
    static normalize(vec) {
        return super._normalize(vec, Float64Array);
    }
    static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float64Array);
    }
    static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float64Array);
    }
    static multiply(vec, value) {
        return super._multiply(vec, value, Float64Array);
    }
    static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float64Array);
    }
    static divide(vec, value) {
        return super._divide(vec, value, Float64Array);
    }
    static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float64Array);
    }
    clone() {
        return super.clone();
    }
}


/***/ }),

/***/ "./src/foundation/math/MutableVector3.ts":
/*!***********************************************!*\
  !*** ./src/foundation/math/MutableVector3.ts ***!
  \***********************************************/
/*! exports provided: MutableVector3_, default, MutableVector3d */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MutableVector3_", function() { return MutableVector3_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MutableVector3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MutableVector3d", function() { return MutableVector3d; });
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3 */ "./src/foundation/math/Vector3.ts");

class MutableVector3_ extends _Vector3__WEBPACK_IMPORTED_MODULE_0__["Vector3_"] {
    constructor(x, y, z, { type }) {
        super(x, y, z, { type });
    }
    set x(x) {
        this.v[0] = x;
    }
    get x() {
        return this.v[0];
    }
    set y(y) {
        this.v[1] = y;
    }
    get y() {
        return this.v[1];
    }
    set z(z) {
        this.v[2] = z;
    }
    get z() {
        return this.v[2];
    }
    raw() {
        return this.v;
    }
    setAt(i, value) {
        this.v[i] = value;
        return this;
    }
    setComponents(x, y, z) {
        this.v[0] = x;
        this.v[1] = y;
        this.v[2] = z;
        return this;
    }
    copyComponents(vec) {
        return this.setComponents(vec.v[0], vec.v[1], vec.v[2]);
    }
    zero() {
        return this.setComponents(0, 0, 0);
    }
    one() {
        return this.setComponents(1, 1, 1);
    }
    /**
   * normalize
   */
    normalize() {
        const length = this.length();
        this.divide(length);
        return this;
    }
    /**
   * add value
   */
    add(vec) {
        this.v[0] += vec.v[0];
        this.v[1] += vec.v[1];
        this.v[2] += vec.v[2];
        return this;
    }
    /**
   * subtract
   */
    subtract(vec) {
        this.v[0] -= vec.v[0];
        this.v[1] -= vec.v[1];
        this.v[2] -= vec.v[2];
        return this;
    }
    /**
     * multiply
     */
    multiply(value) {
        this.v[0] *= value;
        this.v[1] *= value;
        this.v[2] *= value;
        return this;
    }
    /**
     * multiply vector
     */
    multiplyVector(vec) {
        this.v[0] *= vec.v[0];
        this.v[1] *= vec.v[1];
        this.v[2] *= vec.v[2];
        return this;
    }
    /**
     * divide
     */
    divide(value) {
        if (value !== 0) {
            this.v[0] /= value;
            this.v[1] /= value;
            this.v[2] /= value;
        }
        else {
            console.error("0 division occurred!");
            this.v[0] = Infinity;
            this.v[1] = Infinity;
            this.v[2] = Infinity;
        }
        return this;
    }
    /**
   * divide vector
   */
    divideVector(vec) {
        if (vec.v[0] !== 0 && vec.v[1] !== 0 && vec.v[2] !== 0) {
            this.v[0] /= vec.v[0];
            this.v[1] /= vec.v[1];
            this.v[2] /= vec.v[2];
        }
        else {
            console.error("0 division occurred!");
            this.v[0] = vec.v[0] === 0 ? Infinity : this.v[0] / vec.v[0];
            this.v[1] = vec.v[1] === 0 ? Infinity : this.v[1] / vec.v[1];
            this.v[2] = vec.v[2] === 0 ? Infinity : this.v[2] / vec.v[2];
        }
        return this;
    }
    /**
     * cross product
     */
    cross(vec) {
        const x = this.v[1] * vec.v[2] - this.v[2] * vec.v[1];
        const y = this.v[2] * vec.v[0] - this.v[0] * vec.v[2];
        const z = this.v[0] * vec.v[1] - this.v[1] * vec.v[0];
        return this.setComponents(x, y, z);
    }
    /**
     * quaternion * vector3
     */
    multiplyQuaternion(quat) {
        const num = quat.v[0] * 2;
        const num2 = quat.v[1] * 2;
        const num3 = quat.v[2] * 2;
        const num4 = quat.v[0] * num;
        const num5 = quat.v[1] * num2;
        const num6 = quat.v[2] * num3;
        const num7 = quat.v[0] * num2;
        const num8 = quat.v[0] * num3;
        const num9 = quat.v[1] * num3;
        const num10 = quat.v[3] * num;
        const num11 = quat.v[3] * num2;
        const num12 = quat.v[3] * num3;
        const x = (1 - (num5 + num6)) * this.v[0] + (num7 - num12) * this.v[1] + (num8 + num11) * this.v[2];
        const y = (num7 + num12) * this.v[0] + (1 - (num4 + num6)) * this.v[1] + (num9 - num10) * this.v[2];
        const z = (num8 - num11) * this.v[0] + (num9 + num10) * this.v[1] + (1 - (num4 + num5)) * this.v[2];
        return this.setComponents(x, y, z);
    }
}
class MutableVector3 extends MutableVector3_ {
    constructor(x, y, z) {
        super(x, y, z, { type: Float32Array });
    }
    static zero() {
        return super._zero(Float32Array);
    }
    static one() {
        return super._one(Float32Array);
    }
    static dummy() {
        return super._dummy(Float32Array);
    }
    static normalize(vec) {
        return super._normalize(vec, Float32Array);
    }
    static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
    }
    static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
    }
    static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
    }
    static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
    }
    static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
    }
    static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
    }
    static cross(l_vec, r_vec) {
        return super._cross(l_vec, r_vec, Float32Array);
    }
    static multiplyQuaternion(quat, vec) {
        return super._multiplyQuaternion(quat, vec, Float32Array);
    }
    clone() {
        return super.clone();
    }
}
class MutableVector3d extends MutableVector3_ {
    constructor(x, y, z) {
        super(x, y, z, { type: Float64Array });
    }
    static zero() {
        return super._zero(Float64Array);
    }
    static one() {
        return super._one(Float64Array);
    }
    static dummy() {
        return super._dummy(Float64Array);
    }
    static normalize(vec) {
        return super._normalize(vec, Float64Array);
    }
    static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float64Array);
    }
    static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float64Array);
    }
    static multiply(vec, value) {
        return super._multiply(vec, value, Float64Array);
    }
    static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float64Array);
    }
    static divide(vec, value) {
        return super._divide(vec, value, Float64Array);
    }
    static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float64Array);
    }
    static cross(l_vec, r_vec) {
        return super._cross(l_vec, r_vec, Float64Array);
    }
    static multiplyQuaternion(quat, vec) {
        return super._multiplyQuaternion(quat, vec, Float64Array);
    }
    clone() {
        return super.clone();
    }
}


/***/ }),

/***/ "./src/foundation/math/MutableVector4.ts":
/*!***********************************************!*\
  !*** ./src/foundation/math/MutableVector4.ts ***!
  \***********************************************/
/*! exports provided: MutableVector4_, default, MutableVector4d */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MutableVector4_", function() { return MutableVector4_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MutableVector4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MutableVector4d", function() { return MutableVector4d; });
/* harmony import */ var _Vector4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector4 */ "./src/foundation/math/Vector4.ts");

class MutableVector4_ extends _Vector4__WEBPACK_IMPORTED_MODULE_0__["Vector4_"] {
    constructor(x, y, z, w, { type }) {
        super(x, y, z, w, { type });
    }
    set x(x) {
        this.v[0] = x;
    }
    get x() {
        return this.v[0];
    }
    set y(y) {
        this.v[1] = y;
    }
    get y() {
        return this.v[1];
    }
    set z(z) {
        this.v[2] = z;
    }
    get z() {
        return this.v[2];
    }
    set w(w) {
        this.v[3] = w;
    }
    get w() {
        return this.v[3];
    }
    raw() {
        return this.v;
    }
    setAt(i, value) {
        this.v[i] = value;
        return this;
    }
    setComponents(x, y, z, w) {
        this.v[0] = x;
        this.v[1] = y;
        this.v[2] = z;
        this.v[3] = w;
        return this;
    }
    copyComponents(vec) {
        return this.setComponents(vec.v[0], vec.v[1], vec.v[2], vec.v[3]);
    }
    zero() {
        return this.setComponents(0, 0, 0, 0);
    }
    one() {
        return this.setComponents(1, 1, 1, 1);
    }
    /**
     * normalize
     */
    normalize() {
        const length = this.length();
        this.divide(length);
        return this;
    }
    normalize3() {
        const length = Math.hypot(this.v[0], this.v[1], this.v[2]);
        this.divide(length);
        return this;
    }
    /**
     * add value
     */
    add(vec) {
        this.v[0] += vec.v[0];
        this.v[1] += vec.v[1];
        this.v[2] += vec.v[2];
        this.v[3] += vec.v[3];
        return this;
    }
    /**
     * subtract
     */
    subtract(vec) {
        this.v[0] -= vec.v[0];
        this.v[1] -= vec.v[1];
        this.v[2] -= vec.v[2];
        this.v[3] -= vec.v[3];
        return this;
    }
    /**
     * multiply
     */
    multiply(value) {
        this.v[0] *= value;
        this.v[1] *= value;
        this.v[2] *= value;
        this.v[3] *= value;
        return this;
    }
    /**
     * multiply vector
     */
    multiplyVector(vec) {
        this.v[0] *= vec.v[0];
        this.v[1] *= vec.v[1];
        this.v[2] *= vec.v[2];
        this.v[3] *= vec.v[3];
        return this;
    }
    /**
     * divide
     */
    divide(value) {
        if (value !== 0) {
            this.v[0] /= value;
            this.v[1] /= value;
            this.v[2] /= value;
            this.v[3] /= value;
        }
        else {
            console.error("0 division occurred!");
            this.v[0] = Infinity;
            this.v[1] = Infinity;
            this.v[2] = Infinity;
            this.v[3] = Infinity;
        }
        return this;
    }
    /**
     * divide vector
     */
    divideVector(vec) {
        if (vec.v[0] !== 0 && vec.v[1] !== 0 && vec.v[2] !== 0 && vec.v[3] !== 0) {
            this.v[0] /= vec.v[0];
            this.v[1] /= vec.v[1];
            this.v[2] /= vec.v[2];
            this.v[3] /= vec.v[3];
        }
        else {
            console.error("0 division occurred!");
            this.v[0] = vec.v[0] === 0 ? Infinity : this.v[0] / vec.v[0];
            this.v[1] = vec.v[1] === 0 ? Infinity : this.v[1] / vec.v[1];
            this.v[2] = vec.v[2] === 0 ? Infinity : this.v[2] / vec.v[2];
            this.v[3] = vec.v[3] === 0 ? Infinity : this.v[3] / vec.v[3];
        }
        return this;
    }
}
class MutableVector4 extends MutableVector4_ {
    constructor(x, y, z, w) {
        super(x, y, z, w, { type: Float32Array });
    }
    static zero() {
        return super._zero(Float32Array);
    }
    static one() {
        return super._one(Float32Array);
    }
    static dummy() {
        return super._dummy(Float32Array);
    }
    static normalize(vec) {
        return super._normalize(vec, Float32Array);
    }
    static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
    }
    static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
    }
    static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
    }
    static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
    }
    static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
    }
    static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
    }
    clone() {
        return super.clone();
    }
}
class MutableVector4d extends MutableVector4_ {
    constructor(x, y, z, w) {
        super(x, y, z, w, { type: Float64Array });
    }
    static zero() {
        return super._zero(Float64Array);
    }
    static one() {
        return super._one(Float64Array);
    }
    static dummy() {
        return super._dummy(Float64Array);
    }
    static normalize(vec) {
        return super._normalize(vec, Float64Array);
    }
    static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float64Array);
    }
    static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float64Array);
    }
    static multiply(vec, value) {
        return super._multiply(vec, value, Float64Array);
    }
    static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float64Array);
    }
    static divide(vec, value) {
        return super._divide(vec, value, Float64Array);
    }
    static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float64Array);
    }
    clone() {
        return super.clone();
    }
}


/***/ }),

/***/ "./src/foundation/math/Quaternion.ts":
/*!*******************************************!*\
  !*** ./src/foundation/math/Quaternion.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Quaternion; });
/* harmony import */ var _MathUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtil */ "./src/foundation/math/MathUtil.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _LogQuaternion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LogQuaternion */ "./src/foundation/math/LogQuaternion.ts");



class Quaternion {
    constructor(x, y, z, w) {
        if (ArrayBuffer.isView(x)) {
            this.v = x;
            return;
        }
        else if (x == null) {
            this.v = new Float32Array(0);
            return;
        }
        else {
            this.v = new Float32Array(4);
        }
        if (Array.isArray(x)) {
            this.v[0] = x[0];
            this.v[1] = x[1];
            this.v[2] = x[2];
            this.v[3] = x[3];
        }
        else if (typeof x === 'number') {
            this.v[0] = x;
            this.v[1] = y;
            this.v[2] = z;
            this.v[3] = w;
        }
        else if (x instanceof _LogQuaternion__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            const theta = x.v[0] * x.v[0] + x.v[1] * x.v[1] + x.v[2] * x.v[2];
            const sin = Math.sin(theta);
            this.v[0] = x.v[0] * (sin / theta);
            this.v[1] = x.v[1] * (sin / theta);
            this.v[2] = x.v[2] * (sin / theta);
            this.v[3] = Math.cos(theta);
        }
        else {
            if (typeof x.v[2] === 'undefined') {
                // IVector2
                this.v[0] = x.v[0];
                this.v[1] = x.v[1];
                this.v[2] = 0;
                this.v[3] = 1;
            }
            else if (typeof x.v[3] === 'undefined') {
                // IVector3
                this.v[0] = x.v[0];
                this.v[1] = x.v[1];
                this.v[2] = x.v[2];
                this.v[3] = 1;
            }
            else {
                // IVector4 and IQuaternion
                this.v[0] = x.v[0];
                this.v[1] = x.v[1];
                this.v[2] = x.v[2];
                this.v[3] = x.v[3];
            }
        }
    }
    get x() {
        return this.v[0];
    }
    get y() {
        return this.v[1];
    }
    get z() {
        return this.v[2];
    }
    get w() {
        return this.v[3];
    }
    get className() {
        return this.constructor.name;
    }
    static get compositionType() {
        return _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Vec4;
    }
    static identity() {
        return new this(0, 0, 0, 1);
    }
    static dummy() {
        return new this(null);
    }
    static invert(quat) {
        const norm = quat.length();
        if (norm === 0.0) {
            return new this(0, 0, 0, 0);
        }
        const x = -quat.v[0] / norm;
        const y = -quat.v[1] / norm;
        const z = -quat.v[2] / norm;
        const w = quat.v[3] / norm;
        return new this(x, y, z, w);
    }
    static invertTo(quat, out) {
        const norm = quat.length();
        if (norm === 0.0) {
            return out.setComponents(0, 0, 0, 0);
        }
        out.v[0] = -quat.v[0] / norm;
        out.v[1] = -quat.v[1] / norm;
        out.v[2] = -quat.v[2] / norm;
        out.v[3] = quat.v[3] / norm;
        return out;
    }
    static qlerp(l_quat, r_quat, ratio) {
        let qr = l_quat.v[3] * r_quat.v[3] + l_quat.v[0] * r_quat.v[0] + l_quat.v[1] * r_quat.v[1] + l_quat.v[2] * r_quat.v[2];
        const ss = 1.0 - qr * qr;
        if (ss === 0.0) {
            return l_quat.clone();
        }
        else {
            if (qr > 1) {
                qr = 0.999;
            }
            else if (qr < -1) {
                qr = -0.999;
            }
            let ph = Math.acos(qr);
            let s2;
            if (qr < 0.0 && ph > Math.PI / 2.0) {
                qr = -l_quat.v[3] * r_quat.v[3] - l_quat.v[0] * r_quat.v[0] - l_quat.v[1] * r_quat.v[1] - l_quat.v[2] * r_quat.v[2];
                ph = Math.acos(qr);
                s2 = -1 * Math.sin(ph * ratio) / Math.sin(ph);
            }
            else {
                s2 = Math.sin(ph * ratio) / Math.sin(ph);
            }
            const s1 = Math.sin(ph * (1.0 - ratio)) / Math.sin(ph);
            return new this(l_quat.v[0] * s1 + r_quat.v[0] * s2, l_quat.v[1] * s1 + r_quat.v[1] * s2, l_quat.v[2] * s1 + r_quat.v[2] * s2, l_quat.v[3] * s1 + r_quat.v[3] * s2);
        }
    }
    static qlerpTo(l_quat, r_quat, ratio, out) {
        let qr = l_quat.v[3] * r_quat.v[3] + l_quat.v[0] * r_quat.v[0] + l_quat.v[1] * r_quat.v[1] + l_quat.v[2] * r_quat.v[2];
        const ss = 1.0 - qr * qr;
        if (ss === 0.0) {
            return out.copyComponents(l_quat);
        }
        else {
            if (qr > 1) {
                qr = 0.999;
            }
            else if (qr < -1) {
                qr = -0.999;
            }
            let ph = Math.acos(qr);
            let s2;
            if (qr < 0.0 && ph > Math.PI / 2.0) {
                qr = -l_quat.v[3] * r_quat.v[3] - l_quat.v[0] * r_quat.v[0] - l_quat.v[1] * r_quat.v[1] - l_quat.v[2] * r_quat.v[2];
                ph = Math.acos(qr);
                s2 = -1 * Math.sin(ph * ratio) / Math.sin(ph);
            }
            else {
                s2 = Math.sin(ph * ratio) / Math.sin(ph);
            }
            const s1 = Math.sin(ph * (1.0 - ratio)) / Math.sin(ph);
            out.v[0] = l_quat.v[0] * s1 + r_quat.v[0] * s2;
            out.v[1] = l_quat.v[1] * s1 + r_quat.v[1] * s2;
            out.v[2] = l_quat.v[2] * s1 + r_quat.v[2] * s2;
            out.v[3] = l_quat.v[3] * s1 + r_quat.v[3] * s2;
        }
        return out;
    }
    static lerp(l_quat, r_quat, ratio) {
        const x = l_quat.v[0] * (1 - ratio) + r_quat.v[0] * ratio;
        const y = l_quat.v[1] * (1 - ratio) + r_quat.v[1] * ratio;
        const z = l_quat.v[2] * (1 - ratio) + r_quat.v[2] * ratio;
        const w = l_quat.v[3] * (1 - ratio) + r_quat.v[3] * ratio;
        return new this(x, y, z, w);
    }
    static lerpTo(l_quat, r_quat, ratio, out) {
        out.v[0] = l_quat.v[0] * (1 - ratio) + r_quat.v[0] * ratio;
        out.v[1] = l_quat.v[1] * (1 - ratio) + r_quat.v[1] * ratio;
        out.v[2] = l_quat.v[2] * (1 - ratio) + r_quat.v[2] * ratio;
        out.v[3] = l_quat.v[3] * (1 - ratio) + r_quat.v[3] * ratio;
        return out;
    }
    static axisAngle(vec, radian) {
        const halfAngle = 0.5 * radian;
        const sin = Math.sin(halfAngle);
        const length = vec.length();
        if (length === 0) {
            console.error("0 division occurred!");
        }
        return new this(sin * vec.v[0] / length, sin * vec.v[1] / length, sin * vec.v[2] / length, Math.cos(halfAngle));
    }
    static fromMatrix(mat) {
        const quat = new this(0, 0, 0, 1);
        const tr = mat.m00 + mat.m11 + mat.m22;
        if (tr > 0) {
            const S = 0.5 / Math.sqrt(tr + 1.0);
            quat.v[3] = 0.25 / S;
            quat.v[0] = (mat.m21 - mat.m12) * S;
            quat.v[1] = (mat.m02 - mat.m20) * S;
            quat.v[2] = (mat.m10 - mat.m01) * S;
        }
        else if ((mat.m00 > mat.m11) && (mat.m00 > mat.m22)) {
            const S = Math.sqrt(1.0 + mat.m00 - mat.m11 - mat.m22) * 2;
            quat.v[3] = (mat.m21 - mat.m12) / S;
            quat.v[0] = 0.25 * S;
            quat.v[1] = (mat.m01 + mat.m10) / S;
            quat.v[2] = (mat.m02 + mat.m20) / S;
        }
        else if (mat.m11 > mat.m22) {
            const S = Math.sqrt(1.0 + mat.m11 - mat.m00 - mat.m22) * 2;
            quat.v[3] = (mat.m02 - mat.m20) / S;
            quat.v[0] = (mat.m01 + mat.m10) / S;
            quat.v[1] = 0.25 * S;
            quat.v[2] = (mat.m12 + mat.m21) / S;
        }
        else {
            const S = Math.sqrt(1.0 + mat.m22 - mat.m00 - mat.m11) * 2;
            quat.v[3] = (mat.m10 - mat.m01) / S;
            quat.v[0] = (mat.m02 + mat.m20) / S;
            quat.v[1] = (mat.m12 + mat.m21) / S;
            quat.v[2] = 0.25 * S;
        }
        return quat;
    }
    static fromMatrixTo(mat, out) {
        const tr = mat.m00 + mat.m11 + mat.m22;
        if (tr > 0) {
            const S = 0.5 / Math.sqrt(tr + 1.0);
            out.v[3] = 0.25 / S;
            out.v[0] = (mat.m21 - mat.m12) * S;
            out.v[1] = (mat.m02 - mat.m20) * S;
            out.v[2] = (mat.m10 - mat.m01) * S;
        }
        else if ((mat.m00 > mat.m11) && (mat.m00 > mat.m22)) {
            const S = Math.sqrt(1.0 + mat.m00 - mat.m11 - mat.m22) * 2;
            out.v[3] = (mat.m21 - mat.m12) / S;
            out.v[0] = 0.25 * S;
            out.v[1] = (mat.m01 + mat.m10) / S;
            out.v[2] = (mat.m02 + mat.m20) / S;
        }
        else if (mat.m11 > mat.m22) {
            const S = Math.sqrt(1.0 + mat.m11 - mat.m00 - mat.m22) * 2;
            out.v[3] = (mat.m02 - mat.m20) / S;
            out.v[0] = (mat.m01 + mat.m10) / S;
            out.v[1] = 0.25 * S;
            out.v[2] = (mat.m12 + mat.m21) / S;
        }
        else {
            const S = Math.sqrt(1.0 + mat.m22 - mat.m00 - mat.m11) * 2;
            out.v[3] = (mat.m10 - mat.m01) / S;
            out.v[0] = (mat.m02 + mat.m20) / S;
            out.v[1] = (mat.m12 + mat.m21) / S;
            out.v[2] = 0.25 * S;
        }
        return out;
    }
    static lookFromTo(fromDirection, toDirection) {
        if (fromDirection.isEqual(toDirection)) {
            return new this(0, 0, 0, 1);
        }
        return this.qlerp(this.lookForward(fromDirection), this.lookForward(toDirection), 1);
    }
    static lookForward(forward) {
        if (Quaternion.__tmp_upVec == null) {
            Quaternion.__tmp_upVec = new forward.constructor(0, 1, 0);
        }
        return this.lookForwardAccordingToThisUp(forward, Quaternion.__tmp_upVec);
    }
    static lookForwardAccordingToThisUp(forward, up) {
        const forwardLength = forward.length();
        if (forwardLength === 0) {
            console.error("0 division occurred!");
        }
        const forwardX = forward.v[0] / forwardLength;
        const forwardY = forward.v[1] / forwardLength;
        const forwardZ = forward.v[2] / forwardLength;
        const upLength = up.length();
        if (upLength === 0) {
            console.error("0 division occurred!");
        }
        const upX = up.v[0] / upLength;
        const upY = up.v[1] / upLength;
        const upZ = up.v[2] / upLength;
        // Vector3.cross(up, forward)
        let rightX = up.v[1] * forward.v[2] - up.v[2] * forward.v[1];
        let rightY = up.v[2] * forward.v[0] - up.v[0] * forward.v[2];
        let rightZ = up.v[0] * forward.v[1] - up.v[1] * forward.v[0];
        const rightLength = Math.hypot(rightX, rightY, rightZ);
        if (rightLength === 0) {
            console.error("0 division occurred!");
        }
        rightX /= rightLength;
        rightY /= rightLength;
        rightZ /= rightLength;
        const m00 = rightX;
        const m01 = rightY;
        const m02 = rightZ;
        const m10 = upX;
        const m11 = upY;
        const m12 = upZ;
        const m20 = forwardX;
        const m21 = forwardY;
        const m22 = forwardZ;
        const num8 = (m00 + m11) + m22;
        if (num8 > 0) {
            const num = Math.sqrt(num8 + 1);
            const num2 = 0.5 / num;
            return new this((m12 - m21) * num2, (m20 - m02) * num2, (m01 - m10) * num2, num * 0.5);
        }
        else if ((m00 >= m11) && (m00 >= m22)) {
            const num7 = Math.sqrt(((1 + m00) - m11) - m22);
            const num4 = 0.5 / num7;
            return new this(0.5 * num7, (m01 + m10) * num4, (m02 + m20) * num4, (m12 - m21) * num4);
        }
        else if (m11 > m22) {
            const num6 = Math.sqrt(((1 + m11) - m00) - m22);
            const num3 = 0.5 / num6;
            return new this((m10 + m01) * num3, 0.5 * num6, (m21 + m12) * num3, (m20 - m02) * num3);
        }
        else {
            const num5 = Math.sqrt(((1 + m22) - m00) - m11);
            const num2 = 0.5 / num5;
            return new this((m20 + m02) * num2, (m21 + m12) * num2, 0.5 * num5, (m01 - m10) * num2);
        }
    }
    static fromPosition(vec) {
        return new this(vec.v[0], vec.v[1], vec.v[2], 0);
    }
    static add(l_quat, r_quat) {
        const x = l_quat.v[0] + r_quat.v[0];
        const y = l_quat.v[1] + r_quat.v[1];
        const z = l_quat.v[2] + r_quat.v[2];
        const w = l_quat.v[3] + r_quat.v[3];
        return new this(x, y, z, w);
    }
    static addTo(l_quat, r_quat, out) {
        out.v[0] = l_quat.v[0] + r_quat.v[0];
        out.v[1] = l_quat.v[1] + r_quat.v[1];
        out.v[2] = l_quat.v[2] + r_quat.v[2];
        out.v[3] = l_quat.v[3] + r_quat.v[3];
        return out;
    }
    static subtract(l_quat, r_quat) {
        const x = l_quat.v[0] - r_quat.v[0];
        const y = l_quat.v[1] - r_quat.v[1];
        const z = l_quat.v[2] - r_quat.v[2];
        const w = l_quat.v[3] - r_quat.v[3];
        return new this(x, y, z, w);
    }
    static subtractTo(l_quat, r_quat, out) {
        out.v[0] = l_quat.v[0] - r_quat.v[0];
        out.v[1] = l_quat.v[1] - r_quat.v[1];
        out.v[2] = l_quat.v[2] - r_quat.v[2];
        out.v[3] = l_quat.v[3] - r_quat.v[3];
        return out;
    }
    static multiply(l_quat, r_quat) {
        const x = r_quat.v[3] * l_quat.v[0] + r_quat.v[2] * l_quat.v[1] - r_quat.v[1] * l_quat.v[2] + r_quat.v[0] * l_quat.v[3];
        const y = -r_quat.v[2] * l_quat.v[0] + r_quat.v[3] * l_quat.v[1] + r_quat.v[0] * l_quat.v[2] + r_quat.v[1] * l_quat.v[3];
        const z = r_quat.v[1] * l_quat.v[0] - r_quat.v[0] * l_quat.v[1] + r_quat.v[3] * l_quat.v[2] + r_quat.v[2] * l_quat.v[3];
        const w = -r_quat.v[0] * l_quat.v[0] - r_quat.v[1] * l_quat.v[1] - r_quat.v[2] * l_quat.v[2] + r_quat.v[3] * l_quat.v[3];
        return new this(x, y, z, w);
    }
    static multiplyTo(l_quat, r_quat, out) {
        const x = r_quat.v[3] * l_quat.v[0] + r_quat.v[2] * l_quat.v[1] - r_quat.v[1] * l_quat.v[2] + r_quat.v[0] * l_quat.v[3];
        const y = -r_quat.v[2] * l_quat.v[0] + r_quat.v[3] * l_quat.v[1] + r_quat.v[0] * l_quat.v[2] + r_quat.v[1] * l_quat.v[3];
        const z = r_quat.v[1] * l_quat.v[0] - r_quat.v[0] * l_quat.v[1] + r_quat.v[3] * l_quat.v[2] + r_quat.v[2] * l_quat.v[3];
        const w = -r_quat.v[0] * l_quat.v[0] - r_quat.v[1] * l_quat.v[1] - r_quat.v[2] * l_quat.v[2] + r_quat.v[3] * l_quat.v[3];
        return out.setComponents(x, y, z, w);
    }
    static multiplyNumber(quat, value) {
        const x = quat.v[0] * value;
        const y = quat.v[1] * value;
        const z = quat.v[2] * value;
        const w = quat.v[3] * value;
        return new this(x, y, z, w);
    }
    static multiplyNumberTo(quat, value, out) {
        out.v[0] = quat.v[0] * value;
        out.v[1] = quat.v[1] * value;
        out.v[2] = quat.v[2] * value;
        out.v[3] = quat.v[3] * value;
        return out;
    }
    static divideNumber(quat, value) {
        if (value === 0) {
            console.error("0 division occurred!");
        }
        const x = quat.v[0] / value;
        const y = quat.v[1] / value;
        const z = quat.v[2] / value;
        const w = quat.v[3] / value;
        return new this(x, y, z, w);
    }
    static divideNumberTo(quat, value, out) {
        if (value === 0) {
            console.error("0 division occurred!");
        }
        out.v[0] = quat.v[0] / value;
        out.v[1] = quat.v[1] / value;
        out.v[2] = quat.v[2] / value;
        out.v[3] = quat.v[3] / value;
        return out;
    }
    toString() {
        return '(' + this.v[0] + ', ' + this.v[1] + ', ' + this.v[2] + ', ' + this.v[3] + ')';
    }
    toStringApproximately() {
        return _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[0]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[1]) +
            ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[2]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[3]) + '\n';
    }
    flattenAsArray() {
        return [this.v[0], this.v[1], this.v[2], this.v[3]];
    }
    isDummy() {
        if (this.v.length === 0) {
            return true;
        }
        else {
            return false;
        }
    }
    isEqual(quat, delta = Number.EPSILON) {
        if (Math.abs(quat.v[0] - this.v[0]) < delta &&
            Math.abs(quat.v[1] - this.v[1]) < delta &&
            Math.abs(quat.v[2] - this.v[2]) < delta &&
            Math.abs(quat.v[3] - this.v[3]) < delta) {
            return true;
        }
        else {
            return false;
        }
    }
    isStrictEqual(quat) {
        if (this.v[0] === quat.v[0] &&
            this.v[1] === quat.v[1] &&
            this.v[2] === quat.v[2] &&
            this.v[3] === quat.v[3]) {
            return true;
        }
        else {
            return false;
        }
    }
    at(i) {
        return this.v[i];
    }
    length() {
        return Math.hypot(this.v[0], this.v[1], this.v[2], this.v[3]);
    }
    lengthSquared() {
        return this.v[0] ** 2 + this.v[1] ** 2 + this.v[2] ** 2 + this.v[3] ** 2;
    }
    /**
     * dot product
     */
    dot(quat) {
        return this.v[0] * quat.v[0] + this.v[1] * quat.v[1] + this.v[2] * quat.v[2] + this.v[3] * quat.v[3];
    }
    toEulerAnglesTo(out) {
        // this is from https://en.v[3]ikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_Code_2
        const sinr_cosp = 2.0 * (this.v[3] * this.v[0] + this.v[1] * this.v[2]);
        const cosr_cosp = 1.0 - 2.0 * (this.v[0] * this.v[0] + this.v[1] * this.v[1]);
        out.v[0] = Math.atan2(sinr_cosp, cosr_cosp);
        const sinp = 2.0 * (this.v[3] * this.v[1] - this.v[2] * this.v[0]);
        if (Math.abs(sinp) >= 1) {
            out.v[1] = Math.PI / 2 * Math.sign(sinp); // use 90 degrees if out of range
        }
        else {
            out.v[1] = Math.asin(sinp);
        }
        const siny_cosp = 2.0 * (this.v[3] * this.v[2] + this.v[0] * this.v[1]);
        const cosy_cosp = 1.0 - 2.0 * (this.v[1] * this.v[1] + this.v[2] * this.v[2]);
        out.v[2] = Math.atan2(siny_cosp, cosy_cosp);
        return out;
    }
    clone() {
        return new this.constructor(this.v[0], this.v[1], this.v[2], this.v[3]);
    }
}
Quaternion.__tmp_upVec = undefined;


/***/ }),

/***/ "./src/foundation/math/Scalar.ts":
/*!***************************************!*\
  !*** ./src/foundation/math/Scalar.ts ***!
  \***************************************/
/*! exports provided: Scalar_, default, Scalard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scalar_", function() { return Scalar_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Scalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scalard", function() { return Scalard; });
/* harmony import */ var _MathUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtil */ "./src/foundation/math/MathUtil.ts");

class Scalar_ {
    constructor(x, { type }) {
        if (ArrayBuffer.isView(x)) {
            this.v = x;
            return;
        }
        else if (x == null) {
            this.v = new type(0);
            return;
        }
        else {
            this.v = new type(1);
        }
        this.v[0] = x;
    }
    getValue() {
        return this.v[0];
    }
    getValueInArray() {
        return [this.v[0]];
    }
    get x() {
        return this.v[0];
    }
    get raw() {
        return this.v;
    }
    isStrictEqual(scalar) {
        if (this.x === scalar.x) {
            return true;
        }
        else {
            return false;
        }
    }
    isEqual(scalar, delta = Number.EPSILON) {
        if (Math.abs(scalar.x - this.x) < delta) {
            return true;
        }
        else {
            return false;
        }
    }
    get glslStrAsFloat() {
        return `${_MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].convertToStringAsGLSLFloat(this.x)}`;
    }
    get glslStrAsInt() {
        return `${Math.floor(this.x)}`;
    }
}
class Scalar extends Scalar_ {
    constructor(x) {
        super(x, { type: Float32Array });
    }
    static zero() {
        return new Scalar(0);
    }
    static one() {
        return new Scalar(1);
    }
    static dummy() {
        return new Scalar(null);
    }
    clone() {
        return new Scalar(this.x);
    }
}
class Scalard extends Scalar_ {
    constructor(x) {
        super(x, { type: Float64Array });
    }
    static zero() {
        return new Scalard(0);
    }
    static one() {
        return new Scalard(1);
    }
    static dummy() {
        return new Scalard(null);
    }
    clone() {
        return new Scalard(this.x);
    }
}


/***/ }),

/***/ "./src/foundation/math/Vector2.ts":
/*!****************************************!*\
  !*** ./src/foundation/math/Vector2.ts ***!
  \****************************************/
/*! exports provided: Vector2_, default, Vector2d */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2_", function() { return Vector2_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2d", function() { return Vector2d; });
/* harmony import */ var _MathUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtil */ "./src/foundation/math/MathUtil.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");


class Vector2_ {
    constructor(x, y, { type }) {
        if (ArrayBuffer.isView(x)) {
            this.v = x;
            return;
        }
        else if (x == null) {
            this.v = new type(0);
            return;
        }
        else {
            this.v = new type(2);
        }
        if (Array.isArray(x)) {
            this.v[0] = x[0];
            this.v[1] = x[1];
        }
        else if (typeof x === 'number') {
            this.v[0] = x;
            this.v[1] = y;
        }
        else {
            this.v[0] = x.v[0];
            this.v[1] = x.v[1];
        }
    }
    get x() {
        return this.v[0];
    }
    get y() {
        return this.v[1];
    }
    get className() {
        return this.constructor.name;
    }
    get glslStrAsFloat() {
        return `vec2(${_MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].convertToStringAsGLSLFloat(this.v[0])}, ${_MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].convertToStringAsGLSLFloat(this.v[1])})`;
    }
    get glslStrAsInt() {
        return `ivec2(${Math.floor(this.v[0])}, ${Math.floor(this.v[1])})`;
    }
    static get compositionType() {
        return _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Vec2;
    }
    /**
      * to square length(static version)
      */
    static lengthSquared(vec) {
        return vec.lengthSquared();
    }
    static lengthBtw(l_vec, r_vec) {
        return l_vec.lengthTo(r_vec);
    }
    static angleOfVectors(l_vec, r_vec) {
        const multipliedLength = l_vec.length() * r_vec.length();
        if (multipliedLength === 0) {
            console.error('length of a vector is 0!');
        }
        const cos_sita = l_vec.dot(r_vec) / multipliedLength;
        const sita = Math.acos(cos_sita);
        return sita;
    }
    static _zero(type) {
        return new this(0, 0, { type });
    }
    static _one(type) {
        return new this(1, 1, { type });
    }
    static _dummy(type) {
        return new this(null, 0, { type });
    }
    /**
     * normalize(static version)
     */
    static _normalize(vec, type) {
        const length = vec.length();
        return this._divide(vec, length, type);
    }
    /**
     * add value（static version）
     */
    static _add(l_vec, r_vec, type) {
        const x = l_vec.v[0] + r_vec.v[0];
        const y = l_vec.v[1] + r_vec.v[1];
        return new this(x, y, { type });
    }
    /**
      * add value（static version）
      */
    static addTo(l_vec, r_vec, out) {
        out.v[0] = l_vec.v[0] + r_vec.v[0];
        out.v[1] = l_vec.v[1] + r_vec.v[1];
        return out;
    }
    /**
      * subtract value(static version)
      */
    static _subtract(l_vec, r_vec, type) {
        const x = l_vec.v[0] - r_vec.v[0];
        const y = l_vec.v[1] - r_vec.v[1];
        return new this(x, y, { type });
    }
    /**
     * subtract value(static version)
     */
    static subtractTo(l_vec, r_vec, out) {
        out.v[0] = l_vec.v[0] - r_vec.v[0];
        out.v[1] = l_vec.v[1] - r_vec.v[1];
        return out;
    }
    /**
     * multiply value(static version)
     */
    static _multiply(vec, value, type) {
        const x = vec.v[0] * value;
        const y = vec.v[1] * value;
        return new this(x, y, { type });
    }
    /**
     * multiply value(static version)
     */
    static multiplyTo(vec, value, out) {
        out.v[0] = vec.v[0] * value;
        out.v[1] = vec.v[1] * value;
        return out;
    }
    /**
      * multiply vector(static version)
      */
    static _multiplyVector(l_vec, r_vec, type) {
        const x = l_vec.v[0] * r_vec.v[0];
        const y = l_vec.v[1] * r_vec.v[1];
        return new this(x, y, { type });
    }
    /**
      * multiply vector(static version)
      */
    static multiplyVectorTo(l_vec, r_vec, out) {
        out.v[0] = l_vec.v[0] * r_vec.v[0];
        out.v[1] = l_vec.v[1] * r_vec.v[1];
        return out;
    }
    /**
     * divide by value(static version)
     */
    static _divide(vec, value, type) {
        let x;
        let y;
        if (value !== 0) {
            x = vec.v[0] / value;
            y = vec.v[1] / value;
        }
        else {
            console.error("0 division occurred!");
            x = Infinity;
            y = Infinity;
        }
        return new this(x, y, { type });
    }
    /**
     * divide by value(static version)
     */
    static divideTo(vec, value, out) {
        if (value !== 0) {
            out.v[0] = vec.v[0] / value;
            out.v[1] = vec.v[1] / value;
        }
        else {
            console.error("0 division occurred!");
            out.v[0] = Infinity;
            out.v[1] = Infinity;
        }
        return out;
    }
    /**
     * divide by vector(static version)
     */
    static _divideVector(l_vec, r_vec, type) {
        let x;
        let y;
        if (r_vec.v[0] !== 0 && r_vec.v[1] !== 0) {
            x = l_vec.v[0] / r_vec.v[0];
            y = l_vec.v[1] / r_vec.v[1];
        }
        else {
            console.error("0 division occurred!");
            x = r_vec.v[0] === 0 ? Infinity : l_vec.v[0] / r_vec.v[0];
            y = r_vec.v[1] === 0 ? Infinity : l_vec.v[1] / r_vec.v[1];
        }
        return new this(x, y, { type });
    }
    /**
     * divide by vector(static version)
     */
    static divideVectorTo(l_vec, r_vec, out) {
        if (r_vec.v[0] !== 0 && r_vec.v[1] !== 0) {
            out.v[0] = l_vec.v[0] / r_vec.v[0];
            out.v[1] = l_vec.v[1] / r_vec.v[1];
        }
        else {
            console.error("0 division occurred!");
            out.v[0] = r_vec.v[0] === 0 ? Infinity : l_vec.v[0] / r_vec.v[0];
            out.v[1] = r_vec.v[1] === 0 ? Infinity : l_vec.v[1] / r_vec.v[1];
        }
        return out;
    }
    /**
     * dot product(static version)
     */
    static dot(l_vec, r_vec) {
        return l_vec.dot(r_vec);
    }
    /**
    * change to string
    */
    toString() {
        return '(' + this.v[0] + ', ' + this.v[1] + ')';
    }
    toStringApproximately() {
        return _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[0]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[1]) + '\n';
    }
    flattenAsArray() {
        return [this.v[0], this.v[1]];
    }
    isDummy() {
        if (this.v.length === 0) {
            return true;
        }
        else {
            return false;
        }
    }
    isEqual(vec, delta = Number.EPSILON) {
        if (Math.abs(vec.v[0] - this.v[0]) < delta &&
            Math.abs(vec.v[1] - this.v[1]) < delta) {
            return true;
        }
        else {
            return false;
        }
    }
    isStrictEqual(vec) {
        if (this.v[0] === vec.v[0] &&
            this.v[1] === vec.v[1]) {
            return true;
        }
        else {
            return false;
        }
    }
    at(i) {
        return this.v[i];
    }
    length() {
        return Math.hypot(this.v[0], this.v[1]);
    }
    lengthSquared() {
        return this.v[0] ** 2 + this.v[1] ** 2;
    }
    lengthTo(vec) {
        const deltaX = this.v[0] - vec.v[0];
        const deltaY = this.v[1] - vec.v[1];
        return Math.hypot(deltaX, deltaY);
    }
    /**
     * dot product
     */
    dot(vec) {
        return this.v[0] * vec.v[0] + this.v[1] * vec.v[1];
    }
    clone() {
        return new this.constructor(this.v[0], this.v[1]);
    }
}
class Vector2 extends Vector2_ {
    constructor(x, y) {
        super(x, y, { type: Float32Array });
    }
    static zero() {
        return super._zero(Float32Array);
    }
    static one() {
        return super._one(Float32Array);
    }
    static dummy() {
        return super._dummy(Float32Array);
    }
    static normalize(vec) {
        return super._normalize(vec, Float32Array);
    }
    static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
    }
    static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
    }
    static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
    }
    static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
    }
    static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
    }
    static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
    }
    clone() {
        return super.clone();
    }
}
class Vector2d extends Vector2_ {
    constructor(x, y) {
        super(x, y, { type: Float64Array });
    }
    static zero() {
        return super._zero(Float64Array);
    }
    static one() {
        return super._one(Float64Array);
    }
    static dummy() {
        return super._dummy(Float64Array);
    }
    static normalize(vec) {
        return super._normalize(vec, Float64Array);
    }
    static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float64Array);
    }
    static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float64Array);
    }
    static multiply(vec, value) {
        return super._multiply(vec, value, Float64Array);
    }
    static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float64Array);
    }
    static divide(vec, value) {
        return super._divide(vec, value, Float64Array);
    }
    static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float64Array);
    }
    clone() {
        return super.clone();
    }
}


/***/ }),

/***/ "./src/foundation/math/Vector3.ts":
/*!****************************************!*\
  !*** ./src/foundation/math/Vector3.ts ***!
  \****************************************/
/*! exports provided: Vector3_, default, Vector3d */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3_", function() { return Vector3_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3d", function() { return Vector3d; });
/* harmony import */ var _MathUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtil */ "./src/foundation/math/MathUtil.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");


class Vector3_ {
    constructor(x, y, z, { type }) {
        if (ArrayBuffer.isView(x)) {
            this.v = x;
            return;
        }
        else if (x == null) {
            this.v = new type(0);
            return;
        }
        else {
            this.v = new type(3);
        }
        if (Array.isArray(x)) {
            this.v[0] = x[0];
            this.v[1] = x[1];
            this.v[2] = x[2];
        }
        else if (typeof x === 'number') {
            this.v[0] = x;
            this.v[1] = y;
            this.v[2] = z;
        }
        else {
            if (typeof x.v[2] === 'undefined') {
                // IVector2
                this.v[0] = x.v[0];
                this.v[1] = x.v[1];
                this.v[2] = 0;
            }
            else {
                // IVector3 or IVector4
                this.v[0] = x.v[0];
                this.v[1] = x.v[1];
                this.v[2] = x.v[2];
            }
        }
    }
    get x() {
        return this.v[0];
    }
    get y() {
        return this.v[1];
    }
    get z() {
        return this.v[2];
    }
    get w() {
        return 1;
    }
    get className() {
        return this.constructor.name;
    }
    get glslStrAsFloat() {
        return `vec3(${_MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].convertToStringAsGLSLFloat(this.v[0])}, ${_MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].convertToStringAsGLSLFloat(this.v[1])}, ${_MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].convertToStringAsGLSLFloat(this.v[2])})`;
    }
    get glslStrAsInt() {
        return `ivec3(${Math.floor(this.v[0])}, ${Math.floor(this.v[1])}, ${Math.floor(this.v[2])})`;
    }
    static get compositionType() {
        return _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Vec3;
    }
    /**
   * to square length(static version)
   */
    static lengthSquared(vec) {
        return vec.lengthSquared();
    }
    static lengthBtw(l_vec, r_vec) {
        return l_vec.lengthTo(r_vec);
    }
    static angleOfVectors(l_vec, r_vec) {
        const multipliedLength = l_vec.length() * r_vec.length();
        if (multipliedLength === 0) {
            console.error('length of a vector is 0!');
        }
        const cos_sita = l_vec.dot(r_vec) / multipliedLength;
        const sita = Math.acos(cos_sita);
        return sita;
    }
    static _zero(type) {
        return new this(0, 0, 0, { type });
    }
    static _one(type) {
        return new this(1, 1, 1, { type });
    }
    static _dummy(type) {
        return new this(null, 0, 0, { type });
    }
    /**
     * normalize(static version)
     */
    static _normalize(vec, type) {
        const length = vec.length();
        return this._divide(vec, length, type);
    }
    /**
     * add value（static version）
     */
    static _add(l_vec, r_vec, type) {
        const x = l_vec.v[0] + r_vec.v[0];
        const y = l_vec.v[1] + r_vec.v[1];
        const z = l_vec.v[2] + r_vec.v[2];
        return new this(x, y, z, { type });
    }
    /**
     * add value（static version）
     */
    static addTo(l_vec, r_vec, out) {
        out.v[0] = l_vec.v[0] + r_vec.v[0];
        out.v[1] = l_vec.v[1] + r_vec.v[1];
        out.v[2] = l_vec.v[2] + r_vec.v[2];
        return out;
    }
    /**
     * subtract(subtract)
     */
    static _subtract(l_vec, r_vec, type) {
        const x = l_vec.v[0] - r_vec.v[0];
        const y = l_vec.v[1] - r_vec.v[1];
        const z = l_vec.v[2] - r_vec.v[2];
        return new this(x, y, z, { type });
    }
    /**
     * subtract(subtract)
     */
    static subtractTo(l_vec, r_vec, out) {
        out.v[0] = l_vec.v[0] - r_vec.v[0];
        out.v[1] = l_vec.v[1] - r_vec.v[1];
        out.v[2] = l_vec.v[2] - r_vec.v[2];
        return out;
    }
    /**
     * multiply(static version)
     */
    static _multiply(vec, value, type) {
        const x = vec.v[0] * value;
        const y = vec.v[1] * value;
        const z = vec.v[2] * value;
        return new this(x, y, z, { type });
    }
    /**
     * multiplyTo(static version)
     */
    static multiplyTo(vec, value, out) {
        out.v[0] = vec.v[0] * value;
        out.v[1] = vec.v[1] * value;
        out.v[2] = vec.v[2] * value;
        return out;
    }
    /**
     * multiply vector(static version)
     */
    static _multiplyVector(l_vec, r_vec, type) {
        const x = l_vec.v[0] * r_vec.v[0];
        const y = l_vec.v[1] * r_vec.v[1];
        const z = l_vec.v[2] * r_vec.v[2];
        return new this(x, y, z, { type });
    }
    /**
      * multiply vector(static version)
      */
    static multiplyVectorTo(l_vec, r_vec, out) {
        out.v[0] = l_vec.v[0] * r_vec.v[0];
        out.v[1] = l_vec.v[1] * r_vec.v[1];
        out.v[2] = l_vec.v[2] * r_vec.v[2];
        return out;
    }
    /**
   * divide(static version)
   */
    static _divide(vec, value, type) {
        let x;
        let y;
        let z;
        if (value !== 0) {
            x = vec.v[0] / value;
            y = vec.v[1] / value;
            z = vec.v[2] / value;
        }
        else {
            console.error("0 division occurred!");
            x = Infinity;
            y = Infinity;
            z = Infinity;
        }
        return new this(x, y, z, { type });
    }
    /**
     * divide by value(static version)
     */
    static divideTo(vec, value, out) {
        if (value !== 0) {
            out.v[0] = vec.v[0] / value;
            out.v[1] = vec.v[1] / value;
            out.v[2] = vec.v[2] / value;
        }
        else {
            console.error("0 division occurred!");
            out.v[0] = Infinity;
            out.v[1] = Infinity;
            out.v[2] = Infinity;
        }
        return out;
    }
    /**
     * divide vector(static version)
     */
    static _divideVector(l_vec, r_vec, type) {
        let x;
        let y;
        let z;
        if (r_vec.v[0] !== 0 && r_vec.v[1] !== 0 && r_vec.v[2] !== 0) {
            x = l_vec.v[0] / r_vec.v[0];
            y = l_vec.v[1] / r_vec.v[1];
            z = l_vec.v[2] / r_vec.v[2];
        }
        else {
            console.error("0 division occurred!");
            x = r_vec.v[0] === 0 ? Infinity : l_vec.v[0] / r_vec.v[0];
            y = r_vec.v[1] === 0 ? Infinity : l_vec.v[1] / r_vec.v[1];
            z = r_vec.v[2] === 0 ? Infinity : l_vec.v[2] / r_vec.v[2];
        }
        return new this(x, y, z, { type });
    }
    /**
     * divide by vector(static version)
     */
    static divideVectorTo(l_vec, r_vec, out) {
        if (r_vec.v[0] !== 0 && r_vec.v[1] !== 0 && r_vec.v[2] !== 0) {
            out.v[0] = l_vec.v[0] / r_vec.v[0];
            out.v[1] = l_vec.v[1] / r_vec.v[1];
            out.v[2] = l_vec.v[2] / r_vec.v[2];
        }
        else {
            console.error("0 division occurred!");
            out.v[0] = r_vec.v[0] === 0 ? Infinity : l_vec.v[0] / r_vec.v[0];
            out.v[1] = r_vec.v[1] === 0 ? Infinity : l_vec.v[1] / r_vec.v[1];
            out.v[2] = r_vec.v[2] === 0 ? Infinity : l_vec.v[2] / r_vec.v[2];
        }
        return out;
    }
    /**
     * dot product(static version)
     */
    static dot(l_vec, r_vec) {
        return l_vec.dot(r_vec);
    }
    /**
    * cross product(static version)
    */
    static _cross(l_vec, r_vec, type) {
        const x = l_vec.v[1] * r_vec.v[2] - l_vec.v[2] * r_vec.v[1];
        const y = l_vec.v[2] * r_vec.v[0] - l_vec.v[0] * r_vec.v[2];
        const z = l_vec.v[0] * r_vec.v[1] - l_vec.v[1] * r_vec.v[0];
        return new this(x, y, z, { type });
    }
    /**
    * cross product(static version)
    */
    static crossTo(l_vec, r_vec, out) {
        const x = l_vec.v[1] * r_vec.v[2] - l_vec.v[2] * r_vec.v[1];
        const y = l_vec.v[2] * r_vec.v[0] - l_vec.v[0] * r_vec.v[2];
        const z = l_vec.v[0] * r_vec.v[1] - l_vec.v[1] * r_vec.v[0];
        return out.setComponents(x, y, z);
    }
    /**
     * quaternion * vector3
     */
    static _multiplyQuaternion(quat, vec, type) {
        const num = quat.v[0] * 2;
        const num2 = quat.v[1] * 2;
        const num3 = quat.v[2] * 2;
        const num4 = quat.v[0] * num;
        const num5 = quat.v[1] * num2;
        const num6 = quat.v[2] * num3;
        const num7 = quat.v[0] * num2;
        const num8 = quat.v[0] * num3;
        const num9 = quat.v[1] * num3;
        const num10 = quat.v[3] * num;
        const num11 = quat.v[3] * num2;
        const num12 = quat.v[3] * num3;
        const x = (1 - (num5 + num6)) * vec.v[0] + (num7 - num12) * vec.v[1] + (num8 + num11) * vec.v[2];
        const y = (num7 + num12) * vec.v[0] + (1 - (num4 + num6)) * vec.v[1] + (num9 - num10) * vec.v[2];
        const z = (num8 - num11) * vec.v[0] + (num9 + num10) * vec.v[1] + (1 - (num4 + num5)) * vec.v[2];
        return new this(x, y, z, { type });
    }
    /**
     * quaternion * vector3
     */
    static multiplyQuaternionTo(quat, vec, out) {
        const num = quat.v[0] * 2;
        const num2 = quat.v[1] * 2;
        const num3 = quat.v[2] * 2;
        const num4 = quat.v[0] * num;
        const num5 = quat.v[1] * num2;
        const num6 = quat.v[2] * num3;
        const num7 = quat.v[0] * num2;
        const num8 = quat.v[0] * num3;
        const num9 = quat.v[1] * num3;
        const num10 = quat.v[3] * num;
        const num11 = quat.v[3] * num2;
        const num12 = quat.v[3] * num3;
        const x = (1 - (num5 + num6)) * vec.v[0] + (num7 - num12) * vec.v[1] + (num8 + num11) * vec.v[2];
        const y = (num7 + num12) * vec.v[0] + (1 - (num4 + num6)) * vec.v[1] + (num9 - num10) * vec.v[2];
        const z = (num8 - num11) * vec.v[0] + (num9 + num10) * vec.v[1] + (1 - (num4 + num5)) * vec.v[2];
        return out.setComponents(x, y, z);
    }
    /**
     * change to string
     */
    toString() {
        return '(' + this.v[0] + ', ' + this.v[1] + ', ' + this.v[2] + ')';
    }
    toStringApproximately() {
        return _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[0]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[1]) +
            ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[2]) + '\n';
    }
    flattenAsArray() {
        return [this.v[0], this.v[1], this.v[2]];
    }
    isDummy() {
        if (this.v.length === 0) {
            return true;
        }
        else {
            return false;
        }
    }
    isEqual(vec, delta = Number.EPSILON) {
        if (Math.abs(vec.v[0] - this.v[0]) < delta &&
            Math.abs(vec.v[1] - this.v[1]) < delta &&
            Math.abs(vec.v[2] - this.v[2]) < delta) {
            return true;
        }
        else {
            return false;
        }
    }
    isStrictEqual(vec) {
        if (this.v[0] === vec.v[0] &&
            this.v[1] === vec.v[1] &&
            this.v[2] === vec.v[2]) {
            return true;
        }
        else {
            return false;
        }
    }
    at(i) {
        return this.v[i];
    }
    length() {
        return Math.hypot(this.v[0], this.v[1], this.v[2]);
    }
    lengthSquared() {
        return this.v[0] ** 2 + this.v[1] ** 2 + this.v[2] ** 2;
    }
    lengthTo(vec) {
        const deltaX = this.v[0] - vec.v[0];
        const deltaY = this.v[1] - vec.v[1];
        const deltaZ = this.v[2] - vec.v[2];
        return Math.hypot(deltaX, deltaY, deltaZ);
    }
    /**
     * dot product
     */
    dot(vec) {
        return this.v[0] * vec.v[0] + this.v[1] * vec.v[1] + this.v[2] * vec.v[2];
    }
    clone() {
        return new this.constructor(this.v[0], this.v[1], this.v[2]);
    }
}
class Vector3 extends Vector3_ {
    constructor(x, y, z) {
        super(x, y, z, { type: Float32Array });
    }
    static zero() {
        return super._zero(Float32Array);
    }
    static one() {
        return super._one(Float32Array);
    }
    static dummy() {
        return super._dummy(Float32Array);
    }
    static normalize(vec) {
        return super._normalize(vec, Float32Array);
    }
    static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
    }
    static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
    }
    static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
    }
    static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
    }
    static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
    }
    static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
    }
    static cross(l_vec, r_vec) {
        return super._cross(l_vec, r_vec, Float32Array);
    }
    static multiplyQuaternion(quat, vec) {
        return super._multiplyQuaternion(quat, vec, Float32Array);
    }
    clone() {
        return super.clone();
    }
}
class Vector3d extends Vector3_ {
    constructor(x, y, z) {
        super(x, y, z, { type: Float64Array });
    }
    static zero() {
        return super._zero(Float64Array);
    }
    static one() {
        return super._one(Float64Array);
    }
    static dummy() {
        return super._dummy(Float64Array);
    }
    static normalize(vec) {
        return super._normalize(vec, Float64Array);
    }
    static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float64Array);
    }
    static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float64Array);
    }
    static multiply(vec, value) {
        return super._multiply(vec, value, Float64Array);
    }
    static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float64Array);
    }
    static divide(vec, value) {
        return super._divide(vec, value, Float64Array);
    }
    static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float64Array);
    }
    static cross(l_vec, r_vec) {
        return super._cross(l_vec, r_vec, Float64Array);
    }
    static multiplyQuaternion(quat, vec) {
        return super._multiplyQuaternion(quat, vec, Float64Array);
    }
    clone() {
        return super.clone();
    }
}


/***/ }),

/***/ "./src/foundation/math/Vector4.ts":
/*!****************************************!*\
  !*** ./src/foundation/math/Vector4.ts ***!
  \****************************************/
/*! exports provided: Vector4_, default, Vector4d */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4_", function() { return Vector4_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4d", function() { return Vector4d; });
/* harmony import */ var _MathUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtil */ "./src/foundation/math/MathUtil.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");


class Vector4_ {
    constructor(x, y, z, w, { type }) {
        if (ArrayBuffer.isView(x)) {
            this.v = x;
            return;
        }
        else if (x == null) {
            this.v = new type(0);
            return;
        }
        else {
            this.v = new type(4);
        }
        if (Array.isArray(x)) {
            this.v[0] = x[0];
            this.v[1] = x[1];
            this.v[2] = x[2];
            this.v[3] = x[3];
        }
        else if (typeof x === 'number') {
            this.v[0] = x;
            this.v[1] = y;
            this.v[2] = z;
            this.v[3] = w;
        }
        else {
            if (typeof x.v[2] === 'undefined') {
                // IVector2
                this.v[0] = x.v[0];
                this.v[1] = x.v[1];
                this.v[2] = 0;
                this.v[3] = 1;
            }
            else if (typeof x.v[3] === 'undefined') {
                // IVector3
                this.v[0] = x.v[0];
                this.v[1] = x.v[1];
                this.v[2] = x.v[2];
                this.v[3] = 1;
            }
            else {
                // IVector4
                this.v[0] = x.v[0];
                this.v[1] = x.v[1];
                this.v[2] = x.v[2];
                this.v[3] = x.v[3];
            }
        }
    }
    get x() {
        return this.v[0];
    }
    get y() {
        return this.v[1];
    }
    get z() {
        return this.v[2];
    }
    get w() {
        return this.v[3];
    }
    get className() {
        return this.constructor.name;
    }
    get glslStrAsFloat() {
        return `vec4(${_MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].convertToStringAsGLSLFloat(this.v[0])}, ${_MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].convertToStringAsGLSLFloat(this.v[1])}, ${_MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].convertToStringAsGLSLFloat(this.v[2])}, ${_MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].convertToStringAsGLSLFloat(this.v[3])})`;
    }
    get glslStrAsInt() {
        return `ivec4(${Math.floor(this.v[0])}, ${Math.floor(this.v[1])}, ${Math.floor(this.v[2])}, ${Math.floor(this.v[3])})`;
    }
    static get compositionType() {
        return _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Vec4;
    }
    /**
     * to square length(static version)
     */
    static lengthSquared(vec) {
        return vec.lengthSquared();
    }
    static lengthBtw(l_vec, r_vec) {
        return l_vec.lengthTo(r_vec);
    }
    /**
     * Zero Vector
     */
    static _zero(type) {
        return new this(0, 0, 0, 0, { type });
    }
    static _one(type) {
        return new this(1, 1, 1, 1, { type });
    }
    static _dummy(type) {
        return new this(null, 0, 0, 0, { type });
    }
    /**
     * normalize(static version)
     */
    static _normalize(vec, type) {
        const length = vec.length();
        return this._divide(vec, length, type);
    }
    /**
     * add value（static version）
     */
    static _add(l_vec, r_vec, type) {
        const x = l_vec.v[0] + r_vec.v[0];
        const y = l_vec.v[1] + r_vec.v[1];
        const z = l_vec.v[2] + r_vec.v[2];
        const w = l_vec.v[3] + r_vec.v[3];
        return new this(x, y, z, w, { type });
    }
    /**
     * add value（static version）
     */
    static addTo(l_vec, r_vec, out) {
        out.v[0] = l_vec.v[0] + r_vec.v[0];
        out.v[1] = l_vec.v[1] + r_vec.v[1];
        out.v[2] = l_vec.v[2] + r_vec.v[2];
        out.v[3] = l_vec.v[3] + r_vec.v[3];
        return out;
    }
    /**
     * subtract(static version)
     */
    static _subtract(l_vec, r_vec, type) {
        const x = l_vec.v[0] - r_vec.v[0];
        const y = l_vec.v[1] - r_vec.v[1];
        const z = l_vec.v[2] - r_vec.v[2];
        const w = l_vec.v[3] - r_vec.v[3];
        return new this(x, y, z, w, { type });
    }
    /**
     * subtract(static version)
     */
    static subtractTo(l_vec, r_vec, out) {
        out.v[0] = l_vec.v[0] - r_vec.v[0];
        out.v[1] = l_vec.v[1] - r_vec.v[1];
        out.v[2] = l_vec.v[2] - r_vec.v[2];
        out.v[3] = l_vec.v[3] - r_vec.v[3];
        return out;
    }
    /**
     * multiply(static version)
     */
    static _multiply(vec, value, type) {
        const x = vec.v[0] * value;
        const y = vec.v[1] * value;
        const z = vec.v[2] * value;
        const w = vec.v[3] * value;
        return new this(x, y, z, w, { type });
    }
    /**
     * multiplyTo(static version)
     */
    static multiplyTo(vec, value, out) {
        out.v[0] = vec.v[0] * value;
        out.v[1] = vec.v[1] * value;
        out.v[2] = vec.v[2] * value;
        out.v[3] = vec.v[3] * value;
        return out;
    }
    /**
     * multiply vector(static version)
     */
    static _multiplyVector(l_vec, r_vec, type) {
        const x = l_vec.v[0] * r_vec.v[0];
        const y = l_vec.v[1] * r_vec.v[1];
        const z = l_vec.v[2] * r_vec.v[2];
        const w = l_vec.v[3] * r_vec.v[3];
        return new this(x, y, z, w, { type });
    }
    /**
     * multiply vector(static version)
     */
    static multiplyVectorTo(l_vec, r_vec, out) {
        out.v[0] = l_vec.v[0] * r_vec.v[0];
        out.v[1] = l_vec.v[1] * r_vec.v[1];
        out.v[2] = l_vec.v[2] * r_vec.v[2];
        out.v[3] = l_vec.v[3] * r_vec.v[3];
        return out;
    }
    /**
     * divide(static version)
     */
    static _divide(vec, value, type) {
        let x;
        let y;
        let z;
        let w;
        if (value !== 0) {
            x = vec.v[0] / value;
            y = vec.v[1] / value;
            z = vec.v[2] / value;
            w = vec.v[3] / value;
        }
        else {
            console.error("0 division occurred!");
            x = Infinity;
            y = Infinity;
            z = Infinity;
            w = Infinity;
        }
        return new this(x, y, z, w, { type });
    }
    /**
     * divide by value(static version)
     */
    static divideTo(vec, value, out) {
        if (value !== 0) {
            out.v[0] = vec.v[0] / value;
            out.v[1] = vec.v[1] / value;
            out.v[2] = vec.v[2] / value;
            out.v[3] = vec.v[3] / value;
        }
        else {
            console.error("0 division occurred!");
            out.v[0] = Infinity;
            out.v[1] = Infinity;
            out.v[2] = Infinity;
            out.v[3] = Infinity;
        }
        return out;
    }
    /**
     * divide vector(static version)
     */
    static _divideVector(l_vec, r_vec, type) {
        let x;
        let y;
        let z;
        let w;
        if (r_vec.v[0] !== 0 && r_vec.v[1] !== 0 && r_vec.v[2] !== 0 && r_vec.v[3] !== 0) {
            x = l_vec.v[0] / r_vec.v[0];
            y = l_vec.v[1] / r_vec.v[1];
            z = l_vec.v[2] / r_vec.v[2];
            w = l_vec.v[3] / r_vec.v[3];
        }
        else {
            console.error("0 division occurred!");
            x = r_vec.v[0] === 0 ? Infinity : l_vec.v[0] / r_vec.v[0];
            y = r_vec.v[1] === 0 ? Infinity : l_vec.v[1] / r_vec.v[1];
            z = r_vec.v[2] === 0 ? Infinity : l_vec.v[2] / r_vec.v[2];
            w = r_vec.v[3] === 0 ? Infinity : l_vec.v[3] / r_vec.v[3];
        }
        return new this(x, y, z, w, { type });
    }
    /**
     * divide by vector(static version)
     */
    static divideVectorTo(l_vec, r_vec, out) {
        if (r_vec.v[0] !== 0 && r_vec.v[1] !== 0 && r_vec.v[2] !== 0 && r_vec.v[3] !== 0) {
            out.v[0] = l_vec.v[0] / r_vec.v[0];
            out.v[1] = l_vec.v[1] / r_vec.v[1];
            out.v[2] = l_vec.v[2] / r_vec.v[2];
            out.v[3] = l_vec.v[3] / r_vec.v[3];
        }
        else {
            console.error("0 division occurred!");
            out.v[0] = r_vec.v[0] === 0 ? Infinity : l_vec.v[0] / r_vec.v[0];
            out.v[1] = r_vec.v[1] === 0 ? Infinity : l_vec.v[1] / r_vec.v[1];
            out.v[2] = r_vec.v[2] === 0 ? Infinity : l_vec.v[2] / r_vec.v[2];
            out.v[3] = r_vec.v[3] === 0 ? Infinity : l_vec.v[3] / r_vec.v[3];
        }
        return out;
    }
    /**
     * dot product(static version)
     */
    static dot(l_vec, r_vec) {
        return l_vec.dot(r_vec);
    }
    toString() {
        return '(' + this.v[0] + ', ' + this.v[1] + ', ' + this.v[2] + ', ' + this.v[3] + ')';
    }
    toStringApproximately() {
        return _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[0]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[1]) +
            ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[2]) + ' ' + _MathUtil__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].nearZeroToZero(this.v[3]) + '\n';
    }
    flattenAsArray() {
        return [this.v[0], this.v[1], this.v[2], this.v[3]];
    }
    isDummy() {
        if (this.v.length === 0) {
            return true;
        }
        else {
            return false;
        }
    }
    isEqual(vec, delta = Number.EPSILON) {
        if (Math.abs(vec.v[0] - this.v[0]) < delta &&
            Math.abs(vec.v[1] - this.v[1]) < delta &&
            Math.abs(vec.v[2] - this.v[2]) < delta &&
            Math.abs(vec.v[3] - this.v[3]) < delta) {
            return true;
        }
        else {
            return false;
        }
    }
    isStrictEqual(vec) {
        if (this.v[0] === vec.v[0] &&
            this.v[1] === vec.v[1] &&
            this.v[2] === vec.v[2] &&
            this.v[3] === vec.v[3]) {
            return true;
        }
        else {
            return false;
        }
    }
    at(i) {
        return this.v[i];
    }
    length() {
        return Math.hypot(this.v[0], this.v[1], this.v[2], this.v[3]);
    }
    lengthSquared() {
        return this.v[0] ** 2 + this.v[1] ** 2 + this.v[2] ** 2 + this.v[3] ** 2;
    }
    lengthTo(vec) {
        const deltaX = this.v[0] - vec.v[0];
        const deltaY = this.v[1] - vec.v[1];
        const deltaZ = this.v[2] - vec.v[2];
        const deltaW = this.v[3] - vec.v[3];
        return Math.hypot(deltaX, deltaY, deltaZ, deltaW);
    }
    /**
     * dot product
     */
    dot(vec) {
        return this.v[0] * vec.v[0] + this.v[1] * vec.v[1] + this.v[2] * vec.v[2] + this.v[3] * vec.v[3];
    }
    clone() {
        return new this.constructor(this.v[0], this.v[1], this.v[2], this.v[3]);
    }
}
class Vector4 extends Vector4_ {
    constructor(x, y, z, w) {
        super(x, y, z, w, { type: Float32Array });
    }
    static zero() {
        return super._zero(Float32Array);
    }
    static one() {
        return super._one(Float32Array);
    }
    static dummy() {
        return super._dummy(Float32Array);
    }
    static normalize(vec) {
        return super._normalize(vec, Float32Array);
    }
    static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
    }
    static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
    }
    static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
    }
    static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
    }
    static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
    }
    static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
    }
    clone() {
        return super.clone();
    }
}
class Vector4d extends Vector4_ {
    constructor(x, y, z, w) {
        super(x, y, z, w, { type: Float64Array });
    }
    static zero() {
        return super._zero(Float64Array);
    }
    static one() {
        return super._one(Float64Array);
    }
    static dummy() {
        return super._dummy(Float64Array);
    }
    static normalize(vec) {
        return super._normalize(vec, Float64Array);
    }
    static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float64Array);
    }
    static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float64Array);
    }
    static multiply(vec, value) {
        return super._multiply(vec, value, Float64Array);
    }
    static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float64Array);
    }
    static divide(vec, value) {
        return super._divide(vec, value, Float64Array);
    }
    static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float64Array);
    }
    clone() {
        return super.clone();
    }
}


/***/ }),

/***/ "./src/foundation/math/VectorN.ts":
/*!****************************************!*\
  !*** ./src/foundation/math/VectorN.ts ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VectorN; });
class VectorN {
    constructor(float32Array) {
        this.v = float32Array;
    }
}


/***/ }),

/***/ "./src/foundation/memory/Accessor.ts":
/*!*******************************************!*\
  !*** ./src/foundation/memory/Accessor.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Accessor; });
/* harmony import */ var _AccessorBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AccessorBase */ "./src/foundation/memory/AccessorBase.ts");

class Accessor extends _AccessorBase__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ bufferView, byteOffset, compositionType, componentType, byteStride, count, raw, max, min, arrayLength, normalized }) {
        super({ bufferView, byteOffset, compositionType, componentType, byteStride, count, raw, max, min, arrayLength, normalized });
    }
}


/***/ }),

/***/ "./src/foundation/memory/AccessorBase.ts":
/*!***********************************************!*\
  !*** ./src/foundation/memory/AccessorBase.ts ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AccessorBase; });
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector2 */ "./src/foundation/math/Vector2.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_Vector4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _math_Matrix33__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Matrix33 */ "./src/foundation/math/Matrix33.ts");
/* harmony import */ var _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");








class AccessorBase extends _core_RnObject__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor({ bufferView, byteOffset, compositionType, componentType, byteStride, count, raw, max, min, arrayLength, normalized }) {
        super();
        this.__compositionType = _definitions_CompositionType__WEBPACK_IMPORTED_MODULE_1__["CompositionType"].Unknown;
        this.__componentType = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Unknown;
        this.__count = 0;
        this.__takenCount = 0;
        this.__byteStride = 0;
        this.__arrayLength = 1;
        this.__normalized = false;
        this.__bufferView = bufferView;
        this.__byteOffsetInRawArrayBufferOfBuffer = bufferView.byteOffsetInRawArrayBufferOfBuffer + byteOffset;
        this.__compositionType = compositionType;
        this.__componentType = componentType;
        this.__count = count;
        this.__arrayLength = arrayLength;
        this.__max = max;
        this.__min = min;
        this.__raw = raw;
        this.__normalized = normalized;
        this.__byteStride = byteStride;
        if (this.__byteStride === 0) {
            this.__byteStride = this.__compositionType.getNumberOfComponents() * this.__componentType.getSizeInBytes() * this.__arrayLength;
        }
        this.prepare();
    }
    prepare() {
        const typedArrayClass = this.getTypedArrayClass(this.__componentType);
        this.__typedArrayClass = typedArrayClass;
        if (this.__componentType.getSizeInBytes() === 8) {
            if (this.__byteOffsetInRawArrayBufferOfBuffer % 8 !== 0) {
                console.info('Padding added because of byteOffset of accessor is not 8 bytes aligned despite of Double precision.');
                this.__byteOffsetInRawArrayBufferOfBuffer += (this.__byteOffsetInRawArrayBufferOfBuffer % 8 === 0) ? 0 : 8 - this.__byteOffsetInRawArrayBufferOfBuffer % 8;
            }
        }
        //  else if (this.__componentType.getSizeInBytes() === 4) {
        //   if (this.__byteOffsetInBuffer % 4 !== 0) {
        //     console.info('Padding added because of byteOffset of accessor is not 4 bytes aligned despite of Double precision.');
        //     this.__byteOffsetInBuffer += 4 - this.__byteOffsetInBuffer % 4;
        //   }
        // }
        if (this.__bufferView.isSoA) {
            if (this.__raw.byteLength - this.__byteOffsetInRawArrayBufferOfBuffer < this.__compositionType.getNumberOfComponents() * this.__componentType.getSizeInBytes() * this.__count) {
                console.error(`Requesting a data size that exceeds the remaining capacity of the buffer: ${this.bufferView.buffer.name}.`);
            }
            this.__dataView = new DataView(this.__raw, this.__byteOffsetInRawArrayBufferOfBuffer, this.__byteStride * this.__count);
        }
        else {
            this.__dataView = new DataView(this.__raw, this.__byteOffsetInRawArrayBufferOfBuffer);
        }
        if (this.__byteOffsetInRawArrayBufferOfBuffer % this.__componentType.getSizeInBytes() === 0) {
            this.__typedArray = new typedArrayClass(this.__raw, this.__byteOffsetInRawArrayBufferOfBuffer, this.__compositionType.getNumberOfComponents() * this.__count);
        }
        this.__dataViewGetter = this.__dataView[this.getDataViewGetter(this.__componentType)].bind(this.__dataView);
        this.__dataViewSetter = this.__dataView[this.getDataViewSetter(this.__componentType)].bind(this.__dataView);
    }
    getTypedArrayClass(componentType) {
        switch (componentType) {
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Byte: return Int8Array;
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].UnsignedByte: return Uint8Array;
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Short: return Int16Array;
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].UnsignedShort: return Uint16Array;
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Int: return Int32Array;
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].UnsignedInt: return Uint32Array;
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Float: return Float32Array;
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Double: return Float64Array;
            default:
                console.error('Unexpected ComponentType!');
                return void 0;
        }
    }
    getDataViewGetter(componentType) {
        switch (componentType) {
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Byte: return 'getInt8';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].UnsignedByte: return 'getUint8';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Short: return 'getInt16';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].UnsignedShort: return 'getUint16';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Int: return 'getInt32';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].UnsignedInt: return 'getUint32';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Float: return 'getFloat32';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Double: return 'getFloat64';
            default:
                console.error('Unexpected ComponentType!');
                return 'unknown';
        }
    }
    getDataViewSetter(componentType) {
        switch (componentType) {
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Byte: return 'setInt8';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].UnsignedByte: return 'setUint8';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Short: return 'setInt16';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].UnsignedShort: return 'setUint16';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Int: return 'setInt32';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].UnsignedInt: return 'setUint32';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Float: return 'setFloat32';
            case _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_0__["ComponentType"].Double: return 'setFloat64';
            default: console.error('Unexpected ComponentType!');
        }
        return undefined;
    }
    takeOne() {
        const arrayBufferOfBufferView = this.__raw;
        // let stride = this.__compositionType.getNumberOfComponents() * this.__componentType.getSizeInBytes();
        // if (this.__bufferView.isAoS) {
        //   stride = this.__bufferView.byteStride;
        // }
        if (this.__takenCount >= this.__count) {
            console.error('You are trying to allocate more than you have secured.');
        }
        const subTypedArray = new this.__typedArrayClass(arrayBufferOfBufferView, this.__byteOffsetInRawArrayBufferOfBuffer + this.__byteStride * this.__takenCount, this.__compositionType.getNumberOfComponents() * this.__arrayLength);
        this.__takenCount += 1;
        subTypedArray._accessor = this;
        subTypedArray._idx_of_accessor = this.__takenCount;
        return subTypedArray;
    }
    get takenCount() {
        return this.takenCount;
    }
    get numberOfComponents() {
        return this.__compositionType.getNumberOfComponents();
    }
    get componentSizeInBytes() {
        return this.__componentType.getSizeInBytes();
    }
    get elementSizeInBytes() {
        return this.numberOfComponents * this.componentSizeInBytes;
    }
    get elementCount() {
        return this.__count;
    }
    get byteLength() {
        return this.__byteStride * this.__count;
    }
    get componentType() {
        return this.__componentType;
    }
    get compositionType() {
        return this.__compositionType;
    }
    getTypedArray() {
        if (this.__bufferView.isAoS) {
            console.warn('Be careful. this reference bufferView is AoS(Array on Structure), it means Interleaved Data. So you can not access your data properly by this TypedArray.');
        }
        return this.__typedArray;
    }
    get isAoS() {
        return this.__bufferView.isAoS;
    }
    get isSoA() {
        return this.__bufferView.isSoA;
    }
    get byteStride() {
        return this.__byteStride;
    }
    getScalar(i, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        return this.__dataViewGetter(this.__byteStride * index, endian);
    }
    getScalarAt(i, compositionOffset, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        return this.__dataViewGetter(this.__byteStride * index + compositionOffset, endian);
    }
    getVec2AsArray(i, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const byteSize = this.componentSizeInBytes;
        return [this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian)];
    }
    getVec3AsArray(i, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const byteSize = this.componentSizeInBytes;
        return [this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian)];
    }
    getVec4AsArray(i, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const byteSize = this.componentSizeInBytes;
        return [this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian)];
    }
    getMat3AsArray(i, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const byteSize = this.componentSizeInBytes;
        return [
            this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian),
            this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 4 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 5 * byteSize, endian),
            this.__dataViewGetter(this.__byteStride * index + 6 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 7 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 8 * byteSize, endian),
        ];
    }
    getMat4AsArray(i, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const byteSize = this.componentSizeInBytes;
        return [
            this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian),
            this.__dataViewGetter(this.__byteStride * index + 4 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 5 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 6 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 7 * byteSize, endian),
            this.__dataViewGetter(this.__byteStride * index + 8 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 9 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 10 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 11 * byteSize, endian),
            this.__dataViewGetter(this.__byteStride * index + 12 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 13 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 14 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 15 * byteSize, endian),
        ];
    }
    getVec2(i, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const byteSize = this.componentSizeInBytes;
        return new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["default"](this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian));
    }
    getVec3(i, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const byteSize = this.componentSizeInBytes;
        return new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"](this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian));
    }
    getVec4(i, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const byteSize = this.componentSizeInBytes;
        return new _math_Vector4__WEBPACK_IMPORTED_MODULE_5__["default"](this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian));
    }
    getMat3(i, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const byteSize = this.componentSizeInBytes;
        return new _math_Matrix33__WEBPACK_IMPORTED_MODULE_6__["default"](this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 4 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 5 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 6 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 7 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 8 * byteSize, endian));
    }
    getMat4(i, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const byteSize = this.componentSizeInBytes;
        return new _math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_7__["default"](this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 4 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 5 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 6 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 7 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 8 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 9 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 10 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 11 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 12 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 13 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 14 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 15 * byteSize, endian));
    }
    setScalar(i, value, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        this.__dataViewSetter(this.__byteStride * index, value, endian);
    }
    setVec2(i, x, y, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, x, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, y, endian);
    }
    setVec3(i, x, y, z, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, x, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, y, endian);
        this.__dataViewSetter(this.__byteStride * index + 2 * sizeInBytes, z, endian);
    }
    setVec4(i, x, y, z, w, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, x, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, y, endian);
        this.__dataViewSetter(this.__byteStride * index + 2 * sizeInBytes, z, endian);
        this.__dataViewSetter(this.__byteStride * index + 3 * sizeInBytes, w, endian);
    }
    setVec2AsVector(i, vec, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, vec.x, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, vec.y, endian);
    }
    setVec3AsVector(i, vec, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, vec.x, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, vec.y, endian);
        this.__dataViewSetter(this.__byteStride * index + 2 * sizeInBytes, vec.z, endian);
    }
    setVec4AsVector(i, vec, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, vec.x, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, vec.y, endian);
        this.__dataViewSetter(this.__byteStride * index + 2 * sizeInBytes, vec.z, endian);
        this.__dataViewSetter(this.__byteStride * index + 3 * sizeInBytes, vec.w, endian);
    }
    copyFromTypedArray(typedArray) {
        const componentN = this.numberOfComponents;
        const setter = this['setVec' + componentN];
        for (let j = 0; j < (typedArray.byteLength / this.componentSizeInBytes); j++) {
            const idx = Math.floor(j / componentN);
            const idxN = idx * componentN;
            switch (componentN) {
                case 1:
                    setter.call(this, idx, typedArray[idxN + 0], {});
                    break;
                case 2:
                    setter.call(this, idx, typedArray[idxN + 0], typedArray[idxN + 1], {});
                    break;
                case 3:
                    setter.call(this, idx, typedArray[idxN + 0], typedArray[idxN + 1], typedArray[idxN + 2], {});
                    break;
                case 4:
                    setter.call(this, idx, typedArray[idxN + 0], typedArray[idxN + 1], typedArray[idxN + 2], typedArray[idxN + 3], {});
                    break;
                default: throw new Error('Other than vectors are currently not supported.');
            }
        }
    }
    setScalarAt(i, compositionOffset, value, { indicesAccessor, endian = true }) {
        let index = i;
        if (indicesAccessor) {
            index = indicesAccessor.getScalar(i, {});
        }
        this.__dataViewSetter(this.__byteStride * index + compositionOffset, value, endian);
    }
    setElementFromSameCompositionAccessor(i, accessor, secondIdx) {
        const j = (secondIdx != null) ? secondIdx : i;
        if (this.compositionType.getNumberOfComponents() === 1) {
            this.setScalar(i, accessor.getScalar(j, {}), {});
        }
        else if (this.compositionType.getNumberOfComponents() === 2) {
            this.setVec2AsVector(i, accessor.getVec2(j, {}), {});
        }
        else if (this.compositionType.getNumberOfComponents() === 3) {
            this.setVec3AsVector(i, accessor.getVec3(j, {}), {});
        }
        else if (this.compositionType.getNumberOfComponents() === 4) {
            this.setVec4AsVector(i, accessor.getVec4(j, {}), {});
        }
    }
    setElementFromAccessor(i, accessor, secondIdx) {
        const j = (secondIdx != null) ? secondIdx : i;
        if (this.compositionType.getNumberOfComponents() === 1) {
            if (accessor.compositionType.getNumberOfComponents() === 1) {
                this.setScalar(i, accessor.getScalar(j, {}), {});
            }
            else if (accessor.compositionType.getNumberOfComponents() === 2) {
                this.setScalar(i, accessor.getVec2(j, {}).x, {});
            }
            else if (accessor.compositionType.getNumberOfComponents() === 3) {
                this.setScalar(i, accessor.getVec3(j, {}).x, {});
            }
            else if (accessor.compositionType.getNumberOfComponents() === 4) {
                this.setScalar(i, accessor.getVec4(j, {}).x, {});
            }
        }
        else if (this.compositionType.getNumberOfComponents() === 2) {
            if (accessor.compositionType.getNumberOfComponents() === 1) {
                const scalar = accessor.getScalar(j, {});
                this.setVec2(i, scalar, 0, {});
            }
            else if (accessor.compositionType.getNumberOfComponents() === 2) {
                this.setVec2AsVector(i, accessor.getVec2(j, {}), {});
            }
            else if (accessor.compositionType.getNumberOfComponents() === 3) {
                const vec = accessor.getVec3(j, {});
                this.setVec2(i, vec.x, vec.y, {});
            }
            else if (accessor.compositionType.getNumberOfComponents() === 4) {
                const vec = accessor.getVec4(j, {});
                this.setVec2(i, vec.x, vec.y, {});
            }
        }
        else if (this.compositionType.getNumberOfComponents() === 3) {
            if (accessor.compositionType.getNumberOfComponents() === 1) {
                const scalar = accessor.getScalar(j, {});
                this.setVec3(i, scalar, 0, 0, {});
            }
            else if (accessor.compositionType.getNumberOfComponents() === 2) {
                const vec = accessor.getVec2(j, {});
                this.setVec3(i, vec.x, vec.y, 0, {});
            }
            else if (accessor.compositionType.getNumberOfComponents() === 3) {
                const vec = accessor.getVec3(j, {});
                this.setVec3AsVector(i, vec, {});
            }
            else if (accessor.compositionType.getNumberOfComponents() === 4) {
                const vec = accessor.getVec4(j, {});
                this.setVec3(i, vec.x, vec.y, vec.z, {});
            }
        }
        else if (this.compositionType.getNumberOfComponents() === 4) {
            if (accessor.compositionType.getNumberOfComponents() === 1) {
                const scalar = accessor.getScalar(j, {});
                this.setVec4(i, scalar, 0, 0, 0, {});
            }
            else if (accessor.compositionType.getNumberOfComponents() === 2) {
                const vec = accessor.getVec2(j, {});
                this.setVec4(i, vec.x, vec.y, 0, 0, {});
            }
            else if (accessor.compositionType.getNumberOfComponents() === 3) {
                const vec = accessor.getVec3(j, {});
                this.setVec4(i, vec.x, vec.y, vec.z, 0, {});
            }
            else if (accessor.compositionType.getNumberOfComponents() === 4) {
                const vec = accessor.getVec4(j, {});
                this.setVec4AsVector(i, vec, {});
            }
        }
    }
    addElementFromSameCompositionAccessor(i, accessor, coeff, secondIdx) {
        const j = (secondIdx != null) ? secondIdx : i;
        if (this.compositionType.getNumberOfComponents() === 1) {
            this.setScalar(i, this.getScalar(i, {}) + coeff * accessor.getScalar(j, {}), {});
        }
        else if (this.compositionType.getNumberOfComponents() === 2) {
            this.setVec2AsVector(i, _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["default"].add(this.getVec2(i, {}), _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["default"].multiply(accessor.getVec2(j, {}), coeff)), {});
        }
        else if (this.compositionType.getNumberOfComponents() === 3) {
            this.setVec3AsVector(i, _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"].add(this.getVec3(i, {}), _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["default"].multiply(accessor.getVec3(j, {}), coeff)), {});
        }
        else if (this.compositionType.getNumberOfComponents() === 4) {
            this.setVec4AsVector(i, _math_Vector4__WEBPACK_IMPORTED_MODULE_5__["default"].add(this.getVec4(i, {}), _math_Vector4__WEBPACK_IMPORTED_MODULE_5__["default"].multiply(accessor.getVec4(j, {}), coeff)), {});
        }
    }
    get arrayBufferOfBufferView() {
        return this.__raw;
    }
    get dataViewOfBufferView() {
        return this.__dataView;
    }
    get byteOffsetInBufferView() {
        return this.__byteOffsetInRawArrayBufferOfBuffer - this.__bufferView.byteOffsetInRawArrayBufferOfBuffer;
    }
    get byteOffsetInBuffer() {
        return this.__byteOffsetInRawArrayBufferOfBuffer - this.__bufferView.buffer.byteOffsetInRawArrayBuffer;
    }
    get byteOffsetInRawArrayBufferOfBuffer() {
        return this.__byteOffsetInRawArrayBufferOfBuffer;
    }
    get bufferView() {
        return this.__bufferView;
    }
    get min() {
        return this.__min;
    }
    get max() {
        return this.__max;
    }
    get normalized() {
        return this.__normalized;
    }
    calcMinMax() {
        const componentN = this.compositionType.getNumberOfComponents();
        if (componentN === 4) {
            const minVec4 = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];
            const maxVec4 = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];
            for (let i = 0; i < this.elementCount; i++) {
                const vec4array = this.getVec4AsArray(i, {});
                for (let j = 0; j < 4; j++) {
                    if (vec4array[j] < minVec4[j]) {
                        minVec4[j] = vec4array[j];
                    }
                    if (maxVec4[j] < vec4array[j]) {
                        maxVec4[j] = vec4array[j];
                    }
                }
            }
            this.__min = minVec4;
            this.__max = maxVec4;
        }
        else if (componentN === 3) {
            const minVec3 = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];
            const maxVec3 = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];
            for (let i = 0; i < this.elementCount; i++) {
                const vec3array = this.getVec3AsArray(i, {});
                for (let j = 0; j < 3; j++) {
                    if (vec3array[j] < minVec3[j]) {
                        minVec3[j] = vec3array[j];
                    }
                    if (maxVec3[j] < vec3array[j]) {
                        maxVec3[j] = vec3array[j];
                    }
                }
            }
            this.__min = minVec3;
            this.__max = maxVec3;
        }
        else if (componentN === 2) {
            const minVec2 = [Number.MAX_VALUE, Number.MAX_VALUE];
            const maxVec2 = [-Number.MAX_VALUE, -Number.MAX_VALUE];
            for (let i = 0; i < this.elementCount; i++) {
                const vec2array = this.getVec2AsArray(i, {});
                for (let j = 0; j < 2; j++) {
                    if (vec2array[j] < minVec2[j]) {
                        minVec2[j] = vec2array[j];
                    }
                    if (maxVec2[j] < vec2array[j]) {
                        maxVec2[j] = vec2array[j];
                    }
                }
            }
            this.__min = minVec2;
            this.__max = maxVec2;
        }
        else if (componentN === 1) {
            let min = Number.MAX_VALUE;
            let max = -Number.MAX_VALUE;
            for (let i = 0; i < this.elementCount; i++) {
                const scalar = this.getScalar(i, {});
                if (scalar < min) {
                    min = scalar;
                }
                if (max < scalar) {
                    max = scalar;
                }
            }
            this.__min = [min];
            this.__max = [max];
        }
    }
}


/***/ }),

/***/ "./src/foundation/memory/Buffer.ts":
/*!*****************************************!*\
  !*** ./src/foundation/memory/Buffer.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Buffer; });
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _BufferView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BufferView */ "./src/foundation/memory/BufferView.ts");


class Buffer extends _core_RnObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ byteLength, buffer, name }) {
        super();
        this.__byteLength = 0;
        this.__byteOffset = 0;
        this.__name = '';
        this.__takenBytesIndex = 0;
        this.__bufferViews = [];
        this.__name = name;
        this.__byteLength = byteLength;
        if (buffer instanceof Uint8Array) {
            this.__raw = buffer.buffer;
            this.__byteOffset = buffer.byteOffset;
            this.__takenBytesIndex = buffer.byteOffset;
        }
        else {
            this.__raw = buffer;
        }
    }
    set name(str) {
        this.__name = str;
    }
    get name() {
        return this.__name;
    }
    getArrayBuffer() {
        return this.__raw;
    }
    takeBufferView({ byteLengthToNeed, byteStride, isAoS, byteAlign = 4 }) {
        if (byteLengthToNeed % byteAlign !== 0) {
            console.info(`Padding bytes added because byteLengthToNeed must be a multiple of ${byteAlign}.`);
            byteLengthToNeed += byteAlign - (byteLengthToNeed % byteAlign);
        }
        // if (byteStride % 4 !== 0) {
        //   console.info('Padding bytes added, byteStride must be a multiple of 4.');
        //   byteStride += 4 - (byteStride % 4);
        // }
        const bufferView = new _BufferView__WEBPACK_IMPORTED_MODULE_1__["default"]({ buffer: this, byteOffset: this.__takenBytesIndex, byteLength: byteLengthToNeed, raw: this.__raw, isAoS: isAoS });
        bufferView.byteStride = byteStride;
        this.__takenBytesIndex += Uint8Array.BYTES_PER_ELEMENT * byteLengthToNeed;
        this.__bufferViews.push(bufferView);
        return bufferView;
    }
    takeBufferViewWithByteOffset({ byteLengthToNeed, byteStride, byteOffset, isAoS }) {
        // if (byteLengthToNeed % 4 !== 0) {
        //   console.info('Padding bytes added because byteLengthToNeed must be a multiple of 4.');
        //   byteLengthToNeed += 4 - (byteLengthToNeed % 4);
        // }
        // if (byteStride % 4 !== 0) {
        //   console.info('Padding bytes added, byteStride must be a multiple of 4.');
        //   byteStride += 4 - (byteStride % 4);
        // }
        const bufferView = new _BufferView__WEBPACK_IMPORTED_MODULE_1__["default"]({ buffer: this, byteOffset: byteOffset + this.__byteOffset, byteLength: byteLengthToNeed, raw: this.__raw, isAoS: isAoS });
        const takenBytesIndex = Uint8Array.BYTES_PER_ELEMENT * byteLengthToNeed + byteOffset + this.__byteOffset;
        if (this.__takenBytesIndex < takenBytesIndex) {
            this.__takenBytesIndex = takenBytesIndex;
        }
        bufferView.byteStride = byteStride;
        this.__bufferViews.push(bufferView);
        return bufferView;
    }
    _addTakenByteIndex(value) {
        this.__takenBytesIndex += value;
    }
    get byteLength() {
        return this.__byteLength;
    }
    get takenSizeInByte() {
        return this.__takenBytesIndex;
    }
    get byteOffsetInRawArrayBuffer() {
        return this.__byteOffset;
    }
}


/***/ }),

/***/ "./src/foundation/memory/BufferView.ts":
/*!*********************************************!*\
  !*** ./src/foundation/memory/BufferView.ts ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BufferView; });
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _Accessor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Accessor */ "./src/foundation/memory/Accessor.ts");
/* harmony import */ var _FlexibleAccessor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FlexibleAccessor */ "./src/foundation/memory/FlexibleAccessor.ts");



class BufferView extends _core_RnObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ buffer, byteOffset, byteLength, raw, isAoS }) {
        super();
        this.__byteStride = 0;
        this.__takenByteIndex = 0;
        this.__accessors = [];
        this.__buffer = buffer;
        this.__byteOffsetInRawArrayBufferOfBuffer = byteOffset;
        this.__byteLength = byteLength;
        this.__raw = raw;
        this.__isAoS = isAoS;
    }
    set byteStride(stride) {
        this.__byteStride = stride;
    }
    get byteStride() {
        return this.__byteStride;
    }
    get byteLength() {
        return this.__byteLength;
    }
    /**
     * byteOffset in Buffer (includes byteOffset of Buffer in it's inner arraybuffer)
     */
    get byteOffsetInBuffer() {
        return this.__byteOffsetInRawArrayBufferOfBuffer - this.__buffer.byteOffsetInRawArrayBuffer;
    }
    /**
     * byteOffset in Buffer (includes byteOffset of Buffer in it's inner arraybuffer)
     */
    get byteOffsetInRawArrayBufferOfBuffer() {
        return this.__byteOffsetInRawArrayBufferOfBuffer;
    }
    get buffer() {
        return this.__buffer;
    }
    get isSoA() {
        return !this.__isAoS;
    }
    recheckIsSoA() {
        if (this.__accessors.length <= 1) {
            return true;
        }
        let firstStrideBytes = this.__accessors[0].byteStride;
        let secondStrideBytes = this.__accessors[1].byteStride;
        let firstElementSizeInBytes = this.__accessors[0].elementSizeInBytes;
        let secondElementSizeInBytes = this.__accessors[1].elementSizeInBytes;
        if (firstStrideBytes === secondStrideBytes &&
            (firstElementSizeInBytes + secondElementSizeInBytes) < firstElementSizeInBytes) {
            return true;
        }
        else {
            return false;
        }
    }
    get isAoS() {
        return this.__isAoS;
    }
    getUint8Array() {
        return new Uint8Array(this.__raw, this.__byteOffsetInRawArrayBufferOfBuffer, this.__byteLength);
    }
    takeAccessor({ compositionType, componentType, count, max, min, byteAlign = 4, arrayLength, normalized = false }) {
        const byteStride = this.byteStride;
        const _arrayLength = (arrayLength != null) ? arrayLength : 1;
        const accessor = this.__takeAccessorInner({
            compositionType, componentType, count, byteStride, accessorClass: _Accessor__WEBPACK_IMPORTED_MODULE_1__["default"],
            max, min, byteAlign, arrayLength: _arrayLength, normalized
        });
        return accessor;
    }
    takeFlexibleAccessor({ compositionType, componentType, count, byteStride, max, min, byteAlign = 4, arrayLength, normalized = false }) {
        const _arrayLength = (arrayLength != null) ? arrayLength : 1;
        const accessor = this.__takeAccessorInner({
            compositionType, componentType, count, byteStride, accessorClass: _FlexibleAccessor__WEBPACK_IMPORTED_MODULE_2__["default"],
            max, min, byteAlign, arrayLength: _arrayLength, normalized
        });
        return accessor;
    }
    takeAccessorWithByteOffset({ compositionType, componentType, count, byteOffset, max, min, normalized = false }) {
        const byteStride = this.byteStride;
        const accessor = this.__takeAccessorInnerWithByteOffset({
            compositionType, componentType, count, byteStride, byteOffset, accessorClass: _Accessor__WEBPACK_IMPORTED_MODULE_1__["default"], max, min, normalized
        });
        return accessor;
    }
    takeFlexibleAccessorWithByteOffset({ compositionType, componentType, count, byteStride, byteOffset, max, min, normalized = false }) {
        const accessor = this.__takeAccessorInnerWithByteOffset({
            compositionType, componentType, count, byteStride, byteOffset, accessorClass: _FlexibleAccessor__WEBPACK_IMPORTED_MODULE_2__["default"], max, min, normalized
        });
        return accessor;
    }
    __takeAccessorInner({ compositionType, componentType, count, byteStride, accessorClass, max, min, byteAlign, arrayLength, normalized }) {
        let byteOffset = 0;
        if (this.isSoA) {
            byteOffset = this.__takenByteIndex;
            if (byteStride === 0) {
                this.__takenByteIndex += compositionType.getNumberOfComponents() * componentType.getSizeInBytes() * arrayLength * count;
            }
            else {
                this.__takenByteIndex += byteStride * count;
            }
        }
        else {
            byteOffset = this.__takenByteIndex;
            // if (byteStride === 0) {
            this.__takenByteIndex += compositionType.getNumberOfComponents() * componentType.getSizeInBytes() * arrayLength;
            // } else {
            //   this.__takenByteIndex += byteStride;
            // }
        }
        if (byteOffset % byteAlign !== 0) {
            console.info(`Padding bytes added because byteOffset is not ${byteAlign}byte aligned.`);
            const paddingBytes = byteAlign - byteOffset % byteAlign;
            byteOffset += paddingBytes;
            this.__takenByteIndex += paddingBytes;
        }
        // if (this.__byteOffset % byteAlign !== 0) {
        //   console.info(`Padding bytes added because byteOffsetFromBuffer is not ${byteAlign}byte aligned.`);
        //   const paddingBytes = byteAlign - this.__byteOffset % byteAlign;
        //   // this.__byteOffset += paddingBytes;
        //   this.__takenByteIndex += paddingBytes;
        //   // this.buffer._addTakenByteIndex(paddingBytes);
        // }
        const accessor = new accessorClass({
            bufferView: this, byteOffset, compositionType, componentType, byteStride,
            count, raw: this.__raw, max, min, arrayLength, normalized
        });
        this.__accessors.push(accessor);
        return accessor;
    }
    __takeAccessorInnerWithByteOffset({ compositionType, componentType, count, byteStride, byteOffset, accessorClass, max, min, normalized }) {
        // if (byteOffset % 4 !== 0) {
        //   console.info('Padding bytes added because byteOffset is not 4byte aligned.');
        //   byteOffset += 4 - byteOffset % 4;
        // }
        // if (this.__byteOffset % 4 !== 0) {
        //   console.info('Padding bytes added because byteOffsetFromBuffer is not 4byte aligned.');
        //   this.__byteOffset += 4 - this.__byteOffset % 4;
        // this.buffer._addTakenByteIndex(4 - this.__byteOffset % 4);
        // }
        const accessor = new accessorClass({
            bufferView: this, byteOffset, compositionType, componentType, byteStride,
            count, raw: this.__raw, max, min, arrayLength: 1, normalized
        });
        this.__accessors.push(accessor);
        return accessor;
    }
}


/***/ }),

/***/ "./src/foundation/memory/FlexibleAccessor.ts":
/*!***************************************************!*\
  !*** ./src/foundation/memory/FlexibleAccessor.ts ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FlexibleAccessor; });
/* harmony import */ var _AccessorBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AccessorBase */ "./src/foundation/memory/AccessorBase.ts");

class FlexibleAccessor extends _AccessorBase__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ bufferView, byteOffset, compositionType, componentType, byteStride, count, raw, max, min, arrayLength, normalized }) {
        super({ bufferView, byteOffset, compositionType, componentType, byteStride, count, raw, max, min, arrayLength, normalized });
    }
}


/***/ }),

/***/ "./src/foundation/misc/DataUtil.ts":
/*!*****************************************!*\
  !*** ./src/foundation/misc/DataUtil.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DataUtil; });
class DataUtil {
    static isNode() {
        let isNode = (window === void 0 && typeof process !== "undefined" && "function" !== "undefined");
        return isNode;
    }
    static btoa(str) {
        let isNode = DataUtil.isNode();
        if (isNode) {
            let buffer;
            if (Buffer.isBuffer(str)) {
                buffer = str;
            }
            else {
                buffer = new Buffer(str.toString(), 'binary');
            }
            return buffer.toString('base64');
        }
        else {
            return btoa(str);
        }
    }
    static atob(str) {
        let isNode = DataUtil.isNode();
        if (isNode) {
            return new Buffer(str, 'base64').toString('binary');
        }
        else {
            return atob(str);
        }
    }
    static dataUriToArrayBuffer(dataUri) {
        let splittedDataUri = dataUri.split(',');
        // let type = splittedDataUri[0].split(':')[1].split(';')[0];
        let byteString = DataUtil.atob(splittedDataUri[1]);
        let byteStringLength = byteString.length;
        let arrayBuffer = new ArrayBuffer(byteStringLength);
        let uint8Array = new Uint8Array(arrayBuffer);
        for (let i = 0; i < byteStringLength; i++) {
            uint8Array[i] = byteString.charCodeAt(i);
        }
        return arrayBuffer;
    }
    static arrayBufferToString(arrayBuffer) {
        if (typeof TextDecoder !== 'undefined') {
            const textDecoder = new TextDecoder();
            return textDecoder.decode(arrayBuffer);
        }
        else {
            const bytes = new Uint8Array(arrayBuffer);
            const result = this.uint8ArrayToStringInner(bytes);
            return result;
        }
    }
    static uint8ArrayToString(uint8Array) {
        if (typeof TextDecoder !== 'undefined') {
            const textDecoder = new TextDecoder();
            return textDecoder.decode(uint8Array);
        }
        else {
            const result = this.uint8ArrayToStringInner(uint8Array);
            return result;
        }
    }
    static stringToBase64(str) {
        let b64 = null;
        b64 = DataUtil.btoa(str);
        return b64;
    }
    static base64ToArrayBuffer(base64) {
        var binary_string = window.atob(base64);
        var len = binary_string.length;
        var bytes = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes.buffer;
    }
    static UInt8ArrayToDataURL(uint8array, width, height) {
        let canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        let ctx = canvas.getContext("2d");
        let imageData = ctx.createImageData(width, height);
        for (let i = 0; i < imageData.data.length; i += 4) {
            imageData.data[i + 0] = uint8array[(height - Math.floor(i / (4 * width))) * (4 * width) + i % (4 * width) + 0];
            imageData.data[i + 1] = uint8array[(height - Math.floor(i / (4 * width))) * (4 * width) + i % (4 * width) + 1];
            imageData.data[i + 2] = uint8array[(height - Math.floor(i / (4 * width))) * (4 * width) + i % (4 * width) + 2];
            imageData.data[i + 3] = uint8array[(height - Math.floor(i / (4 * width))) * (4 * width) + i % (4 * width) + 3];
        }
        ctx.putImageData(imageData, 0, 0);
        canvas.remove();
        return canvas.toDataURL("image/png");
    }
    static loadResourceAsync(resourceUri, isBinary, resolveCallback, rejectCallback) {
        return new Promise((resolve, reject) => {
            let isNode = DataUtil.isNode();
            if (isNode) {
                // let fs = require('fs');
                // let args: any[] = [resourceUri];
                // let func: Function = (err:any, response: any) => {
                //   if (err) {
                //     if (rejectCallback) {
                //       rejectCallback(reject, err);
                //     }
                //     return;
                //   }
                //   if (isBinary) {
                //     let buffer = new Buffer(response, 'binary');
                //     let uint8Buffer = new Uint8Array(buffer);
                //     response = uint8Buffer.buffer;
                //   }
                //   resolveCallback(resolve, response);
                // };
                // if (isBinary) {
                //   args.push(func);
                // } else {
                //   args.push('utf8');
                //   args.push(func);
                // }
                // fs.readFile.apply(fs, args);
            }
            else {
                let xmlHttp = new XMLHttpRequest();
                if (isBinary) {
                    xmlHttp.onload = (oEvent) => {
                        let response = null;
                        if (isBinary) {
                            response = xmlHttp.response;
                        }
                        else {
                            response = xmlHttp.responseText;
                        }
                        resolveCallback(resolve, response);
                    };
                    xmlHttp.open("GET", resourceUri, true);
                    xmlHttp.responseType = "arraybuffer";
                }
                else {
                    xmlHttp.onreadystatechange = () => {
                        if (xmlHttp.readyState === 4 && (Math.floor(xmlHttp.status / 100) === 2 || xmlHttp.status === 0)) {
                            let response = null;
                            if (isBinary) {
                                response = xmlHttp.response;
                            }
                            else {
                                response = xmlHttp.responseText;
                            }
                            resolveCallback(resolve, response);
                        }
                        else {
                            if (rejectCallback) {
                                rejectCallback(reject, xmlHttp.status);
                            }
                        }
                    };
                    xmlHttp.open("GET", resourceUri, true);
                }
                xmlHttp.send(null);
            }
        });
    }
    static toCRC32(str) {
        var crc = 0, x = 0, y = 0;
        var table = DataUtil.crc32table;
        crc = crc ^ (-1);
        for (var i = 0, iTop = str.length; i < iTop; ++i) {
            y = (crc ^ str.charCodeAt(i)) & 0xff;
            x = "0x" + table[y];
            crc = (crc >>> 8) ^ x;
        }
        return (crc ^ (-1)) >>> 0;
    }
    static accessBinaryAsImage(bufferViewIndex, json, buffer, mimeType) {
        const uint8BufferView = this.takeBufferViewAsUint8Array(json, bufferViewIndex, buffer);
        return this.accessArrayBufferAsImage(uint8BufferView, mimeType);
    }
    static createBlobImageUriFromUint8Array(uint8Array, mimeType) {
        const blob = new Blob([uint8Array], { type: mimeType });
        const imageUrl = URL.createObjectURL(blob);
        return imageUrl;
    }
    static takeBufferViewAsUint8Array(json, bufferViewIndex, buffer) {
        const bufferViewJson = json.bufferViews[bufferViewIndex];
        let byteOffset = (bufferViewJson.byteOffset != null) ? bufferViewJson.byteOffset : 0;
        const byteLength = bufferViewJson.byteLength;
        let arrayBuffer = buffer;
        if (buffer instanceof Uint8Array) {
            arrayBuffer = buffer.buffer;
            byteOffset += buffer.byteOffset;
        }
        const uint8BufferView = new Uint8Array(arrayBuffer, byteOffset, byteLength);
        return uint8BufferView;
    }
    static accessArrayBufferAsImage(arrayBuffer, imageType) {
        const binaryData = this.uint8ArrayToStringInner(new Uint8Array(arrayBuffer));
        const imgSrc = this.getImageType(imageType);
        const dataUrl = imgSrc + DataUtil.btoa(binaryData);
        return dataUrl;
    }
    static uint8ArrayToStringInner(uint8) {
        const charCodeArray = new Array(uint8.byteLength);
        for (let i = 0; i < uint8.byteLength; i++) {
            charCodeArray[i] = uint8[i];
        }
        // the argument of String.fromCharCode has the limit of array length
        const constant = 1024;
        const divisionNumber = Math.ceil(charCodeArray.length / constant);
        let binaryData = '';
        for (let i = 0; i < divisionNumber; i++) {
            binaryData += String.fromCharCode.apply(this, charCodeArray.slice(i * constant, (i + 1) * constant));
        }
        return binaryData;
    }
    static getImageType(imageType) {
        let imgSrc = null;
        if (imageType === 'image/jpeg' || imageType.toLowerCase() === 'jpg' || imageType.toLowerCase() === 'jpeg') {
            imgSrc = "data:image/jpeg;base64,";
        }
        else if (imageType == 'image/png' || imageType.toLowerCase() === 'png') {
            imgSrc = "data:image/png;base64,";
        }
        else if (imageType == 'image/gif' || imageType.toLowerCase() === 'gif') {
            imgSrc = "data:image/gif;base64,";
        }
        else if (imageType == 'image/bmp' || imageType.toLowerCase() === 'bmp') {
            imgSrc = "data:image/bmp;base64,";
        }
        else {
            imgSrc = "data:image/unknown;base64,";
        }
        return imgSrc;
    }
    static getMimeTypeFromExtension(extension) {
        let imgSrc = null;
        if (extension.toLowerCase() === 'jpg' || extension.toLowerCase() === 'jpeg') {
            imgSrc = "image/jpeg";
        }
        else if (extension.toLowerCase() === 'png') {
            imgSrc = "image/png";
        }
        else if (extension.toLowerCase() === 'gif') {
            imgSrc = "image/gif";
        }
        else if (extension.toLowerCase() === 'bmp') {
            imgSrc = "image/bmp";
        }
        else {
            imgSrc = "image/unknown";
        }
        return imgSrc;
    }
    static getExtension(fileName) {
        const splitted = fileName.split('.');
        const fileExtension = splitted[splitted.length - 1];
        return fileExtension;
    }
    static createUint8ArrayFromBufferViewInfo(json, bufferViewIndex, buffer) {
        const bufferViewJson = json.bufferViews[bufferViewIndex];
        let byteOffset = (bufferViewJson.byteOffset != null) ? bufferViewJson.byteOffset : 0;
        const byteLength = bufferViewJson.byteLength;
        let arrayBuffer = buffer;
        if (buffer instanceof Uint8Array) {
            arrayBuffer = buffer.buffer;
            byteOffset += buffer.byteOffset;
        }
        const uint8BufferView = new Uint8Array(arrayBuffer, byteOffset, byteLength);
        return uint8BufferView;
    }
    static createImageFromUri(uri, mimeType) {
        return new Promise(function (resolve) {
            const img = new Image();
            img.crossOrigin = 'Anonymous';
            if (uri.match(/^blob:/) || uri.match(/^data:/)) {
                img.onload = () => {
                    resolve(img);
                };
                img.src = uri;
            }
            else {
                const load = (img, response) => {
                    const bytes = new Uint8Array(response);
                    const imageUri = DataUtil.createBlobImageUriFromUint8Array(bytes, mimeType);
                    img.onload = () => {
                        resolve(img);
                    };
                    img.src = imageUri;
                };
                const loadBinaryImage = () => {
                    var xhr = new XMLHttpRequest();
                    xhr.onreadystatechange = (function (_img) {
                        return function () {
                            if (xhr.readyState == 4 && xhr.status == 200) {
                                load(_img, xhr.response);
                            }
                        };
                    })(img);
                    xhr.open('GET', uri);
                    xhr.responseType = 'arraybuffer';
                    xhr.send();
                };
                loadBinaryImage();
            }
        });
    }
    static createDefaultGltfOptions() {
        const defaultOptions = {
            files: {
            //        "foo.gltf": content of file as ArrayBuffer,
            //        "foo.bin": content of file as ArrayBuffer,
            //        "boo.png": content of file as ArrayBuffer
            },
            loaderExtension: undefined,
            defaultMaterialHelperName: undefined,
            defaultMaterialHelperArgumentArray: [],
            statesOfElements: [
                {
                    targets: [],
                    states: {
                        enable: [
                        // 3042,  // BLEND
                        ],
                        functions: {
                        //"blendFuncSeparate": [1, 0, 1, 0],
                        }
                    },
                    isTransparent: true,
                    opacity: 1.0,
                    isTextureImageToLoadPreMultipliedAlpha: false,
                }
            ],
            tangentCalculationMode: 1,
            isPreComputeForRayCastPickingEnable: false,
            extendedJson: void 0 //   URI string / JSON Object / ArrayBuffer
        };
        return defaultOptions;
    }
    static fetchArrayBuffer(uri) {
        return new Promise((resolve) => {
            fetch(uri).then((response) => {
                response.arrayBuffer().then((arrayBuffer) => {
                    resolve(arrayBuffer);
                });
            }).catch((err) => {
                throw new Error('import error: ' + err);
            });
        });
    }
}
DataUtil.crc32table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D".split(' ');

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/foundation/misc/EnumIO.ts":
/*!***************************************!*\
  !*** ./src/foundation/misc/EnumIO.ts ***!
  \***************************************/
/*! exports provided: EnumClass, _from, _fromString, _fromStringCaseSensitively */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnumClass", function() { return EnumClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_from", function() { return _from; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_fromString", function() { return _fromString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_fromStringCaseSensitively", function() { return _fromStringCaseSensitively; });
// This code idea is from https://qiita.com/junkjunctions/items/5a6d8bed8df8eb3acceb
class EnumClass {
    constructor({ index, str, noCheckStrUnique }) {
        if (EnumClass.__indices.get(this.constructor) == null) {
            EnumClass.__indices.set(this.constructor, []);
        }
        if (EnumClass.__strings.get(this.constructor) == null) {
            EnumClass.__strings.set(this.constructor, []);
        }
        if (EnumClass.__indices.get(this.constructor).indexOf(index) !== -1) {
            throw new Error('Dont use duplicate index.');
        }
        if (noCheckStrUnique !== true) {
            if (EnumClass.__strings.get(this.constructor).indexOf(str) !== -1) {
                throw new Error('Dont use duplicate str.');
            }
        }
        this.index = index;
        this.str = str;
        EnumClass.__indices.get(this.constructor).push(index);
        EnumClass.__strings.get(this.constructor).push(str);
    }
    toString() {
        return this.str;
    }
    toJSON() {
        return this.index;
    }
}
EnumClass.__indices = new Map();
EnumClass.__strings = new Map();
function _from({ typeList, index }) {
    const match = typeList.find(type => type.index === index);
    if (!match) {
        return void 0;
    }
    return match;
}
function _fromString({ typeList, str }) {
    const match = typeList.find(type => type.str.toLowerCase() === str.toLowerCase());
    if (!match) {
        return void 0;
    }
    return match;
}
function _fromStringCaseSensitively({ typeList, str }) {
    const match = typeList.find(type => type.str === str);
    if (!match) {
        return void 0;
    }
    return match;
}


/***/ }),

/***/ "./src/foundation/misc/IsUtil.ts":
/*!***************************************!*\
  !*** ./src/foundation/misc/IsUtil.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const IsUtil = {
    not: {},
    all: {},
    any: {},
    _not(fn) {
        return function () {
            return !fn.apply(null, [...arguments]);
        };
    },
    _all(fn) {
        return function () {
            if (Array.isArray(arguments[0])) {
                return arguments[0].every(fn);
            }
            return [...arguments].every(fn);
        };
    },
    _any(fn) {
        return function () {
            if (Array.isArray(arguments[0])) {
                return arguments[0].some(fn);
            }
            return [...arguments].some(fn);
        };
    },
    defined(val) {
        return val !== void 0;
    },
    undefined(val) {
        return val === void 0;
    },
    null(val) {
        return val === null;
    },
    // is NOT null or undefined
    exist(val) {
        return val != null;
    },
    function(val) {
        return typeof val === 'function';
    }
};
for (let fn in IsUtil) {
    if (IsUtil.hasOwnProperty(fn)) {
        const interfaces = ['not', 'all', 'any'];
        if (fn.indexOf('_') === -1 && !interfaces.includes(fn)) {
            interfaces.forEach((itf) => {
                const op = '_' + itf;
                IsUtil[itf][fn] = IsUtil[op](IsUtil[fn]);
            });
        }
    }
}
/* harmony default export */ __webpack_exports__["default"] = (IsUtil);


/***/ }),

/***/ "./src/foundation/misc/MiscUtil.ts":
/*!*****************************************!*\
  !*** ./src/foundation/misc/MiscUtil.ts ***!
  \*****************************************/
/*! exports provided: MiscUtil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MiscUtil", function() { return MiscUtil; });
const isMobile = function () {
    const ua = [
        'iPod',
        'iPad',
        'iPhone',
        'Android'
    ];
    for (var i = 0; i < ua.length; i++) {
        if (navigator.userAgent.indexOf(ua[i]) > 0) {
            return true;
        }
    }
    return isIPad();
};
const isIOS = function () {
    const ua = [
        'iPod',
        'iPad',
        'iPhone'
    ];
    for (var i = 0; i < ua.length; i++) {
        if (navigator.userAgent.indexOf(ua[i]) > 0) {
            return true;
        }
    }
    return isIPad();
};
const isIPad = function () {
    return navigator.userAgent.indexOf('Macintosh') > -1 && 'ontouchend' in document;
};
const preventDefaultForDesktopOnly = function (e) {
    if (!isMobile()) {
        e.preventDefault();
    }
};
const isObject = function (o) {
    return (o instanceof Object && !(o instanceof Array)) ? true : false;
};
// https://stackoverflow.com/questions/30003353/can-es6-template-literals-be-substituted-at-runtime-or-reused
const fillTemplate = function (templateString, templateVars) {
    return new Function("return `" + templateString + "`;").call(templateVars);
};
const isNode = function () {
    return (typeof process !== "undefined" && "function" !== "undefined");
};
const concatArrayBuffers = function (segments, sizes, paddingSize) {
    var sumLength = 0;
    for (var i = 0; i < sizes.length; ++i) {
        sumLength += sizes[i];
    }
    var whole = new Uint8Array(sumLength + paddingSize);
    var pos = 0;
    for (var i = 0; i < segments.length; ++i) {
        whole.set(new Uint8Array(segments[i], 0, sizes[i]), pos);
        pos += sizes[i];
    }
    return whole.buffer;
};
const MiscUtil = Object.freeze({ isMobile, isIOS, preventDefaultForDesktopOnly, isObject, fillTemplate, isNode, concatArrayBuffers });

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./src/foundation/misc/RnPromise.ts":
/*!******************************************!*\
  !*** ./src/foundation/misc/RnPromise.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RnPromise; });
class RnPromise {
    constructor(arg, callback) {
        this.name = '';
        this.__callbackObj = {
            promiseAllNum: 0,
            resolvedNum: 0,
            rejectedNum: 0,
            pendingNum: 0,
            processedPromises: []
        };
        if (arg instanceof Promise) {
            this.__promise = arg;
        }
        else {
            this.__promise = new Promise(arg);
        }
        this.__callback = callback;
    }
    static resolve(arg) {
        if (arg instanceof Promise) {
            return new RnPromise(arg);
        }
        else if (arg instanceof RnPromise) {
            return arg;
        }
        else if (arg.then != null) {
            const rnPromise = new RnPromise((resolve, reject) => {
                resolve(arg);
            });
            rnPromise.then = arg.then;
            return rnPromise;
        }
        else {
            return new RnPromise((resolve, reject) => {
                resolve(arg);
            });
        }
    }
    static all(args) {
        return new RnPromise(Promise.all(args));
    }
    static allWithProgressCallback(promises, callback) {
        const rnPromises = [];
        const callbackObj = {
            promiseAllNum: promises.length,
            resolvedNum: 0,
            rejectedNum: 0,
            pendingNum: promises.length,
            processedPromises: []
        };
        for (let promise of promises) {
            const rnPromise = RnPromise.resolve(promise);
            rnPromise.__callback = callback;
            rnPromise.__callbackObj = callbackObj;
            rnPromises.push(rnPromise);
        }
        return new RnPromise(Promise.all(promises));
    }
    static race(args) {
        return new RnPromise(Promise.race(args));
    }
    then(onFulfilled, onRejected) {
        const onFulfilledWrapper = (value) => {
            if (this.__callbackObj.promiseAllNum !== 0 && this.__callbackObj.processedPromises.indexOf(this) === -1) {
                this.__callbackObj.pendingNum--;
                this.__callbackObj.resolvedNum++;
                this.__callbackObj.processedPromises.push(this);
            }
            if (this.__callback) {
                this.__callback(this.__callbackObj);
            }
            if (onFulfilled) {
                onFulfilled(value);
            }
        };
        return new RnPromise(this.__promise.then(onFulfilledWrapper, onRejected));
    }
    catch(onRejected) {
        return new RnPromise(this.__promise.catch(onRejected));
    }
    finally(onFinally) {
        this.__promise.finally(onFinally);
    }
    static reject(e) {
        return new RnPromise(Promise.reject(e));
    }
}


/***/ }),

/***/ "./src/foundation/misc/Time.ts":
/*!*************************************!*\
  !*** ./src/foundation/misc/Time.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Time; });
class Time {
    /**
     * @private
     */
    static _processBegin() {
        if (Time.__currentProcessBeginTime === 0) {
            Time.__systemStartTime = performance.now();
        }
        Time.__currentProcessBeginTime = performance.now();
    }
    /**
     * @private
     */
    static _processEnd() {
        Time.__lastProcessEndTime = performance.now();
        Time.__lastTickTimeInterval = Time.__lastProcessEndTime - Time.__currentProcessBeginTime;
    }
    static get timeFromSystemStart() {
        return (Time.__systemStartTime - performance.now() / 1000);
    }
    static get lastTickTimeInterval() {
        return (Time.__lastTickTimeInterval / 1000);
    }
}
Time.__currentProcessBeginTime = 0;
Time.__lastProcessEndTime = 0;
Time.__lastTickTimeInterval = 0;
Time.__systemStartTime = 0;


/***/ }),

/***/ "./src/foundation/physics/SphereCollider.ts":
/*!**************************************************!*\
  !*** ./src/foundation/physics/SphereCollider.ts ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SphereCollider; });
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");

class SphereCollider {
    constructor() {
        this.position = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].zero();
        this.radius = 0;
    }
}


/***/ }),

/***/ "./src/foundation/physics/VRMColliderGroup.ts":
/*!****************************************************!*\
  !*** ./src/foundation/physics/VRMColliderGroup.ts ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VRMColliderGroup; });
class VRMColliderGroup {
    constructor() {
        this.colliders = [];
    }
}


/***/ }),

/***/ "./src/foundation/physics/VRMSpringBoneGroup.ts":
/*!******************************************************!*\
  !*** ./src/foundation/physics/VRMSpringBoneGroup.ts ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VRMSpringBoneGroup; });
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/RnObject */ "./src/foundation/core/RnObject.ts");


class VRMSpringBoneGroup extends _core_RnObject__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super();
        this.stiffnessForce = 0.5;
        this.gravityPower = 0;
        this.gravityDir = new _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](0, -1.0, 0);
        this.dragForce = 0.05;
        this.hitRadius = 0.02;
        this.rootBones = [];
        this.colliderGroupIndices = [];
    }
}


/***/ }),

/***/ "./src/foundation/physics/VRMSpringBonePhysicsStrategy.ts":
/*!****************************************************************!*\
  !*** ./src/foundation/physics/VRMSpringBonePhysicsStrategy.ts ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VRMSpringBonePhysicsStrategy; });
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");
/* harmony import */ var _math_Quaternion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Quaternion */ "./src/foundation/math/Quaternion.ts");
/* harmony import */ var _math_Matrix44__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _misc_Time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../misc/Time */ "./src/foundation/misc/Time.ts");
/* harmony import */ var _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/MutableQuaternion */ "./src/foundation/math/MutableQuaternion.ts");






class VRMSpringBonePhysicsStrategy {
    constructor() {
        this.__boneAxis = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].zero();
        this.__length = 0;
        this.__currentTail = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].zero();
        this.__prevTail = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].zero();
        this.__localDir = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].zero();
        this.__localRotation = new _math_Quaternion__WEBPACK_IMPORTED_MODULE_2__["default"](0, 0, 0, 1);
        this.__initalized = false;
        this.__localChildPosition = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].zero();
    }
    initialize(transform, localChildPosition, center) {
        this.__transform = transform;
        const worldChildPosition = transform.getWorldPositionOf(localChildPosition);
        this.__currentTail = (center != null) ? center.getLocalPositionOf(worldChildPosition) : worldChildPosition;
        this.__prevTail = this.__currentTail;
        this.__localRotation = transform.entity.getTransform().quaternion;
        this.__boneAxis = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].normalize(localChildPosition);
        // this.__boneAxis = Vector3.normalize(Vector3.subtract(this.__currentTail, transform.worldPosition));
        this.__length = localChildPosition.length();
        this.__localChildPosition = localChildPosition;
        this.__initalized = true;
    }
    get isInitialized() {
        return this.__initalized;
    }
    get head() {
        return this.__transform;
    }
    get tail() {
        _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].multiplyTo(this.__boneAxis, this.__length, VRMSpringBonePhysicsStrategy.__tmp_vec3);
        this.__transform.worldMatrixInner.multiplyVector3To(VRMSpringBonePhysicsStrategy.__tmp_vec3, VRMSpringBonePhysicsStrategy.__tmp_vec3_2);
        return VRMSpringBonePhysicsStrategy.__tmp_vec3_2;
    }
    get parentRotation() {
        // return (this.__transform!.parent != null) ? this.__transform!.parent!.entity.getTransform().quaternion : new Quaternion(0, 0, 0, 1);
        return (this.__transform.parent != null) ? _math_Quaternion__WEBPACK_IMPORTED_MODULE_2__["default"].fromMatrix(this.__transform.parent.worldMatrixInner) : new _math_Quaternion__WEBPACK_IMPORTED_MODULE_2__["default"](0, 0, 0, 1);
    }
    static update() {
        for (let boneGroup of this.__boneGroups) {
            this.updateInner(boneGroup.rootBones, boneGroup);
        }
    }
    static updateInner(sceneGraphs, boneGroup) {
        const dragForce = boneGroup.dragForce;
        const stiffnessForce = boneGroup.stiffnessForce * _misc_Time__WEBPACK_IMPORTED_MODULE_4__["default"].lastTickTimeInterval * 1;
        const external = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].multiply(boneGroup.gravityDir, boneGroup.gravityPower * _misc_Time__WEBPACK_IMPORTED_MODULE_4__["default"].lastTickTimeInterval * 1);
        let center = void 0;
        const collisionGroups = VRMSpringBonePhysicsStrategy.getColliderGroups(boneGroup.colliderGroupIndices);
        for (let sg of sceneGraphs) {
            const physicsComponent = sg.entity.getPhysics();
            if (physicsComponent) {
                const strategy = physicsComponent.strategy;
                strategy.update(stiffnessForce, dragForce, external, collisionGroups, boneGroup.hitRadius, center);
                const children = sg.children;
                if (children) {
                    this.updateInner(children, boneGroup);
                }
            }
        }
    }
    static initialize(sceneGraph) {
        const children = sceneGraph.children;
        const physicsComponent = sceneGraph.entity.getPhysics();
        const vrmSpringBone = physicsComponent.strategy;
        if (children.length > 0) {
            const transform = children[0].entity.getTransform();
            vrmSpringBone.initialize(sceneGraph, 
            //   new Vector3(
            //   transform.translate.x * transform.scale.x,
            //   transform.translate.y * transform.scale.y,
            //   transform.translate.z * transform.scale.z
            // ),
            _math_Matrix44__WEBPACK_IMPORTED_MODULE_3__["default"].invert(sceneGraph.worldMatrixInner).multiplyVector3(children[0].worldPosition), void 0);
        }
        else {
            const delta = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].subtract(sceneGraph.worldPosition, sceneGraph.parent.worldPosition);
            let childPosition = new _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](1, 1, 1);
            if (delta.lengthSquared() > 0) {
                childPosition = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].add(sceneGraph.worldPosition, _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].multiply(_math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].normalize(delta), 0.07));
            }
            vrmSpringBone.initialize(sceneGraph, _math_Matrix44__WEBPACK_IMPORTED_MODULE_3__["default"].invert(sceneGraph.worldMatrixInner).multiplyVector3(childPosition), void 0);
        }
    }
    calcParentDeltaRecursivle(sceneGraph) {
        const delta = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].subtract(sceneGraph.worldPosition, sceneGraph.parent.worldPosition);
    }
    update(stiffnessForce, dragForce, external, collisionGroups, boneHitRadius, center) {
        const currentTail = (center != null) ? center.getWorldPositionOf(this.__currentTail) : this.__currentTail;
        const prevTail = (center != null) ? center.getWorldPositionOf(this.__prevTail) : this.__prevTail;
        const delta = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].multiply(_math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].subtract(currentTail, prevTail), 1.0 - dragForce);
        const tmpRotationQuat = VRMSpringBonePhysicsStrategy.__tmp_quat;
        _math_Quaternion__WEBPACK_IMPORTED_MODULE_2__["default"].multiplyTo(this.parentRotation, this.__localRotation, tmpRotationQuat);
        const dist = VRMSpringBonePhysicsStrategy.__tmp_vec3;
        dist.copyComponents(this.__boneAxis).multiplyQuaternion(tmpRotationQuat).multiply(stiffnessForce);
        // const dist = Vector3.multiply((this.__localRotation).multiplyVector3(this.__boneAxis), stiffnessForce);
        // const dist = Vector3.zero();
        let nextTail = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].add(_math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].add(_math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].add(currentTail, delta), dist), external);
        const tmp = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].subtract(nextTail, this.__transform.worldPosition);
        nextTail = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.__transform.worldPosition, _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].multiply(_math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].normalize(tmp), this.__length));
        nextTail = this.collision(collisionGroups, nextTail, boneHitRadius);
        this.__prevTail = (center != null) ? center.getLocalPositionOf(currentTail) : currentTail;
        this.__currentTail = (center != null) ? center.getLocalPositionOf(nextTail) : nextTail;
        const resultRotation = this.applyRotation(nextTail);
        // this.head.entity.getTransform().quaternion = resultRotation;
        // this.head.entity.getTransform().translate = this.__transform!.getLocalPositionOf(currentTail);
        if (this.head.children.length > 0) {
            // this.head.children[0].entity.getTransform().matrix = Matrix44.identity();
            this.head.children[0].entity.getTransform().translate = this.__transform.getLocalPositionOf(nextTail);
            // this.head.children[0].entity.getTransform().translate = new Vector3(1, 0, 0);
            // this.head.children[0].entity.getTransform().quaternion = resultRotation;
        }
        // VRMSpringBonePhysicsStrategy.initialize(this.__transform!);
    }
    applyRotation(nextTail) {
        // const rotation = Quaternion.multiply(this.parentRotation, this.__localRotation);
        const rotation = this.__localRotation;
        // const result = Quaternion.multiply(Quaternion.lookFromTo(rotation.multiplyVector3(this.__boneAxis), Vector3.subtract(nextTail, this.__transform!.worldPosition)), rotation);
        const result = _math_Quaternion__WEBPACK_IMPORTED_MODULE_2__["default"].multiply(_math_Quaternion__WEBPACK_IMPORTED_MODULE_2__["default"].lookFromTo(this.__boneAxis, this.__transform.getLocalPositionOf(nextTail)), rotation);
        // const result = Quaternion.lookFromTo(this.__boneAxis, Vector3.subtract(nextTail, this.__transform!.worldPosition));
        // const result = Quaternion.lookFromTo(this.__boneAxis, this.__transform!.getLocalPositionOf(nextTail));
        // const delta = Vector3.subtract(nextTail, this.__transform!.worldPosition);
        const boneAxis = this.__boneAxis;
        // const result = Quaternion.lookForward(Vector3.subtract(nextTail, this.__transform!.worldPosition));
        // const result = Quaternion.multiply(Quaternion.lookFromTo(rotation.multiplyVector3(this.__boneAxis), Vector3.normalize(delta)), this.__localRotation);
        // const result = new Quaternion(0,0,0,1);
        return result;
    }
    collision(collisionGroups, nextTail, boneHitRadius) {
        for (let collisionGroup of collisionGroups) {
            for (let collider of collisionGroup.colliders) {
                const worldColiderPos = collisionGroup.baseSceneGraph.getWorldPositionOf(collider.position);
                const r = boneHitRadius + collider.radius;
                const delta = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].subtract(nextTail, worldColiderPos);
                const deltaScalar = r - delta.length();
                if (deltaScalar >= 0) {
                    var normal = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].normalize(delta);
                    var resilienceVec = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].multiply(_math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].add(worldColiderPos, normal), deltaScalar);
                    nextTail = _math_Vector3__WEBPACK_IMPORTED_MODULE_0__["default"].add(nextTail, resilienceVec);
                    return nextTail;
                }
            }
        }
        return nextTail;
    }
    static setBoneGroups(sgs) {
        this.__boneGroups = sgs;
    }
    static addColliderGroup(index, group) {
        this.__colliderGroups.set(index, group);
    }
    static getColliderGroups(indices) {
        const colliderGroups = [];
        for (let index of indices) {
            colliderGroups.push(this.__colliderGroups.get(index));
        }
        return colliderGroups;
    }
}
VRMSpringBonePhysicsStrategy.__tmp_vec3 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
VRMSpringBonePhysicsStrategy.__tmp_vec3_2 = _math_MutableVector3__WEBPACK_IMPORTED_MODULE_1__["default"].zero();
VRMSpringBonePhysicsStrategy.__tmp_quat = _math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_5__["default"].identity();
VRMSpringBonePhysicsStrategy.__boneGroups = [];
VRMSpringBonePhysicsStrategy.__colliderGroups = new Map();


/***/ }),

/***/ "./src/foundation/renderer/CGAPIResourceRepository.ts":
/*!************************************************************!*\
  !*** ./src/foundation/renderer/CGAPIResourceRepository.ts ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CGAPIResourceRepository; });
/* harmony import */ var _system_ModuleManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system/ModuleManager */ "./src/foundation/system/ModuleManager.ts");

class CGAPIResourceRepository {
    static getWebGLResourceRepository() {
        const moduleName = 'webgl';
        const moduleManager = _system_ModuleManager__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
        const webglModule = moduleManager.getModule(moduleName);
        const webGLResourceRepository = webglModule.WebGLResourceRepository.getInstance();
        return webGLResourceRepository;
    }
}
CGAPIResourceRepository.InvalidCGAPIResourceUid = -1;


/***/ }),

/***/ "./src/foundation/renderer/Expression.ts":
/*!***********************************************!*\
  !*** ./src/foundation/renderer/Expression.ts ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Expression; });
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/RnObject */ "./src/foundation/core/RnObject.ts");

/**
 * Expression specifies the order of render passes on rendering process.
 */
class Expression extends _core_RnObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this.__renderPasses = [];
    }
    /**
     * Add render passes to the end of this expression.
     */
    addRenderPasses(renderPasses) {
        for (let renderPass of renderPasses) {
            this.__renderPasses.push(renderPass);
        }
    }
    /**
     * Clear render passes of this expression.
     */
    clearRenderPasses() {
        this.__renderPasses.length = 0;
    }
    /**
     * Gets the list of render passes of this expression.
     */
    get renderPasses() {
        return this.__renderPasses;
    }
}


/***/ }),

/***/ "./src/foundation/renderer/FrameBuffer.ts":
/*!************************************************!*\
  !*** ./src/foundation/renderer/FrameBuffer.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FrameBuffer; });
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _definitions_RenderBufferTarget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../definitions/RenderBufferTarget */ "./src/foundation/definitions/RenderBufferTarget.ts");



class FrameBuffer extends _core_RnObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this.__colorAttachments = [];
        this.cgApiResourceUid = _CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__["default"].InvalidCGAPIResourceUid;
        this.width = 0;
        this.height = 0;
        this.__colorAttachmentMap = new Map();
    }
    get colorAttachmentsRenderBufferTargets() {
        return Array.from(this.__colorAttachmentMap.keys());
    }
    get colorAttachments() {
        return this.__colorAttachments;
    }
    get depthAttachment() {
        return this.__depthAttachment;
    }
    get stencilAttachment() {
        return this.__stencilAttachment;
    }
    get depthStencilAttachment() {
        return this.__depthStencilAttachment;
    }
    create(width, height) {
        this.width = width;
        this.height = height;
        const webGLResourceRepository = _CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getWebGLResourceRepository();
        this.cgApiResourceUid = webGLResourceRepository.createFrameBufferObject();
        return this.cgApiResourceUid;
    }
    get framebufferUID() {
        return this.cgApiResourceUid;
    }
    setColorAttachmentAt(index, renderable) {
        if (renderable.width !== this.width || renderable.height !== this.height) {
            return false;
        }
        this.__colorAttachments[index] = renderable;
        const webglResourceRepository = _CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getWebGLResourceRepository();
        webglResourceRepository.attachColorBufferToFrameBufferObject(this, index, renderable);
        this.__colorAttachmentMap.set(_definitions_RenderBufferTarget__WEBPACK_IMPORTED_MODULE_2__["RenderBufferTarget"].from(index), renderable);
        return true;
    }
    setDepthAttachment(renderable) {
        if (renderable.width !== this.width || renderable.height !== this.height) {
            return false;
        }
        this.__depthAttachment = renderable;
        const webglResourceRepository = _CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getWebGLResourceRepository();
        webglResourceRepository.attachDepthBufferToFrameBufferObject(this, renderable);
        return true;
    }
    setStencilAttachment(renderable) {
        if (renderable.width !== this.width || renderable.height !== this.height) {
            return false;
        }
        this.__stencilAttachment = renderable;
        const webglResourceRepository = _CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getWebGLResourceRepository();
        webglResourceRepository.attachStencilBufferToFrameBufferObject(this, renderable);
        return true;
    }
    setDepthStencilAttachment(renderable) {
        if (renderable.width !== this.width || renderable.height !== this.height) {
            return false;
        }
        this.__depthStencilAttachment = renderable;
        const webglResourceRepository = _CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getWebGLResourceRepository();
        webglResourceRepository.attachDepthStencilBufferToFrameBufferObject(this, renderable);
        return true;
    }
    resize(width, height) {
        this.destroy3DAPIResources();
        this.create(width, height);
        if (this.depthAttachment) {
            this.depthAttachment.resize(width, height);
            this.setDepthAttachment(this.depthAttachment);
        }
        if (this.depthStencilAttachment) {
            this.depthStencilAttachment.resize(width, height);
            this.setDepthStencilAttachment(this.depthStencilAttachment);
        }
        if (this.stencilAttachment) {
            this.stencilAttachment.resize(width, height);
            this.setStencilAttachment(this.stencilAttachment);
        }
        for (let i = 0; i < this.colorAttachments.length; i++) {
            this.colorAttachments[i].resize(width, height);
            this.setColorAttachmentAt(i, this.colorAttachments[i]);
        }
    }
    destroy3DAPIResources() {
        const webGLResourceRepository = _CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getWebGLResourceRepository();
        webGLResourceRepository.deleteFrameBufferObject(this.cgApiResourceUid);
        if (this.depthAttachment) {
            this.depthAttachment.destroy3DAPIResources();
        }
        if (this.depthStencilAttachment) {
            this.depthStencilAttachment.destroy3DAPIResources();
        }
        if (this.stencilAttachment) {
            this.stencilAttachment.destroy3DAPIResources();
        }
        for (let colorAttachment of this.colorAttachments) {
            colorAttachment.destroy3DAPIResources();
        }
    }
    whichColorAttachment(renderable) {
        return this.__colorAttachments.indexOf(renderable);
    }
}


/***/ }),

/***/ "./src/foundation/renderer/RenderPass.ts":
/*!***********************************************!*\
  !*** ./src/foundation/renderer/RenderPass.ts ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderPass; });
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _math_Vector4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _system_System__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../system/System */ "./src/foundation/system/System.ts");
/* harmony import */ var _system_ModuleManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../system/ModuleManager */ "./src/foundation/system/ModuleManager.ts");
/* harmony import */ var _math_MutableVector4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/MutableVector4 */ "./src/foundation/math/MutableVector4.ts");






/**
 * A render pass is a collection of the resources which is used in rendering process.
 */
class RenderPass extends _core_RnObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this.__entities = [];
        this.__sceneGraphDirectlyAdded = [];
        this.__topLevelSceneGraphComponents = [];
        this.toClearColorBuffer = false;
        this.toClearDepthBuffer = true;
        this.toClearStencilBuffer = false;
        this.clearColor = new _math_Vector4__WEBPACK_IMPORTED_MODULE_2__["default"](1, 1, 1, 1);
        this.clearDepth = 1;
        this.clearStencil = 0;
        this.cullFrontFaceCCW = true;
        this.__primitiveMaterial = new Map();
        this.isMainPass = false;
    }
    setPreRenderFunction(func) {
        this.__preRenderFunc = func;
    }
    unsetPreRenderFunction() {
        this.__preRenderFunc = void 0;
    }
    doPreRender() {
        if (this.__preRenderFunc != null) {
            this.__preRenderFunc();
        }
    }
    /**
     * Add entities to draw.
     * @param entities An array of entities.
     */
    addEntities(entities) {
        for (let entity of entities) {
            const sceneGraphComponent = entity.getSceneGraph();
            this.__sceneGraphDirectlyAdded.push(sceneGraphComponent);
            const collectedSgComponents = _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_1__["default"].flattenHierarchy(sceneGraphComponent, false);
            const collectedEntities = collectedSgComponents.map((sg) => { return sg.entity; });
            // Eliminate duplicates
            const map = this.__entities.concat(collectedEntities).reduce((map, entity) => {
                map.set(entity.entityUID, entity);
                return map;
            }, new Map());
            this.__entities = Array.from(map.values());
        }
        this.__meshComponents = void 0;
        this.__topLevelSceneGraphComponents = void 0;
        this.__collectMeshComponents();
        this.__collectTopLevelSceneGraphComponents();
    }
    /**
     * Gets the list of entities on this render pass.
     * @return An array of entities
     */
    get entities() {
        return this.__entities;
    }
    /**
     * Clear entities on this render pass.
     */
    clearEntities() {
        this.__meshComponents = void 0;
        this.__topLevelSceneGraphComponents = void 0;
        this.__entities = [];
    }
    __collectTopLevelSceneGraphComponents() {
        if (this.__topLevelSceneGraphComponents == null) {
            const goToTopLevel = (sg) => {
                if (sg.parent) {
                    goToTopLevel(sg.parent);
                }
                return sg;
            };
            this.__topLevelSceneGraphComponents = this.__sceneGraphDirectlyAdded.map((sg) => {
                return goToTopLevel(sg);
            });
            let set = new Set(this.__topLevelSceneGraphComponents);
            this.__topLevelSceneGraphComponents = Array.from(set);
        }
    }
    __collectMeshComponents() {
        if (this.__meshComponents == null) {
            this.__meshComponents = [];
            this.__entities.filter((entity) => {
                const meshComponent = entity.getMesh();
                if (meshComponent) {
                    this.__meshComponents.push(meshComponent);
                }
            });
        }
    }
    /**
     * Get all the MeshComponents list of the entities on this render pass.
     * @return An array of MeshComponents
     */
    get meshComponents() {
        this.__collectMeshComponents();
        return this.__meshComponents;
    }
    /**
     * Get all the highest level SceneGraphComponents list of the entities on this render pass.
     * @return An array of SceneGraphComponents
     */
    get sceneTopLevelGraphComponents() {
        this.__collectTopLevelSceneGraphComponents();
        return this.__topLevelSceneGraphComponents != null ? this.__topLevelSceneGraphComponents : [];
    }
    /**
     * Sets the target framebuffer of this render pass.
     * If two or more render pass share a framebuffer, Rhodonite renders entities in render passes to same framebuffer.
     * @param framebuffer A framebuffer
     */
    setFramebuffer(framebuffer) {
        this.__frameBuffer = framebuffer;
        if (framebuffer != null) {
            this.setViewport(new _math_Vector4__WEBPACK_IMPORTED_MODULE_2__["default"](0, 0, framebuffer.width, framebuffer.height));
        }
        else {
            this.__viewport = undefined;
        }
    }
    /**
     * Gets the framebuffer if this render pass has the target framebuffer.
     * @return A framebuffer
     */
    getFramebuffer() {
        return this.__frameBuffer;
    }
    /**
     * Sets the viewport of this render pass.
     * @param vec A Vector4 (Origin of coordinatesX, origin of coordinatesY, width, height).
     */
    setViewport(vec) {
        if (this.__viewport != null) {
            this.__viewport.copyComponents(vec);
        }
        else {
            this.__viewport = new _math_MutableVector4__WEBPACK_IMPORTED_MODULE_5__["default"](vec);
        }
    }
    /**
     * Gets the viewport if this render pass has the viewport.
     * @return A Vector4 (Origin of coordinatesX, origin of coordinatesY, width, height).
     */
    getViewport() {
        let viewport = this.__viewport;
        if (viewport != null) {
            viewport = RenderPass.__tmp_Vector4_0.copyComponents(viewport);
        }
        return viewport;
    }
    __setupMaterial(material, isPointSprite = false) {
        if (material.isEmptyMaterial())
            return;
        if (this.__webglRenderingStrategy == null) {
            this.__setWebglRenderingStrategy();
        }
        this.__webglRenderingStrategy.setupDefaultShaderSemantics(material, isPointSprite);
    }
    /**
     * Sets a material for the primitive on this render pass.
     * If Rhodonite draw the primitive using this render pass, Rhodonite uses this material instead of the material on the primitive.
     * @param material A material attaching to the primitive
     * @param primitive A target primitive
     * @param isPointSprite Set true, if the primitive is a point sprite
     */
    setMaterialForPrimitive(material, primitive, isPointSprite = false) {
        this.__primitiveMaterial.set(primitive, material);
        this.__setupMaterial(material, isPointSprite);
    }
    /**
     * Sets a material for all the primitive on this render pass.
     * For all the primitive, Rhodonite uses this material instead of the material on the primitive.
     * Where if this render pass has a map between primitive and material by setMaterialForPrimitive, Rhodonite uses the material mapped by primitive.
     * @param material A material attaching to the primitive
     * @param isPointSprite Set true, if the primitive is a point sprite
     */
    setMaterial(material, isPointSprite = false) {
        this.__material = material;
        this.__setupMaterial(material, isPointSprite);
    }
    get material() {
        return this.__material;
    }
    __setWebglRenderingStrategy() {
        const system = _system_System__WEBPACK_IMPORTED_MODULE_3__["default"].getInstance();
        const processApproach = system.processApproach;
        const moduleManager = _system_ModuleManager__WEBPACK_IMPORTED_MODULE_4__["default"].getInstance();
        const moduleName = 'webgl';
        const webglModule = moduleManager.getModule(moduleName);
        this.__webglRenderingStrategy = webglModule.getRenderingStrategy(processApproach);
    }
    __getMaterialOf(primitive) {
        return this.__primitiveMaterial.get(primitive);
    }
    __hasMaterialOf(primitive) {
        return this.__primitiveMaterial.has(primitive);
    }
    getAppropriateMaterial(primitive, defaultMaterial) {
        let material;
        if (this.__hasMaterialOf(primitive)) {
            material = this.__getMaterialOf(primitive);
        }
        else if (this.material != null) {
            material = this.material;
        }
        else {
            material = defaultMaterial;
        }
        return material;
    }
}
RenderPass.__tmp_Vector4_0 = _math_MutableVector4__WEBPACK_IMPORTED_MODULE_5__["default"].zero();


/***/ }),

/***/ "./src/foundation/system/ModuleManager.ts":
/*!************************************************!*\
  !*** ./src/foundation/system/ModuleManager.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModuleManager; });
class ModuleManager {
    constructor() {
        this.__modules = new Map();
    }
    async loadModule(moduleName) {
        let module;
        if (moduleName.toLowerCase() === 'webgl') {
            module = await Promise.resolve(/*! import() | webgl */).then(__webpack_require__.bind(null, /*! ../../webgl/main */ "./src/webgl/main.ts"));
        }
        else if (moduleName.toLowerCase() === 'effekseer') {
            module = await Promise.resolve(/*! import() | effekseer */).then(__webpack_require__.bind(null, /*! ../../effekseer/main */ "./src/effekseer/main.ts"));
        }
        else if (moduleName.toLowerCase() === 'sparkgear') {
            module = await Promise.resolve(/*! import() | sparkgear */).then(__webpack_require__.bind(null, /*! ../../sparkgear/main */ "./src/sparkgear/main.ts"));
        }
        else if (moduleName.toLowerCase() === 'pbr') {
            module = await Promise.resolve(/*! import() | pbr */).then(__webpack_require__.bind(null, /*! ../../pbr/main */ "./src/pbr/main.ts"));
        }
        else if (moduleName.toLowerCase() === 'xr') {
            module = await Promise.resolve(/*! import() | xr */).then(__webpack_require__.bind(null, /*! ../../rhodonite-xr */ "./src/rhodonite-xr.ts"));
        }
        this.__modules.set(moduleName, module);
        console.log('Module Loaded:', module);
        return module === null || module === void 0 ? void 0 : module.default;
    }
    getModule(moduleName) {
        var _a;
        return (_a = this.__modules.get(moduleName)) === null || _a === void 0 ? void 0 : _a.default;
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new ModuleManager();
        }
        return this.__instance;
    }
}


/***/ }),

/***/ "./src/foundation/system/System.ts":
/*!*****************************************!*\
  !*** ./src/foundation/system/System.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return System; });
/* harmony import */ var _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../definitions/ProcessApproach */ "./src/foundation/definitions/ProcessApproach.ts");
/* harmony import */ var _ModuleManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ModuleManager */ "./src/foundation/system/ModuleManager.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _renderer_Expression__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../renderer/Expression */ "./src/foundation/renderer/Expression.ts");
/* harmony import */ var _components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/MeshRendererComponent */ "./src/foundation/components/MeshRendererComponent.ts");
/* harmony import */ var _core_EntityRepository__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/EntityRepository */ "./src/foundation/core/EntityRepository.ts");
/* harmony import */ var _components_CameraComponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _core_MemoryManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../core/GlobalDataRepository */ "./src/foundation/core/GlobalDataRepository.ts");
/* harmony import */ var _components_TransformComponent__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../components/TransformComponent */ "./src/foundation/components/TransformComponent.ts");
/* harmony import */ var _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _definitions_CameraType__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../definitions/CameraType */ "./src/foundation/definitions/CameraType.ts");
/* harmony import */ var _misc_Time__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../misc/Time */ "./src/foundation/misc/Time.ts");
/* harmony import */ var _SystemState__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./SystemState */ "./src/foundation/system/SystemState.ts");


















class System {
    constructor() {
        this.__componentRepository = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance();
        this.__entityRepository = _core_EntityRepository__WEBPACK_IMPORTED_MODULE_8__["default"].getInstance();
        this.__processApproach = _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_2__["ProcessApproach"].None;
        this.__webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getWebGLResourceRepository();
        this.__localExpression = new _renderer_Expression__WEBPACK_IMPORTED_MODULE_6__["default"]();
        this.__lastEntitiesNumber = -1;
        this.__renderPassTickCount = 0;
        this.__animationFrameId = -1;
        this.__rnXRModule = _ModuleManager__WEBPACK_IMPORTED_MODULE_3__["default"].getInstance().getModule('xr');
    }
    doRenderLoop(renderLoopFunc, time, ...args) {
        const animationFrameObject = this.__getAnimationFrameObject();
        this.__animationFrameId = animationFrameObject.requestAnimationFrame((_time) => {
            var _a, _b;
            const webVRSystem = this.__rnXRModule.WebVRSystem.getInstance();
            if ((webVRSystem === null || webVRSystem === void 0 ? void 0 : webVRSystem.isWebVRMode) && ((_a = webVRSystem.vrDisplay) === null || _a === void 0 ? void 0 : _a.isPresenting)) {
                webVRSystem.getFrameData();
            }
            args.splice(0, 0, time);
            renderLoopFunc.apply(renderLoopFunc, args);
            if ((webVRSystem === null || webVRSystem === void 0 ? void 0 : webVRSystem.isWebVRMode) && ((_b = webVRSystem.vrDisplay) === null || _b === void 0 ? void 0 : _b.isPresenting)) {
                webVRSystem.vrDisplay.submitFrame();
            }
            if (webVRSystem === null || webVRSystem === void 0 ? void 0 : webVRSystem.requestedToEnterWebVR) {
                webVRSystem._setIsWebVRMode();
            }
            this.doRenderLoop(renderLoopFunc, _time, args);
        });
    }
    __getAnimationFrameObject() {
        let animationFrameObject = window;
        const webVRSystem = this.__rnXRModule.WebVRSystem.getInstance();
        if (webVRSystem === null || webVRSystem === void 0 ? void 0 : webVRSystem.isWebVRMode) {
            animationFrameObject = webVRSystem.vrDisplay;
        }
        return animationFrameObject;
    }
    stopRenderLoop() {
        const animationFrameObject = this.__getAnimationFrameObject();
        animationFrameObject.cancelAnimationFrame(this.__animationFrameId);
        this.__animationFrameId = -1;
    }
    process(expressions) {
        if (this.__processApproach === _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_2__["ProcessApproach"].None) {
            throw new Error('Choose a process approach first.');
        }
        _misc_Time__WEBPACK_IMPORTED_MODULE_16__["default"]._processBegin();
        if (_components_CameraComponent__WEBPACK_IMPORTED_MODULE_9__["default"].main === _core_Component__WEBPACK_IMPORTED_MODULE_5__["default"].InvalidObjectUID) {
            const cameraEntity = this.__entityRepository.createEntity([_components_TransformComponent__WEBPACK_IMPORTED_MODULE_12__["default"], _components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_13__["default"], _components_CameraComponent__WEBPACK_IMPORTED_MODULE_9__["default"]]);
            cameraEntity.getTransform().translate = new _math_Vector3__WEBPACK_IMPORTED_MODULE_14__["default"](0, 0, 1);
            cameraEntity.getCamera().type = _definitions_CameraType__WEBPACK_IMPORTED_MODULE_15__["CameraType"].Orthographic;
            cameraEntity.getCamera().zNear = 0.1;
            cameraEntity.getCamera().zFar = 10000;
            const wgl = this.__webglResourceRepository.currentWebGLContextWrapper;
            cameraEntity.getCamera().xMag = wgl.width / wgl.height;
            cameraEntity.getCamera().yMag = 1;
        }
        for (let stage of _core_Component__WEBPACK_IMPORTED_MODULE_5__["default"]._processStages) {
            const methodName = stage.methodName;
            const commonMethodName = 'common_' + methodName;
            const componentTids = this.__componentRepository.getComponentTIDs();
            for (let componentTid of componentTids) {
                if (stage === _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_0__["ProcessStage"].Render) {
                    for (let exp of expressions) {
                        let loopN = 1;
                        if (componentTid === _components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_7__["default"].componentTID) {
                            loopN = exp.renderPasses.length;
                        }
                        for (let i = 0; i < loopN; i++) {
                            const renderPass = exp.renderPasses[i];
                            renderPass.doPreRender();
                            if (componentTid === _components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_7__["default"].componentTID && (stage == _definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_0__["ProcessStage"].Render)) {
                                this.__webglResourceRepository.bindFramebuffer(renderPass.getFramebuffer());
                                this.__webglResourceRepository.setViewport(renderPass.getViewport());
                                this.__webglResourceRepository.setDrawTargets(renderPass.getFramebuffer());
                                this.__webglResourceRepository.clearFrameBuffer(renderPass);
                            }
                            const componentClass = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getComponentClass(componentTid);
                            componentClass.updateComponentsOfEachProcessStage(componentClass, stage, this.__componentRepository, renderPass);
                            const componentClass_commonMethod = componentClass[commonMethodName];
                            if (componentClass_commonMethod) {
                                componentClass_commonMethod({ processApproach: this.__processApproach, renderPass: renderPass, processStage: stage, renderPassTickCount: this.__renderPassTickCount });
                            }
                            componentClass.process({
                                componentType: componentClass,
                                processStage: stage,
                                processApproach: this.__processApproach,
                                componentRepository: this.__componentRepository,
                                strategy: this.__webglStrategy,
                                renderPass: renderPass,
                                renderPassTickCount: this.__renderPassTickCount
                            });
                            this.__renderPassTickCount++;
                        }
                    }
                }
                else {
                    const componentClass = _core_ComponentRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getComponentClass(componentTid);
                    componentClass.updateComponentsOfEachProcessStage(componentClass, stage, this.__componentRepository);
                    const componentClass_commonMethod = componentClass[commonMethodName];
                    if (componentClass_commonMethod) {
                        componentClass_commonMethod({ processApproach: this.__processApproach, renderPass: void 0, processStage: stage, renderPassTickCount: this.__renderPassTickCount });
                    }
                    componentClass.process({
                        componentType: componentClass,
                        processStage: stage,
                        processApproach: this.__processApproach,
                        componentRepository: this.__componentRepository,
                        strategy: this.__webglStrategy,
                        renderPass: void 0,
                        renderPassTickCount: this.__renderPassTickCount
                    });
                }
            }
        }
        _misc_Time__WEBPACK_IMPORTED_MODULE_16__["default"]._processEnd();
    }
    setProcessApproachAndCanvas(approach, canvas, memoryUsageOrder = 1, webglOption = {}, rnWebGLDebug = true) {
        const moduleManager = _ModuleManager__WEBPACK_IMPORTED_MODULE_3__["default"].getInstance();
        const moduleName = 'webgl';
        const webglModule = moduleManager.getModule(moduleName);
        this.__webglStrategy = webglModule.getRenderingStrategy(approach);
        const repo = webglModule.WebGLResourceRepository.getInstance();
        let gl;
        if (approach === _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_2__["ProcessApproach"].DataTextureWebGL2 ||
            approach === _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_2__["ProcessApproach"].UBOWebGL2 ||
            approach === _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_2__["ProcessApproach"].TransformFeedbackWebGL2 ||
            approach === _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_2__["ProcessApproach"].UniformWebGL2) {
            gl = canvas.getContext('webgl2', webglOption);
        }
        else {
            gl = canvas.getContext('webgl', webglOption) ||
                canvas.getContext('experimental-webgl', webglOption);
        }
        gl.enable(gl.DEPTH_TEST);
        _core_MemoryManager__WEBPACK_IMPORTED_MODULE_10__["default"].createInstanceIfNotCreated(0.125 * memoryUsageOrder, 0.0625 * memoryUsageOrder, 0.9375 * memoryUsageOrder);
        const globalDataRepository = _core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_11__["default"].getInstance();
        globalDataRepository.initialize();
        repo.addWebGLContext(gl, canvas, true, rnWebGLDebug);
        this.__processApproach = approach;
        _SystemState__WEBPACK_IMPORTED_MODULE_17__["default"].currentProcessApproach = approach;
        return gl;
    }
    get processApproach() {
        return this.__processApproach;
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new System();
        }
        return this.__instance;
    }
}


/***/ }),

/***/ "./src/foundation/system/SystemState.ts":
/*!**********************************************!*\
  !*** ./src/foundation/system/SystemState.ts ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../definitions/ProcessApproach */ "./src/foundation/definitions/ProcessApproach.ts");

let currentProcessApproach = _definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_0__["ProcessApproach"].None;
/* harmony default export */ __webpack_exports__["default"] = ({
    currentProcessApproach
});


/***/ }),

/***/ "./src/foundation/textures/AbstractTexture.ts":
/*!****************************************************!*\
  !*** ./src/foundation/textures/AbstractTexture.ts ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AbstractTexture; });
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/PixelFormat */ "./src/foundation/definitions/PixelFormat.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/TextureParameter */ "./src/foundation/definitions/TextureParameter.ts");
/* harmony import */ var _TextureDataFloat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextureDataFloat */ "./src/foundation/textures/TextureDataFloat.ts");





class AbstractTexture extends _core_RnObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this.__width = 0;
        this.__height = 0;
        this.__level = 0;
        this.__internalFormat = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_1__["PixelFormat"].RGBA;
        this.__format = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_1__["PixelFormat"].RGBA;
        this.__type = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_2__["ComponentType"].UnsignedByte;
        this.__magFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_3__["TextureParameter"].Linear;
        this.__minFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_3__["TextureParameter"].Linear;
        this.__wrapS = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_3__["TextureParameter"].ClampToEdge;
        this.__wrapT = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_3__["TextureParameter"].ClampToEdge;
        this.__hasTransparentPixels = false;
        this.cgApiResourceUid = -1;
        this.__isTextureReady = false;
        this.__startedToLoad = false;
        this.__name = 'untitled';
        this.__textureUid = ++AbstractTexture.__textureUidCount;
    }
    get textureUID() {
        return this.__textureUid;
    }
    get width() {
        return this.__width;
    }
    get height() {
        return this.__height;
    }
    get isTextureReady() {
        return this.__isTextureReady;
    }
    get startedToLoad() {
        return this.__startedToLoad;
    }
    /**
     * get a value nearest power of two.
     *
     * @param x texture size.
     * @returns a value nearest power of two.
     */
    __getNearestPowerOfTwo(x) {
        return Math.pow(2, Math.round(Math.log(x) / Math.LN2));
    }
    get htmlImageElement() {
        return this.__htmlImageElement;
    }
    get htmlCanvasElement() {
        if (this.__htmlCanvasElement == null) {
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext("2d");
            ctx.drawImage(this.__htmlImageElement, 0, 0, this.__htmlImageElement.width, this.__htmlImageElement.height);
            this.__htmlCanvasElement = canvas;
        }
        return this.__htmlCanvasElement;
    }
    get uri() {
        return this.__uri;
    }
    static getRhodoniteTexture(textureUid) {
        return this.__textureMap.get(textureUid);
    }
    set name(name) {
        this.__name = name;
    }
    get name() {
        return this.__name;
    }
    getImageData(x, y, width, height) {
        return this.__canvasContext.getImageData(x, y, width, height);
    }
    get isTransparent() {
        return this.__hasTransparentPixels;
    }
    createInternalCanvasContext() {
        let canvas;
        if (this.__htmlCanvasElement != null) {
            canvas = this.__htmlCanvasElement;
        }
        else {
            canvas = document.createElement("canvas");
            canvas.width = this.width;
            canvas.height = this.height;
        }
        this.__htmlCanvasElement = canvas;
        this.__canvasContext = canvas.getContext("2d");
    }
    getTextureDataFloat(channels) {
        const pixel = this.getImageData(0, 0, this.width, this.height);
        const textureDataFloat = new _TextureDataFloat__WEBPACK_IMPORTED_MODULE_4__["default"](this.width, this.height, channels);
        const data = pixel.data;
        for (let i = 0; i < this.height; i++) {
            for (let j = 0; j < this.width; j++) {
                for (let k = 0; k < channels; k++) {
                    textureDataFloat.setPixelAtChannel(j, i, k, data[(i * this.width * 4) + (j * 4) + k] / 255);
                }
            }
        }
        return textureDataFloat;
    }
}
AbstractTexture.InvalidTextureUid = -1;
AbstractTexture.__textureUidCount = AbstractTexture.InvalidTextureUid;
AbstractTexture.__textureMap = new Map();


/***/ }),

/***/ "./src/foundation/textures/CubeTexture.ts":
/*!************************************************!*\
  !*** ./src/foundation/textures/CubeTexture.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CubeTexture; });
/* harmony import */ var _AbstractTexture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractTexture */ "./src/foundation/textures/AbstractTexture.ts");
/* harmony import */ var _definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/HdriFormat */ "./src/foundation/definitions/HdriFormat.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/TextureParameter */ "./src/foundation/definitions/TextureParameter.ts");




class CubeTexture extends _AbstractTexture__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this.mipmapLevelNumber = 1;
        this.hdriFormat = _definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_1__["HdriFormat"].LDR_SRGB;
        this.isNamePosNeg = false;
    }
    async loadTextureImages() {
        this.__startedToLoad = true;
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].getWebGLResourceRepository();
        this.cgApiResourceUid = await webGLResourceRepository.createCubeTextureFromFiles(this.baseUriToLoad, this.mipmapLevelNumber, this.isNamePosNeg, this.hdriFormat);
        this.__isTextureReady = true;
    }
    loadTextureImagesAsync() {
        this.__startedToLoad = true;
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].getWebGLResourceRepository();
        webGLResourceRepository.createCubeTextureFromFiles(this.baseUriToLoad, this.mipmapLevelNumber, this.isNamePosNeg, this.hdriFormat).then((cubeTextureUid) => {
            this.cgApiResourceUid = cubeTextureUid;
        }).then(() => {
            this.__isTextureReady = true;
        });
    }
    loadTextureImagesFromBasis(uint8Array, { magFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_3__["TextureParameter"].Linear, minFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_3__["TextureParameter"].LinearMipmapLinear, wrapS = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_3__["TextureParameter"].Repeat, wrapT = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_3__["TextureParameter"].Repeat, } = {}) {
        this.__startedToLoad = true;
        if (typeof BASIS === 'undefined') {
            console.error('Failed to call BASIS() function. Please check to import basis_transcoder.js.');
        }
        BASIS().then((basisTransCoder) => {
            const { initializeBasis } = basisTransCoder;
            initializeBasis();
            const BasisFile = basisTransCoder.BasisFile;
            const basisFile = new BasisFile(uint8Array);
            if (!basisFile.startTranscoding()) {
                console.error("failed to start transcoding.");
                basisFile.close();
                basisFile.delete();
                return;
            }
            const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].getWebGLResourceRepository();
            const texture = webGLResourceRepository.createCubeTextureFromBasis(basisFile, {
                magFilter: magFilter, minFilter: minFilter,
                wrapS: wrapS, wrapT: wrapT
            });
            this.cgApiResourceUid = texture;
            this.__isTextureReady = true;
            basisFile.close();
            basisFile.delete();
        });
    }
    load1x1Texture(rgbaStr = 'rgba(0,0,0,1)') {
        var canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = rgbaStr;
        ctx.fillRect(0, 0, 1, 1);
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].getWebGLResourceRepository();
        this.cgApiResourceUid = webGLResourceRepository.createCubeTexture(1, [{ posX: canvas, negX: canvas, posY: canvas, negY: canvas, posZ: canvas, negZ: canvas }], 1, 1);
        this.__isTextureReady = true;
    }
    importWebGLTextureDirectly(webGLTexture, width = 0, height = 0) {
        this.__width = width;
        this.__height = height;
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].getWebGLResourceRepository();
        const texture = webGLResourceRepository.setWebGLTextureDirectly(webGLTexture);
        this.cgApiResourceUid = texture;
        this.__startedToLoad = true;
        this.__isTextureReady = true;
        _AbstractTexture__WEBPACK_IMPORTED_MODULE_0__["default"].__textureMap.set(texture, this);
    }
}


/***/ }),

/***/ "./src/foundation/textures/RenderBuffer.ts":
/*!*************************************************!*\
  !*** ./src/foundation/textures/RenderBuffer.ts ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderBuffer; });
/* harmony import */ var _core_RnObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../definitions/TextureParameter */ "./src/foundation/definitions/TextureParameter.ts");



class RenderBuffer extends _core_RnObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this.width = 0;
        this.height = 0;
        this.__internalFormat = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Depth24;
        this.cgApiResourceUid = -1;
    }
    set _fbo(fbo) {
        this.__fbo = fbo;
    }
    get fbo() {
        return this.__fbo;
    }
    create(width, height, internalFormat) {
        this.width = width;
        this.height = height;
        this.__internalFormat = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Depth24;
        const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getWebGLResourceRepository();
        this.cgApiResourceUid = webglResourceRepository.createRenderBuffer(width, height, internalFormat);
    }
    resize(width, height) {
        this.destroy3DAPIResources();
        this.create(width, height, this.__internalFormat);
    }
    destroy3DAPIResources() {
        const webglResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getWebGLResourceRepository();
        webglResourceRepository.deleteRenderBuffer(this.cgApiResourceUid);
        return true;
    }
}


/***/ }),

/***/ "./src/foundation/textures/RenderTargetTexture.ts":
/*!********************************************************!*\
  !*** ./src/foundation/textures/RenderTargetTexture.ts ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderTargetTexture; });
/* harmony import */ var _AbstractTexture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractTexture */ "./src/foundation/textures/AbstractTexture.ts");
/* harmony import */ var _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/TextureParameter */ "./src/foundation/definitions/TextureParameter.ts");
/* harmony import */ var _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../definitions/PixelFormat */ "./src/foundation/definitions/PixelFormat.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _math_Vector4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Vector4 */ "./src/foundation/math/Vector4.ts");






class RenderTargetTexture extends _AbstractTexture__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    create({ width, height, level = 0, internalFormat = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_2__["PixelFormat"].RGBA, format = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_2__["PixelFormat"].RGBA, type = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].UnsignedByte, magFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_1__["TextureParameter"].Linear, minFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_1__["TextureParameter"].Linear, wrapS = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_1__["TextureParameter"].ClampToEdge, wrapT = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_1__["TextureParameter"].ClampToEdge }) {
        this.__width = width;
        this.__height = height;
        this.__level = level;
        this.__internalFormat = internalFormat;
        this.__format = format;
        this.__type = type;
        this.__magFilter = magFilter;
        this.__minFilter = minFilter;
        this.__wrapS = wrapS;
        this.__wrapT = wrapT;
        this.__createRenderTargetTexture();
    }
    set _fbo(fbo) {
        this.__fbo = fbo;
    }
    get fbo() {
        return this.__fbo;
    }
    __createRenderTargetTexture() {
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getWebGLResourceRepository();
        const texture = webGLResourceRepository.createRenderTargetTexture({
            width: this.__width,
            height: this.__height,
            level: this.__level,
            internalFormat: this.__internalFormat,
            format: this.__format,
            type: this.__type,
            magFilter: this.__magFilter,
            minFilter: this.__minFilter,
            wrapS: this.__wrapS,
            wrapT: this.__wrapT
        });
        this.cgApiResourceUid = texture;
        _AbstractTexture__WEBPACK_IMPORTED_MODULE_0__["default"].__textureMap.set(texture, this);
    }
    resize(width, height) {
        this.destroy3DAPIResources();
        this.__width = width;
        this.__height = height;
        this.__createRenderTargetTexture();
    }
    destroy3DAPIResources() {
        _AbstractTexture__WEBPACK_IMPORTED_MODULE_0__["default"].__textureMap.delete(this.cgApiResourceUid);
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getWebGLResourceRepository();
        webGLResourceRepository.deleteTexture(this.cgApiResourceUid);
        return true;
    }
    getTexturePixelData() {
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getWebGLResourceRepository();
        const glw = webGLResourceRepository.currentWebGLContextWrapper;
        const gl = glw.getRawContext();
        // Create a framebuffer backed by the texture
        const fbo = webGLResourceRepository.getWebGLResource(this.__fbo.framebufferUID);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        // const texture = webGLResourceRepository.getWebGLResource(this.cgApiResourceUid!) as WebGLTexture;
        // gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        // Read the contents of the framebuffer (data stores the pixel data)
        let data = new Uint8Array(this.width * this.height * 4);
        if (gl.readBuffer != null) {
            gl.readBuffer(36064 + this.__fbo.whichColorAttachment(this)); // 36064 means gl.COLOR_ATTACHMENT0
        }
        gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return data;
    }
    /**
     * Origin is left bottom
     *
     * @param x horizontal pixel position (0 is left)
     * @param y vertical pixel position (0 is bottom)
     * @param argByteArray Pixel Data as Uint8Array
     * @returns Pixel Value in Vector4
     */
    getPixelValueAt(x, y, argByteArray) {
        let byteArray = argByteArray;
        if (!byteArray) {
            byteArray = this.getTexturePixelData();
        }
        let color = new _math_Vector4__WEBPACK_IMPORTED_MODULE_5__["default"](byteArray[(y * this.width + x) * 4 + 0], byteArray[(y * this.width + x) * 4 + 1], byteArray[(y * this.width + x) * 4 + 2], byteArray[(y * this.width + x) * 4 + 3]);
        return color;
    }
}


/***/ }),

/***/ "./src/foundation/textures/Texture.ts":
/*!********************************************!*\
  !*** ./src/foundation/textures/Texture.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Texture; });
/* harmony import */ var _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../definitions/PixelFormat */ "./src/foundation/definitions/PixelFormat.ts");
/* harmony import */ var _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../definitions/TextureParameter */ "./src/foundation/definitions/TextureParameter.ts");
/* harmony import */ var _AbstractTexture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbstractTexture */ "./src/foundation/textures/AbstractTexture.ts");
/* harmony import */ var _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _core_Config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Config */ "./src/foundation/core/Config.ts");






class Texture extends _AbstractTexture__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super();
        this.autoResize = true;
        this.autoDetectTransparency = false;
    }
    __getResizedCanvas(image, maxSize) {
        var canvas = document.createElement("canvas");
        const potWidth = this.__getNearestPowerOfTwo(image.width);
        const potHeight = this.__getNearestPowerOfTwo(image.height);
        const aspect = potHeight / potWidth;
        let dstWidth = 0;
        let dstHeight = 0;
        if (potWidth > potHeight) {
            dstWidth = Math.min(potWidth, maxSize);
            dstHeight = dstWidth * aspect;
        }
        else {
            dstHeight = Math.min(potHeight, maxSize);
            dstWidth = dstHeight / aspect;
        }
        canvas.width = dstWidth;
        canvas.height = dstHeight;
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, dstWidth, dstHeight);
        if (this.autoDetectTransparency) {
            this.__imageData = ctx.getImageData(0, 0, dstWidth, dstHeight);
            for (let y = 0; y < dstHeight; y++) {
                for (let x = 0; x < dstWidth; x++) {
                    const alpha = this.__imageData.data[(x + y * dstWidth) * 4 + 3];
                    if (alpha < 1) {
                        this.__hasTransparentPixels = true;
                        return canvas;
                    }
                }
            }
            this.__hasTransparentPixels = false;
        }
        return canvas;
    }
    generateTextureFromBasis(uint8Array, options) {
        var _a;
        this.__startedToLoad = true;
        if (typeof BASIS === 'undefined') {
            console.error('Failed to call BASIS() function. Please check to import basis_transcoder.js.');
        }
        // download basis_transcoder.wasm once
        if (!Texture.__loadedBasisFunc) {
            Texture.__loadedBasisFunc = true;
            Texture.__basisLoadPromise = new Promise((resolve) => {
                BASIS().then((basisTransCoder) => {
                    const { initializeBasis } = basisTransCoder;
                    initializeBasis();
                    Texture.__BasisFile = basisTransCoder.BasisFile;
                    this.__setBasisTexture(uint8Array, options);
                    resolve();
                });
            });
        }
        else {
            // already download basis_transcoder.wasm or not
            if (Texture.__BasisFile) {
                this.__setBasisTexture(uint8Array, options);
            }
            else {
                (_a = Texture.__basisLoadPromise) === null || _a === void 0 ? void 0 : _a.then(() => {
                    this.__setBasisTexture(uint8Array, options);
                });
            }
        }
    }
    __setBasisTexture(uint8Array, { level = 0, internalFormat = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_0__["PixelFormat"].RGBA, format = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_0__["PixelFormat"].RGBA, type = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].UnsignedByte, magFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Linear, minFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].LinearMipmapLinear, wrapS = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Repeat, wrapT = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Repeat, generateMipmap = true, anisotropy = true, isPremultipliedAlpha = false } = {}) {
        this.__startedToLoad = true;
        const basisFile = new Texture.__BasisFile(uint8Array);
        const width = basisFile.getImageWidth(0, 0);
        const height = basisFile.getImageHeight(0, 0);
        if (!basisFile.startTranscoding()) {
            console.error("failed to start transcoding.");
            basisFile.close();
            basisFile.delete();
            return;
        }
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getWebGLResourceRepository();
        const texture = webGLResourceRepository.createCompressedTextureFromBasis(basisFile, {
            border: 0, format, type, magFilter, minFilter, wrapS, wrapT, anisotropy, isPremultipliedAlpha
        });
        this.cgApiResourceUid = texture;
        this.__isTextureReady = true;
        _AbstractTexture__WEBPACK_IMPORTED_MODULE_3__["default"].__textureMap.set(texture, this);
        basisFile.close();
        basisFile.delete();
    }
    generateTextureFromImage(image, { level = 0, internalFormat = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_0__["PixelFormat"].RGBA, format = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_0__["PixelFormat"].RGBA, type = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].UnsignedByte, magFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Linear, minFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Linear, wrapS = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Repeat, wrapT = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Repeat, generateMipmap = true, anisotropy = true, isPremultipliedAlpha = false } = {}) {
        this.__startedToLoad = true;
        this.__htmlImageElement = image;
        let img;
        if (this.autoResize || this.autoDetectTransparency) {
            img = this.__getResizedCanvas(image, _core_Config__WEBPACK_IMPORTED_MODULE_5__["default"].maxSizeLimitOfNonCompressedTexture);
            this.__htmlCanvasElement = img;
        }
        else {
            img = image;
        }
        this.__width = img.width;
        this.__height = img.height;
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getWebGLResourceRepository();
        let texture = webGLResourceRepository.createTexture(img, {
            level, internalFormat,
            width: this.__width, height: this.__height, border: 0,
            format, type, magFilter, minFilter, wrapS, wrapT, generateMipmap, anisotropy, isPremultipliedAlpha
        });
        this.cgApiResourceUid = texture;
        this.__isTextureReady = true;
        this.__uri = image.src;
        _AbstractTexture__WEBPACK_IMPORTED_MODULE_3__["default"].__textureMap.set(texture, this);
    }
    generateTextureFromUri(imageUri, { level = 0, internalFormat = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_0__["PixelFormat"].RGBA, format = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_0__["PixelFormat"].RGBA, type = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].UnsignedByte, magFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Linear, minFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Linear, wrapS = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Repeat, wrapT = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Repeat, generateMipmap = true, anisotropy = true, isPremultipliedAlpha = false } = {}) {
        this.__uri = imageUri;
        this.__startedToLoad = true;
        return new Promise((resolve, reject) => {
            this.__img = new Image();
            if (!imageUri.match(/^data:/)) {
                this.__img.crossOrigin = 'Anonymous';
            }
            this.__img.onload = () => {
                this.__htmlImageElement = this.__img;
                let img;
                if (this.autoResize || this.autoDetectTransparency) {
                    img = this.__getResizedCanvas(this.__img, _core_Config__WEBPACK_IMPORTED_MODULE_5__["default"].maxSizeLimitOfNonCompressedTexture);
                    this.__htmlCanvasElement = img;
                }
                else {
                    img = this.__img;
                }
                this.__width = img.width;
                this.__height = img.height;
                const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getWebGLResourceRepository();
                let texture = webGLResourceRepository.createTexture(img, {
                    level, internalFormat,
                    width: this.__width, height: this.__height, border: 0,
                    format, type, magFilter, minFilter, wrapS, wrapT, generateMipmap, anisotropy, isPremultipliedAlpha
                });
                this.cgApiResourceUid = texture;
                this.__isTextureReady = true;
                _AbstractTexture__WEBPACK_IMPORTED_MODULE_3__["default"].__textureMap.set(texture, this);
                resolve();
            };
            this.__img.src = imageUri;
        });
    }
    generate1x1TextureFrom(rgbaStr = "rgba(255,255,255,1)") {
        var canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = rgbaStr;
        ctx.fillRect(0, 0, 1, 1);
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getWebGLResourceRepository();
        const texture = webGLResourceRepository.createTexture(canvas, {
            level: 0, internalFormat: _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_0__["PixelFormat"].RGBA, width: 1, height: 1,
            border: 0, format: _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_0__["PixelFormat"].RGBA, type: _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].UnsignedByte, magFilter: _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Nearest, minFilter: _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Nearest,
            wrapS: _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].ClampToEdge, wrapT: _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].ClampToEdge, generateMipmap: false, anisotropy: false, isPremultipliedAlpha: true
        });
        this.cgApiResourceUid = texture;
        this.__isTextureReady = true;
        _AbstractTexture__WEBPACK_IMPORTED_MODULE_3__["default"].__textureMap.set(texture, this);
    }
    generateTextureFromTypedArray(typedArray, { level = 0, internalFormat = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_0__["PixelFormat"].RGBA, format = _definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_0__["PixelFormat"].RGBA, magFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Linear, minFilter = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].LinearMipmapLinear, wrapS = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Repeat, wrapT = _definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Repeat, generateMipmap = true, anisotropy = true, isPremultipliedAlpha = false } = {}) {
        const type = _definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].fromTypedArray(typedArray);
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getWebGLResourceRepository();
        let texture = webGLResourceRepository.createTexture(typedArray, {
            level, internalFormat,
            width: this.__width, height: this.__height, border: 0,
            format, type, magFilter, minFilter, wrapS, wrapT, generateMipmap, anisotropy, isPremultipliedAlpha
        });
        this.cgApiResourceUid = texture;
        this.__isTextureReady = true;
    }
    importWebGLTextureDirectly(webGLTexture, width = 0, height = 0) {
        this.__width = width;
        this.__height = height;
        const webGLResourceRepository = _renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getWebGLResourceRepository();
        const texture = webGLResourceRepository.setWebGLTextureDirectly(webGLTexture);
        this.cgApiResourceUid = texture;
        this.__startedToLoad = true;
        this.__isTextureReady = true;
        _AbstractTexture__WEBPACK_IMPORTED_MODULE_3__["default"].__textureMap.set(texture, this);
    }
}
Texture.__loadedBasisFunc = false;


/***/ }),

/***/ "./src/foundation/textures/TextureDataFloat.ts":
/*!*****************************************************!*\
  !*** ./src/foundation/textures/TextureDataFloat.ts ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TextureDataFloat; });
class TextureDataFloat {
    constructor(width, height, channels) {
        this.__channels = channels;
        this.__width = width;
        this.__height = height;
        this.__data = new Float32Array(width * height * channels);
    }
    resize(width, height, channels) {
        this.__width = width;
        this.__height = height;
        this.__channels = channels;
        this.__data = new Float32Array(TextureDataFloat.transfer(this.__data.buffer, width * height * channels * 4));
    }
    setPixelAtChannel(x, y, channelIdx, value) {
        this.__data[y * this.__width * this.__channels + x * this.__channels + channelIdx] = value;
    }
    get width() {
        return this.__width;
    }
    get height() {
        return this.__height;
    }
    get data() {
        return this.__data;
    }
    getPixel(x, y, channelIdx) {
        return this.__data[y * this.__width * this.__channels + x * this.__channels + channelIdx];
    }
    getPixelAs(x, y, channels, typeClass) {
        if (channels === 3) {
            return new typeClass(this.__data[y * this.__width * this.__channels + x * this.__channels + 0], this.__data[y * this.__width * this.__channels + x * this.__channels + 1], this.__data[y * this.__width * this.__channels + x * this.__channels + 2]);
        }
        else if (channels === 4) {
            return new typeClass(this.__data[y * this.__width * this.__channels + x * this.__channels + 0], this.__data[y * this.__width * this.__channels + x * this.__channels + 1], this.__data[y * this.__width * this.__channels + x * this.__channels + 2], this.__data[y * this.__width * this.__channels + x * this.__channels + 3]);
        }
    }
    getPixelAsArray(x, y) {
        const array = [];
        for (let i = 0; i < this.__channels; i++) {
            array.push(this.__data[y * this.__width * this.__channels + x * this.__channels + i]);
        }
        return array;
    }
    initialize(width, height, channels) {
        this.__width = width;
        this.__height = height;
        this.__channels = channels;
        this.__data = new Float32Array(width * height * channels);
    }
    static transfer(source, length) {
        source = Object(source);
        var dest = new ArrayBuffer(length);
        if (!(source instanceof ArrayBuffer) || !(dest instanceof ArrayBuffer)) {
            throw new TypeError('Source and destination must be ArrayBuffer instances');
        }
        if (dest.byteLength >= source.byteLength) {
            var nextOffset = 0;
            var leftBytes = source.byteLength;
            var wordSizes = [8, 4, 2, 1];
            wordSizes.forEach(function (_wordSize_) {
                if (leftBytes >= _wordSize_) {
                    var done = transferWith(_wordSize_, source, dest, nextOffset, leftBytes);
                    nextOffset = done.nextOffset;
                    leftBytes = done.leftBytes;
                }
            });
        }
        return dest;
        function transferWith(wordSize, source, dest, nextOffset, leftBytes) {
            var ViewClass = Uint8Array;
            switch (wordSize) {
                case 8:
                    ViewClass = Float64Array;
                    break;
                case 4:
                    ViewClass = Float32Array;
                    break;
                case 2:
                    ViewClass = Uint16Array;
                    break;
                case 1:
                    ViewClass = Uint8Array;
                    break;
                default:
                    ViewClass = Uint8Array;
                    break;
            }
            var view_source = new ViewClass(source, nextOffset, Math.trunc(leftBytes / wordSize));
            var view_dest = new ViewClass(dest, nextOffset, Math.trunc(leftBytes / wordSize));
            for (var i = 0; i < view_dest.length; i++) {
                view_dest[i] = view_source[i];
            }
            return {
                nextOffset: view_source.byteOffset + view_source.byteLength,
                leftBytes: source.byteLength - (view_source.byteOffset + view_source.byteLength)
            };
        }
    }
}


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _foundation_core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./foundation/core/EntityRepository */ "./src/foundation/core/EntityRepository.ts");
/* harmony import */ var _foundation_core_Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation/core/Entity */ "./src/foundation/core/Entity.ts");
/* harmony import */ var _foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation/core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _foundation_components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation/components/TransformComponent */ "./src/foundation/components/TransformComponent.ts");
/* harmony import */ var _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation/components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _foundation_components_MeshComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation/components/MeshComponent */ "./src/foundation/components/MeshComponent.ts");
/* harmony import */ var _foundation_components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./foundation/components/MeshRendererComponent */ "./src/foundation/components/MeshRendererComponent.ts");
/* harmony import */ var _foundation_geometry_Primitive__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./foundation/geometry/Primitive */ "./src/foundation/geometry/Primitive.ts");
/* harmony import */ var _foundation_system_System__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./foundation/system/System */ "./src/foundation/system/System.ts");
/* harmony import */ var _foundation_math_Scalar__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./foundation/math/Scalar */ "./src/foundation/math/Scalar.ts");
/* harmony import */ var _foundation_math_Vector2__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./foundation/math/Vector2 */ "./src/foundation/math/Vector2.ts");
/* harmony import */ var _foundation_math_Vector3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./foundation/math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _foundation_math_Vector4__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./foundation/math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _foundation_math_MutableVector2__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./foundation/math/MutableVector2 */ "./src/foundation/math/MutableVector2.ts");
/* harmony import */ var _foundation_math_MutableVector3__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./foundation/math/MutableVector3 */ "./src/foundation/math/MutableVector3.ts");
/* harmony import */ var _foundation_math_MutableVector4__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./foundation/math/MutableVector4 */ "./src/foundation/math/MutableVector4.ts");
/* harmony import */ var _foundation_math_Matrix22__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./foundation/math/Matrix22 */ "./src/foundation/math/Matrix22.ts");
/* harmony import */ var _foundation_math_Matrix33__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./foundation/math/Matrix33 */ "./src/foundation/math/Matrix33.ts");
/* harmony import */ var _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./foundation/math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _foundation_math_MutableMatrix22__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./foundation/math/MutableMatrix22 */ "./src/foundation/math/MutableMatrix22.ts");
/* harmony import */ var _foundation_math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./foundation/math/MutableMatrix33 */ "./src/foundation/math/MutableMatrix33.ts");
/* harmony import */ var _foundation_math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./foundation/math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _foundation_importer_Gltf1Importer__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./foundation/importer/Gltf1Importer */ "./src/foundation/importer/Gltf1Importer.ts");
/* harmony import */ var _foundation_importer_Gltf2Importer__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./foundation/importer/Gltf2Importer */ "./src/foundation/importer/Gltf2Importer.ts");
/* harmony import */ var _foundation_importer_DrcPointCloudImporter__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./foundation/importer/DrcPointCloudImporter */ "./src/foundation/importer/DrcPointCloudImporter.ts");
/* harmony import */ var _foundation_importer_GltfImporter__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./foundation/importer/GltfImporter */ "./src/foundation/importer/GltfImporter.ts");
/* harmony import */ var _foundation_exporter_Gltf2Exporter__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./foundation/exporter/Gltf2Exporter */ "./src/foundation/exporter/Gltf2Exporter.ts");
/* harmony import */ var _foundation_importer_ModelConverter__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./foundation/importer/ModelConverter */ "./src/foundation/importer/ModelConverter.ts");
/* harmony import */ var _foundation_system_ModuleManager__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./foundation/system/ModuleManager */ "./src/foundation/system/ModuleManager.ts");
/* harmony import */ var _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./foundation/core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./foundation/components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _foundation_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./foundation/components/AnimationComponent */ "./src/foundation/components/AnimationComponent.ts");
/* harmony import */ var _foundation_components_LightComponent__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./foundation/components/LightComponent */ "./src/foundation/components/LightComponent.ts");
/* harmony import */ var _foundation_textures_CubeTexture__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./foundation/textures/CubeTexture */ "./src/foundation/textures/CubeTexture.ts");
/* harmony import */ var _foundation_components_CameraControllerComponent__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./foundation/components/CameraControllerComponent */ "./src/foundation/components/CameraControllerComponent.ts");
/* harmony import */ var _foundation_importer_FormatDetector__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./foundation/importer/FormatDetector */ "./src/foundation/importer/FormatDetector.ts");
/* harmony import */ var _foundation_core_Config__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./foundation/core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _foundation_geometry_Plane__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./foundation/geometry/Plane */ "./src/foundation/geometry/Plane.ts");
/* harmony import */ var _foundation_geometry_Sphere__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./foundation/geometry/Sphere */ "./src/foundation/geometry/Sphere.ts");
/* harmony import */ var _foundation_materials_core_Material__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./foundation/materials/core/Material */ "./src/foundation/materials/core/Material.ts");
/* harmony import */ var _foundation_helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./foundation/helpers/MaterialHelper */ "./src/foundation/helpers/MaterialHelper.ts");
/* harmony import */ var _foundation_renderer_RenderPass__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./foundation/renderer/RenderPass */ "./src/foundation/renderer/RenderPass.ts");
/* harmony import */ var _foundation_renderer_FrameBuffer__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./foundation/renderer/FrameBuffer */ "./src/foundation/renderer/FrameBuffer.ts");
/* harmony import */ var _foundation_renderer_Expression__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./foundation/renderer/Expression */ "./src/foundation/renderer/Expression.ts");
/* harmony import */ var _foundation_textures_RenderTargetTexture__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./foundation/textures/RenderTargetTexture */ "./src/foundation/textures/RenderTargetTexture.ts");
/* harmony import */ var _foundation_textures_RenderBuffer__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./foundation/textures/RenderBuffer */ "./src/foundation/textures/RenderBuffer.ts");
/* harmony import */ var _foundation_helpers_RenderableHelper__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./foundation/helpers/RenderableHelper */ "./src/foundation/helpers/RenderableHelper.ts");
/* harmony import */ var _foundation_textures_Texture__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./foundation/textures/Texture */ "./src/foundation/textures/Texture.ts");
/* harmony import */ var _foundation_helpers_EntityHelper__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./foundation/helpers/EntityHelper */ "./src/foundation/helpers/EntityHelper.ts");
/* harmony import */ var _foundation_math_MathClassUtil__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./foundation/math/MathClassUtil */ "./src/foundation/math/MathClassUtil.ts");
/* harmony import */ var _foundation_geometry_Mesh__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./foundation/geometry/Mesh */ "./src/foundation/geometry/Mesh.ts");
/* harmony import */ var _foundation_core_Component__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./foundation/core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _foundation_materials_singles_EnvConstantSingleMaterialNode__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./foundation/materials/singles/EnvConstantSingleMaterialNode */ "./src/foundation/materials/singles/EnvConstantSingleMaterialNode.ts");
/* harmony import */ var _foundation_materials_singles_ShadowMapDecodeClassicSingleMaterialNode__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./foundation/materials/singles/ShadowMapDecodeClassicSingleMaterialNode */ "./src/foundation/materials/singles/ShadowMapDecodeClassicSingleMaterialNode.ts");
/* harmony import */ var _foundation_core_RnObject__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./foundation/core/RnObject */ "./src/foundation/core/RnObject.ts");
/* harmony import */ var _foundation_importer_VRMImporter__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./foundation/importer/VRMImporter */ "./src/foundation/importer/VRMImporter.ts");
/* harmony import */ var _foundation_components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./foundation/components/BlendShapeComponent */ "./src/foundation/components/BlendShapeComponent.ts");
/* harmony import */ var _foundation_importer_AnimationAssigner__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./foundation/importer/AnimationAssigner */ "./src/foundation/importer/AnimationAssigner.ts");
/* harmony import */ var _foundation_misc_MiscUtil__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./foundation/misc/MiscUtil */ "./src/foundation/misc/MiscUtil.ts");
/* harmony import */ var _foundation_math_MathUtil__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./foundation/math/MathUtil */ "./src/foundation/math/MathUtil.ts");
/* harmony import */ var _foundation_cameras_OrbitCameraController__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./foundation/cameras/OrbitCameraController */ "./src/foundation/cameras/OrbitCameraController.ts");
/* harmony import */ var _foundation_cameras_WalkThroughCameraController__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./foundation/cameras/WalkThroughCameraController */ "./src/foundation/cameras/WalkThroughCameraController.ts");
/* harmony import */ var _foundation_materials_core_ShaderityUtility__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./foundation/materials/core/ShaderityUtility */ "./src/foundation/materials/core/ShaderityUtility.ts");
/* harmony import */ var _foundation_materials_core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./foundation/materials/core/AbstractMaterialNode */ "./src/foundation/materials/core/AbstractMaterialNode.ts");
/* harmony import */ var _foundation_materials_nodes_ConstantVariableShaderNode__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./foundation/materials/nodes/ConstantVariableShaderNode */ "./src/foundation/materials/nodes/ConstantVariableShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_AddShaderNode__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./foundation/materials/nodes/AddShaderNode */ "./src/foundation/materials/nodes/AddShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_DotProductShaderNode__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./foundation/materials/nodes/DotProductShaderNode */ "./src/foundation/materials/nodes/DotProductShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_MultiplyShaderNode__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./foundation/materials/nodes/MultiplyShaderNode */ "./src/foundation/materials/nodes/MultiplyShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_OutPositionShaderNode__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./foundation/materials/nodes/OutPositionShaderNode */ "./src/foundation/materials/nodes/OutPositionShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_OutColorShaderNode__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./foundation/materials/nodes/OutColorShaderNode */ "./src/foundation/materials/nodes/OutColorShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_ScalarToVector4ShaderNode__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./foundation/materials/nodes/ScalarToVector4ShaderNode */ "./src/foundation/materials/nodes/ScalarToVector4ShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_Vector3AndScalarToVector4ShaderNode__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./foundation/materials/nodes/Vector3AndScalarToVector4ShaderNode */ "./src/foundation/materials/nodes/Vector3AndScalarToVector4ShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_AttributePositionShaderNode__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./foundation/materials/nodes/AttributePositionShaderNode */ "./src/foundation/materials/nodes/AttributePositionShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_AttributeNormalShaderNode__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./foundation/materials/nodes/AttributeNormalShaderNode */ "./src/foundation/materials/nodes/AttributeNormalShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_WorldMatrixShaderNode__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./foundation/materials/nodes/WorldMatrixShaderNode */ "./src/foundation/materials/nodes/WorldMatrixShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_ViewMatrixShaderNode__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./foundation/materials/nodes/ViewMatrixShaderNode */ "./src/foundation/materials/nodes/ViewMatrixShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_NormalMatrixShaderNode__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./foundation/materials/nodes/NormalMatrixShaderNode */ "./src/foundation/materials/nodes/NormalMatrixShaderNode.ts");
/* harmony import */ var _foundation_math_AABB__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./foundation/math/AABB */ "./src/foundation/math/AABB.ts");
/* harmony import */ var _foundation_materials_nodes_ProjectionMatrixShaderNode__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./foundation/materials/nodes/ProjectionMatrixShaderNode */ "./src/foundation/materials/nodes/ProjectionMatrixShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_VaryingInVariableShaderNode__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./foundation/materials/nodes/VaryingInVariableShaderNode */ "./src/foundation/materials/nodes/VaryingInVariableShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_VaryingOutVariableShaderNode__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./foundation/materials/nodes/VaryingOutVariableShaderNode */ "./src/foundation/materials/nodes/VaryingOutVariableShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_UniformDataShaderNode__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./foundation/materials/nodes/UniformDataShaderNode */ "./src/foundation/materials/nodes/UniformDataShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_NormalizeShaderNode__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./foundation/materials/nodes/NormalizeShaderNode */ "./src/foundation/materials/nodes/NormalizeShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_IfStatementShaderNode__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./foundation/materials/nodes/IfStatementShaderNode */ "./src/foundation/materials/nodes/IfStatementShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_BlockBeginShaderNode__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./foundation/materials/nodes/BlockBeginShaderNode */ "./src/foundation/materials/nodes/BlockBeginShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_BlockEndShaderNode__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./foundation/materials/nodes/BlockEndShaderNode */ "./src/foundation/materials/nodes/BlockEndShaderNode.ts");
/* harmony import */ var _foundation_materials_nodes_GreaterShaderNode__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./foundation/materials/nodes/GreaterShaderNode */ "./src/foundation/materials/nodes/GreaterShaderNode.ts");
/* harmony import */ var _foundation_materials_core_ShaderGraphResolver__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./foundation/materials/core/ShaderGraphResolver */ "./src/foundation/materials/core/ShaderGraphResolver.ts");
/* harmony import */ var _foundation_math_Quaternion__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./foundation/math/Quaternion */ "./src/foundation/math/Quaternion.ts");
/* harmony import */ var _foundation_math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./foundation/math/MutableQuaternion */ "./src/foundation/math/MutableQuaternion.ts");
/* harmony import */ var _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./foundation/definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _foundation_definitions_LightType__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./foundation/definitions/LightType */ "./src/foundation/definitions/LightType.ts");
/* harmony import */ var _foundation_definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./foundation/definitions/AlphaMode */ "./src/foundation/definitions/AlphaMode.ts");
/* harmony import */ var _foundation_definitions_CameraType__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./foundation/definitions/CameraType */ "./src/foundation/definitions/CameraType.ts");
/* harmony import */ var _foundation_definitions_ShaderType__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./foundation/definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./foundation/definitions/TextureParameter */ "./src/foundation/definitions/TextureParameter.ts");
/* harmony import */ var _foundation_definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./foundation/definitions/BoneDataType */ "./src/foundation/definitions/BoneDataType.ts");
/* harmony import */ var _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./foundation/definitions/PixelFormat */ "./src/foundation/definitions/PixelFormat.ts");
/* harmony import */ var _foundation_definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./foundation/definitions/ProcessApproach */ "./src/foundation/definitions/ProcessApproach.ts");
/* harmony import */ var _foundation_definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./foundation/definitions/PrimitiveMode */ "./src/foundation/definitions/PrimitiveMode.ts");
/* harmony import */ var _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./foundation/definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./foundation/definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./foundation/definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _foundation_definitions_CameraControllerType__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./foundation/definitions/CameraControllerType */ "./src/foundation/definitions/CameraControllerType.ts");
/* harmony import */ var _foundation_definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./foundation/definitions/HdriFormat */ "./src/foundation/definitions/HdriFormat.ts");
/* harmony import */ var _foundation_definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./foundation/definitions/ShadingModel */ "./src/foundation/definitions/ShadingModel.ts");
/* harmony import */ var _foundation_definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./foundation/definitions/AnimationAttribute */ "./src/foundation/definitions/AnimationAttribute.ts");
/* harmony import */ var _foundation_definitions_AnimationInterpolation__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./foundation/definitions/AnimationInterpolation */ "./src/foundation/definitions/AnimationInterpolation.ts");


























































































const _VERSION = __webpack_require__(/*! ./../VERSION-FILE */ "./VERSION-FILE").default;
// definitions


















/* harmony default export */ __webpack_exports__["default"] = ({
    Entity: _foundation_core_Entity__WEBPACK_IMPORTED_MODULE_1__["default"],
    EntityRepository: _foundation_core_EntityRepository__WEBPACK_IMPORTED_MODULE_0__["default"],
    ComponentRepository: _foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_2__["default"],
    TransformComponent: _foundation_components_TransformComponent__WEBPACK_IMPORTED_MODULE_3__["default"],
    SceneGraphComponent: _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_4__["default"],
    MeshComponent: _foundation_components_MeshComponent__WEBPACK_IMPORTED_MODULE_5__["default"],
    MeshRendererComponent: _foundation_components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_6__["default"],
    AABB: _foundation_math_AABB__WEBPACK_IMPORTED_MODULE_77__["default"],
    Primitive: _foundation_geometry_Primitive__WEBPACK_IMPORTED_MODULE_7__["default"],
    System: _foundation_system_System__WEBPACK_IMPORTED_MODULE_8__["default"],
    Scalar: _foundation_math_Scalar__WEBPACK_IMPORTED_MODULE_9__["default"],
    Vector2: _foundation_math_Vector2__WEBPACK_IMPORTED_MODULE_10__["default"],
    Vector3: _foundation_math_Vector3__WEBPACK_IMPORTED_MODULE_11__["default"],
    Vector4: _foundation_math_Vector4__WEBPACK_IMPORTED_MODULE_12__["default"],
    MutableVector2: _foundation_math_MutableVector2__WEBPACK_IMPORTED_MODULE_13__["default"],
    MutableVector3: _foundation_math_MutableVector3__WEBPACK_IMPORTED_MODULE_14__["default"],
    MutableVector4: _foundation_math_MutableVector4__WEBPACK_IMPORTED_MODULE_15__["default"],
    Matrix22: _foundation_math_Matrix22__WEBPACK_IMPORTED_MODULE_16__["default"],
    Matrix33: _foundation_math_Matrix33__WEBPACK_IMPORTED_MODULE_17__["default"],
    Matrix44: _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_18__["default"],
    MutableMatrix22: _foundation_math_MutableMatrix22__WEBPACK_IMPORTED_MODULE_19__["default"],
    MutableMatrix33: _foundation_math_MutableMatrix33__WEBPACK_IMPORTED_MODULE_20__["default"],
    MutableMatrix44: _foundation_math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_21__["default"],
    Gltf1Importer: _foundation_importer_Gltf1Importer__WEBPACK_IMPORTED_MODULE_22__["default"],
    Gltf2Importer: _foundation_importer_Gltf2Importer__WEBPACK_IMPORTED_MODULE_23__["default"],
    DrcPointCloudImporter: _foundation_importer_DrcPointCloudImporter__WEBPACK_IMPORTED_MODULE_24__["default"],
    GltfImporter: _foundation_importer_GltfImporter__WEBPACK_IMPORTED_MODULE_25__["default"],
    ModelConverter: _foundation_importer_ModelConverter__WEBPACK_IMPORTED_MODULE_27__["default"],
    ModuleManager: _foundation_system_ModuleManager__WEBPACK_IMPORTED_MODULE_28__["default"],
    MemoryManager: _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_29__["default"],
    CameraComponent: _foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_30__["default"],
    AnimationComponent: _foundation_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_31__["default"],
    LightComponent: _foundation_components_LightComponent__WEBPACK_IMPORTED_MODULE_32__["default"],
    CubeTexture: _foundation_textures_CubeTexture__WEBPACK_IMPORTED_MODULE_33__["default"],
    CameraControllerComponent: _foundation_components_CameraControllerComponent__WEBPACK_IMPORTED_MODULE_34__["default"],
    Gltf2Exporter: _foundation_exporter_Gltf2Exporter__WEBPACK_IMPORTED_MODULE_26__["default"],
    detectFormat: _foundation_importer_FormatDetector__WEBPACK_IMPORTED_MODULE_35__["default"],
    Config: _foundation_core_Config__WEBPACK_IMPORTED_MODULE_36__["default"],
    Plane: _foundation_geometry_Plane__WEBPACK_IMPORTED_MODULE_37__["default"],
    Sphere: _foundation_geometry_Sphere__WEBPACK_IMPORTED_MODULE_38__["default"],
    Material: _foundation_materials_core_Material__WEBPACK_IMPORTED_MODULE_39__["default"],
    MaterialHelper: _foundation_helpers_MaterialHelper__WEBPACK_IMPORTED_MODULE_40__["default"],
    RenderPass: _foundation_renderer_RenderPass__WEBPACK_IMPORTED_MODULE_41__["default"],
    FrameBuffer: _foundation_renderer_FrameBuffer__WEBPACK_IMPORTED_MODULE_42__["default"],
    Expression: _foundation_renderer_Expression__WEBPACK_IMPORTED_MODULE_43__["default"],
    RenderTargetTexture: _foundation_textures_RenderTargetTexture__WEBPACK_IMPORTED_MODULE_44__["default"],
    RenderBuffer: _foundation_textures_RenderBuffer__WEBPACK_IMPORTED_MODULE_45__["default"],
    RenderableHelper: _foundation_helpers_RenderableHelper__WEBPACK_IMPORTED_MODULE_46__["default"],
    Texture: _foundation_textures_Texture__WEBPACK_IMPORTED_MODULE_47__["default"],
    EntityHelper: _foundation_helpers_EntityHelper__WEBPACK_IMPORTED_MODULE_48__["default"],
    MathClassUtil: _foundation_math_MathClassUtil__WEBPACK_IMPORTED_MODULE_49__["default"],
    Mesh: _foundation_geometry_Mesh__WEBPACK_IMPORTED_MODULE_50__["default"],
    Component: _foundation_core_Component__WEBPACK_IMPORTED_MODULE_51__["default"],
    EnvConstantSingleMaterialNode: _foundation_materials_singles_EnvConstantSingleMaterialNode__WEBPACK_IMPORTED_MODULE_52__["default"],
    ShadowMapDecodeClassicSingleMaterialNode: _foundation_materials_singles_ShadowMapDecodeClassicSingleMaterialNode__WEBPACK_IMPORTED_MODULE_53__["default"],
    RnObject: _foundation_core_RnObject__WEBPACK_IMPORTED_MODULE_54__["default"],
    VRMImporter: _foundation_importer_VRMImporter__WEBPACK_IMPORTED_MODULE_55__["default"],
    BlendShapeComponent: _foundation_components_BlendShapeComponent__WEBPACK_IMPORTED_MODULE_56__["default"],
    AnimationAssigner: _foundation_importer_AnimationAssigner__WEBPACK_IMPORTED_MODULE_57__["default"],
    MiscUtil: _foundation_misc_MiscUtil__WEBPACK_IMPORTED_MODULE_58__["MiscUtil"],
    MathUtil: _foundation_math_MathUtil__WEBPACK_IMPORTED_MODULE_59__["MathUtil"],
    OrbitCameraController: _foundation_cameras_OrbitCameraController__WEBPACK_IMPORTED_MODULE_60__["default"],
    WalkThroughCameraController: _foundation_cameras_WalkThroughCameraController__WEBPACK_IMPORTED_MODULE_61__["default"],
    ShaderityUtility: _foundation_materials_core_ShaderityUtility__WEBPACK_IMPORTED_MODULE_62__["default"],
    AbstractMaterialNode: _foundation_materials_core_AbstractMaterialNode__WEBPACK_IMPORTED_MODULE_63__["default"],
    ConstantVariableShaderNode: _foundation_materials_nodes_ConstantVariableShaderNode__WEBPACK_IMPORTED_MODULE_64__["default"],
    AddShaderNode: _foundation_materials_nodes_AddShaderNode__WEBPACK_IMPORTED_MODULE_65__["default"],
    DotProductShaderNode: _foundation_materials_nodes_DotProductShaderNode__WEBPACK_IMPORTED_MODULE_66__["default"],
    MultiplyShaderNode: _foundation_materials_nodes_MultiplyShaderNode__WEBPACK_IMPORTED_MODULE_67__["default"],
    OutPositionShaderNode: _foundation_materials_nodes_OutPositionShaderNode__WEBPACK_IMPORTED_MODULE_68__["default"],
    OutColorShaderNode: _foundation_materials_nodes_OutColorShaderNode__WEBPACK_IMPORTED_MODULE_69__["default"],
    ScalarToVector4ShaderNode: _foundation_materials_nodes_ScalarToVector4ShaderNode__WEBPACK_IMPORTED_MODULE_70__["default"],
    Vector3AndScalarToVector4ShaderNode: _foundation_materials_nodes_Vector3AndScalarToVector4ShaderNode__WEBPACK_IMPORTED_MODULE_71__["default"],
    AttributePositionShaderNode: _foundation_materials_nodes_AttributePositionShaderNode__WEBPACK_IMPORTED_MODULE_72__["default"],
    AttributeNormalShaderNode: _foundation_materials_nodes_AttributeNormalShaderNode__WEBPACK_IMPORTED_MODULE_73__["default"],
    WorldMatrixShaderNode: _foundation_materials_nodes_WorldMatrixShaderNode__WEBPACK_IMPORTED_MODULE_74__["default"],
    ViewMatrixShaderNode: _foundation_materials_nodes_ViewMatrixShaderNode__WEBPACK_IMPORTED_MODULE_75__["default"],
    ProjectionMatrixShaderNode: _foundation_materials_nodes_ProjectionMatrixShaderNode__WEBPACK_IMPORTED_MODULE_78__["default"],
    VaryingInVariableShaderNode: _foundation_materials_nodes_VaryingInVariableShaderNode__WEBPACK_IMPORTED_MODULE_79__["default"],
    VaryingOutVariableShaderNode: _foundation_materials_nodes_VaryingOutVariableShaderNode__WEBPACK_IMPORTED_MODULE_80__["default"],
    NormalMatrixShaderNode: _foundation_materials_nodes_NormalMatrixShaderNode__WEBPACK_IMPORTED_MODULE_76__["default"],
    UniformDataShaderNode: _foundation_materials_nodes_UniformDataShaderNode__WEBPACK_IMPORTED_MODULE_81__["default"],
    NormalizeShaderNode: _foundation_materials_nodes_NormalizeShaderNode__WEBPACK_IMPORTED_MODULE_82__["default"],
    IfStatementShaderNode: _foundation_materials_nodes_IfStatementShaderNode__WEBPACK_IMPORTED_MODULE_83__["default"],
    BlockBeginShaderNode: _foundation_materials_nodes_BlockBeginShaderNode__WEBPACK_IMPORTED_MODULE_84__["default"],
    BlockEndShaderNode: _foundation_materials_nodes_BlockEndShaderNode__WEBPACK_IMPORTED_MODULE_85__["default"],
    GreaterShaderNode: _foundation_materials_nodes_GreaterShaderNode__WEBPACK_IMPORTED_MODULE_86__["default"],
    ShaderGraphResolver: _foundation_materials_core_ShaderGraphResolver__WEBPACK_IMPORTED_MODULE_87__["default"],
    Quaternion: _foundation_math_Quaternion__WEBPACK_IMPORTED_MODULE_88__["default"],
    MutableQuaternion: _foundation_math_MutableQuaternion__WEBPACK_IMPORTED_MODULE_89__["default"],
    VERSION: _VERSION,
    // Definition Objects
    CompositionType: _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_101__["CompositionType"],
    ShaderType: _foundation_definitions_ShaderType__WEBPACK_IMPORTED_MODULE_94__["ShaderType"],
    PixelFormat: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_97__["PixelFormat"],
    BoneDataType: _foundation_definitions_BoneDataType__WEBPACK_IMPORTED_MODULE_96__["BoneDataType"],
    CameraControllerType: _foundation_definitions_CameraControllerType__WEBPACK_IMPORTED_MODULE_103__["CameraControllerType"],
    AlphaMode: _foundation_definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_92__["AlphaMode"],
    ProcessApproach: _foundation_definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_98__["ProcessApproach"],
    ComponentType: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_102__["ComponentType"],
    VertexAttribute: _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_100__["VertexAttribute"],
    LightType: _foundation_definitions_LightType__WEBPACK_IMPORTED_MODULE_91__["LightType"],
    CameraType: _foundation_definitions_CameraType__WEBPACK_IMPORTED_MODULE_93__["CameraType"],
    ShaderSemantics: _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_90__["ShaderSemantics"],
    TextureParameter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_95__["TextureParameter"],
    PrimitiveMode: _foundation_definitions_PrimitiveMode__WEBPACK_IMPORTED_MODULE_99__["PrimitiveMode"],
    HdriFormat: _foundation_definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_104__["HdriFormat"],
    ShadingModel: _foundation_definitions_ShadingModel__WEBPACK_IMPORTED_MODULE_105__["ShadingModel"],
    AnimationAttribute: _foundation_definitions_AnimationAttribute__WEBPACK_IMPORTED_MODULE_106__["AnimationAttribute"],
    AnimationInterpolation: _foundation_definitions_AnimationInterpolation__WEBPACK_IMPORTED_MODULE_107__["AnimationInterpolation"]
});


/***/ }),

/***/ "./src/pbr/main.ts":
/*!*************************!*\
  !*** ./src/pbr/main.ts ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// This is based from https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/textures/brdfLUT.png
const pbrCookTorranceBrdfLutDataUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAADTED8xAAAAA3NCSVQICAjb4U/gAAAgAElEQVR4nO19Xbfjqo7tJOV9zumHvn///tm7w32wAX0jsJNatbsZa7iEEJgkc0oCk1T5v38BQIW6VltvGwOojt7paFTr3HiqdwVr8FXBk/cM3F7V0TvyfbOPVj9hkNRkzI4CVMC4FtQ6NLS/3aWgVLcVmWq7o2c81UeCGnxDgCP398czTvbq70Onq2tDZCTM8k3PVk0NFg22S2bkAx6gyScBzyDHAeSr5fJ/ZqupNw1sgQ8uBD2gKQglHNk0XhihANWwD+RHmm5WdZnyIUOYPU1yPn4EODuEfj3JAaxUT9ZtgD4FYjK4aEJuBG2WkfNKLSNh9kjTzeqGgS7byM4MZRY3AsBS7nEA4chGlYxAW6GEvOcWg3s24hammdkllnfQT3I2MaDustF0s6rLI649Ux4kCbwIAFrli4FVDiAYOahymOYhngJxej1gjqCVq3LWuL2MP9HZi7LHh2exbvY1IgB49Q4H9FBIV6FW4VOsZ5z6JRTAyYVW3XYyCCAcxJXTcSAY7dnqJwweL/nxZQQAr+5x4CpWF6SrgL0vBB/rSwLCXOjTQcCTDYjn4oDs5VjerG4Y6GIabLv/m1w64KcrexxA2AWrZPD3hR4QClDZxDx7sxUrMu07HVz23Y0Dz1Y3DEyNLp8OCEE5Ctx0ZY8DCLvAt6RV8BFg7QttCFDjgwcZ1+y248fuOEjHgY9WNwySGrN8jRLXGgD5DGdmibALchEAfARYYWpDgNlKCBaZtbdsKQh4ffPyGIrHAWH50aqpmZZnsW6a3efJQXFwhwNiTl4XaoAcGa6qk7Kv+XvPzBrcHEQrYxlW33x3D5R6tHw1HllXtzW6JHt9zf1DLoJ3OYB0FyRdvmlWgDCSCAF8tNgM1t6o2cXuvgL3oGnSpYAGK205rd63/6jmkbI0rNoG3eKAHMTvgtlT3pgbJkyTAqatHF6PB4GlJjcOtGBlt86qWLF/UJMvn3P/HU60WA/C1jmAjPF5+9lT3jkZwiM9U8c/ac3lQoEBLJs7TQZA2wv4aCjY1pjlJqyXuptA94pzFGKRA/Yg1hUYz4kh9HkyKFc9dfx5d04PomUQP8W0xjcSvaZNQVX01dUNg6TGU+pyp++GsVeyx6FjDiB9YA6noDZesUgGcBZB2XiCaS+VimC6VzACLBuzKW8pwUq8nG6FtgcrX0b/I0jVxfP0we10l8lx6CQHkD402udHV7RZ0FuRBJab33H8XIlZLqRH0DKcprgaN40xOUvNvuZoWOyS1HjK7xePGGaJjkN/ggMgVSSeD5j6YdBYpJuEAD4glDz1659z/F5H776j42xBDH+0O5ql8tsDRVzCCPBhDgBrzwdgGmx9zQUJuad2rkF7Ez24r0I/rsYBBKHBtsYsPwe+XgmCgGg6Uvj+PAdADJCOAOBITTr+BRoQF/tgEBCtS1U5lPV4WNxLD5jU3DGL9U+VPNC9pgNJfD/KASgEm158GgGgboq048/SgMzNG0TLcJrM1qWqMRT5PE28wlLegXXS7HexopeYA+dM2hrgaQ6AO/UoAigvbhu0GbuCvyYW9lrpGYDPDc4g0p7ISFdF37UqZ6nXxbypaZZXfg3NXglQnulL1gAFFTPn/dzzAWgh/U1IVyiAtSYWZghlE6DTXCgYc1pNGuSr5gh5M9PSU3rltxPjLFN6qF2gaQKT4QmxhEMYmBAPn5GlBCubEmbYk/1ciI6vZfhVT7PDDfJR33T82tIz9kpgHDRt+/K4I/28dDnEKCkOJG24V/YigARoQQFw5wsAZXQHaQVcZVZu98g7/jyyPc3U0w9NOhFaUm7oHy9TbmwbHHbbdzlgCOEXAHQXYQNrTWxbzmRqD8gsyzVTTUE1r1kyMG08pdn9WX3cdL9kOABl4z4IE+P9Rg7oJg/HDMRqTexaEpkO6/XVjjYeLaje0dhunnxqH/Xx348JU3znbUDMskchXLN7HIDv3QHj2NxUAFU63jqIAHoQW2633A4C2xpxF0NTAHVEwuvo3SKw3y73R3uKAyCf5sJRCPd+NzgAJWgQZ367wUX5vV38CN+EXbGlWYW6I0IbT2lr+BEJbzQ9sftNny4bPj62ZL8KMeWAvprzuskBKZAuU2NoZfOI2iApu01q5LjjtLqhnGo8ZazX95r2+mklSYPxqxDbHAhixRc4ADNuiLcgXA8E8ryJPx/wOuoqnTZ8m1Xl0FjkjLt7s3qq9amSd/AZ47YGeJoDEybMOAAO69Pdml+GRDjCkNsdpd6R802rVc/AtBFKczRXqRKhbrzn3X+U7xcAmxqfRXcha4CCghDlN45LQBtzDiAD65WDn9ByuB4QstlkVxeDANXQOYOb5d22iUtPaY4QdEm2ZgwyZQPWeXuodx7el+IzE9zggOxIOEDHjgQFYo8zMOUiE4Nn3Hy4Mdo1UwcfeHetj+37xHr/2PGb41ODL6AfbRobmF7qQjsexv3idIhsTZqDTmMF+GgbHEC4N4pYzq0HvKowBp+VbnXtlYFQmpaxPUwgtrdr2/GbN8qPsFEece3JcvT+JspjDkRu/lEOQDh75/kAHFliut3Rs4dfjQzIsMEIj7v8uIlyPj9aN3gQ2V927ch19x+E7XJgvE7yirc5AEspHHkAd9e1z062Tau2AYlOwQimxlOad8z0QojgKbiT6H/c/YuyTQPanRYxVPgg7B4HqA3WOQBuYwg52pgy4K4HvKoYxzVQ39OlBqYmVmp9vnU0Eccwdfz4GPpXgwDtiBs00EP1csDa/GHmwW35vFwOgC2szRtRDoB8SB64LyGkzVSGtR7wqoGB1Chqxb2gPpXYqZtd5n3brKbQDwYXlhu+f5sDSLjzjcK+EUbvNEA83f10lsXeIKYBCAcglOTFG8SwaJOUYXUXlsw4r7kRBwK9bpr2je+obZKYvpP53OGAHoqWjWHH9wEQpDRpDrje3RoEyr4A4F+jAR/NJoaT0OtewsbsDoWVDO51LxCfkoS+5+ECqE1xD/5GmRjJDCLst9Hfb/QUB8SwusQ34ovgAMfTKW9tDcGypH49dv9DydE2yXx0lSQtnrGpiZXi6+raTEwvHlO3egbR4OpzXEJzPkGaFvEmf67EszW+EikmxeiBcHOT97WZQJC9xAEoe6kkIJ5nPro6e6AL/lYukwGsLPEh7rJtuYrm+45flw+FgnyR26CYJjzp1l4CjmlLUJQ3DjCladn6F+7IY6cuq63DNAKAQyEig7UYgEJSANklNGcs0TzFEpo/gf4+Hfw+GsgnwQPHYCkNKw5tPYZIA7jbo2L4AntZjIAP/oPeVNVK3GNn7+kLaTYXA9Q+cPkB7BZAvzKs2eVD6O/F9DJfKIfOSUS6QkWNYBPo0Zi9/QYHhAGEbMUNQELTc/DiUAP4Z79JBuUytl3+HujlsOnMY4MtN8s37wX9y3B0HpOEZ/aYzCUPuUeSA1DnQCeywxmEiQ0NI6iGgdkL6jOzEaw2mkVJ4n7V07t3nHHg+9D/LaWlQBwxDI7BO+U3XQyB/3iBZCyaeIa8cphZcAY+DTwDL2/xgJjig/V2PYV7/TlsY/d/CPTPQg7D8U2eXibOfnr4efoIrMjFxpQDkY0CXJAFTTQqFzLNhF63ijgARXhdkrjfTofoZPSA/2Do65emdoG8UJCLAzYTWkZh0KPfFMMGIaaFY45DAdS+ECzcuBDnuRB8aE7yDZX46ZJE813Qh2P+6dDfmP8hcEn9vRw9Xg/wbKdPKF4SMMsiOQBT5k40CAXoEQayC8iApmYo/dw9xmJEiTC26PIU6A3eKYb/8PL4VA9aCXw2TXjMaZnpEDNw0n3BPTgPv8T08vv9tAssME0zHPOBLnwy6FbP7FnQexF6Mk4Q239T+QIh+y3kz6JghnUsnh5lCnUvYXOHA0iEAlh7O5H7530NvWUPx4aZ8bcgyZ/s4H9m+cT8p2MeZn7SK+7xHgfo1NO76b5aY0AIeQ4gSoegq/yVwgGxDSyeekG9uY67sIt4DzfgnuyVKr87CDz1QjbGabtA5NEvRO4O490JgD76e+m+dfRaCjMOgNJgdo6NVZ2cPpXbOOcadC9RXOyGyPuHOXhd7r+iOyOcffmvQyvYIcY6rwerBenvLb4ZE/Q5IKYt8vsJDVrPBfc/azINAkvW5vzIwFcR/8UgcPN13Qc9LeMskJmisK48TaJATyJYDus/BaOTiRMbQV0kaeCsBzBFvEUes69ZdhiyONRS+SbHfgvu52uAbifSD6o3nTq7iWkfrC58vk05IIYasHaoa9IA1noAJuJ1EycPTBun2J+H732DAR/Hrvmg+rHBv9g3b1/6YbheN1MU2sNeFgc/FuQciBjV8PfeantBwYmJ/pq988yuRlHaYwLE2+pvByeLt2raHvCZwt/AB0f9dMekpZECwcnXuxTn/XJsKxR4QzG+Ob5HJPpTTGf2eQT9zJRGvFMGH5z3IelDjQ/si1l4sjxCg41BvoD7XsZhONtP87zCy4WmocBLhzyGiCTHW+xCwUb7dY8GULeG0FtdmI0F2Wd9529YHKsX9QOzl4xZ0oavAcxVqemZnJNzZCyr5mdK/UYmB8RwcZYPyOMSpg1TqjnTEqHwXhwwBn0OfA8OsjfCNx153kYYHEa7Rlhi+cvU/glQEVKkYOVR8j5mYqbn4p99sJWKM7oXLWI+mS6p8pVEaDK9J17Rg5jOmG0bjKMQ8DF6VuJHAWbSr0QgzPi1QcwBxKHAMYPDBBR5TjOYZhGVJ+JAHFUeL0uYftz4Eejfbx1HITxPzDANA+7RqSF/awgI/wM8a0wGZZOloRmonhtre9EqipebmRPeKQkOPLUSsMe58XI+kaisGgStTgpkZZ/2Lr6zJDC6Q4BRAT3+pXXra5DmTDby+2iZOwtQWAHNN8sdSjzls+/bbEN/b1j2jTAjt1bo8XY/Apc8CQXOkiAYM5NodeX5T4Xr2o1e2ynNExx4KhG6m7VvBYE7Bp+A/rRJnQWCQrwTHPSJ/KJwNgYPgO5FD373iAMYNur+5NUmnl49sLR9MA7k8rHMME8Zf8h5/8amw1hxaoftu3zT37sYdPBnBx/eqgcwc32pF6MRM5cnasLLeF7kQIQbf6gNPjySxG+78E/47/tdjqtFZ9A6DmBiJvSGzw6QwbsYmRhskniRpL9aj59xFiRmtVzuxQGTh1n7JyyDNGwDeXHr6oBPDTVSoLOmvX7qoZhFjAjrzv9upFfMbDQiRVMIP7AgvRFv0Dz6ZYof8TZGetbyE7nKdxz5BsRjvVwEI1wS8Oas0nPn9uTi38AKkyWEQYa5/BDW8o27586TJZkIZSD+iM1qEPiOw75j7KdAwiSTDiWXBFE+roZVlYADXinNIEZsN+tlgvA9DmxnUAkS3vHiGYNV4H7Ol38I+i0F0vs5CcTb5+H8tMfeAsqdnFPDXB0R5u7it849swXPeoMDQWNmgHiobRzHrcF9P+ShTf3NYadm8kvx3WS+EWSeh/P8+owbhomf7cxbyXDiLcjuWYVj5s1Xez3rlW92/KjrzejvjJk0O1iLXPOq3pns30t7EhyQOoVyTbYMB/TsTLMUShXDU2W9l20zy6k+BfTE/B9XfpoPLQWiKpHYmKzALjEc5RWC9LDOHU0OwBsgGFlNbA/NgVWy1/S+RVRmaduq3mv6dPqx1Hd7/FhzyA8m4/jXgwPLheBi3f22gPedNT4gfWHLW5k3cqEkczJfun0qIVnVf4cAH0X/nsZ6EPYZDgi9jXWTM1Y9bkXOAcvYdoMDZnvca83xU30ytfP1O8rZzH8vjjc0PAUSiDSTnwwHMDFjoSC9JEDPlFY4MB3Z+CB3ObCN5s1W5yemn8067vT9Mo63NYfUBaBXBici5/sqXtrjeLLoANzTHFi1yQQW25I0mNiddvwCuL+Zxvwu9Isq+z/CrvaE449ihdkrVBotAQoVB9j973GgJAexBlzw4onQEYymJ/kld9s+LHdKvua3oD9jn1gD5JIfedJ4iQNw9fbPAVnJzBIHYh+cGcQDtG2g9Zl8zNf/uSnH3pifI0P7PsCUA+Cb5TlWdM0cnWn94AAblyumLnYlF4pdu+jxIb1NgxmLfktSMTV4/I535kP+n2Af9PAMZnFAb/Cb2HUHPNXOzxCZXYph5BTfIDlIHATm4J6xNEUDFc0+6zutLOijfPj0aPw5gAV6+WhsShIYxHh8SRBwYDIZa5TIx0+DCbH0MisX3wnafD/B+I2A/uatz+rCGiCf/NhfG1jhgKHb44DfWjJ9HZjKQax7zSNAq2varIF+3SvfAeXNwfPVO/fN93XOAiUcfyWsSCGeayLsep5b6fc4EKDWNuA2QRzw2OJGgNBmAQFWKPsUTMOk60HUPsWceErq+wDVkEXi7q0ZjAUAteeD2Df19R7Wx5AJDrjYjVtPkziSqNHMJlsTsutB5/3bwfcDxzm07w+WBJnNouA4XZREwYJXjhtjAG8c3zdPW4Xzy2Y4cczRn0Ron2KFM7dHQPYF4P4uFl0RgCFbeG4f9LbfXddM0qEcB+CAL+61jO/gvutKcfel/ZzHsbXQ5NP1EXQ+zqigeoDk8bXydn9JQKvVcvyVkkR3wQrcm1I2rgDdHM1snZ+xCUcoykxbfsqh5u74PB9+XlNgKczkNqgLdB0WwEFWAHFEIhMHYCiNn69qlk9xIEK5796GJo4kjtn8A3Oo9VHoPOuVf8IISwMeYoEL8etu1JdzvFbSKnKY4fVh0MZbK8s55uODaezZZxBc7DXxsg0Msu158ewHzG/3fT58rsveCNNe/DQoxbq5LIYRJR5fEsTK6RcJYn1RTa7zxmxzxgGreaOFD+keB25CMDtUYpKfwOvjo6knwRYHuu/3PL3cKaLGYihzBFOjRu7KVQ64R9+mD6Fm/jvr4B2yfcSn+kFg446flpNNz0YMWj1GraVANgdaU18x9y5XLgRFg2CFABVJxDR4R1lyHNDOXpvPvfjU1S06+LhKCfMTAPpDyPAgl4RspUAU3ArocTqksyPm46EYBU4bfQtTA6CgwNbv5ELY34LMWqYfoD7Agef489OIsUGY2IylQHIn1MS9tfC9wgKvIkx+2CycdEjOOr8s9jgAf+Xqh4J5vhsCblSTZg9hdHvAbMf2tvwEkmxHkisFqn1zpqCauT5Fdkt4RjoUrAEKgDBQOJpbcHcII4BObftQGxBfQMMSaCziZWG6HgSejQZ30LmN5o1bOylQReW+v2csOkSccrAGEDFE5zlu5gNLuZv2FEu/4Oyn2J0Gig3HeYcDi8bfIYCHyN8VFg6GXcoBNBooj14JJUQ6FK8B9DGhye9w0SkFGk/Z9MXSu/s/YRwwN1imBnfkfWUuCDzIkG3j3ygfMjXnft1LgZgNHDMzDkBpNhCfDg4lrc/6ch9VU/5s8mTKOkv5aaybL/ZZkn9IFtWxCK4t+698SWCCm/4gCg0FgDoFbXn66MsG4qZcUywz+cpmlkXpTdi5OA56cWpFH/AidDbhnmHjF2mzbfwhGWMRbLn/azXcUGVwACwd0qtkgLWa1TGpxFGiOuUApMuklkWrF+OA9sqbJFFTij6wBI4XWPFol6lyyeCO7Ln5wP0X4/8JJk60Y47hW+E+8P1Jx29kVmImRFMFjhUHiqWEwnq/g3bYoskGStDkKzda49vF46x23Jhzdv43en1IxkUA7v5PuFfq/jPLAMv3244frCMNFHLYOxquLLESzKOLJu3LS6ap3Wvy2fsjuF22hMdbb3ZZMvioPE6D1srPe3Y+NGUVqb+QwWkQonzyheMZvqtOctoEBKyNtKcAsB7KKiwO2Up45k1Thjg2rn1mtC1ho/VmlyWDj8rH8N+FQZ8KHfoQqT+RIVIgQg8xFLuFV8UyK5JmhesFYeL9lgCXxTPYQu2zZg/OwVCm37SlwZcMhLzU5QABLuhGEHf/UPiOlwHgfUXTdf8l0JsGXEPdJNMgDXeCZqH3PH0eVa5BGEaYcgvKD3Lv8dZtg0Be6jIWwdWJA9L9OxwwlwEgZuOetBci0BtfwF3RBHAHZwt7X8iARRnbmFYInnacjhALSbOnmPOI2dRyqddT8jHSGAJ90/33tOfE98UBYgAwGpgrZrEyRlg9jQsMg0pfT4IVhStpXzMO2GGdw8hDuYe/KYa+AOUHcX9ntGcN7shsG3Q8AiNormSbSKQ6YslLwS2ALn+wZMoBMBrIUJBBvLgjMZNvhAkpD2eNGwZ2LZQvcCBHkqeEbRyvdtxTLhnckcc2KF0JaKGaLj+zDPCAqykB19jmALe3f7hKI56YFWJmZCCKA2hAdxOemAOhPg/ZzSCw10sJj5hNlUsGd+SDwdpaBNO1wfm5s5iAkQ4BUj9uZYUFONVitRocMLtDIp7aFOsusdJOzYnxAqzjpYKP0ZuQXaCWElYH3GhdMnieABAZTiHAJUJfEoxQEKZDtCMbrd/cT4cqBYHmAAadiu6uNKaN7d1N/JnEUGwslv19DriQdajyu4SnWp81yMjj16E7rPtKgAoA8fSzdMj29wHudRMIDUSr6Kurjkb68tnyV2M9C1bFAWFjKveqgcGSze/F/e8kwOW/O+Y6dLhQiafXz4MBgyT9ViMdUk1REt/uUvyqfEFBNqW7EA17T3lHQYwppCg3pk2ie3yv1SkFXZZ6fQH3v5MAoIDuEcBaCYALgNwdYtBP4p4At3cfE52C3gJ0sQxcBPguP4WePaBPObBV3TB4UHi8dapcNTab2lEIwoETcSP54SgHX/jqVa/7O7sW7g1kF1SQ5KQxrVit1XlKIF8lBa4GXwGgvGkbR1pquM/QPG0yDKZLhbB6U3iQABtdtvG9Jx8jpWlQo5s84A8HKkgEcFbDfexKZGiZ9wXPyCtHlQHrRFWj2TXgg3SyZVHIB9Q4DiA+JUmkfOKARkaYYFe9n8nB95R3jLW9HQHMbVCx/8M4ABUo2lBnEWGheDZgTfToPz0BWn1M21WuKf3VWzyZIMzD9EMcMCeToUdWv7UMWBU2WveU92U7AkCthu1FcOuCwP37WL8QQ2RwoCNOeKYcAAc0NzDxbcJUAjG3SI2vd8wm05sxIW+wLWy0bhtkjIMmIwKMdTDdD00sgmG6f2Ipjyf0m4JhUYQCefpfkAp+VRjzu1CDYlUjuJjMceikfXkAX6+jabBXDYQMapMoTxLgWYMNmUWAnuuLLIgui+EtghPuv0LqqVeOcN/MasNNna0QTEyLauHdXdiZLv8pDoSoTRqsVb+SBcWo/Rq+p/KIANTHjywIjAxQKwEmgGVNWlmoAQaLhl7k+k2+kn5IRrEXlF4WB7mQTQlikFcmAR1zA/E6QY3g2oTVjwp7yiUDIWf69urRjzd3sFaaBXFKiAWACX1786fhmEKzcL3p+xkHePfzFtXcS23Vwqu0VcBUvjUaeUsuX10DKGeuq017VVNImm2z4hGDTF9TJr8NCrIYUBzoORJdLlPo68OkDO4FQMOKj/sO2WqFi24WLAkKOEN8x8+oSGaiwb0E936jBRDH3EhvmD4O/U/A/aYykDNm2v5gDl7kP34WBIJ4LTDIFoZdnQ6x1J9s+9SGJCPvbwwcVZ8SgeOXSN3jgAl3R7kaBLJm608VpvptYaN1qvyQDHYYrp0GrUEWhGEDng6ZSb/mQ0/le69LwWXBATZ3E9wxB7xe0yrRROA24W4izOPACjdWDczb6WWD1ysW7phNlUsGQk6aHRTrMDkAaw1AyECFAProbMH4vEF3+qn75ynQsME1ve75TKAbkKIYFXiNwwKMJ529NcJZyApT6V53h4qVU/22sNE6Vd6UvaaDnXQw4wBYggRnHaxDAWDwocNauHzP/Qus20vhdP6zmRqBBaLiG0i0JbaJ5npVta/h+iRZnepjIa/8Gu4DDpzV8X+EiZUASARgywOx/FXbPvQpb8eZnfm0Qbo83L/y90Y6dIMDGnCsyQP0iX7PwO9iXpNmmcHzd0lWp3pP+RQZMnIS6DEHDp3q0DjQvbXOgtAFL+8nxKCBwoC+dv8FpS9zBaOmMr07kSmSepN2/KI6cJBZ/iZZMQsCRtPKNaNMVpPCRutUmZHzQPeq13+QMbw7ANhrAPYYuJGBkiReANBEX0I/5/49eRoWzA3Qws3yHAjAZzfNFrhB0zbc7zMh0AfGS61LBjdlr8r+p3gG+v4nkiJcwtmLLn9H8mNBv7d26OOEclOm3L+Fb/PQBL1111NQijVxv1XMgTklhMEqK4IgMN0pEjNXVzGamKdnHAsbZksGN+Vpk50CQW+GlsYQjAgAz/FzwYM+XdTWzgGM7trlZ/hAP9quL9xGVtMcEFWDEkQzwe4MgpnrnkGyui3sKR+U800Hgz54HFBLArYL1LBoOH4lUOijOXhwT5+B+7UwIQmVMBgv0YsJYJQoSQ60q10VlIDRkTZ5rWJWG3CfmiWrDwqe/AWsZ8yu7wRTDgTo18/COi4HzrigoX/huAxBrATcLH8Kd8ug0JnA6JvigEh1rMUAq7Y7ZmC9gObFYxGBgVfdMKDCVLlkEMhxNT/CoXObCiMLMvIfshMKvhg4hcJtOvTPT5EKhT8O02iu3ZIYBKm/TRI4lAg4wMEXZD5m6h/gUvBEGHi95gbOgDGm7yD+JgdWOz7eJE+DmnFAE4OBPkj9yTq4Ix4k16fr3ar4YKZD05jAcNCpeJqYNmRigQ1FeQx0E9yF3CUGd2wZdNxWetWsUN2mL8hxddqrrQE09DH+AIl+dh6uo9ASOtBxYroLGMQYCY/iwzVT/Qy4C1Mll2MOdOx2/Jmg790neVGIeJMn5pVVd79NH9tM9YFB3OtD8lI1GOTACe5wGQAeCjqgRzoEC4XE8aNhGhzcA/Hc6/cRos0fTxnm91SmHIg+eG5fgphgsYUh3qFECvppg0eqUz0V8q0b8keb5C5QvCUK/jgMxUj9teNHwzco0AsAK8/hOdI5ptgpGgLpMiFGwAFYSgVlF/QxmjOIbwMys8UsKCFjysgAACAASURBVKP0qtt6KuRbk/Ke2Wo1TIG8CECzf7oUthw/Gr67UKxQMIBuPhX2US6XBBzBcHBP5eIsANxkCXaOZFfJZIuDbA1c75pRmszxqtt6U9hTCnmvKUZ5YND+h5hwGYC+BUSq1OX3aulVDA3b8lehAM6S1xCafZtHRIwlDoBzQMsU2QYCeJPE9A3E29fcwc+l1rw+FqbKm3K+SVdNg2MsAEwOkDNCchFMUE5zFYpFc7ELuKHgcueNKlSgQDe9PoWFJobLgf6mkORey71jsDgegmoSBqDjkCl5QA9wHCin+i9D/3NYX8U91bSjEJQG0xRIPP11yMASfWJQRKpDVgUFDN8U6JN0yMr+S8gB2tqxrmUBXypHoFfnTCXirWvQhJWmqf6HQz8P7sAyoynjNCg4DSreFgfGFYvoF7ucFP16X0ghni6RPfd/zqFwpeYAjRKF2F/4I/L4/JTjp7LNByVkqhvXZHVbHwsbrUk537RaFZqD5T/BMoAIoKlOgH7qYs1jDrwJlgCRBQVCu5cQdNwYHGgtDNakwUyKkouEwOsXMo2hbN2pUpsBsvqboV/D1nXofwf3vaoI4C0D+LdkjEdgVrVwf29HAC34/r7OfLyn0b2Yht+lOIkQOJoDpSEIeiiztWsxkPdRxMfg3oN7Eut7yE5WLQIAb/EwmC8A4C+CL49O0C/NYK+Ae/ZC/T17GpBZAPgcuMAXaHD57EJb6acVOn4qx3wY1dzCILjG1ZtA3+bAVLkh6+rUYNr9VJJFMPAG3IwIAMgC4Cw++ntr6S4/3AM9u1zoV2sAKEvBKJMDhWvkMoBrxFvvBYTC/S4FtAF6wYfpfugjJ0Zn9KBC3HoH5Z+D/rPEGNugb+H7zb0gAGIB4ISConaKjGfATQDZHvWwrpMf49bKQEBZYHoSEDpGCY4puB8IAgEZtkBPiaotpdCmKprmHXPKB+VpdarRrWcxUqDOgS5EC4Cz1OtNZ6BvKBegL23AvtsDnvago5+m/iHWS2hQrKS/vy9FvFPKmNncDAIbuF8JC8mqKXjynS4b8s3qqsFRy+X7Rebz5nEABDluCtSUPdXprCiQCwMRAUD01xx7zKnKiztYL9TACwgEl9TAS4SK6q5b6YAx6ONzE8I4ec0ok0JeeQfij9Bgw8DUOItglQJBrYPjFEivB9gCoJHBQHmzpyvjKNvREO8BweKARryZCGk3X1RH2jrMLKUnQCstSthXx9Krar2Z/0zRmVcGcr5pWr2pOegCQMcBYwVcrcG8zZ/zTvqhWBkDnnqK8hEKAtBTvWNGIV6o/1bcmJKh9yvkldFWxhDwICBOUJN33yPDtElcY+VUn1E+YizkfNOegakRyuNNngS/+UbQm0C/nwi6ihkESNNJA82KvvND8/5zEHp2Oo/y1aqkRKGv6jIUQB/KDvc7QSB+QHbvmqzGgqc0bKqjX5FvVpMab6iRAnUmnGvfNwkCEO7fx71EakdgT4HOG3Nn3zkzTav2QB9VObgZJThb6LvGoM+DgAZ3IIB3gW8T5EWxcqo3BU8ZVL+A9Q0mTC3VF2IIB2giBOkoW5kFAaj1rlgYpOAOhf6QEjTnYeDm1fFm+BlRUWSIVwJDtk5PSGSb1YeeBnjVpJCU97rEg6xWTU1S2dYAbSUwFgP6LBBB29iXpKVv9iuv38kwZqCgLPZDTWR7ylKVCw+6t6q5SCjW263xTbEr8K3BHQhmNVCCzyRWetWksCFPW1ehvAH9JTK0bVCyGfruV5L/1DZAjwMVcvFKGkgKpJAdPEaAOmdqLIU5lEvh08ixhb0HVjUOAlLTunb6TdAvbFpVmCWvsXKqN4WpUsi6OjW42T2pmSpbCsQ3Q0UcgBUE0J9qnUXgHgPKA2M917e6ZJXtWvSygcK9Qa2ojAgqYhhV9X6N7lxzVdVmEVXGxDCrS9eMMilMlYGsqxnNI0DfpkfbBdIpEP8DCQKsVDlwAdn5aTY9XxIOfszMSfGrdvAN/aazH1B2DEx/b1bNIIBMECByXsBMKa4ZZUYfGGeUZjWj+Sisp/fq+isFepNtH5ERIV4En8Vx23TnR6Y0RFkprM0xvSsYJUyqoOOS08N2/9QS9tEgCghdPSVz458J3EYYILcOzii3hakSVTZNq55ygxvbQwnlUV+ob5IC8VNAtSc/mGOxNDNjx7Pn97iGY/s/Q+2AmF/FwqDQ0TgfGCvoG9DNOOilpaKE7MVtaBO0ksjgfeeIb33N1mQ1KUyVQp5WTU3SLNkxMwdTedSCWtouUOWhoABNRpPFQAPDZtYubk+UNhmsnEdomAeyvP6UDxT082WD9RBg9KXcMFlBZCGY1UAJrSSs8Cynek/5CPQfZMIn+uJcA7wL+l7Q6fLlUzCM6yV545FoANjnJjRkE9xRzRb6dRZUHD6gQYf9qbWyQQwOERfxsywoUw2uGeV9Qcisau0T5KumZsnyKeUVAfrTAHMdjI4EEgrsPVBuVmjVDyOm4zdR7skijFAs0tcslgF6tTBMNT1Ia/yYTLKCKHEP93nQP4L4jHyzGihN/VL3zAgjBTIiQHPhYwHg3aY/650FCr0kKJ55Zhkgcp4+ICeGMOhm7M/MkehoUCGCj0OrQh4CzfWtdfDGNVk1hakykOOm2NjTeMp890BvNo0UKI4AZ6EY9RhRWmu3o3s7zP2fNLCcMXvCQMeJYwIhmHbzWfff5+dlSiD6YAEQngsyq4ESjnID9Ek+BHK+SVdNjad8xDjQ49oFqm4EAA0CZzUYjrQVrpZJkcOlodSOX9xFoL+b+LgHN2Z/5g6pNoBNCXAD/WRACJlqcI2VUz0Vpkoh55t0NanxlIF+dRzaOo8AEP6R5utmMTMf0rfHhCW4D/cPif5iKWGlRh3NgkUS7pwV9PWLVqEEEaisj3wa6F85AxcrUwJfxZo0ENVtJmxrYv1eF9F61IL6wht4v50I0G01ssOFAb2Zke7T/EeMxLMaquzEKxYxRP5zyWBVKGcvuaeSIsYHDXHzEIRFCV3NYD3JAa8aCxsyIPeFEVjCKEnob+B+o+moPQKUVATogC4ctRQz9E6V9xIjyBK4f6vKVgUY4KauXeOevpbJn0qK+kulZuBMoJbB494A36X1hW+jm7wqHOUO9HNNuuop89APkH2n9Xj3NUAZJyDsCNCq3nCF2Ah9AH22CO5dLCYUMOb1qhkWBCWYk7bWwXINYPl7KIZQJR0fVSqHGWUFt4yvGWVS8JSeTSDr6oOaWB83ZQxKjwD9r/aD0G1NDKRSneD2xhr3rIrDP+a9VOfigR4D/ddK10+E9Ep38kKcUJA8CWc4eL8aXGOl1gc292VdfVCzp88bdJuj5z/jaQD5eiT8/Cczenf8AsZJ6BeKeKKxcyEMv97dMHgiRHctz5nZjn8aChJMAO/iNe1dtRAAPebDhqyrD2r29HkDYXPUgvfrOgU0fiGCn4TrhUI0zoV0zmPaX8qZ1xfCIEPz9CwCdMFcG3B3Lqbt/Zk2QkOrhuAcjti4etWk4Ml5uH+IDHv6TGtgdpzoH4kQJ8BZ3Ay+KIoApf/OoYoA+iqLl/DADgi6yQwFdG06aIDR6h0FpS9UBIQxAgV6vxcXBIgDfAdAj0GfRPwD0Pe3gLY1e/pM69TsSoHeVgoEjoep+z+x5aY9Pu7t0fRkRd4v6NHuytwtoQHNiMyDQ5oSdurfpmfQiTRpJaxqoKRvQqaaFDbkaTWpWVLeaUoaYCyCzzjwQn0bEaCXgVTLWdJtUOpPI8RbSU7hmoFyAn0KdMCIAGittEmeXcMgiVDSP1ooT0QkoVXwvh7QY9ybcE9hvc5tkvK0mtQsKe80JQ26zfF+4f0m+Q85EwFrBQzTYRcU5ft1xFjdTCqcHpQDUlaOv/RWFQpYcmLt8Qt6S0oU6fULN8NMgJUXBddkNRamyvtVU+MpN/TT1iS6qNn1JLhW1MaECrxfwJtgoADixDJvKmDoR//fAPrV3wyF/mDIHhHL+MEcvCdDJeKMGDQFajeNzv/oI3QC+p1aFrgN9FvV4BorbbM2Jf0OX7IKEUJerXrKDYhv43uKftOAR4AyNkDrayT0tLOZBdVWHf/pi0j91ZYLNBN4yDA4QPTnp3gBjsuDEtZ69OxceDToL3KaBWm9sDFBv41+kwNeNRYCOd/U+Y/AJlRu6OOmaWtscDDok4fBAq4shymsWWz7FIJk7eynWZD9VgoOYFTNaNApIR4LMNBzGgwQ05dBZmVQIn4Q1u/YX9c087HOw5nGXlW8gXdkU/PToD81mHY/6gsiCFSMPzkKhwVE6n9W27WfcRh8IOATDDM+htqgfCobBwzcw4gGY+3b5tmpK2gARYPx5+0CKU1HPAQNmrHQj2ubgNTztyVQGkK1WwN5tWpqPOWG/n5rxgDjSXB7FvbWj8B4Kj/GrkA3a0FAR4AKlnBPptt3ftD6g+dCaCjXuIeMBr3J3JKX7hzMxjAojZMa+pDDggtmdenqVWNhQ9bVbc2e/n5r3gY0Bao8AsDa1hyVJtD/6VE6fp5hB2tfUzNkuh4AcW8C92DJD0Cyf7CERD4S5txgr5EoNGHMqph8AGKTHoGNV2Xv1SINVqtJTazfbkoaJG1Os+PNU6BzDQAOAJn6E3yMPR+MbaJaJWEW4gCHe2m3KQT0Ju6LMmPVOuYjNoI0DTpPRDSgbxxV6tgiBLMaKDFTmsJUGcjTKsDcWWDmKadNN1vzNtRSLoLf5+9kkdymb33W9km/cGkKgX7f66RsqZ0MFP1ELuaMe76ubHQW1IEOjCVB4VGCUUWsgPk7onGvZ8v4wEOH5tsSGcTVqw6h+k2hnG/yNEvKadPN1ryNtjzqqxHgXAaAnIIGoJ9htXQf5P9O1cmPDgLQMtGZ/sakAQM0GBnoapLtC7WqWAEzuFsT63cxngY4J0ChhE+hPxQiudr6O5pYv92UNEjamJYHQ//r+mIkyNZ+UQvZ2uTadoFY8uNv9cQa6VxPJd+glL6WQByCD9bDKS3LLSAvHVJ4EojX4J6gvzC6imuyCjWrQCnkaTWpifVx07Q1Y5C08cyMNYCMAArQJzco9CtYBBjGhewoOS7Wm6uBOb6ZCIycZ1wtPhgpENTCV926M8RuIpohd0aRW9D5eIgP4B6APk8Dz8asmpol5bRp2poxSNrElgfd/+lbopVshTIcFABtx7PJdLfn6kf/N7F+f43+BCUmvtZ5cFtIHBjGBJ1sz14/GKatYNHAnJiWhWBWg6tXTQqBPK26mvQKONBnWjMGS2ax5fF+sS/F02NwHTRnCvTCyHwAtvytNPkpV+faT1JooJ+Q8uDLQd/HuDTcxdJXOK76ESzIwtTMgnIz0Uo9Dp0tvaMxzxX0m5heQv8G9JeUd5qSBo9bthSIPAroWB1PdgFUvIFXgz7aWpkiXl5x0UDGgWpvqMlibUEWAXoBdA07XNBn3ZXvH3MzBW4soC/SHighmqG6xkpTmCo3qqvKO01Jgz3jqSVZBLdlAFQa30fq0L+QTHz/Va1jiUwB1KEfzKk76QEs0SpkeuSB6As3YF3857jJv/OFiPVD4RMQAnn/djiQFJKyriY1e/q4aclm1TJpLLdBz+/EnL3HV9fp/k+DfkcDuk1DeSVwp9A35zSwpZoFmoUxO/RmOVomiNUw+FFQ/xyoODEqZmvuhEY4nuVCXjUWmOwfhJ5WV5WBPm5aslm1XLI/LujTcxBl+LnavOwLwAlC8ospl9cHcfw+9PWcitDUBlPRdCKmMGVnhcb9uNLnZWIHiSKeM8Hcs9Kz0lUqPLL/kxQ8pV1dfAjgKQN93PQ5s71yUPRfC4AX+QrLefO2nD01fYtI4J7JehOp/70l9AcQxSuvQ1+E8pQLQ4y8mu6ZhAKAZfbeSThBEpMJnmBWg6tXpcJUKeRpNamJ9ZnWvE3e7GYvdhTi3fMfsM1NkK2hsSpo0rXbUy9Zun+V+pfXRQNwJHWpNJ/NKEF3MLuZ8rLij97CSJmKzKwkE0T+46T+MG/nVIOrVzWFqTJTTWpifdy0ZJM3e6pX2wVqi+CO9dIWu2fy8wZekL7/FE6syxTI2ecZE32hvJmeefrBMxYHmAaAOBTUr2SfZ7SK5a/5PRhnzpRR4FWhp8Ln0O8hPs+EpObS+7t2U+TlobkH4u2OZy+WAp1PA87Gfvr/3Tgwtnraahho2RENEOA06PueAu5tCh2dDPFkB7OQew3P3SzHCPTKD0QIm2sEtSA2ZBP6Kh1iAs/+oef2A9C/AH1HHzclDTYsH++ovhLZ/DzdhaTwpk/KxH8cf4UCb8/nddFgfJAkCLA9e4L4QRLCCsoEqVGo9TBa1Nsn+xbGZ4MJStZU/A76A3xPob+knDYlDbaNH+lIy/G3iADn0C0CXE++Ghh6JKztn0qvxK5Q99/SfQDlNbJ/uu3TX43w/QUjBeo37tn8GNY7E0oFwpau7B7ddIqaTnQ0nVOxKRH74OpVk0IgT6umxlNOm5IG28Yf6nu8Cy4OvNo5Z7L/cz79pWvfTgOW+WDA3Shk1XtWS3vUUNr9xuZMv40SCogZBb04VlmITAWO+/Fm5L4EI/oK6AdpD1aUT6H/ccf/c6B/s7voe7BzEKd75tuRPe2pAv1oD4Y7P5TvZ+7/ReQTo6+2JUo+W+n7lUDNgNFd49uOA0T2fP9loQIFTe062eh6ANbd9ZvutT5Cg2nV1HjKQJ83uGl/v2NQjDVAad9l6fmP+LFoIwKIIEBz/RepKt9fyqiO9W53+VZYKN3l66POp6H1dExA/5LEysFc/lq4Bxk8EK5Jqrwog/4Y6NvoX4J+3JQ02DZ+pON0HLkLhLb7CeBd2tan+qa8WAMYyc9rbP6c0AeB/shSSJW5f3oKQ31JhWJX0ABkcH1OYcja9xf1EkiLTSErvJg4TqJ/1d8H4P6o1/8C6D+HeFFkBEBDwquRgaG/NNCfRTt+mgWdCU/Lcy6v/7o2Vq90iEKfy4IMNBSMZ2T8e17gSGIPAQSO4yPQzkpAski9yyYZHkS/B/EHvb6hr2FrfpyP9bozFI8AJP+53D/9hsBJibNfz/5hEOBK/fva9+SAYEK/im/ZNlleuzHIfgulAd0yClFVNETCtS+ossgU604E8KqxkJTzmlifad2zvNPlqQFZBEDfdClAOxjX8yJQX6Cff3HHL9L9yxmL6wn3Vr3uS72+igBjv4XkMGwTRkQG32dTf6+THxEKoEYAH40KSQ541aSgq9uO/58E/dUx2S5QxQWg10kAwgGa5Ne+AlYRoLzJUZ9Xq/acR/h+Dv0L3w0Uw6nT/Iesg7szRuveX3zfFzI5wN4gvfDl53/QBtRPf8GFKcRNgG6jP4b7lx3/D4H+xrAHzX/6OvVd8CrS/aMQ6MNAfz8wRHHfkx+UlgX1CCCyIO7+dSI0AgLtFSwDisEBkKokw8xAxxCtFFdzZG3zJfTXiVm+NW/zVK8PDcsiAF4XbtDR36/i3fPRT3F/en2ApTosAgjod/fvJULE8Xdnz/IfxQHAPclMhxJ/4p2V0C/jKYF49zW+vSt4l6QQdDerpsZTJlszBg/2+ujIx99iC6igdPf/GlnQuInn/sHQD+71T7gP3HcmkJsy9099P3+hctHclOgcwEiNClEWjNHoilm+kXV0TEYAWMIU/fkgICZ4lWrY3Ef/Hwf9m4Mf7Bxo+7tOxVElLU7qL64oLRSc+O75T3PkQhawHl5fJD/na+bRYPQi74gBKcWEbmBEAE4G8+1mNBPvk7Uzaw5iTzVsdauzLcvvQ/9Oxy8MTlKgF9CXvy/GgWspLBYAdPMHPDI0318a4kHkngUVzgEUAmvl43tAYPs/GMsAilcKPoFRkKpkNwk4SfeP0PHrshoEPOVqNVAG+rzB4x2/Nv5B90ABvF94ndB/8bDQytj/6ehXac/4Ek2HNYZMgU45cAGXR4DzVdrLAOVizfUAOIZ0PLPJQFvFTEiTEGjVuwozrxooN4bahn7S5qle37/F+FmUKz95obY/0NSolzrcfKnM8V/JDy5nPzIfkESIg/56JZQVaFRR+Q995aVJpTJcUpdv6ukIpvsvAvT6puLuRBMwwVMGYDXjQCCbo3nKQM8M1I7wtPwp0D/L0f9f1NPlvwgBTg6gf00MPP8hwrXvieH1L9wTMtAIAEEGup0v0h4iiB1Sdgq6jERI6Av8XaBeiv1Ja/vA/QfO3tNPR8vL5k09ZaDPGzzSZaM8e5eDbQGduP814kD//PvPXfXTzqXg/P/0rgm1r05eoOG4Z46fCFIvIgAGH+jzWuaMKX8sxw+uoSPEf+D2Wva8uGZCjNQvo/9/oU/L+HHcK//5hfrrWgOcMYHdtvI/tDM/uOSicFQIxKE+YwFcFgEgg0Dnw1XlK12xANCsMLd02F2UWnOGTj54OWYxXvLH0P81x//nQv8sx/m/w5+5/usX6i/gV4sDBaD5D8YzrzMOdN9/pv7oGzhFun+0bZ8oAlAnrVbDNoitzVD6lolYYab1U9//iPvPOGxRvoz+nwn9T99orAF6/nNyYLj/fv/u+MuV/Iz5tc2f0YNs8ohdIPYIjL5IGjEqaeA7MPYaQAtFpv59tKI0opg00HLs/s2Pber1p3HAHHB633iQaesd4zvlCzca/03qyH9+XcsAvDj60b7g0mX6gVUj/xlQshKhKAKAbAFR500QDPChCE/QGaVT/9JeThd0UXcBjJtqQTNhaKz44wmmWWAzbV2iUFy+g/6vcexKgU7/ffn+48qCIPZ/qPvHeKwLst059i5fRKabPyBdigUCsjU02uguUNOMhwnqgWu/0vElu/zvxNCiaaAnrJ+/3gRcEsdJlDyF/n8Y9M9ynP8vankB1P3/au6/Taef9ReOf8i10aAqNDWsX46wEJTo3SGxZUmQSu9ouF6LCcJYV83CmGCFESHIahlrFT0fbxBzWE/WVVPjKadN25Z3ypehf5bj+m8hC17d/R8tBQrcP/1c6+XyWd4P5v6Z4weJAIWN1qyGPY0Deg0gZ8KZABiMWiox68RNUY1ewYBT/f8Q9P8W3PdyjKdgv1AP1ONKgdgHTk890I//BCKHvun+Gdb5Clg/H7jsaYpipRlQZAhQopvcP3Uv+QmpmDBei6OZun9vnmb5Gvr/2dA/y7UGKL8uAuDkwGs81QKu5EfurFeW8OhnXtL9E+ifMsw1gMZcAxxFZ3GwBaUvRW4HTd93bdN9/B5kTcuABkIZ3+JPRP9PgP5ZjtoiADr6D7IAOD/yc5eT/qB5vRw/vUovjnFlW0BdaMP1gGD42sKyIOPgJ732UMANAClnyhSvJkm8FXlmGhvu/89C/8/BfS/HG6gvlKPlP3+RFTDGqYdCftRWop94/Y5iEQSAy9+P5IfSAE4AcX6poVCXTK8YAzJh6xEYrPsKwaya5RH3v3GjZNOSzUb5gdA/y3H90v8v4C/gr7YAaKcb+qPfsxSiHOh/8QP9VhAQiRD6RhDhAOL8xHoezNt51TeLIWLSILDXVdPxrw41tTdbfyD6fyz0z3K8Afwi7v8vlv+MzZ9WSk94iO8HF2jmcwpXtcmlV8EzIlLYYGUkQhSjGmo0FLAm9aDNLq371GEng8AqgvNDLQHrt6D/h0P/LEc917J/Af9qEUDkP+fv157oaQvfgXWS/Q9nT9a+hWQ+HgfAacDwVwZ2mfsvzjLAwejGh/EgEKddNtx/3v776P8joH+WowI4UP9q7r8vACpKJf+LUTv+QLOdnvywIHAW5ajZln9RApqNgK1zfGB016eGTEteivWni3iMoAfRVR2UgmnkbfYodPOmG+UPgv5ZjlpRjub+/2pPANAe/fYX1Ksv8pUAgv7CaXCJYhsUJOnvfKDE6BJfBA+9mZ+QtIc1FZYOed35bQ2llpNBIKaBN1o85uPlqRv9cdA/S4sA/0L911gA9IMPAPf9lSc8xYDdBW4eAcpo40/BhEFTaoQF7lYXLwtKusN8kvOsf/2++38EtX8o9M9yVKD8Czj/jv4f4pHnTVVu8rBsh+QQdLP/KqQqN4JgJ0Xuu0lXsSozYdfClgfUbFLChEfoVz/176Pkf9GfKUcF6r+Af7cV8AnTN/kfLir5az9xNXBc2BUYTBiJEAgNxP3FOjhRNiC458KX+GPwMDel1fwn7/4/Xf506J/lqC/gPy0CtOXvwCWH/vi9NxoHOIiN98VMgUgiNATCE/pHfTMz9h+72h8P6UIIe+uzTAJ9arydxuz1ugnffwb6ARz4BfwH+DfKX2OBO15eZb9xYp5oAHhSRAtPgewiFgCaQmILfyVR0TYe3E29Oc52FvSJ8iF6fLT7jypH/Qv4r7YLBPbct/9SEPvRK7ECFrgnfptBuft74vg1JUQcuGQL7rZn5YHiuoWzN2qWD320S8PuJWzbt1st/yT0Azjwr5YC/QLQUv9+zrn/zg/YlT3ihfLimVTk0XJt2KrvN/Kn2LLqjrN000ctY2PdZBr3b48Gt8DMZtrXLH8cPY76X8B/rg3Q8Suftf26rUiTc68vfo8Ci6pbKxOLJZvjlCZpDpwlqSyWXMgtaNW7er2E4N0O/IXD0XgvSjd5NrFxpsw/+h9WXvjvRoD+Rfh+FoikOoVmLDoUYLxnXpL9WLnzHnM69b+P3rw6VS1EshXcpvcSTfnJV/X3Ty0H/g/wL5Rf7SsvFPq8VCFVgH4wdfxrvHe1XSoZoI1DR65VjdCUhYxfcCn5dK5b0My/8Dkg8IX6cyZdKhfsYrUVb3Cr2DP/3/KxcuC/2/IXLeNXpfaPsKNcgK5yG8WAE8eXGWHOADGBvnn3biB6FXKlMzr/0eiHdYtpW8WVH3ZBdvFcN0lyMoUai456HHNkkTKJBp1B5SfmlT8u76elEaD9144eBz5RvPdUYCmzbPWwEkBElAy2knfPz8qc5yoH9OQDvTDAzCxT/twwVYAD/wYq8Ab+Bv5G/Rv4f5dQ/76UvTr+3qh/4/3G62+83yh/4/X3pSnqD38Dp/BmCEVL9QAAAI9JREFUwvXzcm/g3Rz8G7U1nXLpTRW14v3G6xTqJZR2PTXn9ayWphnfLGut4g90ySOU9YokBUN5aXrVvNZxBQFZX50bG2XVkTVGze82zL7wsAx08gL/qeWFf/NVL+wFQGH/qPLcm/Tg2/2TPzlzbj95wv/U8mJfgQfzVPLzuP35bAyQ7/IPQ88/7OX82PL/AWvoH5jBiy2hAAAAAElFTkSuQmCC';
const PBR = Object.freeze({
    pbrCookTorranceBrdfLutDataUrl,
});
/* harmony default export */ __webpack_exports__["default"] = (PBR);


/***/ }),

/***/ "./src/rhodonite-xr.ts":
/*!*****************************!*\
  !*** ./src/rhodonite-xr.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _xr_WebVRSystem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./xr/WebVRSystem */ "./src/xr/WebVRSystem.ts");

const XR = Object.freeze({
    WebVRSystem: _xr_WebVRSystem__WEBPACK_IMPORTED_MODULE_0__["default"]
});
/* harmony default export */ __webpack_exports__["default"] = (XR);
(0, eval)('this').RnXR = XR;


/***/ }),

/***/ "./src/sparkgear/SparkGearComponent.ts":
/*!*********************************************!*\
  !*** ./src/sparkgear/SparkGearComponent.ts ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SparkGearComponent; });
/* harmony import */ var _foundation_core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../foundation/core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../foundation/components/WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _foundation_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../foundation/definitions/ProcessStage */ "./src/foundation/definitions/ProcessStage.ts");
/* harmony import */ var _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../foundation/math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../foundation/components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../foundation/core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../foundation/components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _foundation_system_ModuleManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../foundation/system/ModuleManager */ "./src/foundation/system/ModuleManager.ts");








class SparkGearComponent extends _foundation_core_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(entityUid, componentSid, entityRepository) {
        super(entityUid, componentSid, entityRepository);
    }
    static get componentTID() {
        return _foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_1__["WellKnownComponentTIDs"].SparkGearComponentTID;
    }
    onBeforeRender() {
    }
    onAfterRender() {
        const ThisClass = SparkGearComponent;
        ThisClass.SPARK_BackupStatus();
        _SPARK_Draw(this.__hSPFXInst);
        ThisClass.SPARK_RestoreStatus();
    }
    // clone() {
    //   return new this.constructor(this._LoadingManager, this._Url).copy(this);
    // }
    play() {
        _SPARK_Instance_Play(this.__hSPFXInst, 1.0, false, 0);
    }
    stop() {
        _SPARK_Instance_Stop(this.__hSPFXInst);
    }
    pause() {
        _SPARK_Instance_Pause(this.__hSPFXInst);
    }
    isPlaying() {
        return _SPARK_Instance_IsPlaying(this.__hSPFXInst);
    }
    kickTrigger(trigger) {
        _SPARK_Instance_KickTrigger(this.__hSPFXInst, trigger);
    }
    static SPARK_BackupStatus() {
        const ThisClass = SparkGearComponent;
        const gl = ThisClass.SPFX_WebGLResourceRepository.currentWebGLContextWrapper.getRawContext();
        ThisClass.SPFX_ArrayBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
        ThisClass.SPFX_ElementArrayBuffer = gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING);
        ThisClass.SPFX_CurrentProgram = gl.getParameter(gl.CURRENT_PROGRAM);
        ThisClass.SPFX_FrontFace = gl.getParameter(gl.FRONT_FACE);
        ThisClass.SPFX_DepthFunc = gl.getParameter(gl.DEPTH_FUNC);
        ThisClass.SPFX_DepthWriteMask = gl.getParameter(gl.DEPTH_WRITEMASK);
        ThisClass.SPFX_StencilTestEnabled = gl.isEnabled(gl.STENCIL_TEST);
        ThisClass.SPFX_DepthTestEnabled = gl.isEnabled(gl.DEPTH_TEST);
        ThisClass.SPFX_CullFaceEnabled = gl.isEnabled(gl.CULL_FACE);
        ThisClass.SPFX_BlendEnabled = gl.isEnabled(gl.BLEND);
        ThisClass.SPFX_BlendSrcRgb = gl.getParameter(gl.BLEND_SRC_RGB);
        ThisClass.SPFX_BlendDstRgb = gl.getParameter(gl.BLEND_DST_RGB);
        ThisClass.SPFX_BlendSrcAlpha = gl.getParameter(gl.BLEND_SRC_ALPHA);
        ThisClass.SPFX_BlendDstAlpha = gl.getParameter(gl.BLEND_DST_ALPHA);
        ThisClass.SPFX_ActiveTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
        for (let i = 0; i < 8; i++) {
            gl.activeTexture(gl.TEXTURE0 + i);
            ThisClass.SPFX_Texture[i] = gl.getParameter(gl.TEXTURE_BINDING_2D);
        }
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    }
    static SPFX_Uninitialize() {
        const ThisClass = SparkGearComponent;
        ThisClass.SPARK_BackupStatus();
        _SPARK_Uninitialize();
        ThisClass.SPARK_RestoreStatus();
    }
    static SPARK_SetCameraMatrix(viewMatrix, projectionMatrix) {
        _SPARK_SetMatrix(0, viewMatrix.v[0], viewMatrix.v[1], viewMatrix.v[2], viewMatrix.v[3], viewMatrix.v[4], viewMatrix.v[5], viewMatrix.v[6], viewMatrix.v[7], viewMatrix.v[8], viewMatrix.v[9], viewMatrix.v[10], viewMatrix.v[11], viewMatrix.v[12], viewMatrix.v[13], viewMatrix.v[14], viewMatrix.v[15]);
        _SPARK_SetMatrix(1, projectionMatrix.v[0], projectionMatrix.v[1], projectionMatrix.v[2], projectionMatrix.v[3], projectionMatrix.v[4], projectionMatrix.v[5], projectionMatrix.v[6], projectionMatrix.v[7], projectionMatrix.v[8], projectionMatrix.v[9], projectionMatrix.v[10], projectionMatrix.v[11], projectionMatrix.v[12], projectionMatrix.v[13], projectionMatrix.v[14], projectionMatrix.v[15]);
    }
    static SPARK_Draw() {
        const ThisClass = SparkGearComponent;
        ThisClass.SPARK_BackupStatus();
        _SPARK_DrawAll();
        ThisClass.SPARK_RestoreStatus();
    }
    static SPARK_DrawDebugInfo(InfoType) {
        const ThisClass = SparkGearComponent;
        ThisClass.SPARK_BackupStatus();
        _SPARK_DrawDebugInfo(InfoType);
        ThisClass.SPARK_RestoreStatus();
    }
    $create() {
        this.__sceneGraphComponent = this.__entityRepository.getComponentOfEntity(this.__entityUid, _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.moveStageTo(_foundation_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_2__["ProcessStage"].Load);
    }
    static common_$load() {
        if (SparkGearComponent.__isInitialized) {
            return;
        }
        const moduleManager = _foundation_system_ModuleManager__WEBPACK_IMPORTED_MODULE_7__["default"].getInstance();
        const moduleName = 'webgl';
        const webglModule = moduleManager.getModule(moduleName);
        // Initialize SPARKGEAR
        SparkGearComponent.SPFX_Initialize(webglModule.WebGLResourceRepository.getInstance());
    }
    $load() {
        if (this.url == null) {
            return;
        }
        const loadBytes = function (path, type, callback) {
            var request = new XMLHttpRequest();
            request.open('GET', path, true);
            request.responseType = type;
            request.onload = () => {
                switch (request.status) {
                    case 200:
                        callback(request.response);
                        break;
                    default:
                        console.error('Failed to load (' + request.status + ') : ' + path);
                        break;
                }
            };
            request.send(null);
        };
        const ThisClass = SparkGearComponent;
        loadBytes(this.url, 'arraybuffer', (data) => {
            var buffer = new Uint8Array(data);
            ThisClass.SPARK_BackupStatus();
            var SPFXData = window.Module.ccall("SPARK_Data_Create", 'number', ['string', 'number', 'array', 'number'], [this.url, this.url.length, buffer, buffer.length]);
            this.__hSPFXInst = _SPARK_Instance_Create(SPFXData);
            _SPARK_Data_Delete(SPFXData);
            ThisClass.SPARK_RestoreStatus();
            this.moveStageTo(_foundation_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_2__["ProcessStage"].Logic);
        });
    }
    $logic() {
        // Keep Playing
        if (!this.isPlaying()) {
            this.play();
        }
        const cameraComponent = _foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_5__["default"].getInstance().getComponent(_foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_4__["default"], _foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_4__["default"].main);
        let viewMatrix = SparkGearComponent.__tmp_indentityMatrix;
        let projectionMatrix = SparkGearComponent.__tmp_indentityMatrix;
        if (cameraComponent) {
            viewMatrix = cameraComponent.viewMatrix;
            projectionMatrix = cameraComponent.projectionMatrix;
        }
        SparkGearComponent.SPARK_SetCameraMatrix(viewMatrix, projectionMatrix);
        SparkGearComponent.SPFX_Update(1.0);
        const m = this.__sceneGraphComponent.worldMatrixInner;
        _SPARK_Instance_SetTransformFor3D(this.__hSPFXInst, m.v[0], m.v[4], m.v[8], m.v[12], m.v[1], m.v[5], m.v[9], m.v[13], m.v[2], m.v[6], m.v[10], m.v[14], m.v[3], m.v[7], m.v[11], m.v[15]);
        this.moveStageTo(_foundation_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_2__["ProcessStage"].Render);
    }
    $render() {
        this.onAfterRender();
        this.moveStageTo(_foundation_definitions_ProcessStage__WEBPACK_IMPORTED_MODULE_2__["ProcessStage"].Logic);
    }
}
SparkGearComponent.__isInitialized = false;
SparkGearComponent.SPFX_Texture = [];
SparkGearComponent.__tmp_indentityMatrix = _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_3__["default"].identity();
SparkGearComponent.SPARK_RestoreStatus = function () {
    const ThisClass = SparkGearComponent;
    const gl = ThisClass.SPFX_WebGLResourceRepository.currentWebGLContextWrapper.getRawContext();
    gl.useProgram(ThisClass.SPFX_CurrentProgram);
    gl.bindBuffer(gl.ARRAY_BUFFER, ThisClass.SPFX_ArrayBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ThisClass.SPFX_ElementArrayBuffer);
    gl.frontFace(ThisClass.SPFX_FrontFace);
    gl.depthFunc(ThisClass.SPFX_DepthFunc);
    gl.depthMask(ThisClass.SPFX_DepthWriteMask);
    gl.blendFuncSeparate(ThisClass.SPFX_BlendSrcRgb, ThisClass.SPFX_BlendDstRgb, ThisClass.SPFX_BlendSrcAlpha, ThisClass.SPFX_BlendDstAlpha);
    ThisClass.SPFX_StencilTestEnabled ? gl.enable(gl.STENCIL_TEST) : gl.disable(gl.STENCIL_TEST);
    ThisClass.SPFX_DepthTestEnabled ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST);
    ThisClass.SPFX_CullFaceEnabled ? gl.enable(gl.CULL_FACE) : gl.disable(gl.CULL_FACE);
    ThisClass.SPFX_BlendEnabled ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND);
    for (let i = 0; i < 8; i++) {
        gl.activeTexture(gl.TEXTURE0 + i);
        gl.bindTexture(gl.TEXTURE_2D, ThisClass.SPFX_Texture[i]);
    }
    gl.activeTexture(ThisClass.SPFX_ActiveTexture);
};
SparkGearComponent.SPFX_Initialize = function (repository) {
    const ThisClass = SparkGearComponent;
    if (repository.currentWebGLContextWrapper == null) {
        return;
    }
    ThisClass.SPFX_WebGLResourceRepository = repository;
    window.GLctx = ThisClass.SPFX_WebGLResourceRepository.currentWebGLContextWrapper.getRawContext();
    ThisClass.SPARK_BackupStatus();
    const glw = ThisClass.SPFX_WebGLResourceRepository.currentWebGLContextWrapper;
    _SPARK_InitializeFor3D(glw.width, glw.height);
    ThisClass.SPARK_RestoreStatus();
    ThisClass.__isInitialized = true;
};
SparkGearComponent.SPFX_Update = function (DeltaTime) {
    _SPARK_Update(DeltaTime);
};
_foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_5__["default"].registerComponentClass(SparkGearComponent);


/***/ }),

/***/ "./src/sparkgear/main.ts":
/*!*******************************!*\
  !*** ./src/sparkgear/main.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _SparkGearComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SparkGearComponent */ "./src/sparkgear/SparkGearComponent.ts");
/* harmony import */ var _foundation_core_EntityRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../foundation/core/EntityRepository */ "./src/foundation/core/EntityRepository.ts");
/* harmony import */ var _foundation_components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../foundation/components/TransformComponent */ "./src/foundation/components/TransformComponent.ts");
/* harmony import */ var _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../foundation/components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");




const createSparkGearEntity = function () {
    const entityRepository = _foundation_core_EntityRepository__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance();
    const entity = entityRepository.createEntity([_foundation_components_TransformComponent__WEBPACK_IMPORTED_MODULE_2__["default"], _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_3__["default"], _SparkGearComponent__WEBPACK_IMPORTED_MODULE_0__["default"]]);
    return entity;
};
const SparkGear = Object.freeze({
    SparkGearComponent: _SparkGearComponent__WEBPACK_IMPORTED_MODULE_0__["default"],
    createSparkGearEntity
});
/* harmony default export */ __webpack_exports__["default"] = (SparkGear);


/***/ }),

/***/ "./src/webgl/WebGLContextWrapper.ts":
/*!******************************************!*\
  !*** ./src/webgl/WebGLContextWrapper.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WebGLContextWrapper; });
/* harmony import */ var _WebGLExtension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLExtension */ "./src/webgl/WebGLExtension.ts");
/* harmony import */ var _foundation_math_Vector4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../foundation/math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _foundation_core_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../foundation/core/Config */ "./src/foundation/core/Config.ts");



class WebGLContextWrapper {
    constructor(gl, canvas, isDebug) {
        this.__webglVersion = 1;
        this.width = 0;
        this.height = 0;
        this.__activeTextureBackup = -1;
        this.__activeTextures2D = [];
        this.__activeTexturesCube = [];
        this.__isDebugMode = false;
        this.__viewport_left = 0;
        this.__viewport_top = 0;
        this.__viewport_width = 0;
        this.__viewport_height = 0;
        this.__extensions = new Map();
        this.__gl = gl;
        this.width = canvas.width;
        this.height = canvas.height;
        this.canvas = canvas;
        this.__viewport_width = this.width;
        this.__viewport_height = this.height;
        this.__isDebugMode = isDebug;
        if (this.__gl.constructor.name === 'WebGL2RenderingContext') {
            this.__webglVersion = 2;
            this.webgl2ExtTFL = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].TextureFloatLinear);
            this.webgl2ExtTFA = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].TextureFilterAnisotropic);
        }
        else {
            this.webgl1ExtVAO = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].VertexArrayObject);
            this.webgl1ExtIA = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].InstancedArrays);
            this.webgl1ExtTF = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].TextureFloat);
            this.webgl1ExtTHF = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].TextureHalfFloat);
            this.webgl1ExtTFL = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].TextureFloatLinear);
            this.webgl1ExtTHFL = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].TextureHalfFloatLinear);
            this.webgl1ExtTFA = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].TextureFilterAnisotropic);
            this.webgl1ExtEIUI = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].ElementIndexUint);
            this.webgl1ExtSTL = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].ShaderTextureLod);
            this.webgl1ExtDRV = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].ShaderDerivatives);
            this.webgl1ExtDB = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].DrawBuffers);
            this.webgl1ExtBM = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].BlendMinmax);
            this.webgl1ExtCBF = this.__getExtension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_0__["WebGLExtension"].ColorBufferFloat);
        }
    }
    getRawContext() {
        return this.__gl;
    }
    get viewport() {
        return new _foundation_math_Vector4__WEBPACK_IMPORTED_MODULE_1__["default"](this.__viewport_left, this.__viewport_top, this.__viewport_width, this.__viewport_height);
    }
    isSupportWebGL1Extension(webGLExtension) {
        if (this.__getExtension(webGLExtension)) {
            return true;
        }
        else {
            return false;
        }
    }
    isNotSupportWebGL1Extension(webGLExtension) {
        return !this.isSupportWebGL1Extension(webGLExtension);
    }
    get isDebugMode() {
        return this.__isDebugMode;
    }
    get isWebGL2() {
        if (this.__webglVersion === 2) {
            return true;
        }
        else {
            return false;
        }
    }
    createVertexArray() {
        if (this.isWebGL2) {
            return this.__gl.createVertexArray();
        }
        else {
            if (this.webgl1ExtVAO != null) {
                return this.webgl1ExtVAO.createVertexArrayOES();
            }
        }
    }
    deleteVertexArray(vertexArray) {
        if (this.isWebGL2) {
            this.__gl.createVertexArray(vertexArray);
        }
        else {
            if (this.webgl1ExtVAO != null) {
                this.webgl1ExtVAO.deleteVertexArrayOES(vertexArray);
            }
        }
    }
    bindVertexArray(vao) {
        if (this.isWebGL2) {
            this.__gl.bindVertexArray(vao);
        }
        else {
            if (this.webgl1ExtVAO != null) {
                this.webgl1ExtVAO.bindVertexArrayOES(vao);
            }
        }
    }
    vertexAttribDivisor(index, divisor) {
        if (this.isWebGL2) {
            this.__gl.vertexAttribDivisor(index, divisor);
        }
        else {
            this.webgl1ExtIA.vertexAttribDivisorANGLE(index, divisor);
        }
    }
    drawElementsInstanced(primitiveMode, indexCount, type, offset, instanceCount) {
        if (this.isWebGL2) {
            this.__gl.drawElementsInstanced(primitiveMode, indexCount, type, offset, instanceCount);
        }
        else {
            this.webgl1ExtIA.drawElementsInstancedANGLE(primitiveMode, indexCount, type, offset, instanceCount);
        }
    }
    drawArraysInstanced(primitiveMode, first, count, instanceCount) {
        if (this.isWebGL2) {
            this.__gl.drawArraysInstanced(primitiveMode, first, count, instanceCount);
        }
        else {
            this.webgl1ExtIA.drawArraysInstancedANGLE(primitiveMode, first, count, instanceCount);
        }
    }
    colorAttachment(index) {
        return this.webgl1ExtDB ?
            this.webgl1ExtDB[`COLOR_ATTACHMENT${index}_WEBGL`] :
            this.__gl[`COLOR_ATTACHMENT${index}`];
    }
    drawBuffers(buffers) {
        const gl = this.__gl;
        if (buffers.length === 0) {
            return;
        }
        let buffer = buffers;
        if (this.isWebGL2) {
            gl.drawBuffers(buffers.map((buf) => { return gl[buf.str]; }));
            buffer = gl[buffer[0].str];
        }
        else if (this.webgl1ExtDB) {
            this.webgl1ExtDB.drawBuffersWEBGL(buffers.map((buf) => { return gl[buf.str]; }));
            buffer = gl[buffer[0].str];
        }
        if (buffer === gl.NONE) {
            gl.colorMask(false, false, false, false);
        }
        else {
            gl.colorMask(true, true, true, true);
        }
    }
    __activeTexture(activeTextureIndex) {
        if (this.__activeTextureBackup === activeTextureIndex) {
            return;
        }
        switch (activeTextureIndex) {
            case 0:
                this.__gl.activeTexture(this.__gl.TEXTURE0);
                break;
            case 1:
                this.__gl.activeTexture(this.__gl.TEXTURE1);
                break;
            case 2:
                this.__gl.activeTexture(this.__gl.TEXTURE2);
                break;
            case 3:
                this.__gl.activeTexture(this.__gl.TEXTURE3);
                break;
            case 4:
                this.__gl.activeTexture(this.__gl.TEXTURE4);
                break;
            case 5:
                this.__gl.activeTexture(this.__gl.TEXTURE5);
                break;
            case 6:
                this.__gl.activeTexture(this.__gl.TEXTURE6);
                break;
            case 7:
                this.__gl.activeTexture(this.__gl.TEXTURE7);
                break;
            case 8:
                this.__gl.activeTexture(this.__gl.TEXTURE8);
                break;
            case 9:
                this.__gl.activeTexture(this.__gl.TEXTURE9);
                break;
            case 10:
                this.__gl.activeTexture(this.__gl.TEXTURE10);
                break;
            case 11:
                this.__gl.activeTexture(this.__gl.TEXTURE11);
                break;
            case 12:
                this.__gl.activeTexture(this.__gl.TEXTURE12);
                break;
            case 13:
                this.__gl.activeTexture(this.__gl.TEXTURE13);
                break;
            case 14:
                this.__gl.activeTexture(this.__gl.TEXTURE14);
                break;
            case 15:
                this.__gl.activeTexture(this.__gl.TEXTURE15);
                break;
        }
        this.__activeTextureBackup = activeTextureIndex;
    }
    bindTexture2D(activeTextureIndex, texture) {
        if (this.__isDebugMode) {
            if (texture) {
                if (texture._bound_as === 'CUBE_MAP') {
                    debugger;
                }
                texture._bound_as = '2D';
            }
        }
        if (!_foundation_core_Config__WEBPACK_IMPORTED_MODULE_2__["default"].noWebGLTex2DStateCache && this.__activeTextures2D[activeTextureIndex] === texture) {
            return;
        }
        this.__activeTexture(activeTextureIndex);
        this.__gl.bindTexture(this.__gl.TEXTURE_2D, texture);
        this.__activeTextures2D[activeTextureIndex] = texture;
    }
    bindTextureCube(activeTextureIndex, texture) {
        if (this.__isDebugMode) {
            if (texture) {
                if (texture._bound_as === '2D') {
                    debugger;
                }
                texture._bound_as = 'CUBE_MAP';
            }
        }
        if (this.__activeTexturesCube[activeTextureIndex] === texture) {
            return;
        }
        this.__activeTexture(activeTextureIndex);
        this.__gl.bindTexture(this.__gl.TEXTURE_CUBE_MAP, texture);
        this.__activeTexturesCube[activeTextureIndex] = texture;
    }
    unbindTexture2D(activeTextureIndex) {
        if (this.__isDebugMode) {
            delete this.__activeTextures2D[activeTextureIndex];
        }
        this.__activeTexture(activeTextureIndex);
        this.__gl.bindTexture(this.__gl.TEXTURE_2D, null);
    }
    unbindTextureCube(activeTextureIndex) {
        if (this.__isDebugMode) {
            delete this.__activeTexturesCube[activeTextureIndex];
        }
        this.__activeTexture(activeTextureIndex);
        this.__gl.bindTexture(this.__gl.TEXTURE_CUBE_MAP, null);
    }
    unbindTextures() {
        for (let i = 0; i < this.__activeTextures2D.length; i++) {
            if (this.__activeTextures2D[i] == null) {
                continue;
            }
            this.__activeTexture(i);
            this.__gl.bindTexture(this.__gl.TEXTURE_2D, null);
            delete this.__activeTextures2D[i];
        }
        for (let i = 0; i < this.__activeTexturesCube.length; i++) {
            if (this.__activeTexturesCube[i] == null) {
                continue;
            }
            this.__activeTexture(i);
            this.__gl.bindTexture(this.__gl.TEXTURE_CUBE_MAP, null);
            delete this.__activeTexturesCube[i];
        }
    }
    __getExtension(extension) {
        const gl = this.__gl;
        if (!this.__extensions.has(extension)) {
            const extObj = gl.getExtension(extension.toString());
            if (extObj == null) {
                const text = `The library does not support this environment because the ${extension.toString()} is not available`;
                if (console.error != null) {
                    console.error(text);
                }
                else {
                    console.log(text);
                }
            }
            this.__extensions.set(extension, extObj);
            return extObj;
        }
        return this.__extensions.get(extension);
    }
    setViewport(left, top, width, height) {
        const gl = this.__gl;
        if (this.__viewport_width === width && this.__viewport_height === height && this.__viewport_left === left && this.__viewport_top === top) {
            return;
        }
        else {
            gl.viewport(left, top, width, height);
            this.__viewport_left = left;
            this.__viewport_top = top;
            this.__viewport_width = width;
            this.__viewport_height = height;
        }
    }
    setViewportAsVector4(viewport) {
        const gl = this.__gl;
        if (this.__viewport_width === viewport.z && this.__viewport_height === viewport.w && this.__viewport_left === viewport.x && this.__viewport_top === viewport.y) {
            return;
        }
        else {
            gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
            this.__viewport_left = viewport.x;
            this.__viewport_top = viewport.y;
            this.__viewport_width = viewport.z;
            this.__viewport_height = viewport.w;
        }
    }
}


/***/ }),

/***/ "./src/webgl/WebGLExtension.ts":
/*!*************************************!*\
  !*** ./src/webgl/WebGLExtension.ts ***!
  \*************************************/
/*! exports provided: WebGLExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLExtension", function() { return WebGLExtension; });
/* harmony import */ var _foundation_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../foundation/misc/EnumIO */ "./src/foundation/misc/EnumIO.ts");

class WebGLExtensionClass extends _foundation_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["EnumClass"] {
    constructor({ index, str }) {
        super({ index, str });
    }
}
const VertexArrayObject = new WebGLExtensionClass({ index: 1, str: 'OES_vertex_array_object' });
const TextureFloat = new WebGLExtensionClass({ index: 2, str: 'OES_texture_float' });
const TextureHalfFloat = new WebGLExtensionClass({ index: 3, str: 'OES_texture_half_float' });
const TextureFloatLinear = new WebGLExtensionClass({ index: 4, str: 'OES_texture_float_linear' });
const TextureHalfFloatLinear = new WebGLExtensionClass({ index: 5, str: 'OES_texture_half_float_linear' });
const InstancedArrays = new WebGLExtensionClass({ index: 6, str: 'ANGLE_instanced_arrays' });
const TextureFilterAnisotropic = new WebGLExtensionClass({ index: 7, str: 'EXT_texture_filter_anisotropic' });
const ElementIndexUint = new WebGLExtensionClass({ index: 8, str: 'OES_element_index_uint' });
const ShaderTextureLod = new WebGLExtensionClass({ index: 9, str: 'EXT_shader_texture_lod' });
const ShaderDerivatives = new WebGLExtensionClass({ index: 10, str: 'OES_standard_derivatives' });
const DrawBuffers = new WebGLExtensionClass({ index: 11, str: 'WEBGL_draw_buffers' });
const BlendMinmax = new WebGLExtensionClass({ index: 12, str: 'EXT_blend_minmax' });
const ColorBufferFloat = new WebGLExtensionClass({ index: 13, str: 'WEBGL_color_buffer_float' });
const typeList = [VertexArrayObject, TextureFloat, TextureHalfFloat, TextureFloatLinear,
    TextureHalfFloatLinear, InstancedArrays, TextureFilterAnisotropic, ElementIndexUint,
    ShaderTextureLod, ShaderDerivatives, DrawBuffers, BlendMinmax, ColorBufferFloat];
function from({ index }) {
    return Object(_foundation_misc_EnumIO__WEBPACK_IMPORTED_MODULE_0__["_from"])({ typeList, index });
}
const WebGLExtension = Object.freeze({
    VertexArrayObject, TextureFloat, TextureHalfFloat, TextureFloatLinear, TextureHalfFloatLinear,
    InstancedArrays, TextureFilterAnisotropic, ElementIndexUint, ShaderTextureLod,
    ShaderDerivatives, DrawBuffers, BlendMinmax, ColorBufferFloat
});


/***/ }),

/***/ "./src/webgl/WebGLResourceRepository.ts":
/*!**********************************************!*\
  !*** ./src/webgl/WebGLResourceRepository.ts ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WebGLResourceRepository; });
/* harmony import */ var _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../foundation/renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../foundation/definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../foundation/definitions/TextureParameter */ "./src/foundation/definitions/TextureParameter.ts");
/* harmony import */ var _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../foundation/definitions/PixelFormat */ "./src/foundation/definitions/PixelFormat.ts");
/* harmony import */ var _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../foundation/definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../foundation/definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _WebGLContextWrapper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WebGLContextWrapper */ "./src/webgl/WebGLContextWrapper.ts");
/* harmony import */ var _foundation_math_MathUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../foundation/math/MathUtil */ "./src/foundation/math/MathUtil.ts");
/* harmony import */ var _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../foundation/definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _foundation_textures_AbstractTexture__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../foundation/textures/AbstractTexture */ "./src/foundation/textures/AbstractTexture.ts");
/* harmony import */ var _foundation_textures_RenderTargetTexture__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../foundation/textures/RenderTargetTexture */ "./src/foundation/textures/RenderTargetTexture.ts");
/* harmony import */ var _foundation_definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../foundation/definitions/HdriFormat */ "./src/foundation/definitions/HdriFormat.ts");
/* harmony import */ var _foundation_math_Vector4__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../foundation/math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _foundation_definitions_RenderBufferTarget__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../foundation/definitions/RenderBufferTarget */ "./src/foundation/definitions/RenderBufferTarget.ts");
/* harmony import */ var _foundation_misc_MiscUtil__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../foundation/misc/MiscUtil */ "./src/foundation/misc/MiscUtil.ts");
/* harmony import */ var _foundation_misc_DataUtil__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../foundation/misc/DataUtil */ "./src/foundation/misc/DataUtil.ts");
/* harmony import */ var _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../foundation/definitions/BasisCompressionType */ "./src/foundation/definitions/BasisCompressionType.ts");
/* harmony import */ var _WebGLExtension__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./WebGLExtension */ "./src/webgl/WebGLExtension.ts");


















class WebGLResourceRepository extends _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this.__webglContexts = new Map();
        this.__resourceCounter = _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_0__["default"].InvalidCGAPIResourceUid;
        this.__webglResources = new Map();
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new (WebGLResourceRepository)();
        }
        return this.__instance;
    }
    addWebGLContext(gl, canvas, asCurrent, isDebug) {
        const glw = new _WebGLContextWrapper__WEBPACK_IMPORTED_MODULE_6__["default"](gl, canvas, isDebug);
        this.__webglContexts.set('default', glw);
        if (asCurrent) {
            this.__glw = glw;
        }
    }
    get currentWebGLContextWrapper() {
        return this.__glw;
    }
    getResourceNumber() {
        return ++this.__resourceCounter;
    }
    getWebGLResource(WebGLResourceHandle) {
        const result = this.__webglResources.get(WebGLResourceHandle);
        return (result != null) ? result : null;
    }
    createIndexBuffer(accessor) {
        const gl = this.__glw.getRawContext();
        if (gl == null) {
            throw new Error("No WebGLRenderingContext set as Default.");
        }
        this.__glw.bindVertexArray(null);
        const ibo = gl.createBuffer();
        const resourceHandle = this.getResourceNumber();
        this.__webglResources.set(resourceHandle, ibo);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        //    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, accessor.bufferView.buffer.getArrayBuffer(), gl.STATIC_DRAW);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, accessor.getTypedArray(), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        return resourceHandle;
    }
    createVertexBuffer(accessor) {
        const gl = this.__glw.getRawContext();
        ;
        if (gl == null) {
            throw new Error("No WebGLRenderingContext set as Default.");
        }
        this.__glw.bindVertexArray(null);
        const vbo = gl.createBuffer();
        const resourceHandle = this.getResourceNumber();
        this.__webglResources.set(resourceHandle, vbo);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, accessor.bufferView.getUint8Array(), gl.STATIC_DRAW);
        //    gl.bufferData(gl.ARRAY_BUFFER, accessor.getTypedArray(), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return resourceHandle;
    }
    createVertexBufferFromTypedArray(typedArray) {
        const gl = this.__glw.getRawContext();
        ;
        if (gl == null) {
            throw new Error("No WebGLRenderingContext set as Default.");
        }
        this.__glw.bindVertexArray(null);
        const vbo = gl.createBuffer();
        const resourceHandle = this.getResourceNumber();
        this.__webglResources.set(resourceHandle, vbo);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, typedArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return resourceHandle;
    }
    resendVertexBuffer(primitive, vboHandles) {
        const gl = this.__glw.getRawContext();
        ;
        if (gl == null) {
            throw new Error("No WebGLRenderingContext set as Default.");
        }
        this.__glw.bindVertexArray(null);
        // const vbo = gl.createBuffer();
        // const resourceHandle = this.getResourceNumber();
        // this.__webglResources.set(resourceHandle, vbo!);
        primitive.attributeAccessors.forEach((accessor, i) => {
            const vbo = this.getWebGLResource(vboHandles[i]);
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, accessor.bufferView.getUint8Array(), gl.STATIC_DRAW);
            //    gl.bufferData(gl.ARRAY_BUFFER, accessor.getTypedArray(), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        });
    }
    createVertexArray() {
        const gl = this.__glw;
        if (gl == null) {
            throw new Error("No WebGLRenderingContext set as Default.");
        }
        const vao = this.__glw.createVertexArray();
        const resourceHandle = this.getResourceNumber();
        this.__webglResources.set(resourceHandle, vao);
        return resourceHandle;
    }
    bindTexture2D(textureSlotIndex, textureUid) {
        const texture = this.getWebGLResource(textureUid);
        this.__glw.bindTexture2D(textureSlotIndex, texture);
    }
    bindTextureCube(textureSlotIndex, textureUid) {
        const texture = this.getWebGLResource(textureUid);
        this.__glw.bindTextureCube(textureSlotIndex, texture);
    }
    createVertexDataResources(primitive) {
        const gl = this.__glw.getRawContext();
        const vaoHandle = this.createVertexArray();
        let iboHandle;
        if (primitive.hasIndices()) {
            iboHandle = this.createIndexBuffer(primitive.indicesAccessor);
        }
        const attributesFlags = [];
        for (let i = 0; i < _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].AttributeTypeNumber; i++) {
            attributesFlags[i] = false;
        }
        const vboHandles = [];
        primitive.attributeAccessors.forEach((accessor, i) => {
            const vboHandle = this.createVertexBuffer(accessor);
            const slotIdx = primitive.attributeSemantics[i].getAttributeSlot();
            attributesFlags[slotIdx] = true;
            vboHandles.push(vboHandle);
        });
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        return { vaoHandle: vaoHandle, iboHandle: iboHandle, vboHandles: vboHandles, attributesFlags: attributesFlags, setComplete: false };
    }
    createVertexBufferAndIndexBuffer(primitive) {
        const gl = this.__glw.getRawContext();
        let iboHandle;
        if (primitive.hasIndices()) {
            iboHandle = this.createIndexBuffer(primitive.indicesAccessor);
        }
        const attributesFlags = [];
        for (let i = 0; i < _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].AttributeTypeNumber; i++) {
            attributesFlags[i] = false;
        }
        const vboHandles = [];
        primitive.attributeAccessors.forEach((accessor, i) => {
            const vboHandle = this.createVertexBuffer(accessor);
            const slotIdx = primitive.attributeSemantics[i].getAttributeSlot();
            attributesFlags[slotIdx] = true;
            vboHandles.push(vboHandle);
        });
        return { vaoHandle: -1, iboHandle: iboHandle, vboHandles: vboHandles, attributesFlags: attributesFlags, setComplete: false };
    }
    createShaderProgram({ materialTypeName, vertexShaderStr, fragmentShaderStr, attributeNames, attributeSemantics }) {
        const gl = this.__glw.getRawContext();
        if (gl == null) {
            throw new Error("No WebGLRenderingContext set as Default.");
        }
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderStr);
        gl.compileShader(vertexShader);
        if (this.__glw.isDebugMode) {
            this.__checkShaderCompileStatus(materialTypeName, vertexShader, vertexShaderStr);
        }
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderStr);
        gl.compileShader(fragmentShader);
        if (this.__glw.isDebugMode) {
            this.__checkShaderCompileStatus(materialTypeName, fragmentShader, fragmentShaderStr);
        }
        const shaderProgram = gl.createProgram();
        shaderProgram._gl = gl;
        shaderProgram._materialTypeName = materialTypeName;
        shaderProgram._vertexShaderStr = vertexShaderStr;
        shaderProgram._fragmentShaderStr = fragmentShaderStr;
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        attributeNames.forEach((attributeName, i) => {
            gl.bindAttribLocation(shaderProgram, attributeSemantics[i].getAttributeSlot(), attributeName);
        });
        gl.linkProgram(shaderProgram);
        if (this.__glw.isDebugMode) {
            this.__checkShaderProgramLinkStatus(materialTypeName, shaderProgram, vertexShaderStr, fragmentShaderStr);
        }
        const resourceHandle = this.getResourceNumber();
        this.__webglResources.set(resourceHandle, shaderProgram);
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        return resourceHandle;
    }
    __addLineNumber(shaderString) {
        let shaderTextLines = shaderString.split(/\r\n|\r|\n/);
        let shaderTextWithLineNumber = '';
        for (let i = 0; i < shaderTextLines.length; i++) {
            let lineIndex = i + 1;
            let splitter = ' : ';
            if (lineIndex < 10) {
                splitter = '  : ';
            }
            else if (lineIndex >= 100) {
                splitter = ': ';
            }
            shaderTextWithLineNumber += lineIndex + splitter + shaderTextLines[i] + '\n';
        }
        return shaderTextWithLineNumber;
    }
    __checkShaderCompileStatus(materialTypeName, shader, shaderText) {
        const gl = this.__glw.getRawContext();
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.log('MaterialTypeName: ' + materialTypeName);
            console.log(this.__addLineNumber(shaderText));
            throw new Error('An error occurred compiling the shaders:' + gl.getShaderInfoLog(shader));
        }
    }
    __checkShaderProgramLinkStatus(materialTypeName, shaderProgram, vertexShaderText, fragmentShaderText) {
        const gl = this.__glw.getRawContext();
        // If creating the shader program failed, alert
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.log('MaterialTypeName: ' + materialTypeName);
            console.log(this.__addLineNumber('Vertex Shader:'));
            console.log(this.__addLineNumber(vertexShaderText));
            console.log(this.__addLineNumber('Fragment Shader:'));
            console.log(this.__addLineNumber(fragmentShaderText));
            throw new Error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
        }
    }
    setupUniformLocations(shaderProgramUid, dataArray) {
        const gl = this.__glw.getRawContext();
        const shaderProgram = this.getWebGLResource(shaderProgramUid);
        const shaderSemanticsInfoMap = new Map();
        for (let arg of dataArray) {
            shaderSemanticsInfoMap.set(arg.semantic.str, arg);
        }
        for (let data of dataArray) {
            let semanticSingular = data.semantic.str;
            let identifier = semanticSingular;
            let shaderVarName = _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_8__["ShaderSemantics"].fullSemanticStr(data);
            if (data.index != null) {
                if (shaderVarName.match(/\[.+?\]/)) {
                    shaderVarName = shaderVarName.replace(/\[.+?\]/g, `[${data.index}]`);
                }
                else {
                    shaderVarName += `[${data.index}]`;
                }
            }
            if (data.none_u_prefix !== true) {
                shaderVarName = 'u_' + shaderVarName;
            }
            const location = gl.getUniformLocation(shaderProgram, shaderVarName);
            if (data.index != null) {
                if (shaderProgram[identifier] == null) {
                    shaderProgram[identifier] = [];
                }
                shaderProgram[identifier][data.index] = location;
            }
            else {
                shaderProgram[identifier] = location;
            }
        }
        if (shaderProgram._shaderSemanticsInfoMap != null) {
            shaderProgram._shaderSemanticsInfoMap = new Map([...shaderProgram._shaderSemanticsInfoMap, ...shaderSemanticsInfoMap]);
        }
        else {
            shaderProgram._shaderSemanticsInfoMap = shaderSemanticsInfoMap;
        }
        return shaderProgram;
    }
    __isUniformValueDirty(isVector, shaderProgram, identifier, { x, y, z, w }, delta = Number.EPSILON) {
        const valueIdentifier = identifier + '_value';
        const value = shaderProgram[valueIdentifier];
        if (value == null) {
            return true;
        }
        let result = false;
        if (isVector) {
            const length = x.length;
            if (length > 4) {
                return true;
            }
            for (let i = 0; i < length; i++) {
                if (Math.abs(x[i] - value[i]) >= delta) {
                    result = true;
                    break;
                }
            }
            shaderProgram[valueIdentifier] = x;
        }
        else {
            const compare = () => {
                if (x != null && Math.abs(x - value[0]) >= delta) {
                    return true;
                }
                if (y != null && Math.abs(y - value[1]) >= delta) {
                    return true;
                }
                if (z != null && Math.abs(z - value[2]) >= delta) {
                    return true;
                }
                if (w != null && Math.abs(w - value[3]) >= delta) {
                    return true;
                }
                return false;
            };
            result = compare();
            shaderProgram[valueIdentifier] = [x, y, z, w];
        }
        return result;
    }
    setUniformValue(shaderProgram, semanticStr, firstTime, value, index) {
        const info = shaderProgram._shaderSemanticsInfoMap.get(semanticStr);
        if (info == null) {
            return false;
        }
        // if (!firstTime) {
        //   const updateInterval = info.updateInterval!;
        //   if (updateInterval != null && updateInterval === ShaderVariableUpdateInterval.FirstTimeOnly) {
        //     return false;
        //   }
        //   // if (!this.__isUniformValueDirty(isVector, shaderProgram, identifier, {x, y, z, w}, delta)) {
        //   //   return false;
        //   // }
        // }
        let setAsMatrix = false;
        let componentNumber = 0;
        if (info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Mat3) {
            setAsMatrix = true;
            componentNumber = 3;
        }
        else if (info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Mat4) {
            setAsMatrix = true;
            componentNumber = 4;
        }
        else {
            componentNumber = info.compositionType.getNumberOfComponents();
        }
        const key = semanticStr;
        let updated = false;
        if (info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Texture2D || info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].TextureCube) {
            updated = this.setUniformValueInner(shaderProgram, key, info, setAsMatrix, componentNumber, false, { x: value[0] }, { firstTime: firstTime }, index);
            this.bindTexture(info, value);
        }
        else if (index == null && (info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].ScalarArray || info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec4Array || info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec3Array || info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec2Array)) {
            if (value.v == null) {
                updated = this.setUniformValueInner(shaderProgram, key, info, setAsMatrix, componentNumber, true, { x: value }, { firstTime: firstTime }, index);
            }
            else {
                updated = this.setUniformValueInner(shaderProgram, key, info, setAsMatrix, componentNumber, true, { x: value.v }, { firstTime: firstTime }, index);
            }
        }
        else if (info.compositionType !== _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Scalar) {
            if (value.v == null) {
                updated = this.setUniformValueInner(shaderProgram, key, info, setAsMatrix, componentNumber, false, value, { firstTime: firstTime }, index);
            }
            else {
                updated = this.setUniformValueInner(shaderProgram, key, info, setAsMatrix, componentNumber, true, { x: value.v }, { firstTime: firstTime }, index);
            }
        }
        else {
            // if CompositionType.Scalar, then...
            if (value.v == null) {
                updated = this.setUniformValueInner(shaderProgram, key, info, setAsMatrix, componentNumber, false, { x: value }, { firstTime: firstTime }, index);
            }
            else {
                updated = this.setUniformValueInner(shaderProgram, key, info, setAsMatrix, componentNumber, true, { x: value.v }, { firstTime: firstTime }, index);
            }
        }
        return updated;
    }
    bindTexture(info, value) {
        if (info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Texture2D) {
            this.bindTexture2D(value[0], (value[1] instanceof _foundation_textures_AbstractTexture__WEBPACK_IMPORTED_MODULE_9__["default"]) ? value[1].cgApiResourceUid : value[1]);
        }
        else if (info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].TextureCube) {
            this.bindTextureCube(value[0], (value[1] instanceof _foundation_textures_AbstractTexture__WEBPACK_IMPORTED_MODULE_9__["default"]) ? value[1].cgApiResourceUid : value[1]);
        }
    }
    setUniformValueInner(shaderProgram, semanticStr, info, isMatrix, componentNumber, isVector, { x, y, z, w }, { firstTime = true, delta }, index) {
        let identifier = semanticStr;
        let program;
        if (index != null) {
            program = shaderProgram[identifier][index];
        }
        else {
            program = shaderProgram[identifier];
        }
        const gl = this.__glw.getRawContext();
        if (isMatrix) {
            if (componentNumber === 4) {
                gl.uniformMatrix4fv(program, false, x);
            }
            else {
                gl.uniformMatrix3fv(program, false, x);
            }
        }
        else if (isVector) {
            const componentType = info.componentType === _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Int || info.componentType === _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Short || info.componentType === _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Byte;
            if (componentNumber === 1) {
                if (componentType) {
                    gl.uniform1iv(program, x);
                }
                else {
                    gl.uniform1fv(program, x);
                }
            }
            else if (componentNumber === 2) {
                if (componentType) {
                    gl.uniform2iv(program, x);
                }
                else {
                    gl.uniform2fv(program, x);
                }
            }
            else if (componentNumber === 3) {
                if (componentType) {
                    gl.uniform3iv(program, x);
                }
                else {
                    gl.uniform3fv(program, x);
                }
            }
            else if (componentNumber === 4) {
                if (componentType) {
                    gl.uniform4iv(program, x);
                }
                else {
                    gl.uniform4fv(program, x);
                }
            }
        }
        else {
            const componentType = info.componentType === _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Int || info.componentType === _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Short || info.componentType === _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Byte;
            if (componentNumber === 1) {
                if (componentType) {
                    gl.uniform1i(program, x);
                }
                else {
                    gl.uniform1f(program, x);
                }
            }
            else if (componentNumber === 2) {
                if (componentType) {
                    gl.uniform2i(program, x, y);
                }
                else {
                    gl.uniform2f(program, x, y);
                }
            }
            else if (componentNumber === 3) {
                if (componentType) {
                    gl.uniform3i(program, x, y, z);
                }
                else {
                    gl.uniform3f(program, x, y, z);
                }
            }
            else if (componentNumber === 4) {
                if (componentType) {
                    gl.uniform4i(program, x, y, z, w);
                }
                else {
                    gl.uniform4f(program, x, y, z, w);
                }
            }
        }
        return true;
    }
    setVertexDataToPipeline({ vaoHandle, iboHandle, vboHandles }, primitive, instanceIDBufferUid = _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_0__["default"].InvalidCGAPIResourceUid) {
        const gl = this.__glw.getRawContext();
        const vao = this.getWebGLResource(vaoHandle);
        // VAO bind
        this.__glw.bindVertexArray(vao);
        // IBO bind
        if (iboHandle != null) {
            const ibo = this.getWebGLResource(iboHandle);
            if (ibo != null) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
            }
            else {
                throw new Error('Nothing Element Array Buffer!');
            }
        }
        // bind vertex attributes to VBO's
        vboHandles.forEach((vboHandle, i) => {
            const vbo = this.getWebGLResource(vboHandle);
            if (vbo != null) {
                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            }
            else {
                throw new Error('Nothing Element Array Buffer at index ' + i);
            }
            gl.enableVertexAttribArray(primitive.attributeSemantics[i].getAttributeSlot());
            gl.vertexAttribPointer(primitive.attributeSemantics[i].getAttributeSlot(), primitive.attributeCompositionTypes[i].getNumberOfComponents(), primitive.attributeComponentTypes[i].index, primitive.attributeAccessors[i].normalized, primitive.attributeAccessors[i].byteStride, primitive.attributeAccessors[i].byteOffsetInBufferView);
        });
        /// for InstanceIDBuffer
        if (instanceIDBufferUid !== _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_0__["default"].InvalidCGAPIResourceUid) {
            const instanceIDBuffer = this.getWebGLResource(instanceIDBufferUid);
            if (instanceIDBuffer != null) {
                gl.bindBuffer(gl.ARRAY_BUFFER, instanceIDBuffer);
            }
            else {
                throw new Error('Nothing Element Array Buffer at index');
            }
            gl.enableVertexAttribArray(_foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].Instance.getAttributeSlot());
            gl.vertexAttribPointer(_foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].Instance.getAttributeSlot(), _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Scalar.getNumberOfComponents(), _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float.index, false, 0, 0);
            this.__glw.vertexAttribDivisor(_foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_1__["VertexAttribute"].Instance.getAttributeSlot(), 1);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this.__glw.bindVertexArray(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }
    createTexture(data, { level, internalFormat, width, height, border, format, type, magFilter, minFilter, wrapS, wrapT, generateMipmap, anisotropy, isPremultipliedAlpha }) {
        const gl = this.__glw.getRawContext();
        const isWebGL2 = this.__glw.isWebGL2;
        const texture = gl.createTexture();
        const resourceHandle = this.getResourceNumber();
        texture._resourceUid = resourceHandle;
        this.__webglResources.set(resourceHandle, texture);
        this.__glw.bindTexture2D(0, texture);
        if (isPremultipliedAlpha) {
            // gl.texParameteri(gl.TEXTURE_2D, gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        }
        else {
            // gl.texParameteri(gl.TEXTURE_2D, gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        }
        if (data instanceof HTMLImageElement || data instanceof HTMLCanvasElement) {
            if (isWebGL2) {
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat.index, width, height, border, format.index, _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].UnsignedByte.index, data);
            }
            else {
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat.index, format.index, type.index, data);
            }
        }
        else {
            if (isWebGL2) {
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat.index, width, height, border, format.index, _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].Float.index, data);
            }
            else {
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat.index, width, height, border, format.index, type.index, data);
            }
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS.index);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT.index);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter.index);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter.index);
        if (_foundation_math_MathUtil__WEBPACK_IMPORTED_MODULE_7__["MathUtil"].isPowerOfTwoTexture(width, height)) {
            if (anisotropy) {
                if (this.__glw.webgl2ExtTFA) {
                    gl.texParameteri(gl.TEXTURE_2D, this.__glw.webgl2ExtTFA.TEXTURE_MAX_ANISOTROPY_EXT, 4);
                }
                else if (this.__glw.webgl1ExtTFA) {
                    gl.texParameteri(gl.TEXTURE_2D, this.__glw.webgl1ExtTFA.TEXTURE_MAX_ANISOTROPY_EXT, 4);
                }
            }
            else if (this.__glw.webgl1ExtTFA) {
                gl.texParameteri(gl.TEXTURE_2D, this.__glw.webgl1ExtTFA.TEXTURE_MAX_ANISOTROPY_EXT, 1);
            }
            const isGenerateMipmap = generateMipmap && (height !== 1 && width !== 1 && !(this.__glw.isWebGL2 && _foundation_misc_MiscUtil__WEBPACK_IMPORTED_MODULE_14__["MiscUtil"].isMobile()));
            if (isGenerateMipmap) {
                gl.generateMipmap(gl.TEXTURE_2D);
            }
        }
        this.__glw.unbindTexture2D(0);
        return resourceHandle;
    }
    createCompressedTextureFromBasis(basisFile, { border, format, type, magFilter, minFilter, wrapS, wrapT, anisotropy, isPremultipliedAlpha }) {
        let basisCompressionType;
        let compressionType;
        const gl = this.__glw.getRawContext();
        const texture = gl.createTexture();
        const resourceHandle = this.getResourceNumber();
        texture._resourceUid = resourceHandle;
        this.__webglResources.set(resourceHandle, texture);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const s3tc = gl.getExtension("WEBGL_compressed_texture_s3tc");
        if (s3tc) {
            basisCompressionType = _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__["BasisCompressionType"].BC3;
            compressionType = s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        const etc1 = gl.getExtension("WEBGL_compressed_texture_etc1");
        if (etc1) {
            basisCompressionType = _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__["BasisCompressionType"].ETC1;
            compressionType = etc1.COMPRESSED_RGB_ETC1_WEBGL;
        }
        const atc = gl.getExtension("WEBGL_compressed_texture_atc");
        if (atc) {
            basisCompressionType = _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__["BasisCompressionType"].ATC_RGBA;
            compressionType = atc.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
        }
        const etc2 = gl.getExtension("WEBGL_compressed_texture_etc");
        if (etc2) {
            basisCompressionType = _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__["BasisCompressionType"].ETC2;
            compressionType = etc2.COMPRESSED_RGBA8_ETC2_EAC;
        }
        const pvrtc = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        if (pvrtc) {
            basisCompressionType = _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__["BasisCompressionType"].PVRTC1_RGBA;
            compressionType = pvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        }
        const astc = gl.getExtension("WEBGL_compressed_texture_astc");
        if (astc) {
            basisCompressionType = _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__["BasisCompressionType"].ASTC;
            compressionType = astc.COMPRESSED_RGBA_ASTC_4x4_KHR;
        }
        const mipmapDepth = basisFile.getNumLevels(0);
        if (isPremultipliedAlpha) {
            // gl.texParameteri(gl.TEXTURE_2D, gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        }
        else {
            // gl.texParameteri(gl.TEXTURE_2D, gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        }
        for (let i = 0; i < mipmapDepth; i++) {
            const width = basisFile.getImageWidth(0, i);
            const height = basisFile.getImageHeight(0, i);
            const textureSource = this.decodeBasisImage(basisFile, basisCompressionType, 0, i);
            gl.compressedTexImage2D(gl.TEXTURE_2D, i, compressionType, width, height, border, textureSource);
        }
        if (mipmapDepth == 0) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter.index);
            let minFilter_ = minFilter;
            if (minFilter === _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].LinearMipmapLinear) {
                minFilter_ = _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Linear;
            }
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter_.index);
        }
        else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter.index);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter.index);
            if (anisotropy && this.__glw.webgl1ExtTFA) {
                gl.texParameteri(gl.TEXTURE_2D, this.__glw.webgl1ExtTFA.TEXTURE_MAX_ANISOTROPY_EXT, 4);
            }
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS.index);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT.index);
        this.__glw.unbindTexture2D(0);
        return resourceHandle;
    }
    decodeBasisImage(basisFile, basisCompressionType, imageIndex, levelIndex) {
        const extractSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisCompressionType.index);
        const textureSource = new Uint8Array(extractSize);
        if (!basisFile.transcodeImage(textureSource, imageIndex, levelIndex, basisCompressionType.index, 0, 0)) {
            console.error("failed to transcode the image.");
        }
        return textureSource;
    }
    createFrameBufferObject() {
        const gl = this.__glw.getRawContext();
        var fbo = gl.createFramebuffer();
        const resourceHandle = this.getResourceNumber();
        this.__webglResources.set(resourceHandle, fbo);
        return resourceHandle;
    }
    attachColorBufferToFrameBufferObject(framebuffer, index, renderable) {
        const gl = this.__glw.getRawContext();
        const fbo = this.getWebGLResource(framebuffer.framebufferUID);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        const renderableWebGLResource = this.getWebGLResource(renderable.cgApiResourceUid);
        const attachmentId = this.__glw.colorAttachment(index);
        if (renderable instanceof _foundation_textures_RenderTargetTexture__WEBPACK_IMPORTED_MODULE_10__["default"]) {
            renderable._fbo = framebuffer;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentId, gl.TEXTURE_2D, renderableWebGLResource, 0);
        }
        else {
            // It's must be RenderBuffer
            renderable._fbo = framebuffer;
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentId, gl.RENDERBUFFER, renderableWebGLResource);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    attachDepthBufferToFrameBufferObject(framebuffer, renderable) {
        this.__attachDepthOrStencilBufferToFrameBufferObject(framebuffer, renderable, 36096); // gl.DEPTH_ATTACHMENT
    }
    attachStencilBufferToFrameBufferObject(framebuffer, renderable) {
        this.__attachDepthOrStencilBufferToFrameBufferObject(framebuffer, renderable, 36128); // gl.STENCIL_ATTACHMENT
    }
    attachDepthStencilBufferToFrameBufferObject(framebuffer, renderable) {
        this.__attachDepthOrStencilBufferToFrameBufferObject(framebuffer, renderable, 33306); // gl.DEPTH_STENCIL_ATTACHMENT
    }
    __attachDepthOrStencilBufferToFrameBufferObject(framebuffer, renderable, attachmentType) {
        const gl = this.__glw.getRawContext();
        const fbo = this.getWebGLResource(framebuffer.framebufferUID);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        const renderableWebGLResource = this.getWebGLResource(renderable.cgApiResourceUid);
        if (renderable instanceof _foundation_textures_RenderTargetTexture__WEBPACK_IMPORTED_MODULE_10__["default"]) {
            renderable._fbo = framebuffer;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, renderableWebGLResource, 0);
        }
        else {
            // It's must be RenderBuffer
            renderable._fbo = framebuffer;
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentType, gl.RENDERBUFFER, renderableWebGLResource);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    createRenderBuffer(width, height, internalFormat) {
        const gl = this.__glw.getRawContext();
        var renderBuffer = gl.createRenderbuffer();
        const resourceHandle = this.getResourceNumber();
        this.__webglResources.set(resourceHandle, renderBuffer);
        gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl[internalFormat.str], width, height);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        return resourceHandle;
    }
    setDrawTargets(framebuffer) {
        if (framebuffer) {
            this.__glw.drawBuffers(framebuffer.colorAttachmentsRenderBufferTargets);
        }
        else {
            this.__glw.drawBuffers([_foundation_definitions_RenderBufferTarget__WEBPACK_IMPORTED_MODULE_13__["RenderBufferTarget"].Back]);
        }
    }
    bindFramebuffer(framebuffer) {
        const gl = this.__glw.getRawContext();
        if (framebuffer) {
            const fboUid = framebuffer.cgApiResourceUid;
            const fbo = this.getWebGLResource(fboUid);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        }
        else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    }
    unbindFramebuffer() {
        const gl = this.__glw.getRawContext();
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    createRenderTargetTexture({ width, height, level, internalFormat, format, type, magFilter, minFilter, wrapS, wrapT }) {
        const gl = this.__glw.getRawContext();
        const texture = gl.createTexture();
        const resourceHandle = this.getResourceNumber();
        texture._resourceUid = resourceHandle;
        this.__webglResources.set(resourceHandle, texture);
        this.__glw.bindTexture2D(0, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter.index);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter.index);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS.index);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT.index);
        if (
        // if WebGL2
        this.__glw.isWebGL2 &&
            // if DEPTH_COMPONENT
            (internalFormat.index === 6402 || internalFormat.index === 33189 ||
                internalFormat.index === 33190 || internalFormat.index === 33191)) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, gl.LESS);
        }
        if (this.__glw.isWebGL2) {
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat.index, width, height, 0, format.index, _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].UnsignedByte.index, null);
        }
        else {
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat.index, width, height, 0, format.index, type.index, null);
        }
        this.__glw.unbindTexture2D(0);
        return resourceHandle;
    }
    createCubeTexture(mipLevelCount, images, width, height) {
        const gl = this.__glw.getRawContext();
        const texture = gl.createTexture();
        const resourceHandle = this.getResourceNumber();
        texture._resourceUid = resourceHandle;
        this.__webglResources.set(resourceHandle, texture);
        this.__glw.bindTextureCube(0, texture);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (images[0].posX.hdriFormat === _foundation_definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_11__["HdriFormat"].HDR_LINEAR &&
            this.__glw.isNotSupportWebGL1Extension(_WebGLExtension__WEBPACK_IMPORTED_MODULE_17__["WebGLExtension"].TextureFloatLinear)) {
            if (mipLevelCount >= 2) {
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
            }
            else {
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            }
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        }
        else {
            if (mipLevelCount >= 2) {
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            }
            else {
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }
        const loadImageToGPU = (image, cubeMapSide, i) => {
            if (image.hdriFormat === _foundation_definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_11__["HdriFormat"].HDR_LINEAR) {
                if (this.__glw.isWebGL2) {
                    gl.texImage2D(cubeMapSide, i, gl.RGB32F, image.width, image.height, 0, gl.RGB, gl.FLOAT, image.dataFloat);
                }
                else {
                    gl.texImage2D(cubeMapSide, i, gl.RGB, image.width, image.height, 0, gl.RGB, gl.FLOAT, image.dataFloat);
                }
            }
            else if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
                gl.texImage2D(cubeMapSide, i, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            }
            else {
                gl.texImage2D(cubeMapSide, i, gl.RGBA, width / (i + 1), height / (i + 1), 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
            }
        };
        for (let i = 0; i < images.length; i++) {
            const image = images[i];
            loadImageToGPU(image.posX, gl.TEXTURE_CUBE_MAP_POSITIVE_X, i);
            loadImageToGPU(image.negX, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, i);
            loadImageToGPU(image.posY, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, i);
            loadImageToGPU(image.negY, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, i);
            loadImageToGPU(image.posZ, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, i);
            loadImageToGPU(image.negZ, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, i);
        }
        this.__glw.unbindTextureCube(0);
        return resourceHandle;
    }
    /**
     * Create Cube Texture from image files.
     * @param baseUri the base uri to load images;
     * @param mipLevelCount the number of mip levels (include root level). if no mipmap, the value should be 1;
     * @returns the WebGLResourceHandle for the generated Cube Texture
     */
    async createCubeTextureFromFiles(baseUri, mipLevelCount, isNamePosNeg, hdriFormat) {
        const gl = this.__glw.getRawContext();
        const imageArgs = [];
        let width = 0;
        let height = 0;
        for (let i = 0; i < mipLevelCount; i++) {
            const loadOneLevel = () => {
                return new Promise((resolve, reject) => {
                    let loadedCount = 0;
                    const images = [];
                    let extension = '.jpg';
                    if (hdriFormat === _foundation_definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_11__["HdriFormat"].HDR_LINEAR) {
                        extension = '.hdr';
                    }
                    else if (hdriFormat === _foundation_definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_11__["HdriFormat"].RGBE_PNG) {
                        extension = '.RGBE.PNG';
                    }
                    let posX = '_right_';
                    let negX = '_left_';
                    let posY = '_top_';
                    let negY = '_bottom_';
                    let posZ = '_front_';
                    let negZ = '_back_';
                    if (isNamePosNeg) {
                        posX = '_posx_';
                        negX = '_negx_';
                        posY = '_posy_';
                        negY = '_negy_';
                        posZ = '_posz_';
                        negZ = '_negz_';
                    }
                    let faces = [
                        [baseUri + posX + i + extension, gl.TEXTURE_CUBE_MAP_POSITIVE_X],
                        [baseUri + negX + i + extension, gl.TEXTURE_CUBE_MAP_NEGATIVE_X],
                        [baseUri + posY + i + extension, gl.TEXTURE_CUBE_MAP_POSITIVE_Y],
                        [baseUri + negY + i + extension, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y],
                        [baseUri + posZ + i + extension, gl.TEXTURE_CUBE_MAP_POSITIVE_Z],
                        [baseUri + negZ + i + extension, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]
                    ];
                    for (var j = 0; j < faces.length; j++) {
                        const face = faces[j][1];
                        let image;
                        if (hdriFormat === _foundation_definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_11__["HdriFormat"].HDR_LINEAR || hdriFormat === _foundation_definitions_HdriFormat__WEBPACK_IMPORTED_MODULE_11__["HdriFormat"].RGB9_E5_PNG) {
                            image = new HDRImage();
                        }
                        else {
                            image = new Image();
                        }
                        image.hdriFormat = hdriFormat;
                        image.side = face;
                        image.uri = faces[j][0];
                        image.crossOrigin = "Anonymous";
                        image.onload = () => {
                            loadedCount++;
                            images.push(image);
                            if (loadedCount === 6) {
                                resolve(images);
                            }
                        };
                        image.onerror = () => {
                            reject(image.uri);
                        };
                        image.src = faces[j][0];
                    }
                });
            };
            let images;
            try {
                images = await loadOneLevel();
            }
            catch (e) {
                // Try again once
                try {
                    images = await loadOneLevel();
                }
                catch (uri) {
                    // Give up
                    console.error(`failed to load ${uri}`);
                }
            }
            const imageObj = {};
            for (let image of images) {
                switch (image.side) {
                    case gl.TEXTURE_CUBE_MAP_POSITIVE_X:
                        imageObj.posX = image;
                        break;
                    case gl.TEXTURE_CUBE_MAP_POSITIVE_Y:
                        imageObj.posY = image;
                        break;
                    case gl.TEXTURE_CUBE_MAP_POSITIVE_Z:
                        imageObj.posZ = image;
                        break;
                    case gl.TEXTURE_CUBE_MAP_NEGATIVE_X:
                        imageObj.negX = image;
                        break;
                    case gl.TEXTURE_CUBE_MAP_NEGATIVE_Y:
                        imageObj.negY = image;
                        break;
                    case gl.TEXTURE_CUBE_MAP_NEGATIVE_Z:
                        imageObj.negZ = image;
                        break;
                }
                if (i === 0) {
                    width = image.width;
                    height = image.height;
                }
            }
            imageArgs.push(imageObj);
        }
        return this.createCubeTexture(mipLevelCount, imageArgs, width, height);
    }
    createCubeTextureFromBasis(basisFile, { magFilter = _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Linear, minFilter = _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].LinearMipmapLinear, wrapS = _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Repeat, wrapT = _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Repeat, border = 0 }) {
        const gl = this.__glw.getRawContext();
        let basisCompressionType;
        let compressionType;
        const texture = gl.createTexture();
        const resourceHandle = this.getResourceNumber();
        texture._resourceUid = resourceHandle;
        this.__webglResources.set(resourceHandle, texture);
        this.__glw.bindTextureCube(0, texture);
        const s3tc = gl.getExtension("WEBGL_compressed_texture_s3tc");
        if (s3tc) {
            basisCompressionType = _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__["BasisCompressionType"].BC3;
            compressionType = s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        const etc1 = gl.getExtension("WEBGL_compressed_texture_etc1");
        if (etc1) {
            basisCompressionType = _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__["BasisCompressionType"].ETC1;
            compressionType = etc1.COMPRESSED_RGB_ETC1_WEBGL;
        }
        const atc = gl.getExtension("WEBGL_compressed_texture_atc");
        if (atc) {
            basisCompressionType = _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__["BasisCompressionType"].ATC_RGBA;
            compressionType = atc.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
        }
        const etc2 = gl.getExtension("WEBGL_compressed_texture_etc");
        if (etc2) {
            basisCompressionType = _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__["BasisCompressionType"].ETC2;
            compressionType = etc2.COMPRESSED_RGBA8_ETC2_EAC;
        }
        const pvrtc = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        if (pvrtc) {
            basisCompressionType = _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__["BasisCompressionType"].PVRTC1_RGBA;
            compressionType = pvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        }
        const astc = gl.getExtension("WEBGL_compressed_texture_astc");
        if (astc) {
            basisCompressionType = _foundation_definitions_BasisCompressionType__WEBPACK_IMPORTED_MODULE_16__["BasisCompressionType"].ASTC;
            compressionType = astc.COMPRESSED_RGBA_ASTC_4x4_KHR;
        }
        const numImages = basisFile.getNumImages();
        const mipmapDepth = basisFile.getNumLevels(0);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, wrapS.index);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, wrapT.index);
        if (mipmapDepth >= 2) {
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, minFilter.index);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, magFilter.index);
        }
        else {
            let minFilter_ = minFilter;
            if (minFilter === _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].LinearMipmapLinear) {
                minFilter_ = _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Linear;
            }
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, minFilter_.index);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, magFilter.index);
        }
        for (let i = 0; i < mipmapDepth; i++) {
            for (let j = 0; j < numImages; j++) {
                const width = basisFile.getImageWidth(j, i);
                const height = basisFile.getImageHeight(j, i);
                const textureSource = this.decodeBasisImage(basisFile, basisCompressionType, j, i);
                gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, i, compressionType, width, height, border, textureSource);
            }
        }
        this.__glw.unbindTextureCube(0);
        return resourceHandle;
    }
    createDummyBlackCubeTexture() {
        const base64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPj/HwADBwIAMCbHYQAAAABJRU5ErkJggg==';
        const arrayBuffer = this.__createDummyTextureInner(base64);
        const typedArray = new Uint8Array(arrayBuffer);
        return this.createCubeTexture(1, [{ posX: typedArray, negX: typedArray, posY: typedArray, negY: typedArray, posZ: typedArray, negZ: typedArray }], 1, 1);
    }
    createDummyCubeTexture(rgbaStr = 'rgba(0,0,0,1)') {
        var canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = rgbaStr;
        ctx.fillRect(0, 0, 1, 1);
        return this.createCubeTexture(1, [{ posX: canvas, negX: canvas, posY: canvas, negY: canvas, posZ: canvas, negZ: canvas }], 1, 1);
    }
    setWebGLTextureDirectly(webGLTexture) {
        const texture = webGLTexture;
        const resourceHandle = this.getResourceNumber();
        texture._resourceUid = resourceHandle;
        this.__webglResources.set(resourceHandle, texture);
        return resourceHandle;
    }
    async createTextureFromDataUri(dataUri, { level, internalFormat, border, format, type, magFilter, minFilter, wrapS, wrapT, generateMipmap, anisotropy, isPremultipliedAlpha }) {
        return new Promise((resolve) => {
            const img = new Image();
            if (!dataUri.match(/^data:/)) {
                img.crossOrigin = 'Anonymous';
            }
            img.onload = () => {
                const width = img.width;
                const height = img.height;
                let texture = this.createTexture(img, { level, internalFormat, width, height, border, format, type, magFilter, minFilter, wrapS, wrapT, generateMipmap, anisotropy, isPremultipliedAlpha });
                resolve(texture);
            };
            img.src = dataUri;
        });
    }
    updateTexture(textureUid, typedArray, { level, xoffset, yoffset, width, height, format, type }) {
        const gl = this.__glw.getRawContext();
        ;
        const texture = this.getWebGLResource(textureUid);
        this.__glw.bindTexture2D(0, texture);
        gl.texSubImage2D(gl.TEXTURE_2D, level, 0, 0, width, height, format.index, type.index, typedArray);
        this.__glw.unbindTexture2D(0);
    }
    deleteFrameBufferObject(frameBufferObjectHandle) {
        const fbo = this.getWebGLResource(frameBufferObjectHandle);
        const gl = this.__glw.getRawContext();
        if (fbo != null) {
            gl.deleteFramebuffer(fbo);
            this.__webglResources.delete(frameBufferObjectHandle);
        }
    }
    deleteRenderBuffer(renderBufferUid) {
        const gl = this.__glw.getRawContext();
        const renderBuffer = this.getWebGLResource(renderBufferUid);
        gl.deleteRenderbuffer(renderBuffer);
        this.__webglResources.delete(renderBufferUid);
    }
    deleteTexture(textureHandle) {
        const texture = this.getWebGLResource(textureHandle);
        const gl = this.__glw.getRawContext();
        if (texture != null) {
            gl.deleteTexture(texture);
            this.__webglResources.delete(textureHandle);
        }
    }
    createDummyTexture(rgbaStr = "rgba(255,255,255,1)") {
        var canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = rgbaStr;
        ctx.fillRect(0, 0, 1, 1);
        return this.createTexture(canvas, {
            level: 0, internalFormat: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_3__["PixelFormat"].RGBA, width: 1, height: 1,
            border: 0, format: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_3__["PixelFormat"].RGBA, type: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].UnsignedByte, magFilter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Nearest, minFilter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Nearest,
            wrapS: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].ClampToEdge, wrapT: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].ClampToEdge, generateMipmap: false, anisotropy: false, isPremultipliedAlpha: false
        });
    }
    createDummyBlackTexture() {
        const base64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPj/HwADBwIAMCbHYQAAAABJRU5ErkJggg==';
        return this.__createDummyTextureInner(base64);
    }
    createDummyWhiteTexture() {
        const base64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5/hPwAIAgL/4d1j8wAAAABJRU5ErkJggg==';
        return this.__createDummyTextureInner(base64);
    }
    createDummyNormalTexture() {
        const base64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mOsr///HwAGgAL+v1RumAAAAABJRU5ErkJggg==';
        return this.__createDummyTextureInner(base64);
    }
    __createDummyTextureInner(base64) {
        const arrayBuffer = _foundation_misc_DataUtil__WEBPACK_IMPORTED_MODULE_15__["default"].base64ToArrayBuffer(base64);
        return this.createTexture(new Uint8Array(arrayBuffer), {
            level: 0, internalFormat: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_3__["PixelFormat"].RGBA, width: 1, height: 1,
            border: 0, format: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_3__["PixelFormat"].RGBA, type: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_5__["ComponentType"].UnsignedByte, magFilter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Nearest, minFilter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].Nearest,
            wrapS: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].ClampToEdge, wrapT: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_2__["TextureParameter"].ClampToEdge, generateMipmap: false, anisotropy: false, isPremultipliedAlpha: false
        });
    }
    createUniformBuffer(bufferView) {
        const gl = this.__glw.getRawContext();
        if (gl == null) {
            throw new Error("No WebGLRenderingContext set as Default.");
        }
        const ubo = gl.createBuffer();
        const resourceHandle = this.getResourceNumber();
        this.__webglResources.set(resourceHandle, ubo);
        gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
        gl.bufferData(gl.UNIFORM_BUFFER, bufferView, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
        return resourceHandle;
    }
    updateUniformBuffer(uboUid, bufferView) {
        const gl = this.__glw.getRawContext();
        const ubo = this.getWebGLResource(uboUid);
        gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
        gl.bufferSubData(gl.UNIFORM_BUFFER, 0, bufferView, 0);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    }
    bindUniformBlock(shaderProgramUid, blockName, blockIndex) {
        const gl = this.__glw.getRawContext();
        if (gl == null) {
            throw new Error("No WebGLRenderingContext set as Default.");
        }
        const shaderProgram = this.getWebGLResource(shaderProgramUid);
        const block = gl.getUniformBlockIndex(shaderProgram, blockName);
        gl.uniformBlockBinding(shaderProgram, block, blockIndex);
    }
    bindUniformBufferBase(blockIndex, uboUid) {
        const gl = this.__glw.getRawContext();
        if (gl == null) {
            throw new Error("No WebGLRenderingContext set as Default.");
        }
        const ubo = this.getWebGLResource(uboUid);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, blockIndex, ubo);
    }
    deleteUniformBuffer(uboUid) {
        const gl = this.__glw.getRawContext();
        if (gl == null) {
            new Error("No WebGLRenderingContext set as Default.");
        }
        const ubo = this.getWebGLResource(uboUid);
        this.__webglResources.delete(uboUid);
        gl.deleteBuffer(ubo);
    }
    createTransformFeedback() {
        const gl = this.__glw.getRawContext();
        var transformFeedback = gl.createTransformFeedback();
        const resourceHandle = this.getResourceNumber();
        this.__webglResources.set(resourceHandle, transformFeedback);
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);
        return resourceHandle;
    }
    deleteTransformFeedback(transformFeedbackUid) {
        const gl = this.__glw.getRawContext();
        const transformFeedback = this.getWebGLResource(transformFeedbackUid);
        gl.deleteTransformFeedback(transformFeedback);
        this.__webglResources.delete(transformFeedbackUid);
    }
    setViewport(viewport) {
        var _a, _b;
        if (viewport) {
            (_a = this.__glw) === null || _a === void 0 ? void 0 : _a.setViewportAsVector4(viewport);
        }
        else {
            (_b = this.__glw) === null || _b === void 0 ? void 0 : _b.setViewport(0, 0, this.__glw.width, this.__glw.height);
        }
    }
    clearFrameBuffer(renderPass) {
        const gl = this.__glw.getRawContext();
        let bufferBit = 0;
        if (renderPass.toClearColorBuffer) {
            gl.clearColor(renderPass.clearColor.x, renderPass.clearColor.y, renderPass.clearColor.z, renderPass.clearColor.w);
            bufferBit |= gl.COLOR_BUFFER_BIT;
        }
        if (renderPass.toClearDepthBuffer) {
            gl.clearDepth(renderPass.clearDepth);
            bufferBit |= gl.DEPTH_BUFFER_BIT;
        }
        if (renderPass.toClearStencilBuffer) {
            gl.clearStencil(renderPass.clearStencil);
            bufferBit |= gl.STENCIL_BUFFER_BIT;
        }
        if (bufferBit !== 0) {
            gl.clear(bufferBit);
        }
    }
    deleteVertexDataResources(vertexHandles) {
        const gl = this.__glw.getRawContext();
        const iboHandle = vertexHandles.iboHandle;
        if (iboHandle) {
            const ibo = this.getWebGLResource(iboHandle);
            gl.deleteBuffer(ibo);
        }
        const vboHandles = vertexHandles.vboHandles;
        for (let vboHandle of vboHandles) {
            const vbo = this.getWebGLResource(vboHandle);
            gl.deleteBuffer(vbo);
        }
        const vaoHandle = vertexHandles.vaoHandle;
        const vao = this.getWebGLResource(vaoHandle);
        this.__glw.deleteVertexArray(vao);
    }
    deleteVertexArray(vaoHandle) {
        const vao = this.getWebGLResource(vaoHandle);
        this.__glw.deleteVertexArray(vao);
    }
    deleteVertexBuffer(vboUid) {
        const gl = this.__glw.getRawContext();
        const vbo = this.getWebGLResource(vboUid);
        gl.deleteBuffer(vbo);
    }
    resizeCanvas(width, height) {
        this.__glw.width = width;
        this.__glw.height = height;
        this.__glw.canvas.width = width;
        this.__glw.canvas.height = height;
        this.__glw.setViewportAsVector4(new _foundation_math_Vector4__WEBPACK_IMPORTED_MODULE_12__["default"](0, 0, width, height));
    }
}


/***/ }),

/***/ "./src/webgl/WebGLStrategyCommonMethod.ts":
/*!************************************************!*\
  !*** ./src/webgl/WebGLStrategyCommonMethod.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _foundation_definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../foundation/definitions/AlphaMode */ "./src/foundation/definitions/AlphaMode.ts");
/* harmony import */ var _foundation_components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../foundation/components/MeshRendererComponent */ "./src/foundation/components/MeshRendererComponent.ts");
/* harmony import */ var _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../foundation/renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");



let lastIsTransparentMode;
let lastBlendEquationMode;
let lastBlendEquationModeAlpha;
let lastBlendFuncSrcFactor;
let lastBlendFuncDstFactor;
let lastBlendFuncAlphaSrcFactor;
let lastBlendFuncAlphaDstFactor;
let lastCullFace;
let lastFrontFaceCCW;
function setCullAndBlendSettings(material, renderPass, gl) {
    const cullFace = material.cullFace;
    const cullFrontFaceCCW = material.cullFrontFaceCCW;
    setCull(cullFace, cullFrontFaceCCW, gl);
    setBlendSettings(material, gl);
}
function setCull(cullFace, cullFrontFaceCCW, gl) {
    if (lastCullFace !== cullFace) {
        if (cullFace) {
            gl.enable(gl.CULL_FACE);
        }
        else {
            gl.disable(gl.CULL_FACE);
        }
        lastCullFace = cullFace;
    }
    if (cullFace === true && lastFrontFaceCCW !== cullFrontFaceCCW) {
        if (cullFrontFaceCCW) {
            gl.frontFace(gl.CCW);
        }
        else {
            gl.frontFace(gl.CW);
        }
        lastFrontFaceCCW = cullFrontFaceCCW;
    }
}
function setBlendSettings(material, gl) {
    const isBlendMode = material.isBlend();
    if (lastIsTransparentMode !== isBlendMode) {
        if (isBlendMode) {
            gl.enable(gl.BLEND);
        }
        else {
            gl.disable(gl.BLEND);
        }
        lastIsTransparentMode = isBlendMode;
    }
    if (material.alphaMode === _foundation_definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_0__["AlphaMode"].Translucent) {
        setBlendEquationMode(material.blendEquationMode, material.blendEquationModeAlpha, gl);
        setBlendFuncSrcFactor(material.blendFuncSrcFactor, material.blendFuncDstFactor, material.blendFuncAlphaSrcFactor, material.blendFuncAlphaDstFactor, gl);
    }
    else if (material.alphaMode === _foundation_definitions_AlphaMode__WEBPACK_IMPORTED_MODULE_0__["AlphaMode"].Additive) {
        setBlendEquationMode(32774, 32774, gl); // gl.FUNC_ADD
        setBlendFuncSrcFactor(1, 1, 1, 1, gl); // gl.ONE
    }
}
function setBlendEquationMode(blendEquationMode, blendEquationModeAlpha, gl) {
    const needUpdateBlendEquation = differentWithLastBlendEquation(blendEquationMode, blendEquationModeAlpha);
    if (needUpdateBlendEquation) {
        gl.blendEquationSeparate(blendEquationMode, blendEquationModeAlpha);
        lastBlendEquationMode = blendEquationMode;
        lastBlendEquationModeAlpha = blendEquationModeAlpha;
    }
}
function differentWithLastBlendEquation(equationMode, equationModeAlpha) {
    const result = (lastBlendEquationMode != equationMode ||
        lastBlendEquationModeAlpha != equationModeAlpha);
    return result;
}
function setBlendFuncSrcFactor(blendFuncSrcFactor, blendFuncDstFactor, blendFuncAlphaSrcFactor, blendFuncAlphaDstFactor, gl) {
    const needUpdateBlendFunc = differentWithLastBlendFuncFactor(blendFuncSrcFactor, blendFuncDstFactor, blendFuncAlphaSrcFactor, blendFuncAlphaDstFactor);
    if (needUpdateBlendFunc) {
        gl.blendFuncSeparate(blendFuncSrcFactor, blendFuncDstFactor, blendFuncAlphaSrcFactor, blendFuncAlphaDstFactor);
        lastBlendFuncSrcFactor = blendFuncSrcFactor;
        lastBlendFuncDstFactor = blendFuncDstFactor;
        lastBlendFuncAlphaSrcFactor = blendFuncAlphaSrcFactor;
        lastBlendFuncAlphaDstFactor = blendFuncAlphaDstFactor;
    }
}
function differentWithLastBlendFuncFactor(srcFactor, dstFactor, alphaSrcFactor, alphaDstFactor) {
    const result = (lastBlendFuncSrcFactor != srcFactor ||
        lastBlendFuncDstFactor != dstFactor ||
        lastBlendFuncAlphaSrcFactor != alphaSrcFactor ||
        lastBlendFuncAlphaDstFactor != alphaDstFactor);
    return result;
}
function startDepthMasking(idx, gl, renderPass) {
    if (_foundation_components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_1__["default"].isDepthMaskTrueForTransparencies) {
        return;
    }
    if (idx === _foundation_components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_1__["default"].firstTransparentIndex) {
        gl.depthMask(false);
    }
}
function endDepthMasking(idx, gl, renderPass) {
    if (idx === _foundation_components_MeshRendererComponent__WEBPACK_IMPORTED_MODULE_1__["default"].lastTransparentIndex) {
        gl.depthMask(true);
    }
}
function isMeshSetup(meshComponent) {
    if (meshComponent.mesh.variationVBOUid !== _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].InvalidCGAPIResourceUid) {
        const primitiveNum = meshComponent.mesh.getPrimitiveNumber();
        let count = 0;
        for (let i = 0; i < primitiveNum; i++) {
            const primitive = meshComponent.mesh.getPrimitiveAt(i);
            if (primitive.vertexHandles != null) {
                count++;
            }
        }
        if (primitiveNum === count) {
            return true;
        }
        else {
            return false;
        }
    }
    else {
        return false;
    }
}
function isMaterialsSetup(meshComponent) {
    if (meshComponent.mesh.variationVBOUid !== _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].InvalidCGAPIResourceUid) {
        const primitiveNum = meshComponent.mesh.getPrimitiveNumber();
        let count = 0;
        for (let i = 0; i < primitiveNum; i++) {
            const primitive = meshComponent.mesh.getPrimitiveAt(i);
            if (primitive.material._shaderProgramUid !== -1) {
                count++;
            }
        }
        if (primitiveNum === count) {
            return true;
        }
        else {
            return false;
        }
    }
    else {
        return false;
    }
}
/* harmony default export */ __webpack_exports__["default"] = (Object.freeze({ setCullAndBlendSettings, startDepthMasking, endDepthMasking, isMeshSetup, isMaterialsSetup }));


/***/ }),

/***/ "./src/webgl/WebGLStrategyFastestWebGL1.ts":
/*!*************************************************!*\
  !*** ./src/webgl/WebGLStrategyFastestWebGL1.ts ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WebGLStrategyFastestWebGL1; });
/* harmony import */ var _WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLResourceRepository */ "./src/webgl/WebGLResourceRepository.ts");
/* harmony import */ var _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../foundation/core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../foundation/definitions/PixelFormat */ "./src/foundation/definitions/PixelFormat.ts");
/* harmony import */ var _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../foundation/definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../foundation/definitions/TextureParameter */ "./src/foundation/definitions/TextureParameter.ts");
/* harmony import */ var _foundation_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../foundation/definitions/BufferUse */ "./src/foundation/definitions/BufferUse.ts");
/* harmony import */ var _foundation_components_MeshComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../foundation/components/MeshComponent */ "./src/foundation/components/MeshComponent.ts");
/* harmony import */ var _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../foundation/renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../foundation/definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _foundation_materials_core_Material__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../foundation/materials/core/Material */ "./src/foundation/materials/core/Material.ts");
/* harmony import */ var _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../foundation/definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _foundation_core_Component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../foundation/core/Component */ "./src/foundation/core/Component.ts");
/* harmony import */ var _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../foundation/components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../foundation/core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _foundation_definitions_ShaderType__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../foundation/definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _foundation_components_LightComponent__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../foundation/components/LightComponent */ "./src/foundation/components/LightComponent.ts");
/* harmony import */ var _foundation_core_Config__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../foundation/core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../foundation/components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");
/* harmony import */ var _foundation_core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../foundation/core/GlobalDataRepository */ "./src/foundation/core/GlobalDataRepository.ts");
/* harmony import */ var _foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../foundation/components/WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _foundation_misc_MiscUtil__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../foundation/misc/MiscUtil */ "./src/foundation/misc/MiscUtil.ts");
/* harmony import */ var _WebGLStrategyCommonMethod__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./WebGLStrategyCommonMethod */ "./src/webgl/WebGLStrategyCommonMethod.ts");
/* harmony import */ var _foundation_definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../foundation/definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");
/* harmony import */ var _foundation_system_ModuleManager__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../foundation/system/ModuleManager */ "./src/foundation/system/ModuleManager.ts");
























class WebGLStrategyFastestWebGL1 {
    constructor() {
        this.__webglResourceRepository = _WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
        this.__dataTextureUid = _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_7__["default"].InvalidCGAPIResourceUid;
        this.__lastShader = _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_7__["default"].InvalidCGAPIResourceUid;
        this.__lastRenderPassTickCount = -1;
    }
    get vertexShaderMethodDefinitions_dataTexture() {
        return `

  mat4 get_worldMatrix(float instanceId)
  {
    highp float index = ${_foundation_core_Component__WEBPACK_IMPORTED_MODULE_11__["default"].getLocationOffsetOfMemberOfComponent(_foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_12__["default"], 'worldMatrix')}.0 + 4.0 * instanceId;
    highp float powWidthVal = ${_foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength}.0;
    highp float powHeightVal = ${_foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferHeightLength}.0;
    vec2 arg = vec2(1.0/powWidthVal, 1.0/powHeightVal);
    // highp vec2 arg = vec2(1.0/powWidthVal, 1.0/powWidthVal/powHeightVal);

    vec4 col0 = fetchElement(u_dataTexture, index + 0.0, arg);
    vec4 col1 = fetchElement(u_dataTexture, index + 1.0, arg);
    vec4 col2 = fetchElement(u_dataTexture, index + 2.0, arg);
    vec4 col3 = fetchElement(u_dataTexture, index + 3.0, arg);

    mat4 matrix = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );

    return matrix;
  }


  mat3 get_normalMatrix(float instanceId) {
    float index = ${_foundation_core_Component__WEBPACK_IMPORTED_MODULE_11__["default"].getLocationOffsetOfMemberOfComponent(_foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_12__["default"], 'normalMatrix')}.0 + 3.0 * instanceId;
    float powWidthVal = ${_foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength}.0;
    float powHeightVal = ${_foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferHeightLength}.0;
    vec2 arg = vec2(1.0/powWidthVal, 1.0/powHeightVal);
  //  vec2 arg = vec2(1.0/powWidthVal, 1.0/powWidthVal/powHeightVal);

    vec4 col0 = fetchElement(u_dataTexture, index + 0.0, arg);
    vec4 col1 = fetchElement(u_dataTexture, index + 1.0, arg);
    vec4 col2 = fetchElement(u_dataTexture, index + 2.0, arg);

    mat3 matrix = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );

    return matrix;
  }

#ifdef RN_IS_MORPHING
  vec3 get_position(float vertexId, vec3 basePosition) {
    vec3 position = basePosition;
    for (int i=0; i<${_foundation_core_Config__WEBPACK_IMPORTED_MODULE_16__["default"].maxVertexMorphNumberInShader}; i++) {
      float index = u_dataTextureMorphOffsetPosition[i] + 1.0 * vertexId;
      float powWidthVal = ${_foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength}.0;
      float powHeightVal = ${_foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferHeightLength}.0;
      vec2 arg = vec2(1.0/powWidthVal, 1.0/powHeightVal);
    //  vec2 arg = vec2(1.0/powWidthVal, 1.0/powWidthVal/powHeightVal);
      vec3 addPos = fetchElement(u_dataTexture, index + 0.0, arg).xyz;
      position += addPos * u_morphWeights[i];
      if (i == u_morphTargetNumber-1) {
        break;
      }
    }

    return position;
  }
#endif
  `;
    }
    setupShaderProgram(meshComponent, isWebGL2) {
        if (meshComponent.mesh == null) {
            _foundation_components_MeshComponent__WEBPACK_IMPORTED_MODULE_6__["default"].alertNoMeshSet(meshComponent);
            return;
        }
        const primitiveNum = meshComponent.mesh.getPrimitiveNumber();
        for (let i = 0; i < primitiveNum; i++) {
            const primitive = meshComponent.mesh.getPrimitiveAt(i);
            const material = primitive.material;
            if (material == null || material.isEmptyMaterial()) {
                continue;
            }
            if (material._shaderProgramUid !== _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_7__["default"].InvalidCGAPIResourceUid) {
                continue;
            }
            const glw = this.__webglResourceRepository.currentWebGLContextWrapper;
            const gl = glw.getRawContext();
            const isPointSprite = primitive.primitiveMode.index === gl.POINTS;
            try {
                this.setupDefaultShaderSemantics(material, isPointSprite, isWebGL2);
                primitive._backupMaterial();
            }
            catch (e) {
                console.log(e);
                primitive._restoreMaterial();
                this.setupDefaultShaderSemantics(primitive._prevMaterial, isPointSprite, isWebGL2);
            }
        }
    }
    setupDefaultShaderSemantics(material, isPointSprite, isWebGL2) {
        material.createProgram(this.vertexShaderMethodDefinitions_dataTexture, this.__getShaderProperty, isWebGL2);
        if (isPointSprite) {
            this.__webglResourceRepository.setupUniformLocations(material._shaderProgramUid, [
                {
                    semantic: _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_8__["ShaderSemantics"].PointSize, compositionType: _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Scalar, componentType: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float,
                    stage: _foundation_definitions_ShaderType__WEBPACK_IMPORTED_MODULE_14__["ShaderType"].PixelShader, min: 0, max: Number.MAX_VALUE, isSystem: true, updateInterval: _foundation_definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_22__["ShaderVariableUpdateInterval"].EveryTime
                },
                {
                    semantic: _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_8__["ShaderSemantics"].PointDistanceAttenuation, compositionType: _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Vec3, componentType: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float,
                    stage: _foundation_definitions_ShaderType__WEBPACK_IMPORTED_MODULE_14__["ShaderType"].PixelShader, min: 0, max: 1, isSystem: true, updateInterval: _foundation_definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_22__["ShaderVariableUpdateInterval"].EveryTime
                },
            ]);
        }
        material.setUniformLocations(material._shaderProgramUid);
        const shaderProgram = this.__webglResourceRepository.getWebGLResource(material._shaderProgramUid);
        const gl = this.__webglResourceRepository.currentWebGLContextWrapper.getRawContext();
        shaderProgram.dataTexture = gl.getUniformLocation(shaderProgram, 'u_dataTexture');
        shaderProgram.currentComponentSIDs = gl.getUniformLocation(shaderProgram, 'u_currentComponentSIDs');
    }
    static __getOffsetOfShaderSemanticsInfo(info) {
        let offset = 1;
        switch (info.compositionType) {
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Mat4:
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Mat4Array:
                offset = 4;
                break;
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Mat3:
                offset = 3;
                break;
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Mat2:
                offset = 2;
                break;
            default:
            // console.error('unknown composition type', info.compositionType.str, memberName);
            // return '';
        }
        return offset;
    }
    __getShaderProperty(materialTypeName, info, propertyIndex, isGlobalData, isWebGL2) {
        const returnType = info.compositionType.getGlslStr(info.componentType);
        const indexArray = [];
        let maxIndex = 1;
        let indexStr;
        const isTexture = info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Texture2D || info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].TextureCube;
        const methodName = info.semantic.str.replace('.', '_');
        // definition of uniform variable
        let varDef = '';
        //      if (isTexture) {
        const varType = info.compositionType.getGlslStr(info.componentType);
        let varIndexStr = '';
        if (info.maxIndex) {
            varIndexStr = `[${info.maxIndex}]`;
        }
        if (info.needUniformInFastest || isTexture) {
            varDef = `  uniform ${varType} u_${methodName}${varIndexStr};\n`;
        }
        //    }
        // inner contents of 'get_' shader function
        if (propertyIndex < 0) {
            if (Math.abs(propertyIndex) % _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_8__["ShaderSemanticsClass"]._scale !== 0) {
                return '';
            }
            const offset = WebGLStrategyFastestWebGL1.__getOffsetOfShaderSemanticsInfo(info);
            for (let i = 0; i < info.maxIndex; i++) {
                const index = _foundation_materials_core_Material__WEBPACK_IMPORTED_MODULE_9__["default"].getLocationOffsetOfMemberOfMaterial(materialTypeName, propertyIndex);
                indexArray.push(index);
            }
            maxIndex = info.maxIndex;
            let arrayStr = `highp float indices[${maxIndex}];`;
            indexArray.forEach((idx, i) => {
                arrayStr += `\nindices[${i}] = ${idx}.0;`;
            });
            if (isWebGL2) {
                indexStr = `
          ${arrayStr}
          highp float idx = 0.0;
          idx = indices[index] + ${offset}.0 * instanceId;
          `;
            }
            else {
                indexStr = `
          ${arrayStr}
          highp float idx = 0.0;
          for (int i=0; i<${maxIndex}; i++) {
            idx = indices[i] + ${offset}.0 * instanceId;
            if (i == index) {
              break;
            }
          }`;
            }
        }
        else {
            const typeSize = WebGLStrategyFastestWebGL1.__getOffsetOfShaderSemanticsInfo(info);
            let dataBeginPos = -1;
            if (isGlobalData) {
                const globalDataRepository = _foundation_core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_18__["default"].getInstance();
                dataBeginPos = globalDataRepository.getLocationOffsetOfProperty(propertyIndex);
                //        let maxCount = globalDataRepository.getGlobalPropertyStruct(propertyIndex)!.maxCount;
            }
            else {
                dataBeginPos = _foundation_materials_core_Material__WEBPACK_IMPORTED_MODULE_9__["default"].getLocationOffsetOfMemberOfMaterial(materialTypeName, propertyIndex);
            }
            let instanceSize = typeSize;
            if (_foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].isArray(info.compositionType)) {
                if (info.maxIndex != null) {
                    instanceSize = typeSize * info.maxIndex;
                }
            }
            if (_foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].isArray(info.compositionType)) {
                indexStr = `highp float idx = ${dataBeginPos}.0 + ${instanceSize}.0 * instanceId + ${typeSize}.0 * float(index);`;
            }
            else if (info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Mat4 || info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Mat3 || info.compositionType === _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Mat2) {
                indexStr = `highp float idx = ${dataBeginPos}.0 + ${instanceSize}.0 * instanceId;`;
            }
            else {
                indexStr = `highp float idx = ${dataBeginPos}.0 + instanceId;`;
            }
        }
        let intStr = '';
        if (info.componentType === _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Int && info.compositionType !== _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Scalar) {
            intStr = 'i';
        }
        let firstPartOfInnerFunc = '';
        if (!isTexture) {
            firstPartOfInnerFunc += `
${returnType} get_${methodName}(highp float instanceId, const int index) {
  ${indexStr}
  highp float powWidthVal = ${_foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength}.0;
  highp float powHeightVal = ${_foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferHeightLength}.0;
  highp vec2 arg = vec2(1.0/powWidthVal, 1.0/powHeightVal);
  highp vec4 col0 = fetchElement(u_dataTexture, idx + 0.0, arg);
`;
        }
        let str = `${varDef}${firstPartOfInnerFunc}`;
        switch (info.compositionType) {
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Vec4:
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Vec4Array:
                str += `        highp ${intStr}vec4 val = ${intStr}vec4(col0);`;
                break;
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Vec3:
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Vec3Array:
                str += `        highp ${intStr}vec3 val = ${intStr}vec3(col0.xyz);`;
                break;
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Vec2:
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Vec2Array:
                str += `        highp ${intStr}vec2 val = ${intStr}vec2(col0.xy);`;
                break;
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Scalar:
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].ScalarArray:
                if (info.componentType === _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Int) {
                    str += `        int val = int(col0.x);`;
                }
                else if (info.componentType === _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Bool) {
                    str += `        bool val = bool(col0.x);`;
                }
                else {
                    str += `       float val = col0.x;`;
                }
                break;
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Mat4:
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Mat4Array:
                str += `
        vec4 col1 = fetchElement(u_dataTexture, idx + 1.0, arg);
        vec4 col2 = fetchElement(u_dataTexture, idx + 2.0, arg);
        vec4 col3 = fetchElement(u_dataTexture, idx + 3.0, arg);

        mat4 val = mat4(
          col0.x, col0.y, col0.z, col0.w,
          col1.x, col1.y, col1.z, col1.w,
          col2.x, col2.y, col2.z, col2.w,
          col3.x, col3.y, col3.z, col3.w
          );
        `;
                break;
            case _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Mat3:
                str += `
        vec4 col1 = fetchElement(u_dataTexture, idx + 1.0, arg);
        vec4 col2 = fetchElement(u_dataTexture, idx + 2.0, arg);
        mat3 val = mat3(
          col0.x, col0.y, col0.z,
          col0.w, col1.x, col1.y,
          col1.z, col1.w, col2.x
          );
        `;
                break;
            default:
                // console.error('unknown composition type', info.compositionType.str, memberName);
                str += '';
        }
        if (!isTexture) {
            str += `
      return val;
    }
  `;
        }
        return str;
    }
    $load(meshComponent) {
        if (meshComponent.mesh == null) {
            _foundation_components_MeshComponent__WEBPACK_IMPORTED_MODULE_6__["default"].alertNoMeshSet(meshComponent);
            return;
        }
        WebGLStrategyFastestWebGL1.__currentComponentSIDs = WebGLStrategyFastestWebGL1.__globalDataRepository.getValue(_foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_8__["ShaderSemantics"].CurrentComponentSIDs, 0);
        if (!_WebGLStrategyCommonMethod__WEBPACK_IMPORTED_MODULE_21__["default"].isMaterialsSetup(meshComponent)) {
            this.setupShaderProgram(meshComponent, false);
        }
        if (!_WebGLStrategyCommonMethod__WEBPACK_IMPORTED_MODULE_21__["default"].isMeshSetup(meshComponent)) {
            const primitiveNum = meshComponent.mesh.getPrimitiveNumber();
            for (let i = 0; i < primitiveNum; i++) {
                const primitive = meshComponent.mesh.getPrimitiveAt(i);
                primitive.create3DAPIVertexData();
            }
            meshComponent.mesh.updateVariationVBO();
        }
    }
    $prerender(meshComponent, meshRendererComponent, instanceIDBufferUid) {
        if (meshRendererComponent._readyForRendering) {
            return;
        }
        if (meshComponent.mesh == null) {
            _foundation_components_MeshComponent__WEBPACK_IMPORTED_MODULE_6__["default"].alertNoMeshSet(meshComponent);
            return;
        }
        if (meshComponent.mesh.isInstanceMesh()) {
            meshRendererComponent._readyForRendering = true;
            return;
        }
        const primitiveNum = meshComponent.mesh.getPrimitiveNumber();
        for (let i = 0; i < primitiveNum; i++) {
            const primitive = meshComponent.mesh.getPrimitiveAt(i);
            this.__webglResourceRepository.setVertexDataToPipeline({ vaoHandle: meshComponent.mesh.getVaoUids(i), iboHandle: primitive.vertexHandles.iboHandle, vboHandles: primitive.vertexHandles.vboHandles }, primitive, meshComponent.mesh.variationVBOUid);
        }
        meshRendererComponent._readyForRendering = true;
    }
    __createAndUpdateDataTexture() {
        const memoryManager = _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance();
        const buffer = memoryManager.getBuffer(_foundation_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_5__["BufferUse"].GPUInstanceData);
        if (buffer == null) {
            return;
        }
        if (this.__dataTextureUid !== _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_7__["default"].InvalidCGAPIResourceUid) {
            const bufferSizeInByte = buffer.takenSizeInByte;
            const height = Math.min(Math.ceil(bufferSizeInByte / _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength / 4 / 4), _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferHeightLength);
            const updateByteSize = _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength * height * 4 * 4;
            const dataTextureByteSize = _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength * _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferHeightLength * 4 * 4;
            if (bufferSizeInByte > dataTextureByteSize) {
                console.warn('The buffer size exceeds the size of the data texture.');
            }
            const floatDataTextureBuffer = new Float32Array(buffer.getArrayBuffer(), 0, updateByteSize / 4);
            if (this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2) {
                this.__webglResourceRepository.updateTexture(this.__dataTextureUid, floatDataTextureBuffer, {
                    level: 0, xoffset: 0, yoffset: 0, width: _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength, height: height,
                    format: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_2__["PixelFormat"].RGBA, type: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float
                });
            }
            else {
                this.__webglResourceRepository.updateTexture(this.__dataTextureUid, floatDataTextureBuffer, {
                    level: 0, xoffset: 0, yoffset: 0, width: _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength, height: height,
                    format: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_2__["PixelFormat"].RGBA, type: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float
                });
            }
        }
        else {
            const morphBuffer = memoryManager.getBuffer(_foundation_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_5__["BufferUse"].GPUVertexData);
            let morphBufferTakenSizeInByte = 0;
            if (morphBuffer != null) {
                morphBufferTakenSizeInByte = morphBuffer.takenSizeInByte;
            }
            let paddingArrayBufferSize = 0;
            const dataTextureByteSize = _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength * _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferHeightLength * 4 * 4;
            if ((buffer.takenSizeInByte + morphBufferTakenSizeInByte) < dataTextureByteSize) {
                paddingArrayBufferSize = dataTextureByteSize - (buffer.takenSizeInByte + morphBufferTakenSizeInByte);
            }
            let morphBufferArrayBuffer = new ArrayBuffer(0);
            if (morphBuffer != null) {
                morphBufferArrayBuffer = morphBuffer.getArrayBuffer();
            }
            const finalArrayBuffer = _foundation_misc_MiscUtil__WEBPACK_IMPORTED_MODULE_20__["MiscUtil"].concatArrayBuffers([buffer.getArrayBuffer(), morphBufferArrayBuffer], [buffer.takenSizeInByte, morphBufferTakenSizeInByte], paddingArrayBufferSize);
            if (finalArrayBuffer.byteLength / _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength / 4 / 4 > _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferHeightLength) {
                console.warn('The buffer size exceeds the size of the data texture.');
            }
            const floatDataTextureBuffer = new Float32Array(finalArrayBuffer);
            const height = _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferHeightLength;
            if (this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2) {
                this.__dataTextureUid = this.__webglResourceRepository.createTexture(floatDataTextureBuffer, {
                    level: 0, internalFormat: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_4__["TextureParameter"].RGBA32F, width: _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength, height: height,
                    border: 0, format: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_2__["PixelFormat"].RGBA, type: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, magFilter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_4__["TextureParameter"].Nearest, minFilter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_4__["TextureParameter"].Nearest,
                    wrapS: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_4__["TextureParameter"].Repeat, wrapT: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_4__["TextureParameter"].Repeat, generateMipmap: false, anisotropy: false, isPremultipliedAlpha: true
                });
            }
            else {
                this.__dataTextureUid = this.__webglResourceRepository.createTexture(floatDataTextureBuffer, {
                    level: 0, internalFormat: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_2__["PixelFormat"].RGBA, width: _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_1__["default"].bufferWidthLength, height: height,
                    border: 0, format: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_2__["PixelFormat"].RGBA, type: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_3__["ComponentType"].Float, magFilter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_4__["TextureParameter"].Nearest, minFilter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_4__["TextureParameter"].Nearest,
                    wrapS: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_4__["TextureParameter"].Repeat, wrapT: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_4__["TextureParameter"].Repeat, generateMipmap: false, anisotropy: false, isPremultipliedAlpha: true
                });
            }
        }
    }
    common_$prerender() {
        // Setup Data Texture
        this.__createAndUpdateDataTexture();
        const componentRepository = _foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_13__["default"].getInstance();
        this.__lightComponents = componentRepository.getComponentsWithType(_foundation_components_LightComponent__WEBPACK_IMPORTED_MODULE_15__["default"]);
    }
    attachGPUData(primitive) {
        const material = primitive.material;
        const glw = this.__webglResourceRepository.currentWebGLContextWrapper;
        const gl = glw.getRawContext();
        const dataTexture = this.__webglResourceRepository.getWebGLResource(this.__dataTextureUid);
        glw.bindTexture2D(0, dataTexture);
        const shaderProgram = this.__webglResourceRepository.getWebGLResource(material._shaderProgramUid);
        var uniform_dataTexture = gl.getUniformLocation(shaderProgram, 'u_dataTexture');
        gl.uniform1i(uniform_dataTexture, 0);
    }
    attachGPUDataInner(gl, shaderProgram) {
        this.__webglResourceRepository.bindTexture2D(0, this.__dataTextureUid);
        var uniform_dataTexture = gl.getUniformLocation(shaderProgram, 'u_dataTexture');
        gl.uniform1i(uniform_dataTexture, 0);
    }
    attachShaderProgram(material) {
        const shaderProgramUid = material._shaderProgramUid;
        if (shaderProgramUid !== this.__lastShader) {
            const glw = this.__webglResourceRepository.currentWebGLContextWrapper;
            const gl = glw.getRawContext();
            const shaderProgram = this.__webglResourceRepository.getWebGLResource(shaderProgramUid);
            gl.useProgram(shaderProgram);
            this.__lastShader = shaderProgramUid;
        }
    }
    attachVertexData(i, primitive, glw, instanceIDBufferUid) {
    }
    attachVertexDataInner(mesh, primitive, primitiveIndex, glw, instanceIDBufferUid) {
        const vertexHandles = primitive.vertexHandles;
        const vao = this.__webglResourceRepository.getWebGLResource(mesh.getVaoUids(primitiveIndex));
        const gl = glw.getRawContext();
        if (vao != null) {
            glw.bindVertexArray(vao);
        }
        else {
            this.__webglResourceRepository.setVertexDataToPipeline(vertexHandles, primitive, mesh.variationVBOUid);
            const ibo = this.__webglResourceRepository.getWebGLResource(vertexHandles.iboHandle);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        }
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new (WebGLStrategyFastestWebGL1)();
        }
        return this.__instance;
    }
    __getViewport(renderPass) {
        let viewport = renderPass.getViewport();
        if (viewport == null) {
            viewport = this.__webglResourceRepository.currentWebGLContextWrapper.viewport;
        }
        return viewport;
    }
    __setVRViewport(renderPass, displayIdx) {
        const rnXRModule = _foundation_system_ModuleManager__WEBPACK_IMPORTED_MODULE_23__["default"].getInstance().getModule('xr');
        const webvrSystem = rnXRModule.WebVRSystem.getInstance();
        this.__webglResourceRepository.setViewport(webvrSystem.getViewportAt(this.__getViewport(renderPass), displayIdx));
    }
    __setCurrentComponentSIDsForEachRenderPass(renderPass, displayIdx, isVRMainPass) {
        if (isVRMainPass) {
            const rnXRModule = _foundation_system_ModuleManager__WEBPACK_IMPORTED_MODULE_23__["default"].getInstance().getModule('xr');
            const webvrSystem = rnXRModule.WebVRSystem.getInstance();
            WebGLStrategyFastestWebGL1.__currentComponentSIDs.v[_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_19__["WellKnownComponentTIDs"].CameraComponentTID] = webvrSystem.getCameraComponentSIDAt(displayIdx);
        }
        else {
            let cameraComponent = renderPass.cameraComponent;
            if (cameraComponent == null) {
                cameraComponent = _foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_13__["default"].getInstance().getComponent(_foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_17__["default"], _foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_17__["default"].main);
            }
            if (cameraComponent) {
                WebGLStrategyFastestWebGL1.__currentComponentSIDs.v[_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_19__["WellKnownComponentTIDs"].CameraComponentTID] = cameraComponent.componentSID;
            }
            else {
                WebGLStrategyFastestWebGL1.__currentComponentSIDs.v[_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_19__["WellKnownComponentTIDs"].CameraComponentTID] = -1;
            }
        }
    }
    __setCurrentComponentSIDsForEachEntity(gl, renderPass, entity) {
        const skeletalComponent = entity.getSkeletal();
        if (skeletalComponent) {
            let index = 0;
            if (skeletalComponent.componentSID < _foundation_core_Config__WEBPACK_IMPORTED_MODULE_16__["default"].maxSkeletonNumber) {
                index = skeletalComponent.componentSID;
            }
            WebGLStrategyFastestWebGL1.__currentComponentSIDs.v[_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_19__["WellKnownComponentTIDs"].SkeletalComponentTID] = index;
        }
        else {
            WebGLStrategyFastestWebGL1.__currentComponentSIDs.v[_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_19__["WellKnownComponentTIDs"].SkeletalComponentTID] = -1;
        }
    }
    __setCurrentComponentSIDsForEachPrimitive(gl, renderPass, material, entity) {
        WebGLStrategyFastestWebGL1.__currentComponentSIDs.v[0] = material.materialSID;
        gl.uniform1fv(WebGLStrategyFastestWebGL1.__shaderProgram.currentComponentSIDs, WebGLStrategyFastestWebGL1.__currentComponentSIDs.v);
    }
    __getDisplayNumber(isVRMainPass) {
        if (isVRMainPass) {
            return 2;
        }
        else {
            return 1;
        }
    }
    common_$render(meshComponentSids, meshComponents, viewMatrix, projectionMatrix, renderPass, renderPassTickCount) {
        const glw = this.__webglResourceRepository.currentWebGLContextWrapper;
        const gl = glw.getRawContext();
        const rnXRModule = _foundation_system_ModuleManager__WEBPACK_IMPORTED_MODULE_23__["default"].getInstance().getModule('xr');
        const isVRMainPass = (rnXRModule === null || rnXRModule === void 0 ? void 0 : rnXRModule.WebVRSystem.getInstance().isWebVRMode) && renderPass.isMainPass;
        const displayNumber = this.__getDisplayNumber(isVRMainPass);
        for (let displayIdx = 0; displayIdx < displayNumber; displayIdx++) {
            if (isVRMainPass) {
                this.__setVRViewport(renderPass, displayIdx);
            }
            this.__setCurrentComponentSIDsForEachRenderPass(renderPass, displayIdx, isVRMainPass); // update u_currentComponentSIDs(uniform)
            for (let idx = 0; idx < meshComponentSids.length; idx++) {
                const sid = meshComponentSids[idx];
                if (sid === _foundation_core_Component__WEBPACK_IMPORTED_MODULE_11__["default"].invalidComponentSID) {
                    break;
                }
                const meshComponent = meshComponents[sid];
                if (meshComponent == null) {
                    break;
                }
                const mesh = meshComponent.mesh;
                if (!(mesh && mesh.isOriginalMesh())) {
                    continue;
                }
                _WebGLStrategyCommonMethod__WEBPACK_IMPORTED_MODULE_21__["default"].startDepthMasking(idx, gl, renderPass);
                const entity = meshComponent.entity;
                this.__setCurrentComponentSIDsForEachEntity(gl, renderPass, entity);
                const meshRendererComponent = entity.getMeshRenderer();
                const primitiveNum = mesh.getPrimitiveNumber();
                let firstTime = false;
                for (let i = 0; i < primitiveNum; i++) {
                    const primitive = mesh.getPrimitiveAt(i);
                    const material = renderPass.getAppropriateMaterial(primitive, primitive.material);
                    if (material.isEmptyMaterial()) {
                        continue;
                    }
                    const shaderProgramUid = material._shaderProgramUid;
                    if (shaderProgramUid === -1) {
                        continue;
                    }
                    this.attachVertexDataInner(mesh, primitive, i, glw, mesh.variationVBOUid);
                    if (shaderProgramUid !== this.__lastShader) {
                        const shaderProgram = this.__webglResourceRepository.getWebGLResource(shaderProgramUid);
                        gl.useProgram(shaderProgram);
                        gl.uniform1i(shaderProgram.dataTexture, 7);
                        this.__webglResourceRepository.bindTexture2D(7, this.__dataTextureUid);
                        WebGLStrategyFastestWebGL1.__shaderProgram = shaderProgram;
                        firstTime = true;
                    }
                    if (this.__lastMaterial !== material) {
                        firstTime = true;
                        this.__lastMaterial = material;
                    }
                    this.__setCurrentComponentSIDsForEachPrimitive(gl, renderPass, material, entity);
                    _WebGLStrategyCommonMethod__WEBPACK_IMPORTED_MODULE_21__["default"].setCullAndBlendSettings(material, renderPass, gl);
                    material.setParametersForGPU({
                        material: material, shaderProgram: WebGLStrategyFastestWebGL1.__shaderProgram, firstTime: firstTime,
                        args: {
                            glw: glw,
                            entity: entity,
                            worldMatrix: entity.getSceneGraph().worldMatrixInner,
                            normalMatrix: entity.getSceneGraph().normalMatrixInner,
                            lightComponents: this.__lightComponents,
                            renderPass: renderPass,
                            primitive: primitive,
                            diffuseCube: meshRendererComponent.diffuseCubeMap,
                            specularCube: meshRendererComponent.specularCubeMap,
                            setUniform: false
                        }
                    });
                    if (primitive.indicesAccessor) {
                        glw.drawElementsInstanced(primitive.primitiveMode.index, primitive.indicesAccessor.elementCount, primitive.indicesAccessor.componentType.index, 0, mesh.instanceCountIncludeOriginal);
                    }
                    else {
                        glw.drawArraysInstanced(primitive.primitiveMode.index, 0, primitive.getVertexCountAsVerticesBased(), mesh.instanceCountIncludeOriginal);
                    }
                    this.__lastShader = shaderProgramUid;
                }
            }
        }
        this.__lastRenderPassTickCount = renderPassTickCount;
        return false;
    }
    $render(idx, meshComponent, worldMatrix, normalMatrix, entity, renderPass, renderPassTickCount, diffuseCube, specularCube) {
        const glw = this.__webglResourceRepository.currentWebGLContextWrapper;
        const gl = glw.getRawContext();
        _WebGLStrategyCommonMethod__WEBPACK_IMPORTED_MODULE_21__["default"].endDepthMasking(idx, gl, renderPass);
    }
}
WebGLStrategyFastestWebGL1.__globalDataRepository = _foundation_core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_18__["default"].getInstance();


/***/ }),

/***/ "./src/webgl/WebGLStrategyUniform.ts":
/*!*******************************************!*\
  !*** ./src/webgl/WebGLStrategyUniform.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WebGLStrategyUniform; });
/* harmony import */ var _WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLResourceRepository */ "./src/webgl/WebGLResourceRepository.ts");
/* harmony import */ var _foundation_components_MeshComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../foundation/components/MeshComponent */ "./src/foundation/components/MeshComponent.ts");
/* harmony import */ var _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../foundation/renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../foundation/definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../foundation/core/ComponentRepository */ "./src/foundation/core/ComponentRepository.ts");
/* harmony import */ var _foundation_components_LightComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../foundation/components/LightComponent */ "./src/foundation/components/LightComponent.ts");
/* harmony import */ var _foundation_core_Config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../foundation/core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../foundation/definitions/PixelFormat */ "./src/foundation/definitions/PixelFormat.ts");
/* harmony import */ var _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../foundation/definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");
/* harmony import */ var _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../foundation/definitions/TextureParameter */ "./src/foundation/definitions/TextureParameter.ts");
/* harmony import */ var _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../foundation/definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _foundation_definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../foundation/definitions/ShaderVariableUpdateInterval */ "./src/foundation/definitions/ShaderVariableUpdateInterval.ts");
/* harmony import */ var _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../foundation/core/MemoryManager */ "./src/foundation/core/MemoryManager.ts");
/* harmony import */ var _foundation_definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../foundation/definitions/ShaderType */ "./src/foundation/definitions/ShaderType.ts");
/* harmony import */ var _foundation_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../foundation/definitions/BufferUse */ "./src/foundation/definitions/BufferUse.ts");
/* harmony import */ var _foundation_core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../foundation/core/GlobalDataRepository */ "./src/foundation/core/GlobalDataRepository.ts");
/* harmony import */ var _foundation_misc_MiscUtil__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../foundation/misc/MiscUtil */ "./src/foundation/misc/MiscUtil.ts");
/* harmony import */ var _WebGLStrategyCommonMethod__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./WebGLStrategyCommonMethod */ "./src/webgl/WebGLStrategyCommonMethod.ts");


















class WebGLStrategyUniform {
    constructor() {
        this.__webglResourceRepository = _WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
        this.__dataTextureUid = _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].InvalidCGAPIResourceUid;
        this.__lastShader = -1;
        this.__lastRenderPassTickCount = -1;
    }
    setupShaderProgram(meshComponent) {
        if (meshComponent.mesh == null) {
            _foundation_components_MeshComponent__WEBPACK_IMPORTED_MODULE_1__["default"].alertNoMeshSet(meshComponent);
            return;
        }
        const primitiveNum = meshComponent.mesh.getPrimitiveNumber();
        for (let i = 0; i < primitiveNum; i++) {
            const primitive = meshComponent.mesh.getPrimitiveAt(i);
            const material = primitive.material;
            if (material == null || material.isEmptyMaterial()) {
                continue;
            }
            if (material._shaderProgramUid !== _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].InvalidCGAPIResourceUid) {
                continue;
            }
            const glw = this.__webglResourceRepository.currentWebGLContextWrapper;
            const gl = glw.getRawContext();
            const isPointSprite = primitive.primitiveMode.index === gl.POINTS;
            try {
                this.setupDefaultShaderSemantics(material, isPointSprite);
                primitive._backupMaterial();
            }
            catch (e) {
                console.log(e);
                primitive._restoreMaterial();
                this.setupDefaultShaderSemantics(primitive.material, isPointSprite);
            }
        }
    }
    setupDefaultShaderSemantics(material, isPointSprite) {
        // Shader Setup
        const shaderSemanticsInfos = [
            {
                semantic: _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_3__["ShaderSemantics"].VertexAttributesExistenceArray, compositionType: _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].ScalarArray, componentType: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_8__["ComponentType"].Int,
                stage: _foundation_definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].VertexShader, min: 0, max: 1, isSystem: true, updateInterval: _foundation_definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_11__["ShaderVariableUpdateInterval"].EveryTime
            },
            {
                semantic: _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_3__["ShaderSemantics"].WorldMatrix, compositionType: _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Mat4, componentType: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_8__["ComponentType"].Float,
                stage: _foundation_definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: _foundation_definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_11__["ShaderVariableUpdateInterval"].EveryTime
            },
            {
                semantic: _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_3__["ShaderSemantics"].NormalMatrix, compositionType: _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Mat3, componentType: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_8__["ComponentType"].Float,
                stage: _foundation_definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isSystem: true, updateInterval: _foundation_definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_11__["ShaderVariableUpdateInterval"].EveryTime
            },
        ];
        if (isPointSprite) {
            shaderSemanticsInfos.push({
                semantic: _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_3__["ShaderSemantics"].PointSize, compositionType: _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Scalar, componentType: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_8__["ComponentType"].Float,
                stage: _foundation_definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, min: 0, max: Number.MAX_VALUE, isSystem: true, updateInterval: _foundation_definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_11__["ShaderVariableUpdateInterval"].EveryTime
            }, {
                semantic: _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_3__["ShaderSemantics"].PointDistanceAttenuation, compositionType: _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_10__["CompositionType"].Vec3, componentType: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_8__["ComponentType"].Float,
                stage: _foundation_definitions_ShaderType__WEBPACK_IMPORTED_MODULE_13__["ShaderType"].PixelShader, min: 0, max: 1, isSystem: true, updateInterval: _foundation_definitions_ShaderVariableUpdateInterval__WEBPACK_IMPORTED_MODULE_11__["ShaderVariableUpdateInterval"].EveryTime
            });
        }
        WebGLStrategyUniform.setupMaterial(material, shaderSemanticsInfos);
    }
    static setupMaterial(material, args) {
        let infoArray;
        if (args != null) {
            infoArray = args;
        }
        else {
            infoArray = material.fieldsInfoArray;
        }
        WebGLStrategyUniform.__vertexShaderMethodDefinitions_uniform =
            `
uniform mat4 u_worldMatrix;
uniform mat3 u_normalMatrix;

mat4 get_worldMatrix(float instanceId) {
  return u_worldMatrix;
}

mat3 get_normalMatrix(float instanceId) {
  return u_normalMatrix;
}

#ifdef RN_IS_MORPHING
  vec3 get_position(float vertexId, vec3 basePosition) {
    vec3 position = basePosition;
    for (int i=0; i<${_foundation_core_Config__WEBPACK_IMPORTED_MODULE_6__["default"].maxVertexMorphNumberInShader}; i++) {
      float index = u_dataTextureMorphOffsetPosition[i] + 1.0 * vertexId;
      float powWidthVal = ${_foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].bufferWidthLength}.0;
      float powHeightVal = ${_foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].bufferHeightLength}.0;
      vec2 arg = vec2(1.0/powWidthVal, 1.0/powHeightVal);
    //  vec2 arg = vec2(1.0/powWidthVal, 1.0/powWidthVal/powHeightVal);
      vec3 addPos = fetchElement(u_dataTexture, index + 0.0, arg).xyz;
      position += addPos * u_morphWeights[i];
      if (i == u_morphTargetNumber-1) {
        break;
      }
    }

    return position;
  }
#endif

  `;
        const webglResourceRepository = _WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getInstance();
        const glw = webglResourceRepository.currentWebGLContextWrapper;
        const gl = glw.getRawContext();
        material.createProgram(WebGLStrategyUniform.__vertexShaderMethodDefinitions_uniform, _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_3__["ShaderSemantics"].getShaderProperty, glw.isWebGL2);
        webglResourceRepository.setupUniformLocations(material._shaderProgramUid, infoArray);
        material.setUniformLocations(material._shaderProgramUid);
        WebGLStrategyUniform.__globalDataRepository.setUniformLocations(material._shaderProgramUid);
        const shaderProgram = webglResourceRepository.getWebGLResource(material._shaderProgramUid);
        shaderProgram.dataTexture = gl.getUniformLocation(shaderProgram, 'u_dataTexture');
        shaderProgram.currentComponentSIDs = gl.getUniformLocation(shaderProgram, 'u_currentComponentSIDs');
    }
    __isMeshSetup(meshComponent) {
        if (meshComponent.mesh.variationVBOUid !== _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].InvalidCGAPIResourceUid) {
            const primitiveNum = meshComponent.mesh.getPrimitiveNumber();
            let count = 0;
            for (let i = 0; i < primitiveNum; i++) {
                const primitive = meshComponent.mesh.getPrimitiveAt(i);
                if (primitive.vertexHandles != null) {
                    count++;
                }
            }
            if (primitiveNum === count) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    $load(meshComponent) {
        if (meshComponent.mesh == null) {
            _foundation_components_MeshComponent__WEBPACK_IMPORTED_MODULE_1__["default"].alertNoMeshSet(meshComponent);
            return;
        }
        if (!_WebGLStrategyCommonMethod__WEBPACK_IMPORTED_MODULE_17__["default"].isMaterialsSetup(meshComponent)) {
            this.setupShaderProgram(meshComponent);
        }
        if (!_WebGLStrategyCommonMethod__WEBPACK_IMPORTED_MODULE_17__["default"].isMeshSetup(meshComponent)) {
            const primitiveNum = meshComponent.mesh.getPrimitiveNumber();
            for (let i = 0; i < primitiveNum; i++) {
                const primitive = meshComponent.mesh.getPrimitiveAt(i);
                primitive.create3DAPIVertexData();
            }
            meshComponent.mesh.updateVariationVBO();
        }
    }
    $prerender(meshComponent, meshRendererComponent, instanceIDBufferUid) {
        if (meshComponent.mesh == null) {
            _foundation_components_MeshComponent__WEBPACK_IMPORTED_MODULE_1__["default"].alertNoMeshSet(meshComponent);
            return;
        }
        const primitiveNum = meshComponent.mesh.getPrimitiveNumber();
        // if (meshComponent.mesh.weights.length > 0) {
        //   for (let i = 0; i < primitiveNum; i++) {
        //     const primitive = meshComponent!.mesh.getPrimitiveAt(i);
        //     this.__webglResourceRepository.resendVertexBuffer(primitive, primitive.vertexHandles!.vboHandles);
        //   }
        // }
        for (let i = 0; i < primitiveNum; i++) {
            const primitive = meshComponent.mesh.getPrimitiveAt(i);
            this.__webglResourceRepository.setVertexDataToPipeline({ vaoHandle: meshComponent.mesh.getVaoUids(i), iboHandle: primitive.vertexHandles.iboHandle, vboHandles: primitive.vertexHandles.vboHandles }, primitive, meshComponent.mesh.variationVBOUid);
        }
    }
    common_$prerender() {
        const componentRepository = _foundation_core_ComponentRepository__WEBPACK_IMPORTED_MODULE_4__["default"].getInstance();
        this.__lightComponents = componentRepository.getComponentsWithType(_foundation_components_LightComponent__WEBPACK_IMPORTED_MODULE_5__["default"]);
        // Setup Data Texture
        if (this.__dataTextureUid === _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].InvalidCGAPIResourceUid) {
            const memoryManager = _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].getInstance();
            const buffer = memoryManager.getBuffer(_foundation_definitions_BufferUse__WEBPACK_IMPORTED_MODULE_14__["BufferUse"].GPUVertexData);
            if (buffer == null) {
                return;
            }
            if (buffer.takenSizeInByte / _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].bufferWidthLength / 4 > _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].bufferHeightLength) {
                console.warn('The buffer size exceeds the size of the data texture.');
            }
            let paddingArrayBufferSize = 0;
            if ((buffer.takenSizeInByte) / 4 / 4 < _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].bufferWidthLength * _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].bufferHeightLength) {
                paddingArrayBufferSize = _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].bufferWidthLength * _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].bufferHeightLength * 4 * 4 - buffer.takenSizeInByte;
            }
            const concatArrayBuffer = _foundation_misc_MiscUtil__WEBPACK_IMPORTED_MODULE_16__["MiscUtil"].concatArrayBuffers([buffer.getArrayBuffer()], [buffer.takenSizeInByte], paddingArrayBufferSize);
            const floatDataTextureBuffer = new Float32Array(concatArrayBuffer);
            if (this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2) {
                this.__dataTextureUid = this.__webglResourceRepository.createTexture(floatDataTextureBuffer, {
                    level: 0, internalFormat: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_9__["TextureParameter"].RGBA32F, width: _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].bufferWidthLength, height: _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].bufferHeightLength,
                    border: 0, format: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_7__["PixelFormat"].RGBA, type: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_8__["ComponentType"].Float, magFilter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_9__["TextureParameter"].Nearest, minFilter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_9__["TextureParameter"].Nearest,
                    wrapS: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_9__["TextureParameter"].Repeat, wrapT: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_9__["TextureParameter"].Repeat, generateMipmap: false, anisotropy: false, isPremultipliedAlpha: true
                });
            }
            else {
                this.__dataTextureUid = this.__webglResourceRepository.createTexture(floatDataTextureBuffer, {
                    level: 0, internalFormat: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_7__["PixelFormat"].RGBA, width: _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].bufferWidthLength, height: _foundation_core_MemoryManager__WEBPACK_IMPORTED_MODULE_12__["default"].bufferHeightLength,
                    border: 0, format: _foundation_definitions_PixelFormat__WEBPACK_IMPORTED_MODULE_7__["PixelFormat"].RGBA, type: _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_8__["ComponentType"].Float, magFilter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_9__["TextureParameter"].Nearest, minFilter: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_9__["TextureParameter"].Nearest,
                    wrapS: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_9__["TextureParameter"].Repeat, wrapT: _foundation_definitions_TextureParameter__WEBPACK_IMPORTED_MODULE_9__["TextureParameter"].Repeat, generateMipmap: false, anisotropy: false, isPremultipliedAlpha: true
                });
            }
        }
    }
    attachGPUData(primitive) {
    }
    attachShaderProgram(material) {
    }
    attachVertexData(i, primitive, glw, instanceIDBufferUid) {
    }
    attachVertexDataInner(mesh, primitive, primitiveIndex, glw, instanceIDBufferUid) {
        const vaoHandles = primitive.vertexHandles;
        const vao = this.__webglResourceRepository.getWebGLResource(mesh.getVaoUids(primitiveIndex));
        const gl = glw.getRawContext();
        if (vao != null) {
            glw.bindVertexArray(vao);
        }
        else {
            this.__webglResourceRepository.setVertexDataToPipeline(vaoHandles, primitive, instanceIDBufferUid);
            const ibo = this.__webglResourceRepository.getWebGLResource(vaoHandles.iboHandle);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        }
    }
    dettachVertexData(glw) {
        const gl = glw.getRawContext();
        if (glw.bindVertexArray) {
            glw.bindVertexArray(null);
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new WebGLStrategyUniform();
        }
        return this.__instance;
    }
    common_$render(meshComponentSids, meshComponents, viewMatrix, projectionMatrix, renderPass) {
        return false;
    }
    $render(idx, meshComponent, worldMatrix, normalMatrix, entity, renderPass, renderPassTickCount, diffuseCube, specularCube) {
        const glw = this.__webglResourceRepository.currentWebGLContextWrapper;
        const gl = glw.getRawContext();
        _WebGLStrategyCommonMethod__WEBPACK_IMPORTED_MODULE_17__["default"].startDepthMasking(idx, gl, renderPass);
        if (meshComponent.mesh == null) {
            _foundation_components_MeshComponent__WEBPACK_IMPORTED_MODULE_1__["default"].alertNoMeshSet(meshComponent);
            return;
        }
        const primitiveNum = meshComponent.mesh.getPrimitiveNumber();
        for (let i = 0; i < primitiveNum; i++) {
            const primitive = meshComponent.mesh.getPrimitiveAt(i);
            this.attachVertexDataInner(meshComponent.mesh, primitive, i, glw, _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_2__["default"].InvalidCGAPIResourceUid);
            const material = renderPass.getAppropriateMaterial(primitive, primitive.material);
            if (material.isEmptyMaterial() || material._shaderProgramUid === -1) {
                continue;
            }
            const shaderProgram = this.__webglResourceRepository.getWebGLResource(material._shaderProgramUid);
            const shaderProgramUid = material._shaderProgramUid;
            let firstTime = false;
            if (renderPassTickCount !== this.__lastRenderPassTickCount) {
                firstTime = true;
            }
            if (shaderProgramUid !== this.__lastShader) {
                gl.useProgram(shaderProgram);
                gl.uniform1i(shaderProgram.dataTexture, 7);
                this.__lastShader = shaderProgramUid;
                firstTime = true;
                this.__webglResourceRepository.bindTexture2D(7, this.__dataTextureUid);
            }
            if (this.__lastMaterial !== material) {
                firstTime = true;
                this.__lastMaterial = material;
            }
            _WebGLStrategyCommonMethod__WEBPACK_IMPORTED_MODULE_17__["default"].setCullAndBlendSettings(material, renderPass, gl);
            material.setParametersForGPU({
                material, shaderProgram, firstTime, args: {
                    setUniform: true,
                    glw: glw,
                    entity: entity,
                    primitive: primitive,
                    worldMatrix: worldMatrix,
                    normalMatrix: normalMatrix,
                    lightComponents: this.__lightComponents,
                    renderPass: renderPass,
                    diffuseCube: diffuseCube,
                    specularCube: specularCube
                }
            });
            if (primitive.indicesAccessor) {
                glw.drawElementsInstanced(primitive.primitiveMode.index, primitive.indicesAccessor.elementCount, primitive.indicesAccessor.componentType.index, 0, 1);
            }
            else {
                glw.drawArraysInstanced(primitive.primitiveMode.index, 0, primitive.getVertexCountAsVerticesBased(), 1);
            }
            // this.dettachVertexData(glw);
        }
        _WebGLStrategyCommonMethod__WEBPACK_IMPORTED_MODULE_17__["default"].endDepthMasking(idx, gl, renderPass);
        this.__lastRenderPassTickCount = renderPassTickCount;
    }
}
WebGLStrategyUniform.__globalDataRepository = _foundation_core_GlobalDataRepository__WEBPACK_IMPORTED_MODULE_15__["default"].getInstance();


/***/ }),

/***/ "./src/webgl/getRenderingStrategy.ts":
/*!*******************************************!*\
  !*** ./src/webgl/getRenderingStrategy.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _foundation_definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../foundation/definitions/ProcessApproach */ "./src/foundation/definitions/ProcessApproach.ts");
/* harmony import */ var _WebGLStrategyUniform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGLStrategyUniform */ "./src/webgl/WebGLStrategyUniform.ts");
/* harmony import */ var _WebGLStrategyFastestWebGL1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGLStrategyFastestWebGL1 */ "./src/webgl/WebGLStrategyFastestWebGL1.ts");



const getRenderingStrategy = function (processApproach) {
    // Strategy
    if (processApproach.index === _foundation_definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_0__["ProcessApproach"].FastestWebGL1.index) {
        return _WebGLStrategyFastestWebGL1__WEBPACK_IMPORTED_MODULE_2__["default"].getInstance();
    }
    else if (processApproach.index === _foundation_definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_0__["ProcessApproach"].UniformWebGL1.index ||
        processApproach.index === _foundation_definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_0__["ProcessApproach"].UniformWebGL2.index) {
        return _WebGLStrategyUniform__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance();
    }
    return _WebGLStrategyUniform__WEBPACK_IMPORTED_MODULE_1__["default"].getInstance();
};
/* harmony default export */ __webpack_exports__["default"] = (getRenderingStrategy);


/***/ }),

/***/ "./src/webgl/main.ts":
/*!***************************!*\
  !*** ./src/webgl/main.ts ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getRenderingStrategy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getRenderingStrategy */ "./src/webgl/getRenderingStrategy.ts");
/* harmony import */ var _shaders_GLSLShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");
/* harmony import */ var _WebGLContextWrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGLContextWrapper */ "./src/webgl/WebGLContextWrapper.ts");
/* harmony import */ var _WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WebGLResourceRepository */ "./src/webgl/WebGLResourceRepository.ts");
/* harmony import */ var _WebGLStrategyUniform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WebGLStrategyUniform */ "./src/webgl/WebGLStrategyUniform.ts");





const WebGL = Object.freeze({
    getRenderingStrategy: _getRenderingStrategy__WEBPACK_IMPORTED_MODULE_0__["default"],
    GLSLShader: _shaders_GLSLShader__WEBPACK_IMPORTED_MODULE_1__["default"],
    WebGLContextWrapper: _WebGLContextWrapper__WEBPACK_IMPORTED_MODULE_2__["default"],
    WebGLResourceRepository: _WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_3__["default"],
    WebGLStrategyUniform: _WebGLStrategyUniform__WEBPACK_IMPORTED_MODULE_4__["default"],
});
/* harmony default export */ __webpack_exports__["default"] = (WebGL);
(0, eval)('this').RnWebGL = WebGL;


/***/ }),

/***/ "./src/webgl/shaderity_shaders/EntityUIDOutputSingleShader/EntityUIDOutputSingleShader.frag":
/*!**************************************************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/EntityUIDOutputSingleShader/EntityUIDOutputSingleShader.frag ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nprecision highp float;\r\nprecision highp int;\r\n\n\n/* shaderity: @{definitions} */\n\nuniform float u_materialSID; // skipProcess=true\r\nuniform sampler2D u_dataTexture; // skipProcess=true\r\n\r\n  /*\r\n  * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\r\n  * arg = vec2(1. / size.x, 1. / size.x / size.y);\r\n  */\r\n  // highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 arg)\r\n  // {\r\n  //   return ${this.glsl_texture}( tex, arg * (index + 0.5) );\r\n  // }\r\n\r\nhighp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 invSize){\r\n  highp float t = (index + 0.5) * invSize.x;\r\n  highp float x = fract(t);\r\n  highp float y = (floor(t) + 0.5) * invSize.y;\r\n  return texture2D( tex, vec2(x, y) );\r\n}\r\n\r\n\r\nfloat rand(const vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvec3 descramble(vec3 v) {\r\n  float seed = 0.0;\r\n  v.x -= sin(fract(v.y*20.0));\r\n  v.z -= cos(fract(-v.y*10.0));\r\n  return v;\r\n}\r\n\r\n\n\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin float v_instanceID;\n\n\n#ifdef GLSL_ES3\r\n  layout(location = 0) out vec4 rt0;\r\n#else\r\n  vec4 rt0;\r\n#endif\r\n\n\n/* shaderity: @{getters} */\n\nconst vec4 bitEnc = vec4(1.,255.,65025.,16581375.);\r\nconst vec4 bitDec = 1./bitEnc;\r\n\r\nvec4 encodeFloatRGBA(float v) {\r\n  float val = v;\r\n  float r = mod(val, 255.0);\r\n  val -= r;\r\n  float g = mod(val, 65025.0);\r\n  val -= g;\r\n  float b = mod(val, 16581375.0);\r\n  return vec4(r/255.0, g/65025.0, b/16581375.0, 1.0);\r\n}\r\n\n\nvoid main ()\n{\n#ifdef RN_IS_FASTEST_MODE\r\n  float materialSID = u_currentComponentSIDs[0];\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = int(u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.LightComponentTID} */]);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.SkeletalComponentTID} */];\r\n  #endif\r\n\r\n#else\r\n\r\n  float materialSID = u_materialSID;\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = get_lightNumber(0.0, 0);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\r\n  #endif\r\n\r\n#endif\r\n\n\n  rt0 = encodeFloatRGBA(v_instanceID);\n\n#ifdef GLSL_ES3\r\n\r\n#else\r\n  gl_FragColor = rt0;\r\n#endif\r\n\n}\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/EntityUIDOutputSingleShader/EntityUIDOutputSingleShader.vert":
/*!**************************************************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/EntityUIDOutputSingleShader/EntityUIDOutputSingleShader.vert ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nprecision highp float;\r\nprecision highp int;\r\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin float a_instanceID;\nin vec2 a_texcoord_0;\nin vec4 a_joint;\nin vec4 a_weight;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout float v_instanceID;\n\nuniform float u_materialSID; // skipProcess=true\r\nuniform sampler2D u_dataTexture; // skipProcess=true\r\n\r\n  /*\r\n  * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\r\n  * arg = vec2(1. / size.x, 1. / size.x / size.y);\r\n  */\r\n  // highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 arg)\r\n  // {\r\n  //   return ${this.glsl_texture}( tex, arg * (index + 0.5) );\r\n  // }\r\n\r\nhighp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 invSize){\r\n  highp float t = (index + 0.5) * invSize.x;\r\n  highp float x = fract(t);\r\n  highp float y = (floor(t) + 0.5) * invSize.y;\r\n  return texture2D( tex, vec2(x, y) );\r\n}\r\n\r\n\r\nfloat rand(const vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvec3 descramble(vec3 v) {\r\n  float seed = 0.0;\r\n  v.x -= sin(fract(v.y*20.0));\r\n  v.z -= cos(fract(-v.y*10.0));\r\n  return v;\r\n}\r\n\r\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\r\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\r\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\r\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\r\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\r\n\r\n  float b00 = a00 * a11 - a01 * a10,\r\n  b01 = a00 * a12 - a02 * a10,\r\n  b02 = a00 * a13 - a03 * a10,\r\n  b03 = a01 * a12 - a02 * a11,\r\n  b04 = a01 * a13 - a03 * a11,\r\n  b05 = a02 * a13 - a03 * a12,\r\n  b06 = a20 * a31 - a21 * a30,\r\n  b07 = a20 * a32 - a22 * a30,\r\n  b08 = a20 * a33 - a23 * a30,\r\n  b09 = a21 * a32 - a22 * a31,\r\n  b10 = a21 * a33 - a23 * a31,\r\n  b11 = a22 * a33 - a23 * a32;\r\n\r\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n  return mat3(\r\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\r\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\r\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\r\n}\r\n\n\n\r\n#ifdef RN_IS_SKINNING\r\n\r\nhighp mat4 createMatrixFromQuaternionTransformUniformScale( highp vec4 quaternion, highp vec4 translationScale ) {\r\n  highp vec4 q = quaternion;\r\n  highp vec3 t = translationScale.xyz;\r\n  highp float scale = translationScale.w;\r\n\r\n  highp float sx = q.x * q.x;\r\n  highp float sy = q.y * q.y;\r\n  highp float sz = q.z * q.z;\r\n  highp float cx = q.y * q.z;\r\n  highp float cy = q.x * q.z;\r\n  highp float cz = q.x * q.y;\r\n  highp float wx = q.w * q.x;\r\n  highp float wy = q.w * q.y;\r\n  highp float wz = q.w * q.z;\r\n\r\n  highp mat4 mat = mat4(\r\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\r\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\r\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\r\n    t.x, t.y, t.z, 1.0\r\n  );\r\n\r\n  highp mat4 uniformScaleMat = mat4(\r\n    scale, 0.0, 0.0, 0.0,\r\n    0.0, scale, 0.0, 0.0,\r\n    0.0, 0.0, scale, 0.0,\r\n    0.0, 0.0, 0.0, 1.0\r\n  );\r\n\r\n  return mat*uniformScaleMat;\r\n}\r\n\r\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\r\n\r\n  highp float r;\r\n  highp float g;\r\n  highp float b;\r\n  highp float a;\r\n\r\n  highp float ix = floor(vec_xy.x * criteria);\r\n  highp float v1x = ix / criteria;\r\n  highp float v1y = ix - floor(v1x) * criteria;\r\n\r\n  r = ( v1x + 1.0 ) / (criteria-1.0);\r\n  g = ( v1y + 1.0 ) / (criteria-1.0);\r\n\r\n  highp float iy = floor( vec_xy.y * criteria);\r\n  highp float v2x = iy / criteria;\r\n  highp float v2y = iy - floor(v2x) * criteria;\r\n\r\n  b = ( v2x + 1.0 ) / (criteria-1.0);\r\n  a = ( v2y + 1.0 ) / (criteria-1.0);\r\n\r\n  r -= 1.0/criteria;\r\n  g -= 1.0/criteria;\r\n  b -= 1.0/criteria;\r\n  a -= 1.0/criteria;\r\n\r\n  r = r*2.0-1.0;\r\n  g = g*2.0-1.0;\r\n  b = b*2.0-1.0;\r\n  a = a*2.0-1.0;\r\n\r\n  return vec4(r, g, b, a);\r\n}\r\n\r\nmat4 getSkinMatrix(float skeletalComponentSID) {\r\n\r\n#ifdef RN_BONE_DATA_TYPE_MAT4X4\r\n  mat4 skinMat = a_weight.x * get_boneMatrix(skeletalComponentSID, int(a_joint.x));\r\n  skinMat += a_weight.y * get_boneMatrix(skeletalComponentSID, int(a_joint.y));\r\n  skinMat += a_weight.z * get_boneMatrix(skeletalComponentSID, int(a_joint.z));\r\n  skinMat += a_weight.w * get_boneMatrix(skeletalComponentSID, int(a_joint.w));\r\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\r\n  highp vec2 criteria = vec2(4096.0, 4096.0);\r\n  highp mat4 skinMat = a_weight.x * createMatrixFromQuaternionTransformUniformScale(\r\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)),\r\n    get_boneTranslateScale(skeletalComponentSID, int(a_joint.x)));\r\n  skinMat += a_weight.y * createMatrixFromQuaternionTransformUniformScale(\r\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)),\r\n    get_boneTranslateScale(skeletalComponentSID, int(a_joint.y)));\r\n  skinMat += a_weight.z * createMatrixFromQuaternionTransformUniformScale(\r\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)),\r\n    get_boneTranslateScale(skeletalComponentSID, int(a_joint.z)));\r\n  skinMat += a_weight.w * createMatrixFromQuaternionTransformUniformScale(\r\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)),\r\n    get_boneTranslateScale(skeletalComponentSID, int(a_joint.w)));\r\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\r\n  highp vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\r\n  highp vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\r\n  highp vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\r\n  highp vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\r\n\r\n  highp vec2 criteria = vec2(4096.0, 4096.0);\r\n  highp vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\r\n  highp mat4 skinMat = a_weight.x * createMatrixFromQuaternionTransformUniformScale(\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x),\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo);\r\n  skinMat += a_weight.y * createMatrixFromQuaternionTransformUniformScale(\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x),\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo);\r\n  skinMat += a_weight.z * createMatrixFromQuaternionTransformUniformScale(\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x),\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo);\r\n  skinMat += a_weight.w * createMatrixFromQuaternionTransformUniformScale(\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x),\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo);\r\n#endif\r\n\r\n  return skinMat;\r\n}\r\n#endif\n\n\r\n#ifdef RN_IS_SKINNING\r\nbool skinning(\r\n  float skeletalComponentSID,\r\n  in mat3 inNormalMatrix,\r\n  out mat3 outNormalMatrix,\r\n  in vec3 inPosition_inLocal,\r\n  out vec4 outPosition_inWorld,\r\n  in vec3 inNormal_inLocal,\r\n  out vec3 outNormal_inWorld\r\n  )\r\n{\r\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\r\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\r\n  outNormalMatrix = toNormalMatrix(skinMat);\r\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\r\n\r\n  return true;\r\n}\r\n#endif\r\n\r\nbool processGeometryWithMorphingAndSkinning(\r\n  float skeletalComponentSID,\r\n  in mat4 worldMatrix,\r\n  in mat3 inNormalMatrix,\r\n  out mat3 outNormalMatrix,\r\n  in vec3 inPosition_inLocal,\r\n  out vec4 outPosition_inWorld,\r\n  in vec3 inNormal_inLocal,\r\n  out vec3 outNormal_inWorld\r\n) {\r\n  bool isSkinning = false;\r\n\r\n  vec3 position_inLocal;\r\n#ifdef RN_IS_MORPHING\r\n  if (u_morphTargetNumber == 0) {\r\n#endif\r\n    position_inLocal = inPosition_inLocal;\r\n#ifdef RN_IS_MORPHING\r\n  } else {\r\n    float vertexIdx = a_baryCentricCoord.w;\r\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\r\n  }\r\n#endif\r\n\r\n\r\n#ifdef RN_IS_SKINNING\r\n  if (skeletalComponentSID >= 0.0) {\r\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\r\n  } else {\r\n#endif\r\n    outNormalMatrix = inNormalMatrix;\r\n    outPosition_inWorld = worldMatrix * vec4(position_inLocal, 1.0);\r\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\r\n#ifdef RN_IS_SKINNING\r\n  }\r\n#endif\r\n\r\n  return isSkinning;\r\n}\r\n\n\n\nvoid main()\n{\n#ifdef RN_IS_FASTEST_MODE\r\n  float materialSID = u_currentComponentSIDs[0];\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = int(u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.LightComponentTID} */]);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.SkeletalComponentTID} */];\r\n  #endif\r\n\r\n#else\r\n\r\n  float materialSID = u_materialSID;\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = get_lightNumber(0.0, 0);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\r\n  #endif\r\n\r\n#endif\r\n\n\n  float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n  mat4 worldMatrix = get_worldMatrix(a_instanceID);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceID);\n\n  // Skeletal\n  processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\r\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\r\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\r\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\r\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\r\nfloat maxPointSize = get_pointSize(materialSID, 0);\r\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\r\n\n\n  v_instanceID = a_instanceID;\n}\n","shaderStage":"vertex"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/FXAA3QualityShader/FXAA3QualitySingleShader.frag":
/*!**************************************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/FXAA3QualityShader/FXAA3QualitySingleShader.frag ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nprecision highp float;\r\nprecision highp int;\r\n\n\n/**\n * This file contains source code provided by NVIDIA Corporation.\n * FXAA antialiasing is developed by NVIDIA.\n * The codes of this file is modified from original code to work on WebGL1.\n * The modification for GLSL 100 is referred from Three.js, https://github.com/mrdoob/three.js/blob/5ba4c25bcb74577e1b1e14906f345135610a94f3/examples/js/shaders/FXAAShader.js\n * The original FXAA code is https://github.com/NVIDIAGameWorks/GraphicsSamples/blob/80e8ba8f5e8935821513207033490735dd3279d8/samples/es3-kepler/FXAA/FXAA3_11.h\n */\n\n//----------------------------------------------------------------------------------\n// File:        es3-kepler\\FXAA/FXAA3_11.h\n// SDK Version: v3.00\n// Email:       gameworks@nvidia.com\n// Site:        http://developer.nvidia.com/\n//\n// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//  * Neither the name of NVIDIA CORPORATION nor the names of its\n//    contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS 'AS IS' AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//----------------------------------------------------------------------------------\n/*============================================================================\n                    NVIDIA FXAA 3.11 by TIMOTHY LOTTES\n============================================================================*/\n\n\n/* shaderity: @{definitions} */\n\nuniform float u_materialSID; // skipProcess=true\r\nuniform sampler2D u_dataTexture; // skipProcess=true\r\n\r\n  /*\r\n  * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\r\n  * arg = vec2(1. / size.x, 1. / size.x / size.y);\r\n  */\r\n  // highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 arg)\r\n  // {\r\n  //   return ${this.glsl_texture}( tex, arg * (index + 0.5) );\r\n  // }\r\n\r\nhighp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 invSize){\r\n  highp float t = (index + 0.5) * invSize.x;\r\n  highp float x = fract(t);\r\n  highp float y = (floor(t) + 0.5) * invSize.y;\r\n  return texture2D( tex, vec2(x, y) );\r\n}\r\n\r\n\r\nfloat rand(const vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvec3 descramble(vec3 v) {\r\n  float seed = 0.0;\r\n  v.x -= sin(fract(v.y*20.0));\r\n  v.z -= cos(fract(-v.y*10.0));\r\n  return v;\r\n}\r\n\r\n\n\nin vec2 v_texcoord_0;\n\n#ifdef GLSL_ES3\r\n  layout(location = 0) out vec4 rt0;\r\n#else\r\n  vec4 rt0;\r\n#endif\r\n\n\n/* shaderity: @{getters} */\n\n\n\n  #define FXAA_PC 1\n  #define FXAA_QUALITYPRESET 39\n  #define FXAA_GREEN_AS_LUMA 0\n  #define FXAA_GLSL_100 1\n\n  /*============================================================================\n                                INTEGRATION KNOBS\n  ============================================================================*/\n  //\n  // FXAA_PS3 and FXAA_360 choose the console algorithm (FXAA3 CONSOLE).\n  // FXAA_360_OPT is a prototype for the new optimized 360 version.\n  //\n  // 1 = Use API.\n  // 0 = Don't use API.\n  //\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_PS3\n  #define FXAA_PS3 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_360\n  #define FXAA_360 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_360_OPT\n  #define FXAA_360_OPT 0\n  #endif\n  /*==========================================================================*/\n  #ifndef FXAA_PC\n  //\n  // FXAA Quality\n  // The high quality PC algorithm.\n  //\n  #define FXAA_PC 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_PC_CONSOLE\n  //\n  // The console algorithm for PC is included\n  // for developers targeting really low spec machines.\n  // Likely better to just run FXAA_PC, and use a really low preset.\n  //\n  #define FXAA_PC_CONSOLE 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_120\n  #define FXAA_GLSL_120 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_130\n  #define FXAA_GLSL_130 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_3\n  #define FXAA_HLSL_3 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_4\n  #define FXAA_HLSL_4 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_5\n  #define FXAA_HLSL_5 0\n  #endif\n  /*==========================================================================*/\n  #ifndef FXAA_GREEN_AS_LUMA\n  //\n  // For those using non-linear color,\n  // and either not able to get luma in alpha, or not wanting to,\n  // this enables FXAA to run using green as a proxy for luma.\n  // So with this enabled, no need to pack luma in alpha.\n  //\n  // This will turn off AA on anything which lacks some amount of green.\n  // Pure red and blue or combination of only R and B, will get no AA.\n  //\n  // Might want to lower the settings for both,\n  //    fxaaConsoleEdgeThresholdMin\n  //    fxaaQualityEdgeThresholdMin\n  // In order to insure AA does not get turned off on colors \n  // which contain a minor amount of green.\n  //\n  // 1 = On.\n  // 0 = Off.\n  //\n  #define FXAA_GREEN_AS_LUMA 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_EARLY_EXIT\n  //\n  // Controls algorithm's early exit path.\n  // On PS3 turning this ON adds 2 cycles to the shader.\n  // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n  // Turning this off on console will result in a more blurry image.\n  // So this defaults to on.\n  //\n  // 1 = On.\n  // 0 = Off.\n  //\n  #define FXAA_EARLY_EXIT 1\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_DISCARD\n  //\n  // Only valid for PC OpenGL currently.\n  // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n  //\n  // 1 = Use discard on pixels which don't need AA.\n  //     For APIs which enable concurrent TEX+ROP from same surface.\n  // 0 = Return unchanged color on pixels which don't need AA.\n  //\n  #define FXAA_DISCARD 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_FAST_PIXEL_OFFSET\n  //\n  // Used for GLSL 120 only.\n  //\n  // 1 = GL API supports fast pixel offsets\n  // 0 = do not use fast pixel offsets\n  //\n  #ifdef GLEXT_gpu_shader4\n  #define FXAA_FAST_PIXEL_OFFSET 1\n  #endif\n  #ifdef GLNV_gpu_shader5\n  #define FXAA_FAST_PIXEL_OFFSET 1\n  #endif\n  #ifdef GLARB_gpu_shader5\n  #define FXAA_FAST_PIXEL_OFFSET 1\n  #endif\n  #ifndef FXAA_FAST_PIXEL_OFFSET\n  #define FXAA_FAST_PIXEL_OFFSET 0\n  #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GATHER4_ALPHA\n  //\n  // 1 = API supports gather4 on alpha channel.\n  // 0 = API does not support gather4 on alpha channel.\n  //\n  #if (FXAA_HLSL_5 == 1)\n  #define FXAA_GATHER4_ALPHA 1\n  #endif\n  #ifdef GLARB_gpu_shader5\n  #define FXAA_GATHER4_ALPHA 1\n  #endif\n  #ifdef GLNV_gpu_shader5\n  #define FXAA_GATHER4_ALPHA 1\n  #endif\n  #ifndef FXAA_GATHER4_ALPHA\n  #define FXAA_GATHER4_ALPHA 0\n  #endif\n  #endif\n\n  /*============================================================================\n                        FXAA CONSOLE PS3 - TUNING KNOBS\n  ============================================================================*/\n  #ifndef FXAA_CONSOLEPS3_EDGE_SHARPNESS\n  //\n  // Consoles the sharpness of edges on PS3 only.\n  // Non-PS3 tuning is done with shader input.\n  //\n  // Due to the PS3 being ALU bound,\n  // there are only two safe values here: 4 and 8.\n  // These options use the shaders ability to a free *|/ by 2|4|8.\n  //\n  // 8.0 is sharper\n  // 4.0 is softer\n  // 2.0 is really soft (good for vector graphics inputs)\n  //\n  #if 1\n  #define FXAA_CONSOLEPS3_EDGE_SHARPNESS 8.0\n  #endif\n  #if 0\n  #define FXAA_CONSOLEPS3_EDGE_SHARPNESS 4.0\n  #endif\n  #if 0\n  #define FXAA_CONSOLEPS3_EDGE_SHARPNESS 2.0\n  #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_CONSOLEPS3_EDGE_THRESHOLD\n  //\n  // Only effects PS3.\n  // Non-PS3 tuning is done with shader input.\n  //\n  // The minimum amount of local contrast required to apply algorithm.\n  // The console setting has a different mapping than the quality setting.\n  //\n  // This only applies when FXAA_EARLY_EXIT is 1.\n  //\n  // Due to the PS3 being ALU bound,\n  // there are only two safe values here: 0.25 and 0.125.\n  // These options use the shaders ability to a free *|/ by 2|4|8.\n  //\n  // 0.125 leaves less aliasing, but is softer\n  // 0.25 leaves more aliasing, and is sharper\n  //\n  #if 1\n  #define FXAA_CONSOLEPS3_EDGE_THRESHOLD 0.125\n  #else\n  #define FXAA_CONSOLEPS3_EDGE_THRESHOLD 0.25\n  #endif\n  #endif\n\n  /*============================================================================\n                          FXAA QUALITY - TUNING KNOBS\n  ------------------------------------------------------------------------------\n  NOTE the other tuning knobs are now in the shader function inputs!\n  ============================================================================*/\n  #ifndef FXAA_QUALITYPRESET\n  //\n  // Choose the quality preset.\n  // This needs to be compiled into the shader as it effects code.\n  // Best option to include multiple presets is to \n  // in each shader define the preset, then include this file.\n  // \n  // OPTIONS\n  // -----------------------------------------------------------------------\n  // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n  // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n  // 39       - no dither, very expensive \n  //\n  // NOTES\n  // -----------------------------------------------------------------------\n  // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n  // 13 = about same speed as FXAA 3.9 and better than 12\n  // 23 = closest to FXAA 3.9 visually and performance wise\n  //  _ = the lowest digit is directly related to performance\n  // _  = the highest digit is directly related to style\n  // \n  #define FXAA_QUALITYPRESET 12\n  #endif\n\n\n  /*============================================================================\n                             FXAA QUALITY - PRESETS\n  ============================================================================*/\n\n  /*============================================================================\n                       FXAA QUALITY - MEDIUM DITHER PRESETS\n  ============================================================================*/\n  #if(FXAA_QUALITYPRESET == 10)\n#define FXAA_QUALITYPS 3\n#define FXAA_QUALITYP0 1.5\n#define FXAA_QUALITYP1 3.0\n#define FXAA_QUALITYP2 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 11)\n#define FXAA_QUALITYPS 4\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 3.0\n#define FXAA_QUALITYP3 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 12)\n#define FXAA_QUALITYPS 5\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 4.0\n#define FXAA_QUALITYP4 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 13)\n#define FXAA_QUALITYPS 6\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 4.0\n#define FXAA_QUALITYP5 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 14)\n#define FXAA_QUALITYPS 7\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 4.0\n#define FXAA_QUALITYP6 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 15)\n#define FXAA_QUALITYPS 8\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 2.0\n#define FXAA_QUALITYP6 4.0\n#define FXAA_QUALITYP7 12.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - LOW DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITYPRESET == 20)\n#define FXAA_QUALITYPS 3\n#define FXAA_QUALITYP0 1.5\n#define FXAA_QUALITYP1 2.0\n#define FXAA_QUALITYP2 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 21)\n#define FXAA_QUALITYPS 4\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 22)\n#define FXAA_QUALITYPS 5\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 23)\n#define FXAA_QUALITYPS 6\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 24)\n#define FXAA_QUALITYPS 7\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 3.0\n#define FXAA_QUALITYP6 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 25)\n#define FXAA_QUALITYPS 8\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 2.0\n#define FXAA_QUALITYP6 4.0\n#define FXAA_QUALITYP7 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 26)\n#define FXAA_QUALITYPS 9\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 2.0\n#define FXAA_QUALITYP6 2.0\n#define FXAA_QUALITYP7 4.0\n#define FXAA_QUALITYP8 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 27)\n#define FXAA_QUALITYPS 10\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 2.0\n#define FXAA_QUALITYP6 2.0\n#define FXAA_QUALITYP7 2.0\n#define FXAA_QUALITYP8 4.0\n#define FXAA_QUALITYP9 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 28)\n#define FXAA_QUALITYPS 11\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 2.0\n#define FXAA_QUALITYP6 2.0\n#define FXAA_QUALITYP7 2.0\n#define FXAA_QUALITYP8 2.0\n#define FXAA_QUALITYP9 4.0\n#define FXAA_QUALITYP10 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITYPRESET == 29)\n#define FXAA_QUALITYPS 12\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.5\n#define FXAA_QUALITYP2 2.0\n#define FXAA_QUALITYP3 2.0\n#define FXAA_QUALITYP4 2.0\n#define FXAA_QUALITYP5 2.0\n#define FXAA_QUALITYP6 2.0\n#define FXAA_QUALITYP7 2.0\n#define FXAA_QUALITYP8 2.0\n#define FXAA_QUALITYP9 2.0\n#define FXAA_QUALITYP10 4.0\n#define FXAA_QUALITYP11 8.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - EXTREME QUALITY\n============================================================================*/\n#if (FXAA_QUALITYPRESET == 39)\n#define FXAA_QUALITYPS 12\n#define FXAA_QUALITYP0 1.0\n#define FXAA_QUALITYP1 1.0\n#define FXAA_QUALITYP2 1.0\n#define FXAA_QUALITYP3 1.0\n#define FXAA_QUALITYP4 1.0\n#define FXAA_QUALITYP5 1.5\n#define FXAA_QUALITYP6 2.0\n#define FXAA_QUALITYP7 2.0\n#define FXAA_QUALITYP8 2.0\n#define FXAA_QUALITYP9 2.0\n#define FXAA_QUALITYP10 4.0\n#define FXAA_QUALITYP11 8.0\n#endif\n\n\n\n/*============================================================================\n                                API PORTING\n============================================================================*/\n#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n#define FxaaBool bool\n#define FxaaDiscard discard\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 ivec2\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTex sampler2D\n#else\n#define FxaaBool bool\n#define FxaaDiscard clip(-1)\n#define FxaaFloat float\n#define FxaaFloat2 float2\n#define FxaaFloat3 float3\n#define FxaaFloat4 float4\n#define FxaaHalf half\n#define FxaaHalf2 half2\n#define FxaaHalf3 half3\n#define FxaaHalf4 half4\n#define FxaaSat(x) saturate(x)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_100 == 1)\n#define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_120 == 1)\n// Requires,\n//  #version 120\n// And at least,\n//  #extension GLEXT_gpu_shader4 : enable\n//  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n#if (FXAA_FAST_PIXEL_OFFSET == 1)\n#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n#else\n#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n#endif\n#if (FXAA_GATHER4_ALPHA == 1)\n// use #extension GLARB_gpu_shader5 : enable\n#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n#endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_130 == 1)\n// Requires \"#version 130\" or better\n#define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n#if (FXAA_GATHER4_ALPHA == 1)\n// use #extension GLARB_gpu_shader5 : enable\n#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n#endif\n#endif\n\n\n/*============================================================================\n                   GREEN AS LUMA OPTION SUPPORT FUNCTION\n============================================================================*/\n#if (FXAA_GREEN_AS_LUMA == 0)\n  FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.298912, 0.586611, 0.114478)); }\n  // FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\n  FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\n\n\n\n\n\n\n\n\n\n/*============================================================================\n                             FXAA3 QUALITY - PC\n============================================================================*/\n#if (FXAA_PC == 1)\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat4 FxaaPixelShader(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Used only for FXAA Console, and not used on the 360 version.\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = upper left of pixel\n    // {zw} = lower right of pixel\n    FxaaFloat4 fxaaConsolePosPos,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {_a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for \"tex\".\n    // For 360, same texture, just alias with a 2nd sampler.\n    // This sampler needs to have an exponent bias of -1.\n    FxaaTex fxaaConsole360TexExpBiasNegOne,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for \"tex\".\n    // For 360, same texture, just alias with a 3nd sampler.\n    // This sampler needs to have an exponent bias of -2.\n    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Console.\n    // This must be from a constant/uniform.\n    // This effects sub-pixel AA quality and inversely sharpness.\n    //   Where N ranges between,\n    //     N = 0.50 (default)\n    //     N = 0.33 (sharper)\n    // {x_} = -N/screenWidthInPixels\n    // {_y} = -N/screenHeightInPixels\n    // {z_} =  N/screenWidthInPixels\n    // {_w} =  N/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n    //\n    // Only used on FXAA Console.\n    // Not used on 360, but used on PS3 and PC.\n    // This must be from a constant/uniform.\n    // {x_} = -2.0/screenWidthInPixels\n    // {_y} = -2.0/screenHeightInPixels\n    // {z_} =  2.0/screenWidthInPixels\n    // {_w} =  2.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n    //\n    // Only used on FXAA Console.\n    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n    // This must be from a constant/uniform.\n    // {x_} =  8.0/screenWidthInPixels\n    // {_y} =  8.0/screenHeightInPixels\n    // {z_} = -4.0/screenWidthInPixels\n    // {_w} = -4.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITYSUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITYEDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality \n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITYEDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin,\n    // \n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLEEDGE_SHARPNESS define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLEPS3_EDGE_SHARPNESS for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only three safe values here: 2 and 4 and 8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // For all other platforms can be a non-power of two.\n    //   8.0 is sharper (default!!!)\n    //   4.0 is softer\n    //   2.0 is really soft (good only for vector graphics inputs)\n    FxaaFloat fxaaConsoleEdgeSharpness,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLEEDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLEPS3_EDGE_THRESHOLD for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only two safe values here: 1/4 and 1/8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // The console setting has a different mapping than the quality setting.\n    // Other platforms can use other values.\n    //   0.125 leaves less aliasing, but is softer (default!!!)\n    //   0.25 leaves more aliasing, and is sharper\n    FxaaFloat fxaaConsoleEdgeThreshold,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLEEDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    // The console setting has a different mapping than the quality setting.\n    // This only applies when FXAA_EARLY_EXIT is 1.\n    // This does not apply to PS3, \n    // PS3 was simplified to avoid more shader instructions.\n    //   0.06 - faster but more aliasing in darks\n    //   0.05 - default\n    //   0.04 - slower and less aliasing in darks\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaConsoleEdgeThresholdMin,\n    //    \n    // Extra constants for 360 FXAA Console only.\n    // Use zeros or anything else for other platforms.\n    // These must be in physical constant registers and NOT immedates.\n    // Immedates will result in compiler un-optimizing.\n    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n    FxaaFloat4 fxaaConsole360ConstDir\n  ) {\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat2 posM;\n  posM.x = pos.x;\n  posM.y = pos.y;\n  #if (FXAA_GATHER4_ALPHA == 1)\n  #if (FXAA_DISCARD == 0)\n    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n  #if (FXAA_GREEN_AS_LUMA == 0)\n  #define lumaM rgbyM.w\n  #else\n  #define lumaM rgbyM.y\n  #endif\n  #endif\n  #if (FXAA_GREEN_AS_LUMA == 0)\n    FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n  FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n  #else\n  FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n  FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n  #endif\n  #if (FXAA_DISCARD == 1)\n  #define lumaM luma4A.w\n  #endif\n  #define lumaE luma4A.z\n  #define lumaS luma4A.x\n  #define lumaSE luma4A.y\n  #define lumaNW luma4B.w\n  #define lumaN luma4B.z\n  #define lumaW luma4B.x\n  #else\n  FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n  #if (FXAA_GREEN_AS_LUMA == 0)\n  #define lumaM rgbyM.w\n  #else\n  #define lumaM rgbyM.y\n  #endif\n  #if (FXAA_GLSL_100 == 1)\n    FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, 1.0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 0.0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, -1.0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n  #else\n  FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, 1), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, -1), fxaaQualityRcpFrame.xy));\n  #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat maxSM = max(lumaS, lumaM);\n  FxaaFloat minSM = min(lumaS, lumaM);\n  FxaaFloat maxESM = max(lumaE, maxSM);\n  FxaaFloat minESM = min(lumaE, minSM);\n  FxaaFloat maxWN = max(lumaN, lumaW);\n  FxaaFloat minWN = min(lumaN, lumaW);\n  FxaaFloat rangeMax = max(maxWN, maxESM);\n  FxaaFloat rangeMin = min(minWN, minESM);\n  FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n  FxaaFloat range = rangeMax - rangeMin;\n  FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n  FxaaBool earlyExit = range < rangeMaxClamped;\n  /*--------------------------------------------------------------------------*/\n  if (earlyExit)\n  #if (FXAA_DISCARD == 1)\n    FxaaDiscard;\n  #else\n  return rgbyM;\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GATHER4_ALPHA == 0)\n  #if (FXAA_GLSL_100 == 1)\n    FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, -1.0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 1.0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, -1.0), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n  #else\n  FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, -1), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 1), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n  #endif\n  #else\n  FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n  FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n  #endif\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat lumaNS = lumaN + lumaS;\n  FxaaFloat lumaWE = lumaW + lumaE;\n  FxaaFloat subpixRcpRange = 1.0 / range;\n  FxaaFloat subpixNSWE = lumaNS + lumaWE;\n  FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n  FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat lumaNESE = lumaNE + lumaSE;\n  FxaaFloat lumaNWNE = lumaNW + lumaNE;\n  FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n  FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat lumaNWSW = lumaNW + lumaSW;\n  FxaaFloat lumaSWSE = lumaSW + lumaSE;\n  FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n  FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n  FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n  FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n  FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n  FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n  FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n  FxaaBool horzSpan = edgeHorz >= edgeVert;\n  FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n  /*--------------------------------------------------------------------------*/\n  if (!horzSpan) lumaN = lumaW;\n  if (!horzSpan) lumaS = lumaE;\n  if (horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n  FxaaFloat subpixB = (subpixA * (1.0 / 12.0)) - lumaM;\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat gradientN = lumaN - lumaM;\n  FxaaFloat gradientS = lumaS - lumaM;\n  FxaaFloat lumaNN = lumaN + lumaM;\n  FxaaFloat lumaSS = lumaS + lumaM;\n  FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n  FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n  if (pairN) lengthSign = -lengthSign;\n  FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat2 posB;\n  posB.x = posM.x;\n  posB.y = posM.y;\n  FxaaFloat2 offNP;\n  offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n  offNP.y = (horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n  if (!horzSpan) posB.x += lengthSign * 0.5;\n  if (horzSpan) posB.y += lengthSign * 0.5;\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat2 posN;\n  posN.x = posB.x - offNP.x * FXAA_QUALITYP0;\n  posN.y = posB.y - offNP.y * FXAA_QUALITYP0;\n  FxaaFloat2 posP;\n  posP.x = posB.x + offNP.x * FXAA_QUALITYP0;\n  posP.y = posB.y + offNP.y * FXAA_QUALITYP0;\n  FxaaFloat subpixD = ((-2.0) * subpixC) + 3.0;\n  FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n  FxaaFloat subpixE = subpixC * subpixC;\n  FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n  /*--------------------------------------------------------------------------*/\n  if (!pairN) lumaNN = lumaSS;\n  FxaaFloat gradientScaled = gradient * 1.0 / 4.0;\n  FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n  FxaaFloat subpixF = subpixD * subpixE;\n  FxaaBool lumaMLTZero = lumaMM < 0.0;\n  /*--------------------------------------------------------------------------*/\n  lumaEndN -= lumaNN * 0.5;\n  lumaEndP -= lumaNN * 0.5;\n  FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n  FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n  if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP1;\n  if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP1;\n  FxaaBool doneNP = (!doneN) || (!doneP);\n  if (!doneP) posP.x += offNP.x * FXAA_QUALITYP1;\n  if (!doneP) posP.y += offNP.y * FXAA_QUALITYP1;\n  /*--------------------------------------------------------------------------*/\n  if (doneNP) {\n    if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n    if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n    if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n    if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n    doneN = abs(lumaEndN) >= gradientScaled;\n    doneP = abs(lumaEndP) >= gradientScaled;\n    if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP2;\n    if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP2;\n    doneNP = (!doneN) || (!doneP);\n    if (!doneP) posP.x += offNP.x * FXAA_QUALITYP2;\n    if (!doneP) posP.y += offNP.y * FXAA_QUALITYP2;\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITYPS > 3)\n      if (doneNP) {\n        if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP3;\n        if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP3;\n        doneNP = (!doneN) || (!doneP);\n        if (!doneP) posP.x += offNP.x * FXAA_QUALITYP3;\n        if (!doneP) posP.y += offNP.y * FXAA_QUALITYP3;\n        /*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITYPS > 4)\n          if (doneNP) {\n            if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP4;\n            if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP4;\n            doneNP = (!doneN) || (!doneP);\n            if (!doneP) posP.x += offNP.x * FXAA_QUALITYP4;\n            if (!doneP) posP.y += offNP.y * FXAA_QUALITYP4;\n            /*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITYPS > 5)\n              if (doneNP) {\n                if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP5;\n                if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP5;\n                doneNP = (!doneN) || (!doneP);\n                if (!doneP) posP.x += offNP.x * FXAA_QUALITYP5;\n                if (!doneP) posP.y += offNP.y * FXAA_QUALITYP5;\n                /*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITYPS > 6)\n                  if (doneNP) {\n                    if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP6;\n                    if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP6;\n                    doneNP = (!doneN) || (!doneP);\n                    if (!doneP) posP.x += offNP.x * FXAA_QUALITYP6;\n                    if (!doneP) posP.y += offNP.y * FXAA_QUALITYP6;\n                    /*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITYPS > 7)\n                      if (doneNP) {\n                        if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP7;\n                        if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP7;\n                        doneNP = (!doneN) || (!doneP);\n                        if (!doneP) posP.x += offNP.x * FXAA_QUALITYP7;\n                        if (!doneP) posP.y += offNP.y * FXAA_QUALITYP7;\n                        /*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITYPS > 8)\n                          if (doneNP) {\n                            if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP8;\n                            if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP8;\n                            doneNP = (!doneN) || (!doneP);\n                            if (!doneP) posP.x += offNP.x * FXAA_QUALITYP8;\n                            if (!doneP) posP.y += offNP.y * FXAA_QUALITYP8;\n                            /*--------------------------------------------------------------------------*/\n                            #if (FXAA_QUALITYPS > 9)\n                              if (doneNP) {\n                                if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                                if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                                doneN = abs(lumaEndN) >= gradientScaled;\n                                doneP = abs(lumaEndP) >= gradientScaled;\n                                if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP9;\n                                if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP9;\n                                doneNP = (!doneN) || (!doneP);\n                                if (!doneP) posP.x += offNP.x * FXAA_QUALITYP9;\n                                if (!doneP) posP.y += offNP.y * FXAA_QUALITYP9;\n                                /*--------------------------------------------------------------------------*/\n                                #if (FXAA_QUALITYPS > 10)\n                                  if (doneNP) {\n                                    if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                    if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                    if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                                    if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                                    doneN = abs(lumaEndN) >= gradientScaled;\n                                    doneP = abs(lumaEndP) >= gradientScaled;\n                                    if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP10;\n                                    if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP10;\n                                    doneNP = (!doneN) || (!doneP);\n                                    if (!doneP) posP.x += offNP.x * FXAA_QUALITYP10;\n                                    if (!doneP) posP.y += offNP.y * FXAA_QUALITYP10;\n                                    /*--------------------------------------------------------------------------*/\n                                    #if (FXAA_QUALITYPS > 11)\n                                      if (doneNP) {\n                                        if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                        if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                        if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                                        if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                                        doneN = abs(lumaEndN) >= gradientScaled;\n                                        doneP = abs(lumaEndP) >= gradientScaled;\n                                        if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP11;\n                                        if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP11;\n                                        doneNP = (!doneN) || (!doneP);\n                                        if (!doneP) posP.x += offNP.x * FXAA_QUALITYP11;\n                                        if (!doneP) posP.y += offNP.y * FXAA_QUALITYP11;\n                                        /*--------------------------------------------------------------------------*/\n                                        #if (FXAA_QUALITYPS > 12)\n                                          if (doneNP) {\n                                            if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                            if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                                            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                                            doneN = abs(lumaEndN) >= gradientScaled;\n                                            doneP = abs(lumaEndP) >= gradientScaled;\n                                            if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP12;\n                                            if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP12;\n                                            doneNP = (!doneN) || (!doneP);\n                                            if (!doneP) posP.x += offNP.x * FXAA_QUALITYP12;\n                                            if (!doneP) posP.y += offNP.y * FXAA_QUALITYP12;\n                                            /*--------------------------------------------------------------------------*/\n                                          }\n                                        #endif\n                                        /*--------------------------------------------------------------------------*/\n                                      }\n                                    #endif\n                                    /*--------------------------------------------------------------------------*/\n                                  }\n                                #endif\n                                /*--------------------------------------------------------------------------*/\n                              }\n                            #endif\n                            /*--------------------------------------------------------------------------*/\n                          }\n                        #endif\n                        /*--------------------------------------------------------------------------*/\n                      }\n                    #endif\n                    /*--------------------------------------------------------------------------*/\n                  }\n                #endif\n                /*--------------------------------------------------------------------------*/\n              }\n            #endif\n            /*--------------------------------------------------------------------------*/\n          }\n        #endif\n        /*--------------------------------------------------------------------------*/\n      }\n    #endif\n    /*--------------------------------------------------------------------------*/\n  }\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat dstN = posM.x - posN.x;\n  FxaaFloat dstP = posP.x - posM.x;\n  if (!horzSpan) dstN = posM.y - posN.y;\n  if (!horzSpan) dstP = posP.y - posM.y;\n  /*--------------------------------------------------------------------------*/\n  FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n  FxaaFloat spanLength = (dstP + dstN);\n  FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n  FxaaFloat spanLengthRcp = 1.0 / spanLength;\n  /*--------------------------------------------------------------------------*/\n  FxaaBool directionN = dstN < dstP;\n  FxaaFloat dst = min(dstN, dstP);\n  FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n  FxaaFloat subpixG = subpixF * subpixF;\n  FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n  FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n  FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n  if (!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n  if (horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n  #if (FXAA_DISCARD == 1)\n    return FxaaTexTop(tex, posM);\n  #else\n  return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n  #endif\n}\n/*==========================================================================*/\n#endif\n\n\nvoid main(){\n#ifdef RN_IS_FASTEST_MODE\r\n  float materialSID = u_currentComponentSIDs[0];\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = int(u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.LightComponentTID} */]);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.SkeletalComponentTID} */];\r\n  #endif\r\n\r\n#else\r\n\r\n  float materialSID = u_materialSID;\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = get_lightNumber(0.0, 0);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\r\n  #endif\r\n\r\n#endif\r\n\n\n  vec2 screenInfo = get_screenInfo(materialSID, 0);\n  rt0 = FxaaPixelShader(\n      v_texcoord_0,\n      vec4(0.0),\n      u_baseColorTexture,\n      u_baseColorTexture,\n      u_baseColorTexture,\n      1.0 / screenInfo,\n      vec4(0.0),\n      vec4(0.0),\n      vec4(0.0),\n      0.75,\n      0.166,\n      0.0833,\n      0.0,\n      0.0,\n      0.0,\n      vec4(0.0)\n  );\n  rt0.a = 1.0;\n\n#ifdef GLSL_ES3\r\n\r\n#else\r\n  gl_FragColor = rt0;\r\n#endif\r\n\n\n}\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/FXAA3QualityShader/FXAA3QualitySingleShader.vert":
/*!**************************************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/FXAA3QualityShader/FXAA3QualitySingleShader.vert ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nprecision highp float;\r\nprecision highp int;\r\n\n\n/* shaderity: @{definitions} */\n\nuniform float u_materialSID; // skipProcess=true\r\nuniform sampler2D u_dataTexture; // skipProcess=true\r\n\r\n  /*\r\n  * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\r\n  * arg = vec2(1. / size.x, 1. / size.x / size.y);\r\n  */\r\n  // highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 arg)\r\n  // {\r\n  //   return ${this.glsl_texture}( tex, arg * (index + 0.5) );\r\n  // }\r\n\r\nhighp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 invSize){\r\n  highp float t = (index + 0.5) * invSize.x;\r\n  highp float x = fract(t);\r\n  highp float y = (floor(t) + 0.5) * invSize.y;\r\n  return texture2D( tex, vec2(x, y) );\r\n}\r\n\r\n\r\nfloat rand(const vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvec3 descramble(vec3 v) {\r\n  float seed = 0.0;\r\n  v.x -= sin(fract(v.y*20.0));\r\n  v.z -= cos(fract(-v.y*10.0));\r\n  return v;\r\n}\r\n\r\n\n\nin float a_instanceID;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_FASTEST_MODE\r\n  float materialSID = u_currentComponentSIDs[0];\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = int(u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.LightComponentTID} */]);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.SkeletalComponentTID} */];\r\n  #endif\r\n\r\n#else\r\n\r\n  float materialSID = u_materialSID;\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = get_lightNumber(0.0, 0);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\r\n  #endif\r\n\r\n#endif\r\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\r\nmat4 worldMatrix = get_worldMatrix(a_instanceID);\r\nmat4 viewMatrix = get_viewMatrix(cameraSID, 0);\r\nmat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\r\ngl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4(a_position, 1.0);\n\n  v_texcoord_0 = a_texcoord_0;\n}\n","shaderStage":"vertex"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.frag":
/*!**************************************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.frag ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nprecision highp float;\r\nprecision highp int;\r\n\n\n/* shaderity: @{definitions} */\n\nuniform float u_materialSID; // skipProcess=true\r\nuniform sampler2D u_dataTexture; // skipProcess=true\r\n\r\n  /*\r\n  * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\r\n  * arg = vec2(1. / size.x, 1. / size.x / size.y);\r\n  */\r\n  // highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 arg)\r\n  // {\r\n  //   return ${this.glsl_texture}( tex, arg * (index + 0.5) );\r\n  // }\r\n\r\nhighp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 invSize){\r\n  highp float t = (index + 0.5) * invSize.x;\r\n  highp float x = fract(t);\r\n  highp float y = (floor(t) + 0.5) * invSize.y;\r\n  return texture2D( tex, vec2(x, y) );\r\n}\r\n\r\n\r\nfloat rand(const vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvec3 descramble(vec3 v) {\r\n  float seed = 0.0;\r\n  v.x -= sin(fract(v.y*20.0));\r\n  v.z -= cos(fract(-v.y*10.0));\r\n  return v;\r\n}\r\n\r\n\n\nin vec2 v_texcoord_0;\n\n#ifdef GLSL_ES3\r\n  layout(location = 0) out vec4 rt0;\r\n#else\r\n  vec4 rt0;\r\n#endif\r\n\n\n/* shaderity: @{getters} */\n\nvec3 linearToSrgb(vec3 linearColor) {\r\n  return pow(linearColor, vec3(1.0/2.2));\r\n}\r\n\r\nvec3 srgbToLinear(vec3 srgbColor) {\r\n  return pow(srgbColor, vec3(2.2));\r\n}\n\n\nvoid main ()\n{\n\n#ifdef RN_IS_FASTEST_MODE\r\n  float materialSID = u_currentComponentSIDs[0];\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = int(u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.LightComponentTID} */]);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.SkeletalComponentTID} */];\r\n  #endif\r\n\r\n#else\r\n\r\n  float materialSID = u_materialSID;\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = get_lightNumber(0.0, 0);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\r\n  #endif\r\n\r\n#endif\r\n\n\nvec4 baseColor = texture2D(u_baseColorTexture, v_texcoord_0);\nbaseColor.rgb = linearToSrgb(baseColor.rgb);\n\nrt0 = baseColor;\n\n#ifdef GLSL_ES3\r\n\r\n#else\r\n  gl_FragColor = rt0;\r\n#endif\r\n\n\n}\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.vert":
/*!**************************************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.vert ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nprecision highp float;\r\nprecision highp int;\r\n\n\n/* shaderity: @{definitions} */\n\nin float a_instanceID;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\nuniform float u_materialSID; // skipProcess=true\r\nuniform sampler2D u_dataTexture; // skipProcess=true\r\n\r\n  /*\r\n  * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\r\n  * arg = vec2(1. / size.x, 1. / size.x / size.y);\r\n  */\r\n  // highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 arg)\r\n  // {\r\n  //   return ${this.glsl_texture}( tex, arg * (index + 0.5) );\r\n  // }\r\n\r\nhighp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 invSize){\r\n  highp float t = (index + 0.5) * invSize.x;\r\n  highp float x = fract(t);\r\n  highp float y = (floor(t) + 0.5) * invSize.y;\r\n  return texture2D( tex, vec2(x, y) );\r\n}\r\n\r\n\r\nfloat rand(const vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvec3 descramble(vec3 v) {\r\n  float seed = 0.0;\r\n  v.x -= sin(fract(v.y*20.0));\r\n  v.z -= cos(fract(-v.y*10.0));\r\n  return v;\r\n}\r\n\r\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main()\n{\n\n#ifdef RN_IS_FASTEST_MODE\r\n  float materialSID = u_currentComponentSIDs[0];\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = int(u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.LightComponentTID} */]);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.SkeletalComponentTID} */];\r\n  #endif\r\n\r\n#else\r\n\r\n  float materialSID = u_materialSID;\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = get_lightNumber(0.0, 0);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\r\n  #endif\r\n\r\n#endif\r\n\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\r\nmat4 worldMatrix = get_worldMatrix(a_instanceID);\r\nmat4 viewMatrix = get_viewMatrix(cameraSID, 0);\r\nmat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\r\ngl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4(a_position, 1.0);\n\nv_texcoord_0 = a_texcoord_0;\n\n}\n","shaderStage":"vertex"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/PbrSingleShader/PbrSingleShader.frag":
/*!**************************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/PbrSingleShader/PbrSingleShader.frag ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\r\n#extension GL_EXT_shader_texture_lod : require\r\n#endif\r\n\r\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\r\n#extension GL_OES_standard_derivatives : require\r\n#endif\r\n\nprecision highp float;\r\nprecision highp int;\r\n\n\n/* shaderity: @{definitions} */\n\nuniform float u_materialSID; // skipProcess=true\r\nuniform sampler2D u_dataTexture; // skipProcess=true\r\n\r\n  /*\r\n  * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\r\n  * arg = vec2(1. / size.x, 1. / size.x / size.y);\r\n  */\r\n  // highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 arg)\r\n  // {\r\n  //   return ${this.glsl_texture}( tex, arg * (index + 0.5) );\r\n  // }\r\n\r\nhighp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 invSize){\r\n  highp float t = (index + 0.5) * invSize.x;\r\n  highp float x = fract(t);\r\n  highp float y = (floor(t) + 0.5) * invSize.y;\r\n  return texture2D( tex, vec2(x, y) );\r\n}\r\n\r\n\r\nfloat rand(const vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvec3 descramble(vec3 v) {\r\n  float seed = 0.0;\r\n  v.x -= sin(fract(v.y*20.0));\r\n  v.z -= cos(fract(-v.y*10.0));\r\n  return v;\r\n}\r\n\r\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec3 v_tangent_inWorld;\nin vec3 v_binormal_inWorld;\nin vec4 v_position_inWorld;\nin vec2 v_texcoord_0;\nin vec2 v_texcoord_1;\nin vec3 v_baryCentricCoord;\n\n#ifdef GLSL_ES3\r\n  layout(location = 0) out vec4 rt0;\r\n#else\r\n  vec4 rt0;\r\n#endif\r\n\n\nconst float M_PI = 3.141592653589793;\r\nconst float c_MinRoughness = 0.04;\r\n\r\nfloat angular_n_h(float NH) {\r\n  return acos(NH);\r\n}\r\n\r\nfloat sqr(float x) {\r\n  return x*x;\r\n}\r\n\r\nfloat d_phong(float NH, float c1) {\r\n  return pow(\r\n    cos(acos(NH))\r\n    , c1\r\n  );\r\n}\r\n\r\n// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile\r\nvec3 envBRDFApprox( vec3 F0, float Roughness, float NoV ) {\r\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );\r\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );\r\n  vec4 r = Roughness * c0 + c1;\r\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\r\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\r\n\r\n  return F0 * AB.x + AB.y;\r\n}\r\n\r\n// GGX NDF\r\nfloat d_ggx(float NH, float alphaRoughness) {\r\n  float roughnessSqr = alphaRoughness * alphaRoughness;\r\n  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;\r\n  return roughnessSqr / (M_PI * f * f);\r\n}\r\n\r\nfloat d_torrance_reiz(float NH, float c3) {\r\n  float CosSquared = NH*NH;\r\n  float TanSquared = (1.0 - CosSquared)/CosSquared;\r\n  //return (1.0/M_PI) * sqr(c3/(CosSquared * (c3*c3 + TanSquared)));  // gamma = 2, aka GGX\r\n  return (1.0/sqrt(M_PI)) * (sqr(c3)/(CosSquared * (c3*c3 + TanSquared))); // gamma = 1, D_Berry\r\n}\r\n\r\nfloat d_beckmann(float NH, float m) {\r\n  float co = 1.0 / (4.0 * m * m * NH * NH * NH * NH);\r\n  float expx = exp((NH * NH - 1.0) / (m * m * NH * NH));\r\n  return co * expx;\r\n}\r\n\r\n// the same as glTF WebGL sample\r\n// https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders/pbr-frag.glsl#L188\r\n// That is, Unreal Engine based approach, but modified to use alphaRoughness (squared artist's roughness parameter),\r\n// and based on 'Separable Masking and Shadowing' approximation (propesed by Christophe Schlick)\r\n// https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\r\nfloat g_shielding(float NL, float NV, float alphaRoughness) {\r\n  float r = alphaRoughness;\r\n\r\n  // Local Shadowing using \"Schlick-Smith\" Masking Function\r\n  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));\r\n\r\n  // Local Masking using \"Schlick-Smith\" Masking Function\r\n  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));\r\n\r\n  return localShadowing * localMasking;\r\n}\r\n\r\n// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv\r\n// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.\r\nfloat v_SmithGGXCorrelated(float NL, float NV, float alphaRoughness) {\r\n  float a2 = alphaRoughness * alphaRoughness;\r\n  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);\r\n  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);\r\n  return 0.5 / (GGXV + GGXL);\r\n}\r\n\r\nfloat v_SmithGGXCorrelatedFast(float NL, float NV, float alphaRoughness) {\r\n  float a = alphaRoughness;\r\n  float GGXV = NL * (NV * (1.0 - a) + a);\r\n  float GGXL = NV * (NL * (1.0 - a) + a);\r\n  return 0.5 / (GGXV + GGXL);\r\n}\r\n\r\n// The Schlick Approximation to Fresnel\r\nvec3 fresnel(vec3 f0, float VH) {\r\n  return vec3(f0) + (vec3(1.0) - f0) * pow(1.0 - VH, 5.0);\r\n}\r\n\r\nvec3 cook_torrance_specular_brdf(float NH, float NL, float NV, vec3 F, float alphaRoughness) {\r\n  float D = d_ggx(NH, alphaRoughness);\r\n  float V = v_SmithGGXCorrelated(NL, NV, alphaRoughness);\r\n  return vec3(D)*vec3(V)*F;\r\n//      float G = g_shielding(NL, NV, alphaRoughness);\r\n//      return vec3(D)*vec3(G)*F/vec3(4.0*NL*NV);\r\n\r\n}\r\n\r\nvec3 diffuse_brdf(vec3 albedo)\r\n{\r\n  return albedo / M_PI;\r\n}\r\n\r\nvec3 srgbToLinear(vec3 srgbColor) {\r\n  return pow(srgbColor, vec3(2.2));\r\n}\r\n\r\nfloat srgbToLinear(float value) {\r\n  return pow(value, 2.2);\r\n}\r\n\r\nvec3 linearToSrgb(vec3 linearColor) {\r\n  return pow(linearColor, vec3(1.0/2.2));\r\n}\r\n\r\nfloat linearToSrgb(float value) {\r\n  return pow(value, 1.0/2.2);\r\n}\r\n\r\nvec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)\r\n{\r\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\n\r\nvec3 normalBlendingUDN(sampler2D baseMap, sampler2D detailMap, vec2 baseUv, vec2 detailUv) {\r\n  vec3 t = texture2D(baseMap,   baseUv).xyz * 2.0 - 1.0;\r\n  vec3 u = texture2D(detailMap, detailUv).xyz * 2.0 - 1.0;\r\n  vec3 r = normalize(vec3(t.xy + u.xy, t.z));\r\n  return r;\r\n}\r\n\r\nvec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {\r\n  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);\r\n  mat3 rotationMat = mat3(\r\n      cos(rotation), -sin(rotation), 0,\r\n      sin(rotation), cos(rotation), 0,\r\n                  0,             0, 1\r\n  );\r\n  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);\r\n\r\n  mat3 matrix = translationMat * rotationMat * scaleMat;\r\n  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;\r\n\r\n  return uvTransformed;\r\n}\r\n\n\n/* shaderity: @{getters} */\n\nvec3 IBLContribution(float materialSID, vec3 n, float NV, vec3 reflection, vec3 albedo, vec3 F0, float userRoughness, vec3 F)\n{\n  vec4 iblParameter = get_iblParameter(materialSID, 0);\n  float mipCount = iblParameter.x;\n  float lod = (userRoughness * (mipCount - 1.0));\n\n  vec4 diffuseTexel = textureCube(u_diffuseEnvTexture, vec3(-n.x, n.y, n.z));\n  vec3 diffuseLight;\n  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);\n  if (hdriFormat.x == 0) {\n    // LDR_SRGB\n    diffuseLight = srgbToLinear(diffuseTexel.rgb);\n  }\n  else if (hdriFormat.x == 3) {\n    // RGBE\n    diffuseLight = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);\n  }\n  else {\n    diffuseLight = diffuseTexel.rgb;\n  }\n\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\r\n  vec4 specularTexel = textureCubeLodEXT(u_specularEnvTexture, vec3(-reflection.x, reflection.y, reflection.z), lod);\r\n#elif defined(GLSL_ES3)\r\n  vec4 specularTexel = textureLod(u_specularEnvTexture, vec3(-reflection.x, reflection.y, reflection.z), lod);\r\n#else\r\n  vec4 specularTexel = textureCube(u_specularEnvTexture, vec3(-reflection.x, reflection.y, reflection.z));\r\n#endif\r\n\n\n  vec3 specularLight;\n  if (hdriFormat.y == 0) {\n    // LDR_SRGB\n    specularLight = srgbToLinear(specularTexel.rgb);\n  }\n  else if (hdriFormat.y == 3) {\n    // RGBE\n    specularLight = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);\n  }\n  else {\n    specularLight = specularTexel.rgb;\n  }\n\n  vec3 kS = fresnelSchlickRoughness(F0, NV, userRoughness);\n  vec3 kD = 1.0 - kS;\n  vec3 diffuse = diffuseLight * albedo * kD;\n  // vec3 brdf = texture2D(u_brdfLutTexture, vec2(1.0 - NV, 1.0 - userRoughness)).rgb;\n  // vec3 specular = specularLight * (F0 * brdf.x + brdf.y);\n  vec3 specular = specularLight * envBRDFApprox(F0, userRoughness, NV);\n\n  float IBLDiffuseContribution = iblParameter.y;\n  float IBLSpecularContribution = iblParameter.z;\n  diffuse *= IBLDiffuseContribution;\n  specular *= IBLSpecularContribution;\n  return diffuse + specular;\n}\n\nfloat edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {\n  vec3 d = fwidth(bary3);\n  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;\n  vec3 a3 = smoothstep(vec3(0.0), d, x);\n  float factor = min(min(a3.x, a3.y), a3.z);\n\n  return clamp((1.0 - factor), 0.0, 1.0);\n}\n\nvec2 getTexcoord(int texcoordIndex) {\n  vec2 texcoord;\n  if(texcoordIndex == 1){\n    texcoord = v_texcoord_1;\n  }else{\n    texcoord = v_texcoord_0;\n  }\n  return texcoord;\n}\n\n\nvoid main ()\n{\n\n#ifdef RN_IS_FASTEST_MODE\r\n  float materialSID = u_currentComponentSIDs[0];\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = int(u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.LightComponentTID} */]);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.SkeletalComponentTID} */];\r\n  #endif\r\n\r\n#else\r\n\r\n  float materialSID = u_materialSID;\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = get_lightNumber(0.0, 0);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\r\n  #endif\r\n\r\n#endif\r\n\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n  vec4 iblParameter = get_iblParameter(materialSID, 0);\n  float rot = iblParameter.w + 3.1415;\n  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  vec3 normal_forEnv = rotEnvMatrix * normal_inWorld;\n\n  if (abs(length(v_tangent_inWorld)) > 0.01) {\n    vec4 normalTextureTransform = get_normalTextureTransform(materialSID, 0);\n    float normalTextureRotation = get_normalTextureRotation(materialSID, 0);\n    int normalTexcoordIndex = get_normalTexcoordIndex(materialSID, 0);\n    vec2 normalTexcoord = getTexcoord(normalTexcoordIndex);\n    vec2 normalTexUv = uvTransform(normalTextureTransform.xy, normalTextureTransform.zw, normalTextureRotation, normalTexcoord);\n    vec3 normal = texture2D(u_normalTexture, normalTexUv).xyz*2.0 - 1.0;\n    vec3 tangent_inWorld = normalize(v_tangent_inWorld);\n    vec3 binormal_inWorld = normalize(v_binormal_inWorld);\n    normal_inWorld = normalize(normal_inWorld);\n\n    mat3 tbnMat_tangent_to_world = mat3(\n      tangent_inWorld.x, tangent_inWorld.y, tangent_inWorld.z,\n      binormal_inWorld.x, binormal_inWorld.y, binormal_inWorld.z,\n      normal_inWorld.x, normal_inWorld.y, normal_inWorld.z\n    );\n\n    normal = normalize(tbnMat_tangent_to_world * normal);\n    normal_inWorld = normal;\n  }\n\n\n\n  // BaseColorFactor\n  vec3 baseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n  vec4 baseColorFactor = get_baseColorFactor(materialSID, 0);\n  if (v_color != baseColor && baseColorFactor.rgb != baseColor) {\n    baseColor = v_color * baseColorFactor.rgb;\n    alpha = baseColorFactor.a;\n  } else if (v_color == baseColor) {\n    baseColor = baseColorFactor.rgb;\n    alpha = baseColorFactor.a;\n  } else if (baseColorFactor.rgb == baseColor) {\n    baseColor = v_color;\n  } else {\n    baseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n\n  // BaseColor (take account for BaseColorTexture)\n  vec4 baseColorTextureTransform = get_baseColorTextureTransform(materialSID, 0);\n  float baseColorTextureRotation = get_baseColorTextureRotation(materialSID, 0);\n  int baseColorTexcoordIndex = get_baseColorTexcoordIndex(materialSID, 0);\n  vec2 baseColorTexcoord = getTexcoord(baseColorTexcoordIndex);\n  vec2 baseColorTexUv = uvTransform(baseColorTextureTransform.xy, baseColorTextureTransform.zw, baseColorTextureRotation, baseColorTexcoord);\n  vec4 textureColor = texture2D(u_baseColorTexture, baseColorTexUv);\n  baseColor *= srgbToLinear(textureColor.rgb);\n  alpha *= textureColor.a;\n\n#ifdef RN_IS_ALPHAMODE_MASK\r\n  float alphaCutoff = get_alphaCutoff(materialSID, 0);\r\n  if (alpha < alphaCutoff) {\r\n    discard;\r\n  }\r\n#endif\n\n#ifdef RN_IS_LIGHTING\n\n  // Metallic & Roughness\n  vec2 metallicRoughnessFactor = get_metallicRoughnessFactor(materialSID, 0);\n  float userRoughness = metallicRoughnessFactor.y;\n  float metallic = metallicRoughnessFactor.x;\n\n  vec4 metallicRoughnessTextureTransform = get_metallicRoughnessTextureTransform(materialSID, 0);\n  float metallicRoughnessTextureRotation = get_metallicRoughnessTextureRotation(materialSID, 0);\n  int metallicRoughnessTexcoordIndex = get_metallicRoughnessTexcoordIndex(materialSID, 0);\n  vec2 metallicRoughnessTexcoord = getTexcoord(metallicRoughnessTexcoordIndex);\n  vec2 metallicRoughnessTexUv = uvTransform(metallicRoughnessTextureTransform.xy, metallicRoughnessTextureTransform.zw, metallicRoughnessTextureRotation, metallicRoughnessTexcoord);\n  vec4 ormTexel = texture2D(u_metallicRoughnessTexture, metallicRoughnessTexUv);\n  userRoughness = ormTexel.g * userRoughness;\n  metallic = ormTexel.b * metallic;\n\n  userRoughness = clamp(userRoughness, c_MinRoughness, 1.0);\n  metallic = clamp(metallic, 0.0, 1.0);\n  float alphaRoughness = userRoughness * userRoughness;\n\n  // F0\n  vec3 diffuseMatAverageF0 = vec3(0.04);\n  vec3 F0 = mix(diffuseMatAverageF0, baseColor.rgb, metallic);\n\n  // Albedo\n  vec3 albedo = baseColor.rgb * (vec3(1.0) - diffuseMatAverageF0);\n  albedo.rgb *= (1.0 - metallic);\n\n  // ViewDirection\n  float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n  vec3 viewPosition = get_viewPosition(cameraSID, 0);\n  vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n\n  // NV\n  float NV = clamp(abs(dot(normal_inWorld, viewDirection)), 0.0, 1.0);\n\n  rt0 = vec4(0.0, 0.0, 0.0, alpha);\n\n  // Lighting\n  vec3 diffuse = vec3(0.0, 0.0, 0.0);\n  for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {\n    if (i >= lightNumber) {\n      break;\n    }\n\n    // Light\n    vec4 gotLightDirection = get_lightDirection(0.0, i);\n    vec4 gotLightPosition = get_lightPosition(0.0, i);\n    vec4 gotLightIntensity = get_lightIntensity(0.0, i);\n    vec3 lightDirection = gotLightDirection.xyz;\n    vec3 lightIntensity = gotLightIntensity.xyz;\n    vec3 lightPosition = gotLightPosition.xyz;\n    float lightType = gotLightPosition.w;\n    float spotCosCutoff = gotLightDirection.w;\n    float spotExponent = gotLightIntensity.w;\n\n    if (0.75 < lightType) { // is pointlight or spotlight\n      lightDirection = normalize(lightPosition.xyz - v_position_inWorld.xyz);\n    }\n    float spotEffect = 1.0;\n    if (lightType > 1.75) { // is spotlight\n      spotEffect = dot(gotLightDirection.xyz, lightDirection);\n      if (spotEffect > spotCosCutoff) {\n        spotEffect = pow(spotEffect, spotExponent);\n      } else {\n        spotEffect = 0.0;\n      }\n    }\n    //diffuse += 1.0 * max(0.0, dot(normal_inWorld, lightDirection)) * spotEffect * lightIntensity.xyz;\n\n    // IncidentLight\n    vec3 incidentLight = spotEffect * lightIntensity.xyz;\n    incidentLight *= M_PI;\n\n    // Fresnel\n    vec3 halfVector = normalize(lightDirection + viewDirection);\n    float VH = clamp(dot(viewDirection, halfVector), 0.0, 1.0);\n    vec3 F = fresnel(F0, VH);\n\n    // Diffuse\n    vec3 diffuseContrib = (vec3(1.0) - F) * diffuse_brdf(albedo);\n\n    // Specular\n    float NL = clamp(dot(normal_inWorld, lightDirection), 0.0, 1.0);\n    float NH = clamp(dot(normal_inWorld, halfVector), 0.0, 1.0);\n    vec3 specularContrib = cook_torrance_specular_brdf(NH, NL, NV, F, alphaRoughness);\n    vec3 diffuseAndSpecular = (diffuseContrib + specularContrib) * vec3(NL) * incidentLight.rgb;\n\n    rt0.xyz += diffuseAndSpecular;\n//      rt0.xyz += specularContrib * vec3(NL) * incidentLight.rgb;\n//    rt0.xyz += diffuseContrib * vec3(NL) * incidentLight.rgb;\n//    rt0.xyz += (vec3(1.0) - F) * diffuse_brdf(albedo);//diffuseContrib;//vec3(NL) * incidentLight.rgb;\n  }\n\n  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);\n\n  vec3 F = fresnel(F0, NV);\n  vec3 ibl = IBLContribution(materialSID, normal_forEnv, NV, reflection, albedo, F0, userRoughness, F);\n\n  int occlusionTexcoordIndex = get_occlusionTexcoordIndex(materialSID, 0);\n  vec2 occlusionTexcoord = getTexcoord(occlusionTexcoordIndex);\n  float occlusion = texture2D(u_occlusionTexture, occlusionTexcoord).r;\n\n  // Occlution to Indirect Lights\n  rt0.xyz += ibl * occlusion;\n#else\n  rt0 = vec4(baseColor, alpha);\n#endif\n\n  // Emissive\n  int emissiveTexcoordIndex = get_emissiveTexcoordIndex(materialSID, 0);\n  vec2 emissiveTexcoord = getTexcoord(emissiveTexcoordIndex);\n  vec3 emissive = srgbToLinear(texture2D(u_emissiveTexture, emissiveTexcoord).xyz);\n\n  rt0.xyz += emissive;\n\n  bool isOutputHDR = get_isOutputHDR(materialSID, 0);\n  if(isOutputHDR){\n#ifdef GLSL_ES3\r\n\r\n#else\r\n  gl_FragColor = rt0;\r\n#endif\r\n\n    return;\n  }\n\n#ifdef RN_IS_ALPHAMODE_OPAQUE\r\n  rt0.a = 1.0;\r\n#elif defined(RN_IS_ALPHAMODE_MASK)\r\n  rt0.a = 1.0;\r\n#endif\n\n  // Wireframe\n  float threshold = 0.001;\n  vec3 wireframe = get_wireframe(materialSID, 0);\n  float wireframeWidthInner = wireframe.z;\n  float wireframeWidthRelativeScale = 1.0;\n  if (wireframe.x > 0.5 && wireframe.y < 0.5) {\n    rt0.a = 0.0;\n  }\n  vec4 wireframeResult = rt0;\n  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);\n  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);\n  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);\n  // if r0.a is 0.0, it is wireframe not on shaded\n  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);\n  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));\n\n  if (wireframe.x > 0.5) {\n    rt0 = wireframeResult;\n    if (wireframe.y < 0.5 && rt0.a == 0.0) {\n      discard;\n    }\n  }\n\n#ifdef GLSL_ES3\r\n\r\n#else\r\n  gl_FragColor = rt0;\r\n#endif\r\n\n}\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/PbrSingleShader/PbrSingleShader.vert":
/*!**************************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/PbrSingleShader/PbrSingleShader.vert ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nprecision highp float;\r\nprecision highp int;\r\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_tangent;\nin float a_instanceID;\nin vec2 a_texcoord_0;\nin vec2 a_texcoord_1;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec3 v_tangent_inWorld;\nout vec3 v_binormal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec2 v_texcoord_1;\nout vec3 v_baryCentricCoord;\n\nuniform float u_materialSID; // skipProcess=true\r\nuniform sampler2D u_dataTexture; // skipProcess=true\r\n\r\n  /*\r\n  * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\r\n  * arg = vec2(1. / size.x, 1. / size.x / size.y);\r\n  */\r\n  // highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 arg)\r\n  // {\r\n  //   return ${this.glsl_texture}( tex, arg * (index + 0.5) );\r\n  // }\r\n\r\nhighp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 invSize){\r\n  highp float t = (index + 0.5) * invSize.x;\r\n  highp float x = fract(t);\r\n  highp float y = (floor(t) + 0.5) * invSize.y;\r\n  return texture2D( tex, vec2(x, y) );\r\n}\r\n\r\n\r\nfloat rand(const vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvec3 descramble(vec3 v) {\r\n  float seed = 0.0;\r\n  v.x -= sin(fract(v.y*20.0));\r\n  v.z -= cos(fract(-v.y*10.0));\r\n  return v;\r\n}\r\n\r\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\r\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\r\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\r\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\r\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\r\n\r\n  float b00 = a00 * a11 - a01 * a10,\r\n  b01 = a00 * a12 - a02 * a10,\r\n  b02 = a00 * a13 - a03 * a10,\r\n  b03 = a01 * a12 - a02 * a11,\r\n  b04 = a01 * a13 - a03 * a11,\r\n  b05 = a02 * a13 - a03 * a12,\r\n  b06 = a20 * a31 - a21 * a30,\r\n  b07 = a20 * a32 - a22 * a30,\r\n  b08 = a20 * a33 - a23 * a30,\r\n  b09 = a21 * a32 - a22 * a31,\r\n  b10 = a21 * a33 - a23 * a31,\r\n  b11 = a22 * a33 - a23 * a32;\r\n\r\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n  return mat3(\r\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\r\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\r\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\r\n}\r\n\n\n\r\n#ifdef RN_IS_SKINNING\r\n\r\nhighp mat4 createMatrixFromQuaternionTransformUniformScale( highp vec4 quaternion, highp vec4 translationScale ) {\r\n  highp vec4 q = quaternion;\r\n  highp vec3 t = translationScale.xyz;\r\n  highp float scale = translationScale.w;\r\n\r\n  highp float sx = q.x * q.x;\r\n  highp float sy = q.y * q.y;\r\n  highp float sz = q.z * q.z;\r\n  highp float cx = q.y * q.z;\r\n  highp float cy = q.x * q.z;\r\n  highp float cz = q.x * q.y;\r\n  highp float wx = q.w * q.x;\r\n  highp float wy = q.w * q.y;\r\n  highp float wz = q.w * q.z;\r\n\r\n  highp mat4 mat = mat4(\r\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\r\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\r\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\r\n    t.x, t.y, t.z, 1.0\r\n  );\r\n\r\n  highp mat4 uniformScaleMat = mat4(\r\n    scale, 0.0, 0.0, 0.0,\r\n    0.0, scale, 0.0, 0.0,\r\n    0.0, 0.0, scale, 0.0,\r\n    0.0, 0.0, 0.0, 1.0\r\n  );\r\n\r\n  return mat*uniformScaleMat;\r\n}\r\n\r\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\r\n\r\n  highp float r;\r\n  highp float g;\r\n  highp float b;\r\n  highp float a;\r\n\r\n  highp float ix = floor(vec_xy.x * criteria);\r\n  highp float v1x = ix / criteria;\r\n  highp float v1y = ix - floor(v1x) * criteria;\r\n\r\n  r = ( v1x + 1.0 ) / (criteria-1.0);\r\n  g = ( v1y + 1.0 ) / (criteria-1.0);\r\n\r\n  highp float iy = floor( vec_xy.y * criteria);\r\n  highp float v2x = iy / criteria;\r\n  highp float v2y = iy - floor(v2x) * criteria;\r\n\r\n  b = ( v2x + 1.0 ) / (criteria-1.0);\r\n  a = ( v2y + 1.0 ) / (criteria-1.0);\r\n\r\n  r -= 1.0/criteria;\r\n  g -= 1.0/criteria;\r\n  b -= 1.0/criteria;\r\n  a -= 1.0/criteria;\r\n\r\n  r = r*2.0-1.0;\r\n  g = g*2.0-1.0;\r\n  b = b*2.0-1.0;\r\n  a = a*2.0-1.0;\r\n\r\n  return vec4(r, g, b, a);\r\n}\r\n\r\nmat4 getSkinMatrix(float skeletalComponentSID) {\r\n\r\n#ifdef RN_BONE_DATA_TYPE_MAT4X4\r\n  mat4 skinMat = a_weight.x * get_boneMatrix(skeletalComponentSID, int(a_joint.x));\r\n  skinMat += a_weight.y * get_boneMatrix(skeletalComponentSID, int(a_joint.y));\r\n  skinMat += a_weight.z * get_boneMatrix(skeletalComponentSID, int(a_joint.z));\r\n  skinMat += a_weight.w * get_boneMatrix(skeletalComponentSID, int(a_joint.w));\r\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\r\n  highp vec2 criteria = vec2(4096.0, 4096.0);\r\n  highp mat4 skinMat = a_weight.x * createMatrixFromQuaternionTransformUniformScale(\r\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)),\r\n    get_boneTranslateScale(skeletalComponentSID, int(a_joint.x)));\r\n  skinMat += a_weight.y * createMatrixFromQuaternionTransformUniformScale(\r\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)),\r\n    get_boneTranslateScale(skeletalComponentSID, int(a_joint.y)));\r\n  skinMat += a_weight.z * createMatrixFromQuaternionTransformUniformScale(\r\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)),\r\n    get_boneTranslateScale(skeletalComponentSID, int(a_joint.z)));\r\n  skinMat += a_weight.w * createMatrixFromQuaternionTransformUniformScale(\r\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)),\r\n    get_boneTranslateScale(skeletalComponentSID, int(a_joint.w)));\r\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\r\n  highp vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\r\n  highp vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\r\n  highp vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\r\n  highp vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\r\n\r\n  highp vec2 criteria = vec2(4096.0, 4096.0);\r\n  highp vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\r\n  highp mat4 skinMat = a_weight.x * createMatrixFromQuaternionTransformUniformScale(\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x),\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo);\r\n  skinMat += a_weight.y * createMatrixFromQuaternionTransformUniformScale(\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x),\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo);\r\n  skinMat += a_weight.z * createMatrixFromQuaternionTransformUniformScale(\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x),\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo);\r\n  skinMat += a_weight.w * createMatrixFromQuaternionTransformUniformScale(\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x),\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo);\r\n#endif\r\n\r\n  return skinMat;\r\n}\r\n#endif\n\n\r\n#ifdef RN_IS_SKINNING\r\nbool skinning(\r\n  float skeletalComponentSID,\r\n  in mat3 inNormalMatrix,\r\n  out mat3 outNormalMatrix,\r\n  in vec3 inPosition_inLocal,\r\n  out vec4 outPosition_inWorld,\r\n  in vec3 inNormal_inLocal,\r\n  out vec3 outNormal_inWorld\r\n  )\r\n{\r\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\r\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\r\n  outNormalMatrix = toNormalMatrix(skinMat);\r\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\r\n\r\n  return true;\r\n}\r\n#endif\r\n\r\nbool processGeometryWithMorphingAndSkinning(\r\n  float skeletalComponentSID,\r\n  in mat4 worldMatrix,\r\n  in mat3 inNormalMatrix,\r\n  out mat3 outNormalMatrix,\r\n  in vec3 inPosition_inLocal,\r\n  out vec4 outPosition_inWorld,\r\n  in vec3 inNormal_inLocal,\r\n  out vec3 outNormal_inWorld\r\n) {\r\n  bool isSkinning = false;\r\n\r\n  vec3 position_inLocal;\r\n#ifdef RN_IS_MORPHING\r\n  if (u_morphTargetNumber == 0) {\r\n#endif\r\n    position_inLocal = inPosition_inLocal;\r\n#ifdef RN_IS_MORPHING\r\n  } else {\r\n    float vertexIdx = a_baryCentricCoord.w;\r\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\r\n  }\r\n#endif\r\n\r\n\r\n#ifdef RN_IS_SKINNING\r\n  if (skeletalComponentSID >= 0.0) {\r\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\r\n  } else {\r\n#endif\r\n    outNormalMatrix = inNormalMatrix;\r\n    outPosition_inWorld = worldMatrix * vec4(position_inLocal, 1.0);\r\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\r\n#ifdef RN_IS_SKINNING\r\n  }\r\n#endif\r\n\r\n  return isSkinning;\r\n}\r\n\n\nvoid main()\n{\n\n#ifdef RN_IS_FASTEST_MODE\r\n  float materialSID = u_currentComponentSIDs[0];\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = int(u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.LightComponentTID} */]);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.SkeletalComponentTID} */];\r\n  #endif\r\n\r\n#else\r\n\r\n  float materialSID = u_materialSID;\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = get_lightNumber(0.0, 0);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\r\n  #endif\r\n\r\n#endif\r\n\n\n  float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n  mat4 worldMatrix = get_worldMatrix(a_instanceID);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceID);\n\n  v_color = a_color;\n\n  bool isSkinning = false;\n\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n  v_texcoord_0 = a_texcoord_0;\n  v_texcoord_1 = a_texcoord_1;\n\n  if (abs(length(a_normal)) > 0.01) {\n    // if normal exist\n    vec3 tangent_inWorld = normalMatrix * a_tangent.xyz;\n\n    v_binormal_inWorld = cross(v_normal_inWorld, tangent_inWorld) * a_tangent.w;\n    v_tangent_inWorld = cross(v_binormal_inWorld, v_normal_inWorld);\n  }\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\r\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\r\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\r\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\r\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\r\nfloat maxPointSize = get_pointSize(materialSID, 0);\r\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\r\n\n\n}","shaderStage":"vertex"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/classicSingleShader/classicSingleShader.frag":
/*!**********************************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/classicSingleShader/classicSingleShader.frag ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nprecision highp float;\r\nprecision highp int;\r\n\n\n/* shaderity: @{definitions} */\n\nuniform float u_materialSID; // skipProcess=true\r\nuniform sampler2D u_dataTexture; // skipProcess=true\r\n\r\n  /*\r\n  * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\r\n  * arg = vec2(1. / size.x, 1. / size.x / size.y);\r\n  */\r\n  // highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 arg)\r\n  // {\r\n  //   return ${this.glsl_texture}( tex, arg * (index + 0.5) );\r\n  // }\r\n\r\nhighp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 invSize){\r\n  highp float t = (index + 0.5) * invSize.x;\r\n  highp float x = fract(t);\r\n  highp float y = (floor(t) + 0.5) * invSize.y;\r\n  return texture2D( tex, vec2(x, y) );\r\n}\r\n\r\n\r\nfloat rand(const vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvec3 descramble(vec3 v) {\r\n  float seed = 0.0;\r\n  v.x -= sin(fract(v.y*20.0));\r\n  v.z -= cos(fract(-v.y*10.0));\r\n  return v;\r\n}\r\n\r\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin vec2 v_texcoord_0;\nin vec3 v_baryCentricCoord;\n\nuniform int u_shadingModel; // initialValue=0\nuniform float u_alphaCutoff; // initialValue=0.01\nuniform float u_shininess; // initialValue=5\nuniform vec4 u_diffuseColorFactor; // initialValue=(1,1,1,1)\nuniform sampler2D u_diffuseColorTexture; // initialValue=(0,white)\nuniform sampler2D u_normalTexture; // initialValue=(1,blue)\n\n#ifdef GLSL_ES3\r\n  layout(location = 0) out vec4 rt0;\r\n#else\r\n  vec4 rt0;\r\n#endif\r\n\n\n/* shaderity: @{getters} */\n\nvoid main ()\n{\n\n#ifdef RN_IS_FASTEST_MODE\r\n  float materialSID = u_currentComponentSIDs[0];\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = int(u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.LightComponentTID} */]);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.SkeletalComponentTID} */];\r\n  #endif\r\n\r\n#else\r\n\r\n  float materialSID = u_materialSID;\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = get_lightNumber(0.0, 0);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\r\n  #endif\r\n\r\n#endif\r\n\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n\n  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);\n\n\n  // diffuseColor (Considered to be premultiplied alpha)\n  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {\n    diffuseColor = v_color * diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (v_color == diffuseColor) {\n    diffuseColor = diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (diffuseColorFactor.rgb == diffuseColor) {\n    diffuseColor = v_color;\n  } else {\n    diffuseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n  // diffuseColorTexture (Considered to be premultiplied alpha)\n  vec4 textureColor = texture2D(u_diffuseColorTexture, v_texcoord_0);\n  diffuseColor *= textureColor.rgb;\n  alpha *= textureColor.a;\n\n#ifdef RN_IS_ALPHAMODE_MASK\r\n  float alphaCutoff = get_alphaCutoff(materialSID, 0);\r\n  if (alpha < alphaCutoff) {\r\n    discard;\r\n  }\r\n#endif\n\n  // Lighting\n  vec3 shadingColor = vec3(0.0, 0.0, 0.0);\n#ifdef RN_IS_LIGHTING\n  int shadingModel = get_shadingModel(materialSID, 0);\n  if (shadingModel > 0) {\n\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */ ; i++) {\n      if (i >= lightNumber) {\n        break;\n      }\n\n      vec4 gotLightDirection = get_lightDirection(0.0, i);\n      vec4 gotLightPosition = get_lightPosition(0.0, i);\n      vec4 gotLightIntensity = get_lightIntensity(0.0, i);\n      vec3 lightDirection = gotLightDirection.xyz;\n      vec3 lightIntensity = gotLightIntensity.xyz;\n      vec3 lightPosition = gotLightPosition.xyz;\n      float lightType = gotLightPosition.w;\n      float spotCosCutoff = gotLightDirection.w;\n      float spotExponent = gotLightIntensity.w;\n\n      if (0.75 < lightType) { // is pointlight or spotlight\n        lightDirection = normalize(lightPosition - v_position_inWorld.xyz);\n      }\n      float spotEffect = 1.0;\n      if (lightType > 1.75) { // is spotlight\n        spotEffect = dot(gotLightDirection.xyz, lightDirection);\n        if (spotEffect > spotCosCutoff) {\n          spotEffect = pow(spotEffect, spotExponent);\n        } else {\n          spotEffect = 0.0;\n        }\n      }\n\n      vec3 incidentLight = spotEffect * lightIntensity;\n\n\n\n      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, lightDirection)) * incidentLight;\n\n      float shininess = get_shininess(materialSID, 0);\n      int shadingModel = get_shadingModel(materialSID, 0);\n\n      float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n      vec3 viewPosition = get_viewPosition(cameraSID, 0);\n\n      if (shadingModel == 2) {// BLINN\n        // ViewDirection\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 halfVector = normalize(lightDirection + viewDirection);\n        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);\n      } else if (shadingModel == 3) { // PHONG\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 R = reflect(lightDirection, normal_inWorld);\n        specular += pow(max(0.0, dot(R, viewDirection)), shininess);\n      }\n\n    }\n\n    shadingColor = diffuse + specular;\n  } else {\n    shadingColor = diffuseColor;\n  }\n#else\n  shadingColor = diffuseColor;\n#endif\n\n  rt0 = vec4(shadingColor, alpha);\n  // rt0 = vec4(u_lightNumber, 0.0, 0.0, 1.0);\n  // rt0 = vec4(1.0, 0.0, 0.0, 1.0);\n  // rt0 = vec4(normal_inWorld*0.5+0.5, 1.0);\n\n#ifdef RN_IS_ALPHAMODE_OPAQUE\r\n  rt0.a = 1.0;\r\n#elif defined(RN_IS_ALPHAMODE_MASK)\r\n  rt0.a = 1.0;\r\n#endif\n\n#ifdef GLSL_ES3\r\n\r\n#else\r\n  gl_FragColor = rt0;\r\n#endif\r\n\n\n}\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/classicSingleShader/classicSingleShader.vert":
/*!**********************************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/classicSingleShader/classicSingleShader.vert ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nprecision highp float;\r\nprecision highp int;\r\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin float a_instanceID;\nin vec2 a_texcoord_0;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec3 v_baryCentricCoord;\n\nuniform float u_pointSize; // initialValue=30\nuniform vec3 u_pointDistanceAttenuation; // initialValue=(0,0.1,0.01)\n\nuniform float u_materialSID; // skipProcess=true\r\nuniform sampler2D u_dataTexture; // skipProcess=true\r\n\r\n  /*\r\n  * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\r\n  * arg = vec2(1. / size.x, 1. / size.x / size.y);\r\n  */\r\n  // highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 arg)\r\n  // {\r\n  //   return ${this.glsl_texture}( tex, arg * (index + 0.5) );\r\n  // }\r\n\r\nhighp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 invSize){\r\n  highp float t = (index + 0.5) * invSize.x;\r\n  highp float x = fract(t);\r\n  highp float y = (floor(t) + 0.5) * invSize.y;\r\n  return texture2D( tex, vec2(x, y) );\r\n}\r\n\r\n\r\nfloat rand(const vec2 co){\r\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvec3 descramble(vec3 v) {\r\n  float seed = 0.0;\r\n  v.x -= sin(fract(v.y*20.0));\r\n  v.z -= cos(fract(-v.y*10.0));\r\n  return v;\r\n}\r\n\r\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\r\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\r\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\r\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\r\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\r\n\r\n  float b00 = a00 * a11 - a01 * a10,\r\n  b01 = a00 * a12 - a02 * a10,\r\n  b02 = a00 * a13 - a03 * a10,\r\n  b03 = a01 * a12 - a02 * a11,\r\n  b04 = a01 * a13 - a03 * a11,\r\n  b05 = a02 * a13 - a03 * a12,\r\n  b06 = a20 * a31 - a21 * a30,\r\n  b07 = a20 * a32 - a22 * a30,\r\n  b08 = a20 * a33 - a23 * a30,\r\n  b09 = a21 * a32 - a22 * a31,\r\n  b10 = a21 * a33 - a23 * a31,\r\n  b11 = a22 * a33 - a23 * a32;\r\n\r\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n  return mat3(\r\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\r\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\r\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\r\n}\r\n\n\n\r\n#ifdef RN_IS_SKINNING\r\n\r\nhighp mat4 createMatrixFromQuaternionTransformUniformScale( highp vec4 quaternion, highp vec4 translationScale ) {\r\n  highp vec4 q = quaternion;\r\n  highp vec3 t = translationScale.xyz;\r\n  highp float scale = translationScale.w;\r\n\r\n  highp float sx = q.x * q.x;\r\n  highp float sy = q.y * q.y;\r\n  highp float sz = q.z * q.z;\r\n  highp float cx = q.y * q.z;\r\n  highp float cy = q.x * q.z;\r\n  highp float cz = q.x * q.y;\r\n  highp float wx = q.w * q.x;\r\n  highp float wy = q.w * q.y;\r\n  highp float wz = q.w * q.z;\r\n\r\n  highp mat4 mat = mat4(\r\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\r\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\r\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\r\n    t.x, t.y, t.z, 1.0\r\n  );\r\n\r\n  highp mat4 uniformScaleMat = mat4(\r\n    scale, 0.0, 0.0, 0.0,\r\n    0.0, scale, 0.0, 0.0,\r\n    0.0, 0.0, scale, 0.0,\r\n    0.0, 0.0, 0.0, 1.0\r\n  );\r\n\r\n  return mat*uniformScaleMat;\r\n}\r\n\r\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\r\n\r\n  highp float r;\r\n  highp float g;\r\n  highp float b;\r\n  highp float a;\r\n\r\n  highp float ix = floor(vec_xy.x * criteria);\r\n  highp float v1x = ix / criteria;\r\n  highp float v1y = ix - floor(v1x) * criteria;\r\n\r\n  r = ( v1x + 1.0 ) / (criteria-1.0);\r\n  g = ( v1y + 1.0 ) / (criteria-1.0);\r\n\r\n  highp float iy = floor( vec_xy.y * criteria);\r\n  highp float v2x = iy / criteria;\r\n  highp float v2y = iy - floor(v2x) * criteria;\r\n\r\n  b = ( v2x + 1.0 ) / (criteria-1.0);\r\n  a = ( v2y + 1.0 ) / (criteria-1.0);\r\n\r\n  r -= 1.0/criteria;\r\n  g -= 1.0/criteria;\r\n  b -= 1.0/criteria;\r\n  a -= 1.0/criteria;\r\n\r\n  r = r*2.0-1.0;\r\n  g = g*2.0-1.0;\r\n  b = b*2.0-1.0;\r\n  a = a*2.0-1.0;\r\n\r\n  return vec4(r, g, b, a);\r\n}\r\n\r\nmat4 getSkinMatrix(float skeletalComponentSID) {\r\n\r\n#ifdef RN_BONE_DATA_TYPE_MAT4X4\r\n  mat4 skinMat = a_weight.x * get_boneMatrix(skeletalComponentSID, int(a_joint.x));\r\n  skinMat += a_weight.y * get_boneMatrix(skeletalComponentSID, int(a_joint.y));\r\n  skinMat += a_weight.z * get_boneMatrix(skeletalComponentSID, int(a_joint.z));\r\n  skinMat += a_weight.w * get_boneMatrix(skeletalComponentSID, int(a_joint.w));\r\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\r\n  highp vec2 criteria = vec2(4096.0, 4096.0);\r\n  highp mat4 skinMat = a_weight.x * createMatrixFromQuaternionTransformUniformScale(\r\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)),\r\n    get_boneTranslateScale(skeletalComponentSID, int(a_joint.x)));\r\n  skinMat += a_weight.y * createMatrixFromQuaternionTransformUniformScale(\r\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)),\r\n    get_boneTranslateScale(skeletalComponentSID, int(a_joint.y)));\r\n  skinMat += a_weight.z * createMatrixFromQuaternionTransformUniformScale(\r\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)),\r\n    get_boneTranslateScale(skeletalComponentSID, int(a_joint.z)));\r\n  skinMat += a_weight.w * createMatrixFromQuaternionTransformUniformScale(\r\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)),\r\n    get_boneTranslateScale(skeletalComponentSID, int(a_joint.w)));\r\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\r\n  highp vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\r\n  highp vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\r\n  highp vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\r\n  highp vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\r\n\r\n  highp vec2 criteria = vec2(4096.0, 4096.0);\r\n  highp vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\r\n  highp mat4 skinMat = a_weight.x * createMatrixFromQuaternionTransformUniformScale(\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x),\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo);\r\n  skinMat += a_weight.y * createMatrixFromQuaternionTransformUniformScale(\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x),\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo);\r\n  skinMat += a_weight.z * createMatrixFromQuaternionTransformUniformScale(\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x),\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo);\r\n  skinMat += a_weight.w * createMatrixFromQuaternionTransformUniformScale(\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x),\r\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo);\r\n#endif\r\n\r\n  return skinMat;\r\n}\r\n#endif\n\n\r\n#ifdef RN_IS_SKINNING\r\nbool skinning(\r\n  float skeletalComponentSID,\r\n  in mat3 inNormalMatrix,\r\n  out mat3 outNormalMatrix,\r\n  in vec3 inPosition_inLocal,\r\n  out vec4 outPosition_inWorld,\r\n  in vec3 inNormal_inLocal,\r\n  out vec3 outNormal_inWorld\r\n  )\r\n{\r\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\r\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\r\n  outNormalMatrix = toNormalMatrix(skinMat);\r\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\r\n\r\n  return true;\r\n}\r\n#endif\r\n\r\nbool processGeometryWithMorphingAndSkinning(\r\n  float skeletalComponentSID,\r\n  in mat4 worldMatrix,\r\n  in mat3 inNormalMatrix,\r\n  out mat3 outNormalMatrix,\r\n  in vec3 inPosition_inLocal,\r\n  out vec4 outPosition_inWorld,\r\n  in vec3 inNormal_inLocal,\r\n  out vec3 outNormal_inWorld\r\n) {\r\n  bool isSkinning = false;\r\n\r\n  vec3 position_inLocal;\r\n#ifdef RN_IS_MORPHING\r\n  if (u_morphTargetNumber == 0) {\r\n#endif\r\n    position_inLocal = inPosition_inLocal;\r\n#ifdef RN_IS_MORPHING\r\n  } else {\r\n    float vertexIdx = a_baryCentricCoord.w;\r\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\r\n  }\r\n#endif\r\n\r\n\r\n#ifdef RN_IS_SKINNING\r\n  if (skeletalComponentSID >= 0.0) {\r\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\r\n  } else {\r\n#endif\r\n    outNormalMatrix = inNormalMatrix;\r\n    outPosition_inWorld = worldMatrix * vec4(position_inLocal, 1.0);\r\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\r\n#ifdef RN_IS_SKINNING\r\n  }\r\n#endif\r\n\r\n  return isSkinning;\r\n}\r\n\n\nvoid main()\n{\n\n#ifdef RN_IS_FASTEST_MODE\r\n  float materialSID = u_currentComponentSIDs[0];\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = int(u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.LightComponentTID} */]);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.SkeletalComponentTID} */];\r\n  #endif\r\n\r\n#else\r\n\r\n  float materialSID = u_materialSID;\r\n\r\n  int lightNumber = 0;\r\n  #ifdef RN_IS_LIGHTING\r\n    lightNumber = get_lightNumber(0.0, 0);\r\n  #endif\r\n\r\n  float skeletalComponentSID = -1.0;\r\n  #ifdef RN_IS_SKINNING\r\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\r\n  #endif\r\n\r\n#endif\r\n\n\n  float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n  mat4 worldMatrix = get_worldMatrix(a_instanceID);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceID);\n\n  // Skeletal\n  processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n\n  v_color = a_color;\n  v_normal_inWorld = normalMatrix * a_normal;\n  v_texcoord_0 = a_texcoord_0;\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\r\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\r\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\r\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\r\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\r\nfloat maxPointSize = get_pointSize(materialSID, 0);\r\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\r\n\n\n}\n","shaderStage":"vertex"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/common/mainPrerequisites.glsl":
/*!*******************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/common/mainPrerequisites.glsl ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"#ifdef RN_IS_FASTEST_MODE\n  float materialSID = u_currentComponentSIDs[0];\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = int(u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.LightComponentTID} */]);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.SkeletalComponentTID} */];\n  #endif\n\n#else\n\n  float materialSID = u_materialSID;\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/common/prerequisites.glsl":
/*!***************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/common/prerequisites.glsl ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"uniform float u_materialSID; // skipProcess=true\nuniform sampler2D u_dataTexture; // skipProcess=true\n\n  /*\n  * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  * arg = vec2(1. / size.x, 1. / size.x / size.y);\n  */\n  // highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 arg)\n  // {\n  //   return ${this.glsl_texture}( tex, arg * (index + 0.5) );\n  // }\n\nhighp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 invSize){\n  highp float t = (index + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  return texture2D( tex, vec2(x, y) );\n}\n\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/Add.glsl":
/*!****************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/Add.glsl ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nvoid add(in float lfs, in float rhs, out float outValue) {\n  outValue = lfs + rhs;\n}\nvoid add(in int lfs, in int rhs, out int outValue) {\n  outValue = lfs + rhs;\n}\nvoid add(in vec2 lfs, in vec2 rhs, out vec2 outValue) {\n  outValue = lfs + rhs;\n}\nvoid add(in vec3 lfs, in vec3 rhs, out vec3 outValue) {\n  outValue = lfs + rhs;\n}\nvoid add(in vec4 lfs, in vec4 rhs, out vec4 outValue) {\n  outValue = lfs + rhs;\n}\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/AttributeNormal.vert":
/*!****************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/AttributeNormal.vert ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nin vec3 a_normal;\n\nvoid attributeNormal(out vec3 outValue) {\n  outValue = a_normal;\n}\n","shaderStage":"vertex"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/AttributePosition.vert":
/*!******************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/AttributePosition.vert ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nin vec4 a_position;\n\nvoid attributePosition(out vec4 outValue) {\n  outValue = a_position;\n}\n","shaderStage":"vertex"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/DotProduct.glsl":
/*!***********************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/DotProduct.glsl ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nvoid dotProduct(in vec2 lfs, in vec2 rhs, out float outValue) {\n  outValue = dot(lfs, rhs);\n}\nvoid dotProduct(in vec3 lfs, in vec3 rhs, out float outValue) {\n  outValue = dot(lfs, rhs);\n}\nvoid dotProduct(in vec4 lfs, in vec4 rhs, out float outValue) {\n  outValue = dot(lfs, rhs);\n}\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/Greater.glsl":
/*!********************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/Greater.glsl ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nvoid greater(in float lhs, in float rhs, out bool outValue) {\n  outValue = lhs > rhs;\n}\n\nvoid greater(in int lhs, in int rhs, out bool outValue) {\n  outValue = lhs > rhs;\n}\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/Multiply.glsl":
/*!*********************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/Multiply.glsl ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nvoid multiply(in float lfs, in float rhs, out float outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in int lfs, in int rhs, out int outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in mat2 lfs, in mat2 rhs, out mat2 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in mat3 lfs, in mat3 rhs, out mat3 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in mat4 lfs, in mat4 rhs, out mat4 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in mat3 lfs, in vec3 rhs, out vec3 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in mat4 lfs, in vec4 rhs, out vec4 outValue) {\n  outValue = lfs * rhs;\n}\n\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/NormalMatrix.vert":
/*!*************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/NormalMatrix.vert ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nvoid normalMatrix(out mat3 outValue) {\n  outValue = get_normalMatrix(a_instanceID);\n}\n","shaderStage":"vertex"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/Normalize.glsl":
/*!**********************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/Normalize.glsl ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nvoid normalize(in vec2 value, out vec2 outValue) {\n  outValue = normalize(value);\n}\n\nvoid normalize(in vec3 value, out vec3 outValue) {\n  outValue = normalize(value);\n}\n\nvoid normalize(in vec4 value, out vec4 outValue) {\n  outValue = normalize(value);\n}\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/ProjectionMatrix.vert":
/*!*****************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/ProjectionMatrix.vert ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nvoid projectionMatrix(out mat4 outValue) {\n  outValue = get_projectionMatrix(a_instanceID, 0);\n}\n","shaderStage":"vertex"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/ScalarToVector4.glsl":
/*!****************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/ScalarToVector4.glsl ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nvoid scalarToVector4(in float x, in float y, in float z, in float w, out vec4 outValue) {\n  outValue.x = x;\n  outValue.y = y;\n  outValue.z = z;\n  outValue.w = w;\n}\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/Vector3AndScalarToVector4.glsl":
/*!**************************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/Vector3AndScalarToVector4.glsl ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nvoid vector3AndScalarToVector4(in vec3 xyz, in float w, out vec4 outValue) {\n  outValue.x = xyz.x;\n  outValue.y = xyz.y;\n  outValue.z = xyz.z;\n  outValue.w = w;\n}\n","shaderStage":"fragment"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/ViewMatrix.vert":
/*!***********************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/ViewMatrix.vert ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nvoid viewMatrix(out mat4 outValue) {\n  outValue = get_viewMatrix(a_instanceID, 0);\n}\n","shaderStage":"vertex"});

/***/ }),

/***/ "./src/webgl/shaderity_shaders/nodes/WorldMatrix.vert":
/*!************************************************************!*\
  !*** ./src/webgl/shaderity_shaders/nodes/WorldMatrix.vert ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({"code":"\nvoid worldMatrix(out mat4 outValue) {\n  outValue = get_worldMatrix(a_instanceID);\n}\n","shaderStage":"vertex"});

/***/ }),

/***/ "./src/webgl/shaders/DepthEncodeShader.ts":
/*!************************************************!*\
  !*** ./src/webgl/shaders/DepthEncodeShader.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DepthEncodeShader; });
/* harmony import */ var _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../foundation/definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _GLSLShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");
/* harmony import */ var _foundation_definitions_ShaderNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../foundation/definitions/ShaderNode */ "./src/foundation/definitions/ShaderNode.ts");
/* harmony import */ var _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../foundation/definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../foundation/components/WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");





class DepthEncodeShader extends _GLSLShader__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super();
        this.attributeNames = [
            'a_instanceID',
            'a_position', 'a_normal',
            'a_joint', 'a_weight',
        ];
        this.attributeSemantics = [
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Instance,
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Position, _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Normal,
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Joints0, _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Weights0,
        ];
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new DepthEncodeShader();
        }
        return this.__instance;
    }
    getVertexShaderBody(args) {
        const _version = this.glsl_versionText;
        const _in = this.glsl_vertex_in;
        const _out = this.glsl_vertex_out;
        return `${_version}
${this.glslPrecision}

${(typeof args.definitions !== 'undefined') ? args.definitions : ''}

${_in} vec3 a_position;
${_in} vec3 a_normal;
${_in} float a_instanceID;
${_in} vec4 a_joint;
${_in} vec4 a_weight;

${_out} vec3 v_normal_inWorld;
${_out} vec4 v_position_inLocal;
${_out} vec4 v_position_inWorld;

${this.prerequisites}

${(typeof args.matricesGetters !== 'undefined') ? args.matricesGetters : ''}

${(typeof args.getters !== 'undefined') ? args.getters : ''}

${this.toNormalMatrix}

${this.getSkinMatrix}

${this.processGeometryWithSkinningOptionally}

  void main(){

    ${this.mainPrerequisites}
    float cameraSID = u_currentComponentSIDs[${_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_4__["WellKnownComponentTIDs"].CameraComponentTID}];
    mat4 worldMatrix = get_worldMatrix(a_instanceID);
    mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
    mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
    mat3 normalMatrix = get_normalMatrix(a_instanceID);

    // Skeletal
    processGeometryWithMorphingAndSkinning(
      skeletalComponentSID,
      worldMatrix,
      normalMatrix,
      normalMatrix,
      a_position,
      v_position_inWorld,
      a_normal,
      v_normal_inWorld
    );

    gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;

    v_position_inLocal = gl_Position;

    ${this.pointSprite}

  }
    `;
    }
    getPixelShaderBody(args) {
        const _version = this.glsl_versionText;
        const _in = this.glsl_fragment_in;
        const _def_rt0 = this.glsl_rt0;
        const _def_fragColor = this.glsl_fragColor;
        return `${_version}
${this.glslPrecision}

${(typeof args.definitions !== 'undefined') ? args.definitions : ''}

${this.prerequisites}

${_in} vec4 v_position_inLocal;
${_def_rt0}

${(typeof args.getters !== 'undefined') ? args.getters : ''}

vec4 encodeDepthToRGBA(float depth){
  float r = depth;
  float g = fract(r * 255.0);
  float b = fract(g * 255.0);
  float a = fract(b * 255.0);
  float coef = 1.0 / 255.0;
  r -= g * coef;
  g -= b * coef;
  b -= a * coef;
  return vec4(r, g, b, a);
}

void main (){
  ${this.mainPrerequisites}

  float zNear = get_zNearInner(materialSID, 0);
  float zFar = get_zFarInner(materialSID, 0);
  float normalizationCoefficient = 1.0 / (zFar - zNear);
  float linerDepth = normalizationCoefficient * length(v_position_inLocal);
  vec4 encodedLinearDepth = encodeDepthToRGBA(linerDepth);

  rt0 = encodedLinearDepth;

  ${_def_fragColor}
}
`;
    }
    get attributeCompositions() {
        return [
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Scalar,
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec3, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec3,
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec4, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec4,
        ];
    }
}
DepthEncodeShader.materialElement = _foundation_definitions_ShaderNode__WEBPACK_IMPORTED_MODULE_2__["ShaderNode"].ClassicShading;


/***/ }),

/***/ "./src/webgl/shaders/EnvConstantShader.ts":
/*!************************************************!*\
  !*** ./src/webgl/shaders/EnvConstantShader.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EnvConstantShader; });
/* harmony import */ var _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../foundation/definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _GLSLShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");
/* harmony import */ var _foundation_definitions_ShaderNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../foundation/definitions/ShaderNode */ "./src/foundation/definitions/ShaderNode.ts");
/* harmony import */ var _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../foundation/definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");




class EnvConstantShader extends _GLSLShader__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super();
        this.attributeNames = [
            'a_position', 'a_color', 'a_normal',
            'a_texcoord_0',
            'a_instanceID'
        ];
        this.attributeSemantics = [
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Position, _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Color0, _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Normal,
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Texcoord0,
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Instance
        ];
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new EnvConstantShader();
        }
        return this.__instance;
    }
    getVertexShaderBody(args) {
        const _version = this.glsl_versionText;
        const _in = this.glsl_vertex_in;
        const _out = this.glsl_vertex_out;
        return `${_version}
${this.glslPrecision}

${(typeof args.definitions !== 'undefined') ? args.definitions : ''}

${_in} float a_instanceID;
${_in} vec2 a_texcoord_0;
${_in} vec3 a_position;
${_in} vec3 a_color;
${_in} vec3 a_normal;

${_out} vec2 v_texcoord_0;
${_out} vec3 v_color;
${_out} vec3 v_normal_inWorld;
${_out} vec3 v_position_inWorld;

${this.prerequisites}

${(typeof args.getters !== 'undefined') ? args.getters : ''}

${(typeof args.matricesGetters !== 'undefined') ? args.matricesGetters : ''}

void main(){
  ${this.mainPrerequisites}

${this.simpleMVPPosition}

  mat3 normalMatrix = get_normalMatrix(a_instanceID);
  v_normal_inWorld = normalMatrix * a_normal;

  v_color = a_color;
  v_position_inWorld = (worldMatrix * vec4(a_position, 1.0)).xyz;
  v_texcoord_0 = a_texcoord_0;
}`;
    }
    getPixelShaderBody(args) {
        const _version = this.glsl_versionText;
        const _in = this.glsl_fragment_in;
        const _def_rt0 = this.glsl_rt0;
        const _def_fragColor = this.glsl_fragColor;
        const _texture = this.glsl_texture;
        const _textureCube = this.glsl_textureCube;
        return `${_version}
${this.glslPrecision}


${this.prerequisites}

${(typeof args.getters !== 'undefined') ? args.getters : ''}

vec3 linearToSrgb(vec3 linearColor) {
  return pow(linearColor, vec3(1.0/2.2));
}

vec3 srgbToLinear(vec3 srgbColor) {
  return pow(srgbColor, vec3(2.2));
}

${_in} vec2 v_texcoord_0;
${_in} vec3 v_color;
${_in} vec3 v_normal_inWorld;
${_in} vec3 v_position_inWorld;
${_def_rt0}
void main(){
  ${this.mainPrerequisites}

  // diffuseColor
  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);
  float alpha = 1.0;
  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);
  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {
    diffuseColor = v_color * diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (v_color == diffuseColor) {
    diffuseColor = diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (diffuseColorFactor.rgb == diffuseColor) {
    diffuseColor = v_color;
  } else {
    diffuseColor = vec3(1.0, 1.0, 1.0);
  }

  // diffuseColorTexture

  // adapt OpenGL (RenderMan) CubeMap convention
  float envRotation = get_envRotation(materialSID, 0);
  float rot = envRotation + 3.1415;
  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  vec3 envNormal = normalize(rotEnvMatrix * v_position_inWorld);
  envNormal.x *= -1.0;

  vec4 diffuseTexel = ${_textureCube}(u_colorEnvTexture, envNormal);
  vec3 textureColor;
  int EnvHdriFormat = get_EnvHdriFormat(materialSID, 0);
  if (EnvHdriFormat == 0) { // LDR_SRGB
    textureColor = srgbToLinear(diffuseTexel.rgb);
  } else if (EnvHdriFormat == 3) { // RGBE
    textureColor = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  } else {
    textureColor = diffuseTexel.rgb;
  }
  diffuseColor *= textureColor;

  rt0 = vec4(diffuseColor, alpha);

  ${_def_fragColor}
}`;
    }
    get attributeCompositions() {
        return [
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec3, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec3, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec3,
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Vec2,
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_3__["CompositionType"].Scalar
        ];
    }
}
EnvConstantShader.materialElement = _foundation_definitions_ShaderNode__WEBPACK_IMPORTED_MODULE_2__["ShaderNode"].ClassicShading;


/***/ }),

/***/ "./src/webgl/shaders/GLSLShader.ts":
/*!*****************************************!*\
  !*** ./src/webgl/shaders/GLSLShader.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLSLShader; });
/* harmony import */ var _foundation_definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../foundation/definitions/ProcessApproach */ "./src/foundation/definitions/ProcessApproach.ts");
/* harmony import */ var _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../foundation/definitions/ShaderSemantics */ "./src/foundation/definitions/ShaderSemantics.ts");
/* harmony import */ var _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../foundation/definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../WebGLResourceRepository */ "./src/webgl/WebGLResourceRepository.ts");
/* harmony import */ var _foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../foundation/components/WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");
/* harmony import */ var _foundation_system_SystemState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../foundation/system/SystemState */ "./src/foundation/system/SystemState.ts");






class GLSLShader {
    constructor() {
        this.__webglResourceRepository = _WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_3__["default"].getInstance();
    }
    get glsl_rt0() {
        const repo = this.__webglResourceRepository;
        if (repo.currentWebGLContextWrapper.isWebGL2) {
            return 'layout(location = 0) out vec4 rt0;\n';
        }
        else {
            return 'vec4 rt0;\n';
        }
    }
    get glsl_fragColor() {
        const repo = this.__webglResourceRepository;
        if (repo.currentWebGLContextWrapper != null && repo.currentWebGLContextWrapper.isWebGL2) {
            return '';
        }
        else {
            return 'gl_FragColor = rt0;\n';
        }
    }
    get glsl_vertex_in() {
        const repo = this.__webglResourceRepository;
        if (repo.currentWebGLContextWrapper.isWebGL2) {
            return 'in';
        }
        else {
            return 'attribute';
        }
    }
    get glsl_fragment_in() {
        const repo = this.__webglResourceRepository;
        if (repo.currentWebGLContextWrapper.isWebGL2) {
            return 'in';
        }
        else {
            return 'varying';
        }
    }
    get glsl_vertex_out() {
        const repo = this.__webglResourceRepository;
        if (repo.currentWebGLContextWrapper.isWebGL2) {
            return 'out';
        }
        else {
            return 'varying';
        }
    }
    get glsl_vertex_centroid_out() {
        const repo = this.__webglResourceRepository;
        if (repo.currentWebGLContextWrapper.isWebGL2) {
            return 'centroid out';
        }
        else {
            return 'varying';
        }
    }
    get glsl_texture() {
        const repo = this.__webglResourceRepository;
        if (repo.currentWebGLContextWrapper.isWebGL2) {
            return 'texture';
        }
        else {
            return 'texture2D';
        }
    }
    get glsl_textureCube() {
        const repo = this.__webglResourceRepository;
        if (repo.currentWebGLContextWrapper.isWebGL2) {
            return 'texture';
        }
        else {
            return 'textureCube';
        }
    }
    get glsl_textureProj() {
        const repo = this.__webglResourceRepository;
        if (repo.currentWebGLContextWrapper.isWebGL2) {
            return 'textureProj';
        }
        else {
            return 'texture2DProj';
        }
    }
    get glsl_versionText() {
        const repo = this.__webglResourceRepository;
        if (repo.currentWebGLContextWrapper != null && repo.currentWebGLContextWrapper.isWebGL2) {
            return '';
            // return '#version 300 es\n'
        }
        else {
            return '';
        }
    }
    get glslPrecision() {
        return `precision highp float;
precision highp int;
    `;
    }
    static get glslMainBegin() {
        return `
void main() {
`;
    }
    static get glslMainEnd() {
        return `
}
    `;
    }
    getGlslVertexShaderProperies(str = '') {
        return str;
    }
    get glsl1ShaderTextureLodExt() {
        const ext = _WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_3__["default"].getInstance().currentWebGLContextWrapper.webgl1ExtSTL;
        return (ext != null) ? '#extension GL_EXT_shader_texture_lod : require' : '';
    }
    get glsl1ShaderDerivativeExt() {
        const ext = _WebGLResourceRepository__WEBPACK_IMPORTED_MODULE_3__["default"].getInstance().currentWebGLContextWrapper.webgl1ExtDRV;
        return (ext != null) ? '#extension GL_OES_standard_derivatives : require' : '';
    }
    get toNormalMatrix() {
        return `
mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}`;
    }
    get getSkinMatrix() {
        return `
#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTransformUniformScale( highp vec4 quaternion, highp vec4 translationScale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translationScale.xyz;
  highp float scale = translationScale.w;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale, 0.0, 0.0, 0.0,
    0.0, scale, 0.0, 0.0,
    0.0, 0.0, scale, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_MAT4X4
  mat4 skinMat = a_weight.x * get_boneMatrix(skeletalComponentSID, int(a_joint.x));
  skinMat += a_weight.y * get_boneMatrix(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.z * get_boneMatrix(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.w * get_boneMatrix(skeletalComponentSID, int(a_joint.w));
#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  highp vec2 criteria = vec2(4096.0, 4096.0);
  highp mat4 skinMat = a_weight.x * createMatrixFromQuaternionTransformUniformScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)),
    get_boneTranslateScale(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * createMatrixFromQuaternionTransformUniformScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)),
    get_boneTranslateScale(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * createMatrixFromQuaternionTransformUniformScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)),
    get_boneTranslateScale(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * createMatrixFromQuaternionTransformUniformScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)),
    get_boneTranslateScale(skeletalComponentSID, int(a_joint.w)));
#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  highp vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  highp vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  highp vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  highp vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  highp vec2 criteria = vec2(4096.0, 4096.0);
  highp vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);
  highp mat4 skinMat = a_weight.x * createMatrixFromQuaternionTransformUniformScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x),
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo);
  skinMat += a_weight.y * createMatrixFromQuaternionTransformUniformScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x),
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo);
  skinMat += a_weight.z * createMatrixFromQuaternionTransformUniformScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x),
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo);
  skinMat += a_weight.w * createMatrixFromQuaternionTransformUniformScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x),
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo);
#endif

  return skinMat;
}

#endif
`;
    }
    get packing() {
        return `
const vec4 bitEnc = vec4(1.,255.,65025.,16581375.);
const vec4 bitDec = 1./bitEnc;

vec4 encodeFloatRGBA(float v) {
  float val = v;
  float r = mod(val, 255.0);
  val -= r;
  float g = mod(val, 65025.0);
  val -= g;
  float b = mod(val, 16581375.0);
  return vec4(r/255.0, g/65025.0, b/16581375.0, 1.0);
}`;
    }
    get processGeometryWithSkinningOptionally() {
        return `
#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif


#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrix * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}`;
    }
    get prerequisites() {
        return `uniform float u_materialSID;
uniform sampler2D u_dataTexture;

  /*
  * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  * arg = vec2(1. / size.x, 1. / size.x / size.y);
  */
  // highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 arg)
  // {
  //   return ${this.glsl_texture}( tex, arg * (index + 0.5) );
  // }

highp vec4 fetchElement(highp sampler2D tex, highp float index, highp vec2 invSize){
  highp float t = (index + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  return ${this.glsl_texture}( tex, vec2(x, y) );
}


float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

`;
    }
    get mainPrerequisites() {
        const processApproach = _foundation_system_SystemState__WEBPACK_IMPORTED_MODULE_5__["default"].currentProcessApproach;
        if (processApproach === _foundation_definitions_ProcessApproach__WEBPACK_IMPORTED_MODULE_0__["ProcessApproach"].FastestWebGL1) {
            return `
  float materialSID = u_currentComponentSIDs[0];

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = int(u_currentComponentSIDs[${_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_4__["WellKnownComponentTIDs"].LightComponentTID}]);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = u_currentComponentSIDs[${_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_4__["WellKnownComponentTIDs"].SkeletalComponentTID}];
  #endif
`;
        }
        else {
            return `
  float materialSID = u_materialSID;

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif
      `;
        }
    }
    get pointSprite() {
        return `  vec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);
  vec3 viewPosition = get_viewPosition(cameraSID, 0);
  float distanceFromCamera = length(position_inWorld.xyz - viewPosition);
  vec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);
  float distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));
  float maxPointSize = get_pointSize(materialSID, 0);
  gl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);`;
    }
    get pbrUniformDefinition() {
        let shaderText = '';
        shaderText += 'uniform vec2 uMetallicRoughnessFactors;\n';
        shaderText += 'uniform vec3 uBaseColorFactor;\n';
        shaderText += 'uniform vec2 uOcclusionFactors;';
        shaderText += 'uniform vec3 uEmissiveFactor;';
        shaderText += 'uniform sampler2D uMetallicRoughnessTexture;\n';
        const occlusionTexture = true; //material.getTextureFromPurpose(GLBoost.TEXTURE_PURPOSE_OCCLUSION);
        if (occlusionTexture) {
            shaderText += 'uniform sampler2D uOcclusionTexture;\n';
        }
        const emissiveTexture = true; //material.getTextureFromPurpose(GLBoost.TEXTURE_PURPOSE_EMISSIVE);
        if (emissiveTexture) {
            shaderText += 'uniform sampler2D uEmissiveTexture;\n';
        }
        const diffuseEnvCubeTexture = true; //material.getTextureFromPurpose(GLBoost.TEXTURE_PURPOSE_IBL_DIFFUSE_ENV_CUBE);
        if (diffuseEnvCubeTexture) {
            shaderText += 'uniform sampler2D u_brdfLutTexture;\n';
            shaderText += 'uniform samplerCube uDiffuseEnvTexture;\n';
            shaderText += 'uniform samplerCube uSpecularEnvTexture;\n';
            shaderText += 'uniform vec4 uIBLParameters;\n'; // Ka * amount of ambient lights
        }
        shaderText += 'uniform vec4 ambient;\n'; // Ka * amount of ambient lights
        return shaderText;
    }
    get mipmapLevel() {
        return `
    // https://stackoverflow.com/questions/24388346/how-to-access-automatic-mipmap-level-in-glsl-fragment-shader-texture
    float mipmapLevel(vec3 uv_as_texel)
    {
      vec3  dx_vtc        = dFdx(uv_as_texel);
      vec3  dy_vtc        = dFdy(uv_as_texel);
      float delta_max_sqr = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));
      float mml = 0.5 * log2(delta_max_sqr);
      return max( 0.0, mml );
    }`;
    }
    get pbrMethodDefinition() {
        return `
    const float M_PI = 3.141592653589793;
    const float c_MinRoughness = 0.04;

    float angular_n_h(float NH) {
      return acos(NH);
    }

    float sqr(float x) {
      return x*x;
    }

    float d_phong(float NH, float c1) {
      return pow(
        cos(acos(NH))
        , c1
      );
    }

    // this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
    vec3 envBRDFApprox( vec3 F0, float Roughness, float NoV ) {
      const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );
      const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );
      vec4 r = Roughness * c0 + c1;
      float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
      vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;

      return F0 * AB.x + AB.y;
    }

    // GGX NDF
    float d_ggx(float NH, float alphaRoughness) {
      float roughnessSqr = alphaRoughness * alphaRoughness;
      float f = (roughnessSqr - 1.0) * NH * NH + 1.0;
      return roughnessSqr / (M_PI * f * f);
    }

    float d_torrance_reiz(float NH, float c3) {
      float CosSquared = NH*NH;
      float TanSquared = (1.0 - CosSquared)/CosSquared;
      //return (1.0/M_PI) * sqr(c3/(CosSquared * (c3*c3 + TanSquared)));  // gamma = 2, aka GGX
      return (1.0/sqrt(M_PI)) * (sqr(c3)/(CosSquared * (c3*c3 + TanSquared))); // gamma = 1, D_Berry
    }

    float d_beckmann(float NH, float m) {
      float co = 1.0 / (4.0 * m * m * NH * NH * NH * NH);
      float expx = exp((NH * NH - 1.0) / (m * m * NH * NH));
      return co * expx;
    }

    // the same as glTF WebGL sample
    // https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders/pbr-frag.glsl#L188
    // That is, Unreal Engine based approach, but modified to use alphaRoughness (squared artist's roughness parameter),
    // and based on 'Separable Masking and Shadowing' approximation (propesed by Christophe Schlick)
    // https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf
    float g_shielding(float NL, float NV, float alphaRoughness) {
      float r = alphaRoughness;

      // Local Shadowing using "Schlick-Smith" Masking Function
      float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));

      // Local Masking using "Schlick-Smith" Masking Function
      float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));

      return localShadowing * localMasking;
    }

    // The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
    // The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
    float v_SmithGGXCorrelated(float NL, float NV, float alphaRoughness) {
      float a2 = alphaRoughness * alphaRoughness;
      float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
      float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
      return 0.5 / (GGXV + GGXL);
    }

    float v_SmithGGXCorrelatedFast(float NL, float NV, float alphaRoughness) {
      float a = alphaRoughness;
      float GGXV = NL * (NV * (1.0 - a) + a);
      float GGXL = NV * (NL * (1.0 - a) + a);
      return 0.5 / (GGXV + GGXL);
    }

    // The Schlick Approximation to Fresnel
    vec3 fresnel(vec3 f0, float VH) {
      return vec3(f0) + (vec3(1.0) - f0) * pow(1.0 - VH, 5.0);
    }

    vec3 cook_torrance_specular_brdf(float NH, float NL, float NV, vec3 F, float alphaRoughness) {
      float D = d_ggx(NH, alphaRoughness);
      float V = v_SmithGGXCorrelated(NL, NV, alphaRoughness);
      return vec3(D)*vec3(V)*F;
//      float G = g_shielding(NL, NV, alphaRoughness);
//      return vec3(D)*vec3(G)*F/vec3(4.0*NL*NV);

    }

    vec3 diffuse_brdf(vec3 albedo)
    {
      return albedo / M_PI;
    }

    vec3 srgbToLinear(vec3 srgbColor) {
      return pow(srgbColor, vec3(2.2));
    }

    float srgbToLinear(float value) {
      return pow(value, 2.2);
    }

    vec3 linearToSrgb(vec3 linearColor) {
      return pow(linearColor, vec3(1.0/2.2));
    }

    float linearToSrgb(float value) {
      return pow(value, 1.0/2.2);
    }

    vec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)
    {
      return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
    }

    vec3 normalBlendingUDN(sampler2D baseMap, sampler2D detailMap, vec2 baseUv, vec2 detailUv) {
      vec3 t = ${this.glsl_texture}(baseMap,   baseUv).xyz * 2.0 - 1.0;
      vec3 u = ${this.glsl_texture}(detailMap, detailUv).xyz * 2.0 - 1.0;
      vec3 r = normalize(vec3(t.xy + u.xy, t.z));
      return r;
    }

    vec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {
      mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);
      mat3 rotationMat = mat3(
          cos(rotation), -sin(rotation), 0,
          sin(rotation),  cos(rotation), 0,
                      0,             0, 1
      );
      mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);

      mat3 matrix = translationMat * rotationMat * scaleMat;
      vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;

      return uvTransformed;
    }

    `;
    }
    get simpleMVPPosition() {
        return `
  float cameraSID = u_currentComponentSIDs[${_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_4__["WellKnownComponentTIDs"].CameraComponentTID}];
  mat4 worldMatrix = get_worldMatrix(a_instanceID);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
  gl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4(a_position, 1.0);
    `;
    }
    static getStringFromShaderAnyDataType(data) {
        if (data instanceof _foundation_definitions_ShaderSemantics__WEBPACK_IMPORTED_MODULE_1__["ShaderSemanticsClass"]) {
            return 'u_' + data.str;
        }
        else if (data instanceof _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_2__["VertexAttributeClass"]) {
            return data.shaderStr;
        }
        else {
            return data;
        }
    }
}


/***/ }),

/***/ "./src/webgl/shaders/MToonShader.ts":
/*!******************************************!*\
  !*** ./src/webgl/shaders/MToonShader.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MToonShader; });
/* harmony import */ var _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../foundation/definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _GLSLShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");
/* harmony import */ var _foundation_core_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../foundation/core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _foundation_definitions_ShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../foundation/definitions/ShaderNode */ "./src/foundation/definitions/ShaderNode.ts");
/* harmony import */ var _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../foundation/definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../foundation/components/WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");






class MToonShader extends _GLSLShader__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super();
        this.attributeNames = [
            'a_instanceID',
            'a_texcoord_0',
            'a_position', 'a_normal', 'a_tangent',
            'a_baryCentricCoord', 'a_joint', 'a_weight',
        ];
        this.attributeSemantics = [
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Instance,
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Texcoord0,
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Position, _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Normal, _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Tangent,
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].BaryCentricCoord, _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Joints0, _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Weights0,
        ];
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new MToonShader();
        }
        return this.__instance;
    }
    getVertexShaderBody(args) {
        const _version = this.glsl_versionText;
        const _texture = this.glsl_texture;
        const _in = this.glsl_vertex_in;
        const _out = this.glsl_vertex_out;
        return `${_version}
${this.glslPrecision}

// This shader is based on https://github.com/Santarh/MToon

${(typeof args.definitions !== 'undefined') ? args.definitions : ''}

${_in} float a_instanceID;
${_in} vec2 a_texcoord_0;
${_in} vec3 a_position;
${_in} vec3 a_normal;
${_in} vec3 a_tangent;
${_in} vec4 a_baryCentricCoord;
${_in} vec4 a_joint;
${_in} vec4 a_weight;

${_out} vec2 v_texcoord_0;
${_out} vec3 v_baryCentricCoord;
${_out} vec3 v_binormal_inWorld; // bitangent_inWorld
${_out} vec3 v_normal_inView;
${_out} vec3 v_normal_inWorld;
${_out} vec3 v_tangent_inWorld;
${_out} vec4 v_position_inWorld;

${this.prerequisites}

${(typeof args.getters !== 'undefined') ? args.getters : ''}

${(typeof args.matricesGetters !== 'undefined') ? args.matricesGetters : ''}

${this.toNormalMatrix}

${this.getSkinMatrix}

${this.processGeometryWithSkinningOptionally}

void main(){
  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_NONE
      return;
    #endif
  #endif
  ${this.mainPrerequisites}

  mat4 worldMatrix = get_worldMatrix(a_instanceID);
  mat3 normalMatrix = get_normalMatrix(a_instanceID);
  bool isSkinning = false;
  isSkinning = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  float cameraSID = u_currentComponentSIDs[${_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_5__["WellKnownComponentTIDs"].CameraComponentTID}];
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);

  v_normal_inView = vec3(viewMatrix * vec4(v_normal_inWorld, 0.0));

  #ifndef RN_MTOON_IS_OUTLINE //ndef
    gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;
  #else
    #if defined(RN_MTOON_HAS_OUTLINE_WIDTH_TEXTURE)
      float outlineTex = ${_texture}(u_outlineWidthTexture, a_texcoord_0).r;
    #else
      float outlineTex = 1.0;
    #endif

    #if defined(RN_MTOON_OUTLINE_WIDTH_WORLD)
      float outlineWidth = get_outlineWidth(materialSID, 0);
      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * a_normal;
      vec4 worldOutlineOffset = worldMatrix * vec4(outlineOffset, 0.0);
      gl_Position = projectionMatrix * viewMatrix * (v_position_inWorld + worldOutlineOffset);

    #elif defined(RN_MTOON_OUTLINE_WIDTH_SCREEN)
      vec4 vertex = projectionMatrix * viewMatrix * v_position_inWorld;

      vec3 clipNormal = (projectionMatrix * vec4(v_normal_inView, 1.0)).xyz;
      vec2 projectedNormal = normalize(clipNormal.xy);
      float outlineScaledMaxDistance = get_outlineScaledMaxDistance(materialSID, 0);
      projectedNormal *= min(vertex.w, outlineScaledMaxDistance);
      float aspect = abs(get_aspect(0.0, 0)); //solo datum
      projectedNormal.x *= aspect;

      float outlineWidth = get_outlineWidth(materialSID, 0);
      vertex.xy += 0.01 * outlineWidth * outlineTex * projectedNormal * clamp(1.0 - abs(v_normal_inView.z), 0.0, 1.0); // ignore offset when normal toward camera

      gl_Position = vertex;
    #else
      gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;
    #endif
  #endif

  if (abs(length(a_normal)) > 0.01) {
    // if normal exist
    vec3 tangent_inWorld;
    if (!isSkinning) {
      tangent_inWorld = normalMatrix * a_tangent;
      v_position_inWorld = worldMatrix * vec4(a_position, 1.0);
    }

    v_binormal_inWorld = cross(v_normal_inWorld, tangent_inWorld);
    v_tangent_inWorld = cross(v_binormal_inWorld, v_normal_inWorld);
  }

  v_texcoord_0 = a_texcoord_0;

  v_baryCentricCoord = a_baryCentricCoord.xyz;
}`;
    }
    getFragmentShader(args) {
        const _version = this.glsl_versionText;
        const _in = this.glsl_fragment_in;
        const _def_rt0 = this.glsl_rt0;
        const _def_fragColor = this.glsl_fragColor;
        const _texture = this.glsl_texture;
        const _textureCube = this.glsl_textureCube;
        let accessSpecularIBLTexture;
        const repo = this.__webglResourceRepository;
        if (repo.currentWebGLContextWrapper.webgl1ExtSTL) {
            accessSpecularIBLTexture = `vec4 specularTexel = ${_textureCube}LodEXT(u_specularEnvTexture, vec3(-reflection.x, reflection.y, reflection.z), lod);`;
        }
        else {
            accessSpecularIBLTexture = `vec4 specularTexel = ${_textureCube}(u_specularEnvTexture, vec3(-reflection.x, reflection.y, reflection.z));`;
        }
        return `${_version}
${this.glsl1ShaderTextureLodExt}
${this.glsl1ShaderDerivativeExt}
${this.glslPrecision}


${(typeof args.definitions !== 'undefined') ? args.definitions : ''}

${this.prerequisites}

const float EPS_COL = 0.00001;

${_in} vec2 v_texcoord_0;
${_in} vec3 v_baryCentricCoord;
${_in} vec3 v_binormal_inWorld; // bitangent_inWorld
${_in} vec3 v_normal_inView;
${_in} vec3 v_normal_inWorld;
${_in} vec3 v_tangent_inWorld;
${_in} vec4 v_position_inWorld;
${_def_rt0}

${(typeof args.getters !== 'undefined') ? args.getters : ''}

float edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {
  vec3 d = fwidth(bary3);
  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;
  vec3 a3 = smoothstep(vec3(0.0), d, x);
  float factor = min(min(a3.x, a3.y), a3.z);

  return clamp((1.0 - factor), 0.0, 1.0);
}

vec3 srgbToLinear(vec3 srgbColor) {
  return pow(srgbColor, vec3(2.2));
}

void main (){
  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_NONE
      discard;
    #endif
  #endif
  ${this.mainPrerequisites}


  // TODO
  // uv transform

  // TODO
  // uv animation

  // main color
  vec4 litTextureColor = ${_texture}(u_litColorTexture, v_texcoord_0);
  vec4 litColorFactor = get_litColor(materialSID, 0);

  // alpha
  float alpha = 1.0;

  #ifdef RN_ALPHATEST_ON
    alpha = litTextureColor.a * litColorFactor.a;
    float cutoff = get_cutoff(materialSID, 0);
    if(alpha < cutoff) discard;
  #elif defined(RN_ALPHABLEND_ON)
    alpha = litTextureColor.a * litColorFactor.a;
  #endif

  if (alpha < 0.01) {
    discard;
  }else{
    rt0.w = alpha;
  }


  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_COLOR_FIXED
      vec3 outlineColor = get_outlineColor(materialSID, 0);
      rt0.xyz = outlineColor;

      rt0.xyz = srgbToLinear(rt0.xyz);
      ${_def_fragColor}
      return;
    #endif
  #endif


  // Normal
  vec3 normal_inWorld = normalize(v_normal_inWorld);

  #ifdef RN_MTOON_HAS_BUMPMAP
    if (abs(length(v_tangent_inWorld)) > 0.01) {
      vec3 tangent_inWorld = normalize(v_tangent_inWorld);
      vec3 binormal_inWorld = normalize(v_binormal_inWorld);

      mat3 tbnMat_tangent_to_world = mat3(
        tangent_inWorld.x, tangent_inWorld.y, tangent_inWorld.z,
        binormal_inWorld.x, binormal_inWorld.y, binormal_inWorld.z,
        normal_inWorld.x, normal_inWorld.y, normal_inWorld.z
      );

      vec3 normal = ${_texture}(u_normalTexture, v_texcoord_0).xyz * 2.0 - 1.0;
      float normalScale = get_normalScale(materialSID, 0);
      normal.xy *= normalScale;
      normal_inWorld = normalize(tbnMat_tangent_to_world * normal);
    }
  #endif

  #ifdef RN_MTOON_IS_OUTLINE
    normal_inWorld *= -1.0;
  #endif


  // Lighting, Direct Light

  float shadowAttenuation = 1.0;
  // TODO: shadowmap computation

  float receiveShadowRate = get_receiveShadowRate(materialSID, 0);
  float lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, receiveShadowRate * ${_texture}(u_receiveShadowTexture, v_texcoord_0).r);

  float shadingGradeRate = get_shadingGradeRate(materialSID, 0);
  float shadingGrade = 1.0 - shadingGradeRate * (1.0 - ${_texture}(u_shadingGradeTexture, v_texcoord_0).r);
  float lightColorAttenuation = get_lightColorAttenuation(materialSID, 0);

  vec3 shadeColorFactor = get_shadeColor(materialSID, 0);
  vec3 shadeColor = shadeColorFactor * ${_texture}(u_shadeColorTexture, v_texcoord_0).xyz;
  shadeColor.xyz = srgbToLinear(shadeColor.xyz);

  vec3 litColor = litColorFactor.xyz * litTextureColor.xyz;
  litColor.xyz = srgbToLinear(litColor.xyz);


  float shadeShift = get_shadeShift(materialSID, 0);
  float shadeToony = get_shadeToony(materialSID, 0);

  vec3 lightings[${_foundation_core_Config__WEBPACK_IMPORTED_MODULE_2__["default"].maxLightNumberInShader}];
  #ifdef RN_MTOON_DEBUG_LITSHADERATE
    float lightIntensities[${_foundation_core_Config__WEBPACK_IMPORTED_MODULE_2__["default"].maxLightNumberInShader}];
  #endif
  for (int i = 0; i < ${_foundation_core_Config__WEBPACK_IMPORTED_MODULE_2__["default"].maxLightNumberInShader}; i++) {
    if (i >= lightNumber) {
      break;
    }

    // Rn_Light
    vec4 gotLightDirection = get_lightDirection(0.0, i);
    vec4 gotLightIntensity = get_lightIntensity(0.0, i); //light color
    vec4 gotLightPosition = get_lightPosition(0.0, i);
    vec3 lightDirection = gotLightDirection.xyz;
    vec3 lightColor = gotLightIntensity.xyz;
    vec3 lightPosition = gotLightPosition.xyz;
    float lightType = gotLightPosition.w;
    float spotCosCutoff = gotLightDirection.w;
    float spotExponent = gotLightIntensity.w;

    float distanceAttenuation = 1.0;
    if (lightType > 0.75) { // is point light or spotlight
      lightDirection = normalize(lightPosition.xyz - v_position_inWorld.xyz);

      float distance = dot(lightPosition - v_position_inWorld.xyz, lightPosition - v_position_inWorld.xyz);
      distanceAttenuation = 1.0 / pow(distance, 2.0);
    }

    float spotEffect = 1.0;
    if (lightType > 1.75) { // is spotlight
      spotEffect *= dot(gotLightDirection.xyz, lightDirection);
      if (spotEffect > spotCosCutoff) {
        spotEffect *= pow(clamp(spotEffect, 0.0, 1.0), spotExponent);
      } else {
        spotEffect = 0.0;
      }
    }

    // lightAttenuation *= distanceAttenuation * spotEffect;
    float dotNL = dot(lightDirection, normal_inWorld);
    float lightIntensity = dotNL * 0.5 + 0.5; // from [-1, +1] to [0, 1]
    lightIntensity = lightIntensity * lightAttenuation; // TODO: receive shadow
    lightIntensity = lightIntensity * shadingGrade; // darker
    lightIntensity = lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]

    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]
    float maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);
    float minIntensityThreshold = shadeShift;
    lightIntensity = clamp((lightIntensity - minIntensityThreshold) / max(EPS_COL, (maxIntensityThreshold - minIntensityThreshold)), 0.0, 1.0);
    #ifdef RN_MTOON_DEBUG_LITSHADERATE
      lightIntensities[i] = lightIntensity;
    #endif

    // Albedo color
    vec3 col = mix(shadeColor, litColor, lightIntensity);

    // Direct Light
    vec3 lighting = lightColor;
    lighting = mix(lighting, vec3(max(EPS_COL, max(lighting.x, max(lighting.y, lighting.z)))), lightColorAttenuation); // color atten


    if(i > 0){
      lighting *= 0.5; // darken if additional light.
      lighting *= min(0.0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert
      // lighting *= shadowAttenuation; // darken if receiving shadow
      #ifdef RN_ALPHABLEND_ON
        lighting *= step(0.0, dotNL); // darken if transparent. Because Unity's transparent material can't receive shadowAttenuation.
      #endif
    }

    col *= lighting;
    lightings[i] = lighting;

    rt0.xyz += col;

    lightAttenuation = 1.0;
  }


  // Indirect Light
  vec3 indirectLighting = get_ambientColor(materialSID, 0);
  indirectLighting = srgbToLinear(indirectLighting);
  indirectLighting = mix(indirectLighting, vec3(max(EPS_COL, max(indirectLighting.x, max(indirectLighting.y, indirectLighting.z)))), lightColorAttenuation); // color atten
  // TODO: use ShadeIrad in www.ppsloan.org/publications/StupidSH36.pdf

  rt0.xyz += indirectLighting * litColor;
  rt0.xyz = min(rt0.xyz, litColor); // comment out if you want to PBR absolutely.


  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_COLOR_MIXED
      vec3 outlineColor = get_outlineColor(materialSID, 0);
      outlineColor = srgbToLinear(outlineColor);
      float outlineLightingMix = get_outlineLightingMix(materialSID, 0);
      rt0.xyz = outlineColor * mix(vec3(1.0), rt0.xyz, outlineLightingMix);
    #endif
  #else
    float cameraSID = u_currentComponentSIDs[${_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_5__["WellKnownComponentTIDs"].CameraComponentTID}];
    vec3 viewPosition = get_viewPosition(cameraSID, 0);
    vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);

    float rimFresnelPower = get_rimFresnelPower(materialSID, 0);
    float rimLift = get_rimLift(materialSID, 0);
    vec3 rimColorFactor = get_rimColor(materialSID, 0);
    vec3 rimTextureColor = ${_texture}(u_rimTexture, v_texcoord_0).xyz;
    vec3 rimColor = srgbToLinear(rimColorFactor * rimTextureColor);
    vec3 rim = pow(clamp(1.0 - dot(normal_inWorld, viewDirection) + rimLift, 0.0, 1.0), rimFresnelPower) * rimColor;

    float staticRimLighting = 1.0;
    float rimLightingMix = get_rimLightingMix(materialSID, 0);
    for (int i = 0; i < ${_foundation_core_Config__WEBPACK_IMPORTED_MODULE_2__["default"].maxLightNumberInShader}; i++) {
      if (i >= lightNumber) break;

      if(i > 0) staticRimLighting = 0.0;

      vec3 rimLighting = mix(vec3(staticRimLighting), lightings[i], vec3(rimLightingMix));
      rt0.xyz += rim * rimLighting;
    }

    // additive matcap
    vec3 cameraUp = get_cameraUp(0.0, 0); //solo datum
    vec3 worldViewUp = normalize(cameraUp - viewDirection * dot(viewDirection, cameraUp));
    vec3 worldViewRight = normalize(cross(viewDirection, worldViewUp));
    vec2 matcapUv = vec2(dot(worldViewRight, normal_inWorld), dot(worldViewUp, normal_inWorld)) * 0.5 + 0.5;
    vec3 matCapColor = srgbToLinear(${_texture}(u_matCapTexture, matcapUv).xyz);
    rt0.xyz += matCapColor;


    // Emission
    vec3 emissionColor = get_emissionColor(materialSID, 0);
    vec3 emission = srgbToLinear(${_texture}(u_emissionTexture, v_texcoord_0).xyz) * emissionColor;
    rt0.xyz += emission;
  #endif


  // debug
  #ifdef RN_MTOON_DEBUG_NORMAL
    rt0 = vec4(normal_inWorld * 0.5 + 0.5, alpha);

    rt0.xyz = srgbToLinear(rt0.xyz);
    ${_def_fragColor}
    return;
  #elif defined(RN_MTOON_DEBUG_LITSHADERATE)
    rt0 = vec4(0.0);
    for (int i = 0; i < ${_foundation_core_Config__WEBPACK_IMPORTED_MODULE_2__["default"].maxLightNumberInShader}; i++) {
      if (i >= lightNumber) break;
      rt0 += vec4(lightIntensities[i] * lightings[i], alpha);
    }

    rt0.xyz = srgbToLinear(rt0.xyz);
    ${_def_fragColor}
    return;
  #endif


  // Wireframe
  float threshold = 0.001;
  vec3 wireframe = get_wireframe(materialSID, 0);
  float wireframeWidthInner = wireframe.z;
  float wireframeWidthRelativeScale = 1.0;
  if (wireframe.x > 0.5 && wireframe.y < 0.5) {
    rt0.a = 0.0;
  }
  vec4 wireframeResult = rt0;
  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);
  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);
  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);
  // if r0.a is 0.0, it is wireframe not on shaded
  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);
  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));

  if (wireframe.x > 0.5) {
    rt0 = wireframeResult;
    if (wireframe.y < 0.5 && rt0.a == 0.0) {
      discard;
    }
  }

  ${_def_fragColor}
}
`;
    }
    get pixelShaderDefinitions() {
        return '';
    }
    getPixelShaderBody(args) {
        return this.getFragmentShader(args);
    }
    get attributeCompositions() {
        return [
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Scalar,
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec2,
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec3, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec3, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec3, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec3,
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec4, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec4, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec4,
        ];
    }
}
MToonShader.materialElement = _foundation_definitions_ShaderNode__WEBPACK_IMPORTED_MODULE_3__["ShaderNode"].PBRShading;


/***/ }),

/***/ "./src/webgl/shaders/ShadowMapDecodeClassicShader.ts":
/*!***********************************************************!*\
  !*** ./src/webgl/shaders/ShadowMapDecodeClassicShader.ts ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShadowMapDecodeClassicShader; });
/* harmony import */ var _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../foundation/definitions/VertexAttribute */ "./src/foundation/definitions/VertexAttribute.ts");
/* harmony import */ var _GLSLShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");
/* harmony import */ var _foundation_core_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../foundation/core/Config */ "./src/foundation/core/Config.ts");
/* harmony import */ var _foundation_definitions_ShaderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../foundation/definitions/ShaderNode */ "./src/foundation/definitions/ShaderNode.ts");
/* harmony import */ var _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../foundation/definitions/CompositionType */ "./src/foundation/definitions/CompositionType.ts");
/* harmony import */ var _foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../foundation/components/WellKnownComponentTIDs */ "./src/foundation/components/WellKnownComponentTIDs.ts");






class ShadowMapDecodeClassicShader extends _GLSLShader__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super();
        this.attributeNames = [
            'a_instanceID',
            'a_texcoord_0', 'a_texcoord_1',
            'a_position', 'a_color', 'a_normal',
            'a_joint', 'a_weight',
        ];
        this.attributeSemantics = [
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Instance,
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Texcoord0, _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Texcoord1,
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Position, _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Color0, _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Normal,
            _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Joints0, _foundation_definitions_VertexAttribute__WEBPACK_IMPORTED_MODULE_0__["VertexAttribute"].Weights0,
        ];
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new ShadowMapDecodeClassicShader();
        }
        return this.__instance;
    }
    getVertexShaderBody(args) {
        const _version = this.glsl_versionText;
        const _in = this.glsl_vertex_in;
        const _out = this.glsl_vertex_out;
        return `${_version}
${this.glslPrecision}

${(typeof args.definitions !== 'undefined') ? args.definitions : ''}

${_in} vec3 a_position;
${_in} vec3 a_color;
${_in} vec3 a_normal;
${_in} float a_instanceID;
${_in} vec2 a_texcoord_0;
${_in} vec2 a_texcoord_1;
${_in} vec4 a_joint;
${_in} vec4 a_weight;
${_out} vec3 v_color;
${_out} vec3 v_normal_inWorld;
${_out} vec4 v_position_inWorld;
${_out} vec2 v_texcoord_0;
${_out} vec4 v_texcoord_1;
${_out} vec4 v_projPosition_from_light;

${this.prerequisites}

${(typeof args.matricesGetters !== 'undefined') ? args.matricesGetters : ''}

${(typeof args.getters !== 'undefined') ? args.getters : ''}

${this.toNormalMatrix}

${this.getSkinMatrix}

${this.processGeometryWithSkinningOptionally}

void main(){

  ${this.mainPrerequisites}
  float cameraSID = u_currentComponentSIDs[${_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_5__["WellKnownComponentTIDs"].CameraComponentTID}];
  mat4 worldMatrix = get_worldMatrix(a_instanceID);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
  mat3 normalMatrix = get_normalMatrix(a_instanceID);

  // Skeletal
  processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;

  ${this.pointSprite}

  // Shadow mapping
  mat4 lightViewProjectionMatrix = get_lightViewProjectionMatrix(materialSID, 0);
  v_projPosition_from_light = lightViewProjectionMatrix * v_position_inWorld;

  // Following tMatrix is based on https://wgld.org/d/webgl/w051.html
  mat4 tMatrix = mat4(
    0.5, 0.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.5, 0.5, 0.0, 1.0
  );
  v_texcoord_1 = tMatrix * v_projPosition_from_light;

  v_color = a_color;
  v_normal_inWorld = normalMatrix * a_normal;
  v_texcoord_0 = a_texcoord_0;

}
`;
    }
    getFragmentShader(args) {
        const _version = this.glsl_versionText;
        const _in = this.glsl_fragment_in;
        const _def_rt0 = this.glsl_rt0;
        const _def_fragColor = this.glsl_fragColor;
        const _texture = this.glsl_texture;
        const _textureProj = this.glsl_textureProj;
        return `${_version}
${this.glslPrecision}

${(typeof args.definitions !== 'undefined') ? args.definitions : ''}

${this.prerequisites}

${_in} vec3 v_color;
${_in} vec3 v_normal_inWorld;
${_in} vec4 v_position_inWorld;
${_in} vec2 v_texcoord_0;
${_in} vec4 v_texcoord_1;
${_in} vec4 v_projPosition_from_light;
${_def_rt0}

${(typeof args.getters !== 'undefined') ? args.getters : ''}

float decodeRGBAToDepth(vec4 RGBA){
  const float rMask = 1.0;
  const float gMask = 1.0 / 255.0;
  const float bMask = 1.0 / (255.0 * 255.0);
  const float aMask = 1.0 / (255.0 * 255.0 * 255.0);
  float depth = dot(RGBA, vec4(rMask, gMask, bMask, aMask));
  return depth;
}

void main (){
  ${this.mainPrerequisites}

  // Normal
  vec3 normal_inWorld = normalize(v_normal_inWorld);

  // diffuseColor
  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);
  float alpha = 1.0;

  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);
  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {
    diffuseColor = v_color * diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (v_color == diffuseColor) {
    diffuseColor = diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (diffuseColorFactor.rgb == diffuseColor) {
    diffuseColor = v_color;
  } else {
    diffuseColor = vec3(1.0, 1.0, 1.0);
  }

  // diffuseColorTexture
  vec4 textureColor = ${_texture}(u_diffuseColorTexture, v_texcoord_0);
  if (textureColor.r > 0.05) {
    diffuseColor *= textureColor.rgb;
    alpha *= textureColor.a;
  }

  // shadow mapping
  if(v_projPosition_from_light.w > 0.0){
    float zNear = get_zNearInner(materialSID, 0);
    float zFar = get_zFarInner(materialSID, 0);
    float normalizationCoefficient = 1.0 / (zFar - zNear);

    vec2 shadowMapUV = v_texcoord_1.xy / v_texcoord_1.w;

    #ifdef RN_IS_DEBUGGING
      bool inShadowMap = (shadowMapUV.x >= 0.0 && shadowMapUV.x <= 1.0) && (shadowMapUV.y >= 0.0 && shadowMapUV.y <= 1.0);
      if(inShadowMap == false){
        rt0 = get_debugColorFactor(materialSID, 0);
        ${_def_fragColor}
        return;
      }
    #endif

    float measureDepth = normalizationCoefficient * length(v_projPosition_from_light);
    float textureDepth = decodeRGBAToDepth(${_texture}(u_depthTexture, shadowMapUV));
    float allowableDepthError = get_allowableDepthError(materialSID, 0);

    if(measureDepth > textureDepth + allowableDepthError){
      // case of shadow
      vec4 shadowColorCoefficient = get_shadowColorCoefficient(materialSID, 0);
      diffuseColor *= shadowColorCoefficient.rgb;
      alpha *= shadowColorCoefficient.a;
    }
  }

  // Lighting
  vec3 shadingColor = vec3(0.0, 0.0, 0.0);
  int shadingModel = get_shadingModel(materialSID, 0);
  if (shadingModel > 0) {

    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    int lightNumber = get_lightNumber(materialSID, 0);
    for (int i = 0; i < ${_foundation_core_Config__WEBPACK_IMPORTED_MODULE_2__["default"].maxLightNumberInShader}; i++) {
      if (i >= lightNumber) {
        break;
      }

      vec4 gotLightDirection = get_lightDirection(0.0, i);
      vec4 gotLightIntensity = get_lightIntensity(0.0, i);
      vec4 gotLightPosition = get_lightPosition(0.0, i);

      vec3 lightDirection = gotLightDirection.xyz;
      vec3 lightIntensity = gotLightIntensity.xyz;
      vec3 lightPosition = gotLightPosition.xyz;
      float spotCosCutoff = gotLightDirection.w;
      float spotExponent = gotLightIntensity.w;
      float lightType = gotLightPosition.w;

      if (0.75 < lightType) { // is pointlight or spotlight
        lightDirection = normalize(lightPosition - v_position_inWorld.xyz);
      }
      float spotEffect = 1.0;
      if (lightType > 1.75) { // is spotlight
        spotEffect = dot(gotLightDirection.xyz, lightDirection);
        if (spotEffect > spotCosCutoff) {
          spotEffect = pow(spotEffect, spotExponent);
        } else {
          spotEffect = 0.0;
        }
      }

      vec3 incidentLight = spotEffect * lightIntensity.xyz;
//      incidentLight *= M_PI;

      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, lightDirection)) * incidentLight;

      float cameraSID = u_currentComponentSIDs[${_foundation_components_WellKnownComponentTIDs__WEBPACK_IMPORTED_MODULE_5__["WellKnownComponentTIDs"].CameraComponentTID}];
      vec3 viewPosition = get_viewPosition(cameraSID, 0);
      float shininess = get_shininess(materialSID, 0);
      if (shadingModel == 2) {// BLINN
        // ViewDirection
        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);
        vec3 halfVector = normalize(lightDirection + viewDirection);
        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);
      } else if (shadingModel == 3) { // PHONG
        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);
        vec3 R = reflect(lightDirection, normal_inWorld);
        specular += pow(max(0.0, dot(R, viewDirection)), shininess);
      }

    }

    shadingColor = diffuse + specular;
  } else {
    shadingColor = diffuseColor;
  }

  rt0 = vec4(shadingColor, alpha);
  //rt0 = vec4(u_lightNumber, 0.0, 0.0, 1.0);


  ${_def_fragColor}
}
`;
    }
    getPixelShaderBody(args) {
        return this.getFragmentShader(args);
    }
    get attributeCompositions() {
        return [
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Scalar,
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec2, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec2,
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec3, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec3, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec3,
            _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec4, _foundation_definitions_CompositionType__WEBPACK_IMPORTED_MODULE_4__["CompositionType"].Vec4,
        ];
    }
}
ShadowMapDecodeClassicShader.materialElement = _foundation_definitions_ShaderNode__WEBPACK_IMPORTED_MODULE_3__["ShaderNode"].ClassicShading;


/***/ }),

/***/ "./src/webgl/shaders/nodes/BlockBeginShader.ts":
/*!*****************************************************!*\
  !*** ./src/webgl/shaders/nodes/BlockBeginShader.ts ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BlockBeginShader; });
/* harmony import */ var _GLSLShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");

class BlockBeginShader extends _GLSLShader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(__functionName, __valueInputs, __valueOutputs) {
        super();
        this.__functionName = __functionName;
        this.__valueInputs = __valueInputs;
        this.__valueOutputs = __valueOutputs;
    }
    get vertexShaderDefinitions() {
        let funcStr = `void ${this.__functionName}(
in bool context,
      `;
        for (let i = 0; i < this.__valueInputs.length; i++) {
            const input = this.__valueInputs[i];
            const type = input.compositionType.getGlslStr(input.componentType);
            funcStr += `
        in ${type} value${i},`;
        }
        for (let i = 0; i < this.__valueOutputs.length; i++) {
            const output = this.__valueOutputs[i];
            const type = output.compositionType.getGlslStr(output.componentType);
            funcStr += `
        out ${type} outValue${i}` + ((i === this.__valueOutputs.length - 1) ? '' : ',');
        }
        funcStr += `) {\n`;
        for (let i = 0; i < this.__valueOutputs.length; i++) {
            funcStr += `
      outValue${i} = value${i};\n`;
        }
        funcStr += `}`;
        return funcStr;
    }
    ;
    get pixelShaderDefinitions() {
        return this.vertexShaderDefinitions;
    }
    get attributeNames() {
        return [];
    }
    get attributeSemantics() {
        return [];
    }
    get attributeCompositions() {
        return [];
    }
}


/***/ }),

/***/ "./src/webgl/shaders/nodes/BlockEndShader.ts":
/*!***************************************************!*\
  !*** ./src/webgl/shaders/nodes/BlockEndShader.ts ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BlockEndShader; });
/* harmony import */ var _GLSLShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");

class BlockEndShader extends _GLSLShader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(__functionName, __valueInputs, __valueOutputs) {
        super();
        this.__functionName = __functionName;
        this.__valueInputs = __valueInputs;
        this.__valueOutputs = __valueOutputs;
    }
    get vertexShaderDefinitions() {
        let funcStr = `void ${this.__functionName}(`;
        for (let i = 0; i < this.__valueInputs.length; i++) {
            const input = this.__valueInputs[i];
            const type = input.compositionType.getGlslStr(input.componentType);
            funcStr += `
        in ${type} value${i},`;
        }
        for (let i = 0; i < this.__valueOutputs.length; i++) {
            const output = this.__valueOutputs[i];
            const type = output.compositionType.getGlslStr(output.componentType);
            funcStr += `
        out ${type} outValue${i}` + ((i === this.__valueOutputs.length - 1) ? '' : ',');
        }
        funcStr += `) {\n`;
        for (let i = 0; i < this.__valueOutputs.length; i++) {
            funcStr += `
      outValue${i} = value${i};\n`;
        }
        funcStr += `}`;
        return funcStr;
    }
    ;
    get pixelShaderDefinitions() {
        return this.vertexShaderDefinitions;
    }
    get attributeNames() {
        return [];
    }
    get attributeSemantics() {
        return [];
    }
    get attributeCompositions() {
        return [];
    }
}


/***/ }),

/***/ "./src/webgl/shaders/nodes/ConstantVariableShader.ts":
/*!***********************************************************!*\
  !*** ./src/webgl/shaders/nodes/ConstantVariableShader.ts ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ConstantVariableShader; });
/* harmony import */ var _GLSLShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");
/* harmony import */ var _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../foundation/definitions/ComponentType */ "./src/foundation/definitions/ComponentType.ts");


class ConstantVariableShader extends _GLSLShader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(__functionName, __compositionType, __componentType) {
        super();
        this.__functionName = __functionName;
        this.__compositionType = __compositionType;
        this.__componentType = __componentType;
        this.__constantValueStr = '';
    }
    setConstantValue(value) {
        let constant = '';
        if (this.__componentType.isFloatingPoint()) {
            constant = value.glslStrAsFloat;
        }
        else if (this.__componentType.isInteger()) {
            constant = value.glslStrAsInt;
        }
        else if (this.__componentType === _foundation_definitions_ComponentType__WEBPACK_IMPORTED_MODULE_1__["ComponentType"].Bool) {
            constant = value.x ? 'true' : 'false';
        }
        this.__constantValueStr = constant;
    }
    get vertexShaderDefinitions() {
        return `
    void ${this.__functionName}(
      out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
      outValue = ${this.__constantValueStr};
    }
    `;
    }
    ;
    get pixelShaderDefinitions() {
        return `
    void ${this.__functionName}(
      out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
      outValue = ${this.__constantValueStr};
    }
    `;
    }
    get attributeNames() {
        return [];
    }
    get attributeSemantics() {
        return [];
    }
    get attributeCompositions() {
        return [];
    }
}


/***/ }),

/***/ "./src/webgl/shaders/nodes/EndShader.ts":
/*!**********************************************!*\
  !*** ./src/webgl/shaders/nodes/EndShader.ts ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EndShader; });
/* harmony import */ var _GLSLShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");
/* harmony import */ var _foundation_definitions_ShaderNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../foundation/definitions/ShaderNode */ "./src/foundation/definitions/ShaderNode.ts");


class EndShader extends _GLSLShader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new EndShader();
        }
        return this.__instance;
    }
    get vertexShaderDefinitions() {
        return `
    void outPosition(in vec4 inPosition) {
      gl_Position = inPosition;
    }
    `;
    }
    ;
    get vertexShaderBody() {
        return `

    `;
    }
    get pixelShaderDefinitions() {
        const _def_fragColor = this.glsl_fragColor;
        let vec4StrOrNot = '';
        if (_def_fragColor !== '') {
            vec4StrOrNot = 'vec4';
        }
        return `
    void outColor(in vec4 inColor) {
      ${vec4StrOrNot} rt0 = inColor;
      ${_def_fragColor}
    }
    `;
    }
    get pixelShaderBody() {
        return '';
    }
    get attributeNames() {
        return [];
    }
    get attributeSemantics() {
        return [];
    }
    get attributeCompositions() {
        return [];
    }
}
EndShader.materialElement = _foundation_definitions_ShaderNode__WEBPACK_IMPORTED_MODULE_1__["ShaderNode"].PBRShading;


/***/ }),

/***/ "./src/webgl/shaders/nodes/IfStatementShader.ts":
/*!******************************************************!*\
  !*** ./src/webgl/shaders/nodes/IfStatementShader.ts ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IfStatementShader; });
/* harmony import */ var _GLSLShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");

class IfStatementShader extends _GLSLShader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    get vertexShaderDefinitions() {
        return `
    `;
    }
    ;
    get pixelShaderDefinitions() {
        return `
    `;
    }
    get attributeNames() {
        return [];
    }
    get attributeSemantics() {
        return [];
    }
    get attributeCompositions() {
        return [];
    }
}


/***/ }),

/***/ "./src/webgl/shaders/nodes/UniformDataShader.ts":
/*!******************************************************!*\
  !*** ./src/webgl/shaders/nodes/UniformDataShader.ts ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UniformDataShader; });
/* harmony import */ var _GLSLShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");

class UniformDataShader extends _GLSLShader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(__functionName, __compositionType, __componentType) {
        super();
        this.__functionName = __functionName;
        this.__compositionType = __compositionType;
        this.__componentType = __componentType;
        this.__variableName = '';
        this.__valueStr = '';
    }
    setVariableName(name) {
        this.__variableName = name;
    }
    setDefaultValue(value) {
        this.__valueStr = value.toString();
    }
    get vertexShaderDefinitions() {
        return `
    uniform ${this.__compositionType.getGlslStr(this.__componentType)} u_${this.__variableName}; // initialValue=${this.__valueStr}
    void ${this.__functionName}(out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
#ifdef RN_IS_FASTEST_MODE
  float materialSID = u_currentComponentSIDs[0];
#else
  float materialSID = u_materialSID;
#endif

outValue = get_${this.__variableName}(materialSID, 0);
    }
    `;
    }
    ;
    get pixelShaderDefinitions() {
        return `
    uniform ${this.__compositionType.getGlslStr(this.__componentType)} u_${this.__variableName}; // initialValue=${this.__valueStr}
    void ${this.__functionName}(out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
#ifdef RN_IS_FASTEST_MODE
  float materialSID = u_currentComponentSIDs[0];
#else
  float materialSID = u_materialSID;
#endif

outValue = get_${this.__variableName}(materialSID, 0);
    }
    `;
    }
    get attributeNames() {
        return [];
    }
    get attributeSemantics() {
        return [];
    }
    get attributeCompositions() {
        return [];
    }
}


/***/ }),

/***/ "./src/webgl/shaders/nodes/VaryingVariableShader.ts":
/*!**********************************************************!*\
  !*** ./src/webgl/shaders/nodes/VaryingVariableShader.ts ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VaryingVariableShader; });
/* harmony import */ var _GLSLShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLSLShader */ "./src/webgl/shaders/GLSLShader.ts");

class VaryingVariableShader extends _GLSLShader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(__functionName, __compositionType, __componentType) {
        super();
        this.__functionName = __functionName;
        this.__compositionType = __compositionType;
        this.__componentType = __componentType;
        this.__variableName = '';
    }
    setVariableName(name) {
        this.__variableName = name;
    }
    get vertexShaderDefinitions() {
        return `
    out ${this.__compositionType.getGlslStr(this.__componentType)} ${this.__variableName};
    void ${this.__functionName}(
      in ${this.__compositionType.getGlslStr(this.__componentType)} value) {
      ${this.__variableName} = value;
    }
    `;
    }
    ;
    get pixelShaderDefinitions() {
        return `
    in ${this.__compositionType.getGlslStr(this.__componentType)} ${this.__variableName};
    void ${this.__functionName}(
      out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
      outValue = ${this.__variableName};
    }
    `;
    }
    get attributeNames() {
        return [];
    }
    get attributeSemantics() {
        return [];
    }
    get attributeCompositions() {
        return [];
    }
}


/***/ }),

/***/ "./src/xr/WebVRSystem.ts":
/*!*******************************!*\
  !*** ./src/xr/WebVRSystem.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WebVRSystem; });
/* harmony import */ var _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../foundation/renderer/CGAPIResourceRepository */ "./src/foundation/renderer/CGAPIResourceRepository.ts");
/* harmony import */ var _foundation_math_Vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../foundation/math/Vector3 */ "./src/foundation/math/Vector3.ts");
/* harmony import */ var _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../foundation/math/Matrix44 */ "./src/foundation/math/Matrix44.ts");
/* harmony import */ var _foundation_math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../foundation/math/MutableMatrix44 */ "./src/foundation/math/MutableMatrix44.ts");
/* harmony import */ var _foundation_math_Vector4__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../foundation/math/Vector4 */ "./src/foundation/math/Vector4.ts");
/* harmony import */ var _foundation_core_EntityRepository__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../foundation/core/EntityRepository */ "./src/foundation/core/EntityRepository.ts");
/* harmony import */ var _foundation_components_TransformComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../foundation/components/TransformComponent */ "./src/foundation/components/TransformComponent.ts");
/* harmony import */ var _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../foundation/components/SceneGraphComponent */ "./src/foundation/components/SceneGraphComponent.ts");
/* harmony import */ var _foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../foundation/components/CameraComponent */ "./src/foundation/components/CameraComponent.ts");









class WebVRSystem {
    constructor() {
        this.__isWebVRMode = false;
        this.__requestedToEnterWebVR = false;
        this.__isReadyForWebVR = false;
        this.__defaultUserSittingPositionInVR = new _foundation_math_Vector3__WEBPACK_IMPORTED_MODULE_1__["default"](0.0, 1.1, 1.5);
        this.__invertSittingToStandingTransform = _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"].identity();
        this.__minRenderWidthFromUser = 0;
        this.__minRenderHeightFromUser = 0;
        this.__canvasWidthBackup = 0;
        this.__canvasHeightBackup = 0;
        this.__leftViewMatrix = _foundation_math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_3__["default"].identity();
        this.__rightViewMatrix = _foundation_math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_3__["default"].identity();
        const repo = _foundation_core_EntityRepository__WEBPACK_IMPORTED_MODULE_5__["default"].getInstance();
        this.__leftCameraEntity = repo.createEntity([_foundation_components_TransformComponent__WEBPACK_IMPORTED_MODULE_6__["default"], _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_7__["default"], _foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_8__["default"]]);
        this.__rightCameraEntity = repo.createEntity([_foundation_components_TransformComponent__WEBPACK_IMPORTED_MODULE_6__["default"], _foundation_components_SceneGraphComponent__WEBPACK_IMPORTED_MODULE_7__["default"], _foundation_components_CameraComponent__WEBPACK_IMPORTED_MODULE_8__["default"]]);
    }
    static getInstance() {
        if (!this.__instance) {
            this.__instance = new WebVRSystem();
        }
        return this.__instance;
    }
    getFrameData() {
        if (this.__webvrDisplay == null) {
            return;
        }
        this.__webvrDisplay.getFrameData(this.__webvrFrameData);
        if (this.__webvrDisplay.stageParameters) {
            this.__invertSittingToStandingTransform = _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"].invert(new _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"](this.__webvrDisplay.stageParameters.sittingToStandingTransform, true));
        }
        else {
            this.__invertSittingToStandingTransform = _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"].invert(_foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"].translate(this.__defaultUserSittingPositionInVR));
        }
    }
    async enterWebVR(initialUserSittingPositionIfStageParametersDoNotExist, minRenderWidth, minRenderHeight) {
        return new Promise((resolve, reject) => {
            const webglResourceRepository = _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getWebGLResourceRepository();
            const glw = webglResourceRepository.currentWebGLContextWrapper;
            if (glw != null && this.__webvrDisplay != null && !this.__webvrDisplay.isPresenting) {
                if (initialUserSittingPositionIfStageParametersDoNotExist != null) {
                    this.__defaultUserSittingPositionInVR = initialUserSittingPositionIfStageParametersDoNotExist;
                }
                if (minRenderWidth != null) {
                    this.__minRenderWidthFromUser = minRenderWidth;
                }
                if (minRenderHeight != null) {
                    this.__minRenderHeightFromUser = minRenderHeight;
                }
                this.__vrDisplay = this.__webvrDisplay;
                const leftEye = this.__webvrDisplay.getEyeParameters("left");
                const rightEye = this.__webvrDisplay.getEyeParameters("right");
                this.__canvasWidthBackup = glw.width;
                this.__canvasHeightBackup = glw.height;
                if (this.__minRenderWidthFromUser > leftEye.renderWidth &&
                    this.__minRenderHeightFromUser > rightEye.renderWidth) {
                    webglResourceRepository.resizeCanvas(this.__minRenderWidthFromUser * 2, this.__minRenderHeightFromUser);
                }
                else {
                    webglResourceRepository.resizeCanvas(Math.max(leftEye.renderWidth, rightEye.renderWidth) * 2, Math.max(leftEye.renderHeight, rightEye.renderHeight));
                }
                this.__webvrDisplay
                    .requestPresent([{ source: glw.canvas }])
                    .then(() => {
                    this.__requestedToEnterWebVR = true;
                    console.info("requestPresent is succeeded.");
                    resolve();
                })
                    .catch(() => {
                    console.error("Failed to requestPresent. Please check your VR Setting, or something wrong with your VR system?");
                    reject();
                });
            }
            else {
                reject("WebGL context or WebVRDisplay is not ready yet.");
            }
        });
    }
    async readyForWebVR(requestButtonDom) {
        return new Promise((resolve, reject) => {
            const glw = _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getWebGLResourceRepository().currentWebGLContextWrapper;
            if (glw == null) {
                reject("WebGL Context is not ready yet.");
                return;
            }
            if (window.VRFrameData) {
                this.__webvrFrameData = new window.VRFrameData();
            }
            else {
                reject("WebVR is not supported in this environment.");
            }
            if (navigator.getVRDisplays) {
                navigator
                    .getVRDisplays()
                    .then((vrDisplays) => {
                    if (vrDisplays.length > 0) {
                        const webvrDisplay = vrDisplays[vrDisplays.length - 1];
                        webvrDisplay.depthNear = 0.01;
                        webvrDisplay.depthFar = 10000;
                        if (webvrDisplay.capabilities.canPresent) {
                            this.__webvrDisplay = webvrDisplay;
                            if (requestButtonDom) {
                                requestButtonDom.style.display = "block";
                            }
                            else {
                                const paragrach = document.createElement("p");
                                const anchor = document.createElement("a");
                                anchor.setAttribute("id", "enter-vr");
                                const enterVr = document.createTextNode("Enter VR");
                                anchor.appendChild(enterVr);
                                paragrach.appendChild(anchor);
                                const canvas = glw.canvas;
                                canvas.parentNode.insertBefore(paragrach, canvas);
                                window.addEventListener("click", this.enterWebVR.bind(this));
                            }
                            this.__isReadyForWebVR = true;
                            resolve();
                        }
                        else {
                            console.error("Can't requestPresent now. try again.");
                            reject();
                        }
                    }
                    else {
                        console.error("Failed to get VR Display. Please check your VR Setting, or something wrong with your VR system?");
                        reject();
                    }
                })
                    .catch(() => {
                    console.error("Failed to get VR Displays. Please check your VR Setting.");
                    reject();
                });
            }
            else {
                console.error("Your browser does not support WebVR. Or it is disabled. Check again.");
                reject();
            }
        });
    }
    async exitWebVR() {
        this.__isWebVRMode = false;
        if (this.__webvrDisplay && this.__webvrDisplay.isPresenting) {
            await this.__webvrDisplay.exitPresent();
        }
        const webglResourceRepository = _foundation_renderer_CGAPIResourceRepository__WEBPACK_IMPORTED_MODULE_0__["default"].getWebGLResourceRepository();
        webglResourceRepository.resizeCanvas(this.__canvasWidthBackup, this.__canvasHeightBackup);
        this.__isReadyForWebVR = false;
    }
    async disableWebVR() {
        this.__isWebVRMode = false;
        this.__requestedToEnterWebVR = false;
        this.__isReadyForWebVR = false;
        if (this.__webvrDisplay && this.__webvrDisplay.isPresenting) {
            await this.__webvrDisplay.exitPresent();
        }
        this.__webvrDisplay = void 0;
    }
    get isWebVRMode() {
        return this.__isWebVRMode;
    }
    get isReadyForWebVR() {
        return this.__isReadyForWebVR;
    }
    webVrSubmitFrame() {
        if (this.__webvrDisplay && this.__webvrDisplay.isPresenting) {
            this.__webvrDisplay.submitFrame();
        }
    }
    get webVrFrameData() {
        return this.__webvrFrameData;
    }
    get leftViewMatrix() {
        _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"].multiplyTo(new _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"](this.__webvrFrameData.leftViewMatrix, true), this.__invertSittingToStandingTransform, this.__leftViewMatrix);
        return this.__leftViewMatrix;
    }
    get rightViewMatrix() {
        _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"].multiplyTo(new _foundation_math_Matrix44__WEBPACK_IMPORTED_MODULE_2__["default"](this.__webvrFrameData.rightViewMatrix, true), this.__invertSittingToStandingTransform, this.__rightViewMatrix);
        return this.__rightViewMatrix;
    }
    get leftProjectionMatrix() {
        return new _foundation_math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_3__["default"](this.__webvrFrameData.leftProjectionMatrix, true);
    }
    get rightProjectionMatrix() {
        return new _foundation_math_MutableMatrix44__WEBPACK_IMPORTED_MODULE_3__["default"](this.__webvrFrameData.rightProjectionMatrix, true);
    }
    getLeftViewport(originalViewport) {
        return new _foundation_math_Vector4__WEBPACK_IMPORTED_MODULE_4__["default"](originalViewport.x, originalViewport.y, originalViewport.z * 0.5, originalViewport.w);
    }
    getRightViewport(originalViewport) {
        return new _foundation_math_Vector4__WEBPACK_IMPORTED_MODULE_4__["default"](originalViewport.z * 0.5, originalViewport.y, originalViewport.z * 0.5, originalViewport.w);
    }
    getViewMatrixAt(index) {
        if (index === 0) {
            return this.leftViewMatrix;
        }
        else {
            return this.rightViewMatrix;
        }
    }
    getProjectMatrixAt(index) {
        if (index === 0) {
            return this.leftProjectionMatrix;
        }
        else {
            return this.rightProjectionMatrix;
        }
    }
    getViewportAt(viewport, index) {
        if (index === 0) {
            return this.getLeftViewport(viewport);
        }
        else {
            return this.getRightViewport(viewport);
        }
    }
    get vrDisplay() {
        return this.__vrDisplay;
    }
    setValuesToGlobalDataRepository() {
        this.__leftCameraEntity.getCamera().viewMatrix = this.leftViewMatrix;
        this.__rightCameraEntity.getCamera().viewMatrix = this.rightViewMatrix;
        this.__leftCameraEntity.getCamera().projectionMatrix = this.leftProjectionMatrix;
        this.__rightCameraEntity.getCamera().projectionMatrix = this.rightProjectionMatrix;
        this.__leftCameraEntity.getCamera().setValuesToGlobalDataRepository();
        this.__rightCameraEntity.getCamera().setValuesToGlobalDataRepository();
    }
    getCameraComponentSIDAt(index) {
        if (index === 0) {
            return this.__leftCameraEntity.getCamera().componentSID;
        }
        else {
            return this.__rightCameraEntity.getCamera().componentSID;
        }
    }
    get requestedToEnterWebVR() {
        return this.__requestedToEnterWebVR;
    }
    _setIsWebVRMode() {
        this.__isWebVRMode = true;
    }
}


/***/ })

/******/ })["default"];
});
//# sourceMappingURL=rhodonite.js.map